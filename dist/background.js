parcelRequire=function(e,r,t,n){var i,o="function"==typeof parcelRequire&&parcelRequire,u="function"==typeof require&&require;function f(t,n){if(!r[t]){if(!e[t]){var i="function"==typeof parcelRequire&&parcelRequire;if(!n&&i)return i(t,!0);if(o)return o(t,!0);if(u&&"string"==typeof t)return u(t);var c=new Error("Cannot find module '"+t+"'");throw c.code="MODULE_NOT_FOUND",c}p.resolve=function(r){return e[t][1][r]||r},p.cache={};var l=r[t]=new f.Module(t);e[t][0].call(l.exports,p,l,l.exports,this)}return r[t].exports;function p(e){return f(p.resolve(e))}}f.isParcelRequire=!0,f.Module=function(e){this.id=e,this.bundle=f,this.exports={}},f.modules=e,f.cache=r,f.parent=o,f.register=function(r,t){e[r]=[function(e,r){r.exports=t},{}]};for(var c=0;c<t.length;c++)try{f(t[c])}catch(e){i||(i=e)}if(t.length){var l=f(t[t.length-1]);"object"==typeof exports&&"undefined"!=typeof module?module.exports=l:"function"==typeof define&&define.amd?define(function(){return l}):n&&(this[n]=l)}if(parcelRequire=f,i)throw i;return f}({"Sk1f":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.KernelBackend=exports.EPSILON_FLOAT32=exports.EPSILON_FLOAT16=exports.DataStorage=void 0;const e=exports.EPSILON_FLOAT32=1e-7,t=exports.EPSILON_FLOAT16=1e-4;class r{constructor(e,t){this.backend=e,this.dataMover=t,this.data=new WeakMap,this.dataIdsCount=0}get(e){return this.data.has(e)||this.dataMover.moveData(this.backend,e),this.data.get(e)}set(e,t){this.dataIdsCount++,this.data.set(e,t)}has(e){return this.data.has(e)}delete(e){return this.dataIdsCount--,this.data.delete(e)}numDataIds(){return this.dataIdsCount}}exports.DataStorage=r;class a{refCount(e){return s("refCount")}incRef(e){return s("incRef")}timerAvailable(){return!0}time(e){return s("time")}read(e){return s("read")}readSync(e){return s("readSync")}readToGPU(e,t){return s("readToGPU")}numDataIds(){return s("numDataIds")}disposeData(e,t){return s("disposeData")}write(e,t,r){return s("write")}move(e,t,r,a,n){return s("move")}createTensorFromGPUData(e,t,r){return s("createTensorFromGPUData")}memory(){return s("memory")}floatPrecision(){return s("floatPrecision")}epsilon(){return 32===this.floatPrecision()?e:t}dispose(){return s("dispose")}}function s(e){throw new Error(`'${e}' not yet implemented or not found in the registry. `+"This kernel may not be supported by the tfjs backend you have chosen")}exports.KernelBackend=a;
},{}],"uID4":[function(require,module,exports) {
"use strict";function r(r){let t=r.length,e=0;for(;t>0;)e=Math.random()*t|0,o(r,--t,e)}function t(r,t){if(r.length!==t.length)throw new Error("Array sizes must match to be shuffled together "+`First array length was ${r.length}`+`Second array length was ${t.length}`);let e=r.length,n=0;for(;e>0;)n=Math.random()*e|0,o(r,--e,n),o(t,e,n)}function e(r,t,e){return Math.max(r,Math.min(t,e))}function n(r){return r%2==0?r:r+1}function o(r,t,e){const n=r[t];r[t]=r[e],r[e]=n}function i(r){let t=0;for(let e=0;e<r.length;e++)t+=r[e];return t}function s(r,t){const e=Math.random();return t*e+(1-e)*r}function u(r,t){let e=0;for(let n=0;n<r.length;n++){const o=Number(r[n])-Number(t[n]);e+=o*o}return e}function a(r,t){if(!r)throw new Error("string"==typeof t?t:t())}function l(r,t,e=""){a(y(r,t),()=>e+` Shapes ${r} and ${t} must match`)}function f(r){a(null!=r,()=>"The input to the tensor constructor must be a non-null value.")}function c(r){if(0===r.length)return 1;let t=r[0];for(let e=1;e<r.length;e++)t*=r[e];return t}function p(r){return 0===r.length}function h(r,t){if(r===t)return!0;if(null==r||null==t)return!1;if(r.length!==t.length)return!1;for(let e=0;e<r.length;e++)if(null!==r[e]&&null!==t[e]&&r[e]!==t[e])return!1;return!0}function y(r,t){if(r===t)return!0;if(null==r||null==t)return!1;if(r.length!==t.length)return!1;for(let e=0;e<r.length;e++)if(r[e]!==t[e])return!1;return!0}function m(r){return r%1==0}function x(r){if(null!=Math.tanh)return Math.tanh(r);if(r===1/0)return 1;if(r===-1/0)return-1;{const t=Math.exp(2*r);return(t-1)/(t+1)}}function g(r){const t=Math.ceil(Math.sqrt(r));return[t,Math.ceil(r/t)]}function w(t){const e=new Uint32Array(t);for(let r=0;r<t;++r)e[r]=r;return r(e),e}function d(r,t){return t<=r.length?r:r+" ".repeat(t-r.length)}function A(r,t=(r=>0),e,n){return new Promise((o,i)=>{let s=0;const u=()=>{if(r())return void o();const a=t(++s);null!=e&&s>=e?i():null!=n?n(u,a):setTimeout(u,a)};u()})}function b(r,t){let e=1,n=-1;for(let i=0;i<r.length;++i)if(r[i]>=0)e*=r[i];else if(-1===r[i]){if(-1!==n)throw Error("Shapes can only have 1 implicit size. "+`Found -1 at dim ${n} and dim ${i}`);n=i}else if(r[i]<0)throw Error(`Shapes can not be < 0. Found ${r[i]} at dim ${i}`);if(-1===n){if(t>0&&t!==e)throw Error(`Size(${t}) must match the product of shape ${r}`);return r}if(0===e)throw Error(`Cannot infer the missing size in [${r}] when `+"there are 0 elements");if(t%e!=0)throw Error("The implicit shape can't be a fractional number. "+`Got ${t} / ${e}`);const o=r.slice();return o[n]=t/e,o}function $(r,t){const e=t.length;return a((r=null==r?t.map((r,t)=>t):[].concat(r)).every(r=>r>=-e&&r<e),()=>`All values in axis param must be in range [-${e}, ${e}) but `+`got axis ${r}`),a(r.every(r=>m(r)),()=>"All values in axis param must be integers but "+`got axis ${r}`),r.map(r=>r<0?e+r:r)}function E(r,t){const e=[],n=[],o=null!=t&&Array.isArray(t)&&0===t.length,i=null==t||o?null:$(t,r).sort();let s=0;for(let u=0;u<r.length;++u){if(null!=i){if(i[s]===u&&1!==r[u])throw new Error(`Can't squeeze axis ${u} since its dim '${r[u]}' is not 1`);(null==i[s]||i[s]>u)&&1===r[u]&&(e.push(r[u]),n.push(u)),i[s]<=u&&s++}1!==r[u]&&(e.push(r[u]),n.push(u))}return{newShape:e,keptDims:n}}function S(r,t){return F(r,t)}function F(r,t){let e=null;if(null==r||"float32"===r)e=new Float32Array(t);else if("int32"===r)e=new Int32Array(t);else if("bool"===r)e=new Uint8Array(t);else{if("string"!==r)throw new Error(`Unknown data type ${r}`);e=new Array(t)}return e}function v(r,t){for(let e=0;e<r.length;e++){const n=r[e];if(isNaN(n)||!isFinite(n))throw Error(`A tensor of type ${t} being uploaded contains ${n}.`)}}function M(r){return"bool"===r||"complex64"===r||"float32"===r||"int32"===r||"string"===r}function T(r,t){return"complex64"!==t&&(("float32"!==t||"complex64"===r)&&(("int32"!==t||"float32"===r||"complex64"===r)&&("bool"!==t||"bool"!==r)))}function I(r){if("float32"===r||"int32"===r)return 4;if("complex64"===r)return 8;if("bool"===r)return 1;throw new Error(`Unknown dtype ${r}`)}function N(r){if(null==r)return 0;let t=0;return r.forEach(r=>t+=r.length),t}function U(r){return"string"==typeof r||r instanceof String}function k(r){return"boolean"==typeof r}function z(r){return"number"==typeof r}function q(r){return Array.isArray(r)?q(r[0]):r instanceof Float32Array?"float32":r instanceof Int32Array||r instanceof Uint8Array||r instanceof Uint8ClampedArray?"int32":z(r)?"float32":U(r)?"string":k(r)?"bool":"float32"}function D(r){return!!(r&&r.constructor&&r.call&&r.apply)}function P(r,t){for(let e=t;e<r;++e)if(r%e==0)return e;return r}function C(r){const t=r.length;if(t<2)return[];const e=new Array(t-1);e[t-2]=r[t-1];for(let n=t-3;n>=0;--n)e[n]=e[n+1]*r[n+1];return e}function B(r,t,e,n=!1){const o=new Array;if(1===t.length){const i=t[0]*(n?2:1);for(let t=0;t<i;t++)o[t]=e[r+t]}else{const i=t[0],s=t.slice(1),u=s.reduce((r,t)=>r*t)*(n?2:1);for(let t=0;t<i;t++)o[t]=B(r+t*u,s,e,n)}return o}function L(r,t,e=!1){if(0===r.length)return t[0];const n=r.reduce((r,t)=>r*t)*(e?2:1);if(0===n)return[];if(n!==t.length)throw new Error(`[${r}] does not match the input size ${t.length}${e?" for a complex tensor":""}.`);return B(0,r,t,e)}function O(r,t){if(Array.isArray(r))return r;if("float32"===t)return r instanceof Float32Array?r:new Float32Array(r);if("int32"===t)return r instanceof Int32Array?r:new Int32Array(r);if("bool"===t||"string"===t)return Uint8Array.from(new Int32Array(r));throw new Error(`Unknown dtype ${t}`)}function V(r,t){const e=Z(r,t);for(let n=0;n<e.length;n++)e[n]=1;return e}function Z(r,t){if(null==t||"float32"===t||"complex64"===t)return new Float32Array(r);if("int32"===t)return new Int32Array(r);if("bool"===t)return new Uint8Array(r);throw new Error(`Unknown data type ${t}`)}function _(r,t){const e=r.reduce((r,t)=>r*t,1);if(null==t||"float32"===t)return L(r,new Float32Array(e));if("int32"===t)return L(r,new Int32Array(e));if("bool"===t)return L(r,new Uint8Array(e));throw new Error(`Unknown data type ${t}`)}function j(r){r.forEach(t=>{a(Number.isInteger(t)&&t>=0,()=>"Tensor must have a shape comprised of positive integers but got "+`shape [${r}].`)})}function G(r,t,e){if(0===t)return 0;if(1===t)return r[0];let n=r[r.length-1];for(let o=0;o<r.length-1;++o)n+=e[o]*r[o];return n}function W(r,t,e){if(0===t)return[];if(1===t)return[r];const n=new Array(t);for(let o=0;o<n.length-1;++o)n[o]=Math.floor(r/e[o]),r-=n[o]*e[o];return n[n.length-1]=r,n}function H(r){return r&&r.then&&"function"==typeof r.then}Object.defineProperty(exports,"__esModule",{value:!0}),exports.arraysEqual=y,exports.arraysEqualWithNull=h,exports.assert=a,exports.assertNonNegativeIntegerDimensions=j,exports.assertNonNull=f,exports.assertShapesMatch=l,exports.bytesFromStringArray=N,exports.bytesPerElement=I,exports.checkConversionForErrors=v,exports.clamp=e,exports.computeStrides=C,exports.convertBackendValuesAndArrayBuffer=O,exports.createShuffledIndices=w,exports.distSquared=u,exports.getArrayFromDType=F,exports.getTypedArrayFromDType=S,exports.hasEncodingLoss=T,exports.indexToLoc=W,exports.inferDtype=q,exports.inferFromImplicitShape=b,exports.isBoolean=k,exports.isFunction=D,exports.isInt=m,exports.isNumber=z,exports.isPromise=H,exports.isScalarShape=p,exports.isString=U,exports.isValidDtype=M,exports.locToIndex=G,exports.makeOnesTypedArray=V,exports.makeZerosNestedTypedArray=_,exports.makeZerosTypedArray=Z,exports.nearestDivisor=P,exports.nearestLargerEven=n,exports.parseAxisParam=$,exports.randUniform=s,exports.repeatedTry=A,exports.rightPad=d,exports.shuffle=r,exports.shuffleCombo=t,exports.sizeFromShape=c,exports.sizeToSquarishShape=g,exports.squeezeShape=E,exports.sum=i,exports.swap=o,exports.tanh=x,exports.toNestedArray=L;
},{}],"vpgN":[function(require,module,exports) {
var global = arguments[3];
var t=arguments[3];Object.defineProperty(exports,"__esModule",{value:!0}),exports.Environment=exports.ENV=void 0,exports.env=i,exports.getQueryParams=r,exports.setEnvironmentGlobal=g;var e=require("./util_base");const s="tfjsflags";class a{constructor(t){this.global=t,this.flags={},this.flagRegistry={},this.urlFlags={},this.getQueryParams=r,this.populateURLFlags()}setPlatform(t,e){null!=this.platform&&(i().getBool("IS_TEST")||i().getBool("PROD")||console.warn(`Platform ${this.platformName} has already been set. `+`Overwriting the platform with ${t}.`)),this.platformName=t,this.platform=e}registerFlag(t,e,s){if(this.flagRegistry[t]={evaluationFn:e,setHook:s},null!=this.urlFlags[t]){const e=this.urlFlags[t];i().getBool("IS_TEST")||i().getBool("PROD")||console.warn(`Setting feature override from URL ${t}: ${e}.`),this.set(t,e)}}async getAsync(t){return t in this.flags?this.flags[t]:(this.flags[t]=await this.evaluateFlag(t),this.flags[t])}get(t){if(t in this.flags)return this.flags[t];const s=this.evaluateFlag(t);if((0,e.isPromise)(s))throw new Error(`Flag ${t} cannot be synchronously evaluated. `+"Please use getAsync() instead.");return this.flags[t]=s,this.flags[t]}getNumber(t){return this.get(t)}getBool(t){return this.get(t)}getString(t){return this.get(t)}getFlags(){return this.flags}get features(){return this.flags}set(t,e){if(null==this.flagRegistry[t])throw new Error(`Cannot set flag ${t} as it has not been registered.`);this.flags[t]=e,null!=this.flagRegistry[t].setHook&&this.flagRegistry[t].setHook(e)}evaluateFlag(t){if(null==this.flagRegistry[t])throw new Error(`Cannot evaluate flag '${t}': no evaluation function found.`);return this.flagRegistry[t].evaluationFn()}setFlags(t){this.flags=Object.assign({},t)}reset(){this.flags={},this.urlFlags={},this.populateURLFlags()}populateURLFlags(){if(void 0===this.global||void 0===this.global.location||void 0===this.global.location.search)return;const t=this.getQueryParams(this.global.location.search);if(s in t){t[s].split(",").forEach(t=>{const[e,s]=t.split(":");this.urlFlags[e]=o(e,s)})}}}function r(t){const e={};return t.replace(/[?&]([^=?&]+)(?:=([^&]*))?/g,(t,...s)=>(l(e,s[0],s[1]),s.join("="))),e}function l(t,e,s){t[decodeURIComponent(e)]=decodeURIComponent(s||"")}function o(t,e){const s=e.toLowerCase();return"true"===s||"false"===s?"true"===s:`${+s}`===s?+s:e}function i(){return n}exports.Environment=a;let n=exports.ENV=null;function g(t){exports.ENV=n=t}
},{"./util_base":"uID4"}],"YATK":[function(require,module,exports) {

var t,e,n=module.exports={};function r(){throw new Error("setTimeout has not been defined")}function o(){throw new Error("clearTimeout has not been defined")}function i(e){if(t===setTimeout)return setTimeout(e,0);if((t===r||!t)&&setTimeout)return t=setTimeout,setTimeout(e,0);try{return t(e,0)}catch(n){try{return t.call(null,e,0)}catch(n){return t.call(this,e,0)}}}function u(t){if(e===clearTimeout)return clearTimeout(t);if((e===o||!e)&&clearTimeout)return e=clearTimeout,clearTimeout(t);try{return e(t)}catch(n){try{return e.call(null,t)}catch(n){return e.call(this,t)}}}!function(){try{t="function"==typeof setTimeout?setTimeout:r}catch(n){t=r}try{e="function"==typeof clearTimeout?clearTimeout:o}catch(n){e=o}}();var c,s=[],l=!1,a=-1;function f(){l&&c&&(l=!1,c.length?s=c.concat(s):a=-1,s.length&&h())}function h(){if(!l){var t=i(f);l=!0;for(var e=s.length;e;){for(c=s,s=[];++a<e;)c&&c[a].run();a=-1,e=s.length}c=null,l=!1,u(t)}}function m(t,e){this.fun=t,this.array=e}function p(){}n.nextTick=function(t){var e=new Array(arguments.length-1);if(arguments.length>1)for(var n=1;n<arguments.length;n++)e[n-1]=arguments[n];s.push(new m(t,e)),1!==s.length||l||i(h)},m.prototype.run=function(){this.fun.apply(null,this.array)},n.title="browser",n.env={},n.argv=[],n.version="",n.versions={},n.on=p,n.addListener=p,n.once=p,n.off=p,n.removeListener=p,n.removeAllListeners=p,n.emit=p,n.prependListener=p,n.prependOnceListener=p,n.listeners=function(t){return[]},n.binding=function(t){throw new Error("process.binding is not supported")},n.cwd=function(){return"/"},n.chdir=function(t){throw new Error("process.chdir is not supported")},n.umask=function(){return 0};
},{}],"TJmh":[function(require,module,exports) {
var global = arguments[3];
var process = require("process");
var e=arguments[3],t=require("process");let o;function n(){if(null==o){let n;if("undefined"!=typeof window)n=window;else if(void 0!==e)n=e;else if(void 0!==t)n=t;else{if("undefined"==typeof self)throw new Error("Could not find a global object");n=self}o=n}return o}function l(){const e=n();return null==e._tfGlobals&&(e._tfGlobals=new Map),e._tfGlobals}function r(e,t){const o=l();if(o.has(e))return o.get(e);{const n=t();return o.set(e,n),o.get(e)}}Object.defineProperty(exports,"__esModule",{value:!0}),exports.getGlobal=r,exports.getGlobalNamespace=n;
},{"process":"YATK"}],"rJl6":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.Maximum=exports.MaxPoolWithArgmax=exports.MaxPoolGrad=exports.MaxPool3DGrad=exports.MaxPool3D=exports.MaxPool=exports.Max=exports.MatrixBandPart=exports.LowerBound=exports.LogicalXor=exports.LogicalOr=exports.LogicalNot=exports.LogicalAnd=exports.LogSoftmax=exports.Log1p=exports.Log=exports.LinSpace=exports.LessEqual=exports.Less=exports.LeakyRelu=exports.LRNGrad=exports.LRN=exports.IsNan=exports.IsInf=exports.IsFinite=exports.Imag=exports.Identity=exports.IFFT=exports.GreaterEqual=exports.Greater=exports.GatherV2=exports.GatherNd=exports.FusedDepthwiseConv2D=exports.FusedConv2D=exports.FusedBatchNorm=exports.FromPixels=exports.FloorDiv=exports.Floor=exports.FlipLeftRight=exports.Fill=exports.FFT=exports.Expm1=exports.ExpandDims=exports.Exp=exports.Erf=exports.Equal=exports.EluGrad=exports.Elu=exports.Einsum=exports.Draw=exports.Dilation2DBackpropInput=exports.Dilation2DBackpropFilter=exports.Dilation2D=exports.Diag=exports.DepthwiseConv2dNativeBackpropInput=exports.DepthwiseConv2dNativeBackpropFilter=exports.DepthwiseConv2dNative=exports.DepthToSpace=exports.DenseBincount=exports.Cumsum=exports.Cumprod=exports.CropAndResize=exports.Cosh=exports.Cos=exports.Conv3DBackpropInputV2=exports.Conv3DBackpropFilterV2=exports.Conv3D=exports.Conv2DBackpropInput=exports.Conv2DBackpropFilter=exports.Conv2D=exports.Concat=exports.ComplexAbs=exports.Complex=exports.ClipByValue=exports.Ceil=exports.Cast=exports.BroadcastTo=exports.BroadcastArgs=exports.BitwiseAnd=exports.Bincount=exports.BatchToSpaceND=exports.BatchMatMul=exports.AvgPoolGrad=exports.AvgPool3DGrad=exports.AvgPool3D=exports.AvgPool=exports.Atanh=exports.Atan2=exports.Atan=exports.Asinh=exports.Asin=exports.ArgMin=exports.ArgMax=exports.Any=exports.All=exports.AddN=exports.Add=exports.Acosh=exports.Acos=exports.Abs=void 0,exports._FusedMatMul=exports.ZerosLike=exports.UpperBound=exports.UnsortedSegmentSum=exports.Unpack=exports.Unique=exports.Transpose=exports.Transform=exports.TopK=exports.Tile=exports.TensorScatterUpdate=exports.Tanh=exports.Tan=exports.Sum=exports.Sub=exports.StringToHashBucketFast=exports.StringSplit=exports.StringNGrams=exports.StridedSlice=exports.Step=exports.StaticRegexReplace=exports.SquaredDifference=exports.Square=exports.Sqrt=exports.SplitV=exports.SparseToDense=exports.SparseSegmentSum=exports.SparseSegmentMean=exports.SparseReshape=exports.SparseFillEmptyRows=exports.SpaceToBatchND=exports.Softplus=exports.Softmax=exports.Slice=exports.Sinh=exports.Sin=exports.Sign=exports.Sigmoid=exports.Selu=exports.Select=exports.SearchSorted=exports.ScatterNd=exports.Rsqrt=exports.Round=exports.RotateWithOffset=exports.Reverse=exports.ResizeNearestNeighborGrad=exports.ResizeNearestNeighbor=exports.ResizeBilinearGrad=exports.ResizeBilinear=exports.Reshape=exports.Relu6=exports.Relu=exports.Reciprocal=exports.RealDiv=exports.Real=exports.Range=exports.RaggedTensorToTensor=exports.RaggedRange=exports.RaggedGather=exports.Prod=exports.Prelu=exports.Pow=exports.Pool=exports.PadV2=exports.Pack=exports.OnesLike=exports.OneHot=exports.NotEqual=exports.NonMaxSuppressionV5=exports.NonMaxSuppressionV4=exports.NonMaxSuppressionV3=exports.Neg=exports.Multiply=exports.Multinomial=exports.Mod=exports.MirrorPad=exports.Minimum=exports.Min=exports.Mean=void 0;const e=exports.Abs="Abs",o=exports.Acos="Acos",r=exports.Acosh="Acosh",t=exports.Add="Add",s=exports.AddN="AddN",p=exports.All="All",x=exports.Any="Any",a=exports.ArgMax="ArgMax",i=exports.ArgMin="ArgMin",n=exports.Asin="Asin",l=exports.Asinh="Asinh",d=exports.Atan="Atan",u=exports.Atanh="Atanh",S=exports.Atan2="Atan2",c=exports.AvgPool="AvgPool",g=exports.AvgPoolGrad="AvgPoolGrad",D=exports.AvgPool3D="AvgPool3D",m=exports.AvgPool3DGrad="AvgPool3DGrad",R=exports.BatchMatMul="BatchMatMul",h=exports.BatchToSpaceND="BatchToSpaceND",M=exports.Bincount="Bincount",A=exports.BitwiseAnd="BitwiseAnd",B=exports.BroadcastTo="BroadcastTo",N=exports.BroadcastArgs="BroadcastArgs",v=exports.Cast="Cast",C=exports.Ceil="Ceil",F=exports.ClipByValue="ClipByValue",P=exports.Complex="Complex",T=exports.ComplexAbs="ComplexAbs",L=exports.Concat="Concat",k=exports.Conv2D="Conv2D",G=exports.Conv2DBackpropFilter="Conv2DBackpropFilter",E=exports.Conv2DBackpropInput="Conv2DBackpropInput",f=exports.Conv3D="Conv3D",I=exports.Conv3DBackpropFilterV2="Conv3DBackpropFilterV2",q=exports.Conv3DBackpropInputV2="Conv3DBackpropInputV2",w=exports.Cos="Cos",V=exports.Cosh="Cosh",y=exports.Cumprod="Cumprod",b=exports.Cumsum="Cumsum",z=exports.CropAndResize="CropAndResize",U=exports.DenseBincount="DenseBincount",O=exports.DepthToSpace="DepthToSpace",H=exports.DepthwiseConv2dNative="DepthwiseConv2dNative",W=exports.DepthwiseConv2dNativeBackpropFilter="DepthwiseConv2dNativeBackpropFilter",_=exports.DepthwiseConv2dNativeBackpropInput="DepthwiseConv2dNativeBackpropInput",K=exports.Diag="Diag",X=exports.Dilation2D="Dilation2D",Z=exports.Dilation2DBackpropInput="Dilation2DBackpropInput",j=exports.Dilation2DBackpropFilter="Dilation2DBackpropFilter",J=exports.Draw="Draw",Q=exports.RealDiv="RealDiv",Y=exports.Einsum="Einsum",$=exports.Elu="Elu",ee=exports.EluGrad="EluGrad",oe=exports.Erf="Erf",re=exports.Equal="Equal",te=exports.Exp="Exp",se=exports.ExpandDims="ExpandDims",pe=exports.Expm1="Expm1",xe=exports.FFT="FFT",ae=exports.Fill="Fill",ie=exports.FlipLeftRight="FlipLeftRight",ne=exports.Floor="Floor",le=exports.FloorDiv="FloorDiv",de=exports.FusedBatchNorm="FusedBatchNorm",ue=exports.GatherV2="GatherV2",Se=exports.GatherNd="GatherNd",ce=exports.Greater="Greater",ge=exports.GreaterEqual="GreaterEqual",De=exports.Identity="Identity",me=exports.IFFT="IFFT",Re=exports.Imag="Imag",he=exports.IsFinite="IsFinite",Me=exports.IsInf="IsInf",Ae=exports.IsNan="IsNan",Be=exports.LeakyRelu="LeakyRelu",Ne=exports.Less="Less",ve=exports.LessEqual="LessEqual",Ce=exports.LinSpace="LinSpace",Fe=exports.Log="Log",Pe=exports.Log1p="Log1p",Te=exports.LogicalAnd="LogicalAnd",Le=exports.LogicalNot="LogicalNot",ke=exports.LogicalOr="LogicalOr",Ge=exports.LogicalXor="LogicalXor",Ee=exports.LogSoftmax="LogSoftmax",fe=exports.LowerBound="LowerBound",Ie=exports.LRN="LRN",qe=exports.LRNGrad="LRNGrad",we=exports.MatrixBandPart="MatrixBandPart",Ve=exports.Max="Max",ye=exports.Maximum="Maximum",be=exports.MaxPool="MaxPool",ze=exports.MaxPoolGrad="MaxPoolGrad",Ue=exports.MaxPool3D="MaxPool3D",Oe=exports.MaxPool3DGrad="MaxPool3DGrad",He=exports.MaxPoolWithArgmax="MaxPoolWithArgmax",We=exports.Mean="Mean",_e=exports.Min="Min",Ke=exports.Minimum="Minimum",Xe=exports.MirrorPad="MirrorPad",Ze=exports.Mod="Mod",je=exports.Multinomial="Multinomial",Je=exports.Multiply="Multiply",Qe=exports.Neg="Neg",Ye=exports.NotEqual="NotEqual",$e=exports.NonMaxSuppressionV3="NonMaxSuppressionV3",eo=exports.NonMaxSuppressionV4="NonMaxSuppressionV4",oo=exports.NonMaxSuppressionV5="NonMaxSuppressionV5",ro=exports.OnesLike="OnesLike",to=exports.OneHot="OneHot",so=exports.Pack="Pack",po=exports.PadV2="PadV2",xo=exports.Pool="Pool",ao=exports.Pow="Pow",io=exports.Prelu="Prelu",no=exports.Prod="Prod",lo=exports.RaggedGather="RaggedGather",uo=exports.RaggedRange="RaggedRange",So=exports.RaggedTensorToTensor="RaggedTensorToTensor",co=exports.Range="Range",go=exports.Real="Real",Do=exports.Reciprocal="Reciprocal",mo=exports.Relu="Relu",Ro=exports.Reshape="Reshape",ho=exports.ResizeNearestNeighbor="ResizeNearestNeighbor",Mo=exports.ResizeNearestNeighborGrad="ResizeNearestNeighborGrad",Ao=exports.ResizeBilinear="ResizeBilinear",Bo=exports.ResizeBilinearGrad="ResizeBilinearGrad",No=exports.Relu6="Relu6",vo=exports.Reverse="Reverse",Co=exports.Round="Round",Fo=exports.Rsqrt="Rsqrt",Po=exports.ScatterNd="ScatterNd",To=exports.TensorScatterUpdate="TensorScatterUpdate",Lo=exports.SearchSorted="SearchSorted",ko=exports.Select="Select",Go=exports.Selu="Selu",Eo=exports.Slice="Slice",fo=exports.Sin="Sin",Io=exports.Sinh="Sinh",qo=exports.Sign="Sign",wo=exports.Sigmoid="Sigmoid",Vo=exports.Softplus="Softplus",yo=exports.Sqrt="Sqrt",bo=exports.Sum="Sum",zo=exports.SpaceToBatchND="SpaceToBatchND",Uo=exports.SplitV="SplitV",Oo=exports.Softmax="Softmax",Ho=exports.SparseFillEmptyRows="SparseFillEmptyRows",Wo=exports.SparseReshape="SparseReshape",_o=exports.SparseSegmentMean="SparseSegmentMean",Ko=exports.SparseSegmentSum="SparseSegmentSum",Xo=exports.SparseToDense="SparseToDense",Zo=exports.SquaredDifference="SquaredDifference",jo=exports.Square="Square",Jo=exports.StaticRegexReplace="StaticRegexReplace",Qo=exports.StridedSlice="StridedSlice",Yo=exports.StringNGrams="StringNGrams",$o=exports.StringSplit="StringSplit",er=exports.StringToHashBucketFast="StringToHashBucketFast",or=exports.Sub="Sub",rr=exports.Tan="Tan",tr=exports.Tanh="Tanh",sr=exports.Tile="Tile",pr=exports.TopK="TopK",xr=exports.Transform="Transform",ar=exports.Transpose="Transpose",ir=exports.Unique="Unique",nr=exports.Unpack="Unpack",lr=exports.UnsortedSegmentSum="UnsortedSegmentSum",dr=exports.UpperBound="UpperBound",ur=exports.ZerosLike="ZerosLike",Sr=exports.Step="Step",cr=exports.FromPixels="FromPixels",gr=exports.RotateWithOffset="RotateWithOffset",Dr=exports._FusedMatMul="_FusedMatMul",mr=exports.FusedConv2D="FusedConv2D",Rr=exports.FusedDepthwiseConv2D="FusedDepthwiseConv2D";
},{}],"kMIn":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.log=n,exports.warn=o;var e=require("./environment");function o(...o){(0,e.env)().getBool("IS_TEST")||(0,e.env)().getBool("PROD")||console.warn(...o)}function n(...o){(0,e.env)().getBool("IS_TEST")||(0,e.env)().getBool("PROD")||console.log(...o)}
},{"./environment":"vpgN"}],"PlaY":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.copyRegisteredKernels=d,exports.getGradient=a,exports.getKernel=s,exports.getKernelsForBackend=c,exports.registerGradient=f,exports.registerKernel=u,exports.unregisterGradient=g,exports.unregisterKernel=l;var e=require("./environment"),r=require("./global_util"),t=n(require("./log"));function n(e,r){if("function"==typeof WeakMap)var t=new WeakMap,o=new WeakMap;return(n=function(e,r){if(!r&&e&&e.__esModule)return e;var n,i,s={__proto__:null,default:e};if(null===e||"object"!=typeof e&&"function"!=typeof e)return s;if(n=r?o:t){if(n.has(e))return n.get(e);n.set(e,s)}for(const t in e)"default"!==t&&{}.hasOwnProperty.call(e,t)&&((i=(n=Object.defineProperty)&&Object.getOwnPropertyDescriptor(e,t))&&(i.get||i.set)?n(s,t,i):s[t]=e[t]);return s})(e,r)}const o=(0,r.getGlobal)("kernelRegistry",()=>new Map),i=(0,r.getGlobal)("gradRegistry",()=>new Map);function s(e,r){const t=p(e,r);return o.get(t)}function a(e){return i.get(e)}function c(e){const r=o.entries(),t=[];for(;;){const{done:n,value:o}=r.next();if(n)break;const[i,s]=o,[a]=i.split("_");a===e&&t.push(s)}return t}function u(e){const{kernelName:r,backendName:n}=e,i=p(r,n);o.has(i)&&t.warn(`The kernel '${r}' for backend `+`'${n}' is already registered`),o.set(i,e)}function f(r){const{kernelName:n}=r;i.has(n)&&(0,e.env)().getBool("DEBUG")&&t.warn(`Overriding the gradient for '${n}'`),i.set(n,r)}function l(e,r){const t=p(e,r);if(!o.has(t))throw new Error(`The kernel '${e}' for backend `+`'${r}' is not registered`);o.delete(t)}function g(e){if(!i.has(e))throw new Error(`The gradient '${e}' for backend is not registered`);i.delete(e)}function d(e,r){c(e).forEach(e=>{u(Object.assign({},e,{backendName:r}))})}function p(e,r){return`${r}_${e}`}
},{"./environment":"vpgN","./global_util":"TJmh","./log":"kMIn"}],"lKzY":[function(require,module,exports) {
"use strict";function r(r){return r instanceof Float32Array||r instanceof Int32Array||r instanceof Uint8Array||r instanceof Uint8ClampedArray}Object.defineProperty(exports,"__esModule",{value:!0}),exports.isTypedArrayBrowser=r;
},{}],"YvD4":[function(require,module,exports) {
module.exports=t;var i=null;try{i=new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([0,97,115,109,1,0,0,0,1,13,2,96,0,1,127,96,4,127,127,127,127,1,127,3,7,6,0,1,1,1,1,1,6,6,1,127,1,65,0,11,7,50,6,3,109,117,108,0,1,5,100,105,118,95,115,0,2,5,100,105,118,95,117,0,3,5,114,101,109,95,115,0,4,5,114,101,109,95,117,0,5,8,103,101,116,95,104,105,103,104,0,0,10,191,1,6,4,0,35,0,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,126,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,127,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,128,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,129,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,130,34,4,66,32,135,167,36,0,32,4,167,11])),{}).exports}catch(L){}function t(i,t,n){this.low=0|i,this.high=0|t,this.unsigned=!!n}function n(i){return!0===(i&&i.__isLong__)}t.prototype.__isLong__,Object.defineProperty(t.prototype,"__isLong__",{value:!0}),t.isLong=n;var h={},s={};function e(i,t){var n,e,r;return t?(r=0<=(i>>>=0)&&i<256)&&(e=s[i])?e:(n=u(i,(0|i)<0?-1:0,!0),r&&(s[i]=n),n):(r=-128<=(i|=0)&&i<128)&&(e=h[i])?e:(n=u(i,i<0?-1:0,!1),r&&(h[i]=n),n)}function r(i,t){if(isNaN(i))return t?N:m;if(t){if(i<0)return N;if(i>=c)return p}else{if(i<=-w)return _;if(i+1>=w)return q}return i<0?r(-i,t).neg():u(i%d|0,i/d|0,t)}function u(i,n,h){return new t(i,n,h)}t.fromInt=e,t.fromNumber=r,t.fromBits=u;var o=Math.pow;function g(i,t,n){if(0===i.length)throw Error("empty string");if("NaN"===i||"Infinity"===i||"+Infinity"===i||"-Infinity"===i)return m;if("number"==typeof t?(n=t,t=!1):t=!!t,(n=n||10)<2||36<n)throw RangeError("radix");var h;if((h=i.indexOf("-"))>0)throw Error("interior hyphen");if(0===h)return g(i.substring(1),t,n).neg();for(var s=r(o(n,8)),e=m,u=0;u<i.length;u+=8){var f=Math.min(8,i.length-u),l=parseInt(i.substring(u,u+f),n);if(f<8){var a=r(o(n,f));e=e.mul(a).add(r(l))}else e=(e=e.mul(s)).add(r(l))}return e.unsigned=t,e}function f(i,t){return"number"==typeof i?r(i,t):"string"==typeof i?g(i,t):u(i.low,i.high,"boolean"==typeof t?t:i.unsigned)}t.fromString=g,t.fromValue=f;var l=65536,a=1<<24,d=l*l,c=d*d,w=c/2,v=e(a),m=e(0);t.ZERO=m;var N=e(0,!0);t.UZERO=N;var E=e(1);t.ONE=E;var y=e(1,!0);t.UONE=y;var b=e(-1);t.NEG_ONE=b;var q=u(-1,2147483647,!1);t.MAX_VALUE=q;var p=u(-1,-1,!0);t.MAX_UNSIGNED_VALUE=p;var _=u(0,-2147483648,!1);t.MIN_VALUE=_;var B=t.prototype;B.toInt=function(){return this.unsigned?this.low>>>0:this.low},B.toNumber=function(){return this.unsigned?(this.high>>>0)*d+(this.low>>>0):this.high*d+(this.low>>>0)},B.toString=function(i){if((i=i||10)<2||36<i)throw RangeError("radix");if(this.isZero())return"0";if(this.isNegative()){if(this.eq(_)){var t=r(i),n=this.div(t),h=n.mul(t).sub(this);return n.toString(i)+h.toInt().toString(i)}return"-"+this.neg().toString(i)}for(var s=r(o(i,6),this.unsigned),e=this,u="";;){var g=e.div(s),f=(e.sub(g.mul(s)).toInt()>>>0).toString(i);if((e=g).isZero())return f+u;for(;f.length<6;)f="0"+f;u=""+f+u}},B.getHighBits=function(){return this.high},B.getHighBitsUnsigned=function(){return this.high>>>0},B.getLowBits=function(){return this.low},B.getLowBitsUnsigned=function(){return this.low>>>0},B.getNumBitsAbs=function(){if(this.isNegative())return this.eq(_)?64:this.neg().getNumBitsAbs();for(var i=0!=this.high?this.high:this.low,t=31;t>0&&0==(i&1<<t);t--);return 0!=this.high?t+33:t+1},B.isZero=function(){return 0===this.high&&0===this.low},B.eqz=B.isZero,B.isNegative=function(){return!this.unsigned&&this.high<0},B.isPositive=function(){return this.unsigned||this.high>=0},B.isOdd=function(){return 1==(1&this.low)},B.isEven=function(){return 0==(1&this.low)},B.equals=function(i){return n(i)||(i=f(i)),(this.unsigned===i.unsigned||this.high>>>31!=1||i.high>>>31!=1)&&(this.high===i.high&&this.low===i.low)},B.eq=B.equals,B.notEquals=function(i){return!this.eq(i)},B.neq=B.notEquals,B.ne=B.notEquals,B.lessThan=function(i){return this.comp(i)<0},B.lt=B.lessThan,B.lessThanOrEqual=function(i){return this.comp(i)<=0},B.lte=B.lessThanOrEqual,B.le=B.lessThanOrEqual,B.greaterThan=function(i){return this.comp(i)>0},B.gt=B.greaterThan,B.greaterThanOrEqual=function(i){return this.comp(i)>=0},B.gte=B.greaterThanOrEqual,B.ge=B.greaterThanOrEqual,B.compare=function(i){if(n(i)||(i=f(i)),this.eq(i))return 0;var t=this.isNegative(),h=i.isNegative();return t&&!h?-1:!t&&h?1:this.unsigned?i.high>>>0>this.high>>>0||i.high===this.high&&i.low>>>0>this.low>>>0?-1:1:this.sub(i).isNegative()?-1:1},B.comp=B.compare,B.negate=function(){return!this.unsigned&&this.eq(_)?_:this.not().add(E)},B.neg=B.negate,B.add=function(i){n(i)||(i=f(i));var t=this.high>>>16,h=65535&this.high,s=this.low>>>16,e=65535&this.low,r=i.high>>>16,o=65535&i.high,g=i.low>>>16,l=0,a=0,d=0,c=0;return d+=(c+=e+(65535&i.low))>>>16,a+=(d+=s+g)>>>16,l+=(a+=h+o)>>>16,l+=t+r,u((d&=65535)<<16|(c&=65535),(l&=65535)<<16|(a&=65535),this.unsigned)},B.subtract=function(i){return n(i)||(i=f(i)),this.add(i.neg())},B.sub=B.subtract,B.multiply=function(t){if(this.isZero())return m;if(n(t)||(t=f(t)),i)return u(i.mul(this.low,this.high,t.low,t.high),i.get_high(),this.unsigned);if(t.isZero())return m;if(this.eq(_))return t.isOdd()?_:m;if(t.eq(_))return this.isOdd()?_:m;if(this.isNegative())return t.isNegative()?this.neg().mul(t.neg()):this.neg().mul(t).neg();if(t.isNegative())return this.mul(t.neg()).neg();if(this.lt(v)&&t.lt(v))return r(this.toNumber()*t.toNumber(),this.unsigned);var h=this.high>>>16,s=65535&this.high,e=this.low>>>16,o=65535&this.low,g=t.high>>>16,l=65535&t.high,a=t.low>>>16,d=65535&t.low,c=0,w=0,N=0,E=0;return N+=(E+=o*d)>>>16,w+=(N+=e*d)>>>16,N&=65535,w+=(N+=o*a)>>>16,c+=(w+=s*d)>>>16,w&=65535,c+=(w+=e*a)>>>16,w&=65535,c+=(w+=o*l)>>>16,c+=h*d+s*a+e*l+o*g,u((N&=65535)<<16|(E&=65535),(c&=65535)<<16|(w&=65535),this.unsigned)},B.mul=B.multiply,B.divide=function(t){if(n(t)||(t=f(t)),t.isZero())throw Error("division by zero");var h,s,e;if(i)return this.unsigned||-2147483648!==this.high||-1!==t.low||-1!==t.high?u((this.unsigned?i.div_u:i.div_s)(this.low,this.high,t.low,t.high),i.get_high(),this.unsigned):this;if(this.isZero())return this.unsigned?N:m;if(this.unsigned){if(t.unsigned||(t=t.toUnsigned()),t.gt(this))return N;if(t.gt(this.shru(1)))return y;e=N}else{if(this.eq(_))return t.eq(E)||t.eq(b)?_:t.eq(_)?E:(h=this.shr(1).div(t).shl(1)).eq(m)?t.isNegative()?E:b:(s=this.sub(t.mul(h)),e=h.add(s.div(t)));if(t.eq(_))return this.unsigned?N:m;if(this.isNegative())return t.isNegative()?this.neg().div(t.neg()):this.neg().div(t).neg();if(t.isNegative())return this.div(t.neg()).neg();e=m}for(s=this;s.gte(t);){h=Math.max(1,Math.floor(s.toNumber()/t.toNumber()));for(var g=Math.ceil(Math.log(h)/Math.LN2),l=g<=48?1:o(2,g-48),a=r(h),d=a.mul(t);d.isNegative()||d.gt(s);)d=(a=r(h-=l,this.unsigned)).mul(t);a.isZero()&&(a=E),e=e.add(a),s=s.sub(d)}return e},B.div=B.divide,B.modulo=function(t){return n(t)||(t=f(t)),i?u((this.unsigned?i.rem_u:i.rem_s)(this.low,this.high,t.low,t.high),i.get_high(),this.unsigned):this.sub(this.div(t).mul(t))},B.mod=B.modulo,B.rem=B.modulo,B.not=function(){return u(~this.low,~this.high,this.unsigned)},B.and=function(i){return n(i)||(i=f(i)),u(this.low&i.low,this.high&i.high,this.unsigned)},B.or=function(i){return n(i)||(i=f(i)),u(this.low|i.low,this.high|i.high,this.unsigned)},B.xor=function(i){return n(i)||(i=f(i)),u(this.low^i.low,this.high^i.high,this.unsigned)},B.shiftLeft=function(i){return n(i)&&(i=i.toInt()),0==(i&=63)?this:i<32?u(this.low<<i,this.high<<i|this.low>>>32-i,this.unsigned):u(0,this.low<<i-32,this.unsigned)},B.shl=B.shiftLeft,B.shiftRight=function(i){return n(i)&&(i=i.toInt()),0==(i&=63)?this:i<32?u(this.low>>>i|this.high<<32-i,this.high>>i,this.unsigned):u(this.high>>i-32,this.high>=0?0:-1,this.unsigned)},B.shr=B.shiftRight,B.shiftRightUnsigned=function(i){if(n(i)&&(i=i.toInt()),0===(i&=63))return this;var t=this.high;return i<32?u(this.low>>>i|t<<32-i,t>>>i,this.unsigned):u(32===i?t:t>>>i-32,0,this.unsigned)},B.shru=B.shiftRightUnsigned,B.shr_u=B.shiftRightUnsigned,B.toSigned=function(){return this.unsigned?u(this.low,this.high,!1):this},B.toUnsigned=function(){return this.unsigned?this:u(this.low,this.high,!0)},B.toBytes=function(i){return i?this.toBytesLE():this.toBytesBE()},B.toBytesLE=function(){var i=this.high,t=this.low;return[255&t,t>>>8&255,t>>>16&255,t>>>24,255&i,i>>>8&255,i>>>16&255,i>>>24]},B.toBytesBE=function(){var i=this.high,t=this.low;return[i>>>24,i>>>16&255,i>>>8&255,255&i,t>>>24,t>>>16&255,t>>>8&255,255&t]},t.fromBytes=function(i,n,h){return h?t.fromBytesLE(i,n):t.fromBytesBE(i,n)},t.fromBytesLE=function(i,n){return new t(i[0]|i[1]<<8|i[2]<<16|i[3]<<24,i[4]|i[5]<<8|i[6]<<16|i[7]<<24,n)},t.fromBytesBE=function(i,n){return new t(i[4]<<24|i[5]<<16|i[6]<<8|i[7],i[0]<<24|i[1]<<16|i[2]<<8|i[3],n)};
},{}],"rAgb":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.fingerPrint64=g,exports.hexToLong=t;var d=a(require("long"));function a(d,r){if("function"==typeof WeakMap)var t=new WeakMap,n=new WeakMap;return(a=function(d,a){if(!a&&d&&d.__esModule)return d;var r,u,e={__proto__:null,default:d};if(null===d||"object"!=typeof d&&"function"!=typeof d)return e;if(r=a?n:t){if(r.has(d))return r.get(d);r.set(d,e)}for(const t in d)"default"!==t&&{}.hasOwnProperty.call(d,t)&&((u=(r=Object.defineProperty)&&Object.getOwnPropertyDescriptor(d,t))&&(u.get||u.set)?r(e,t,u):e[t]=d[t]);return e})(d,r)}const r=d.default||d;function t(d){return r.fromString(d,!0,16)}const n=t("c3a5c85c97cb3127"),u=t("b492b66fbe98f273"),e=t("9ae16a3b2f90404f");function o(d){return d.xor(d.shru(47))}function l(d,a,t){const n=d.slice(a,a+t);return r.fromBytes(Array.from(n),!0,!0)}function f(d,a){return l(d,a,8)}function c(d,a){return l(d,a,4)}function i(d,a){return 0===a?d:d.shru(a).or(d.shl(64-a))}function m(d,a,r=t("9ddfea08eb382d69")){let n=d.xor(a).mul(r);n=n.xor(n.shru(47));let u=a.xor(n).mul(r);return u=(u=u.xor(u.shru(47))).mul(r)}function s(d,a,r,t,n,u){n=n.add(d),u=i(u.add(n).add(t),21);const e=n;return n=(n=n.add(a)).add(r),u=u.add(i(n,44)),[n.add(t),u.add(e)]}function h(d,a,r,t){return s(f(d,a),f(d,a+8),f(d,a+16),f(d,a+24),r,t)}function p(d,a=d.length){if(a>=8){const r=e.add(2*a),t=f(d,0).add(e),n=f(d,a-8);return m(i(n,37).mul(r).add(t),i(t,25).add(n).mul(r),r)}if(a>=4){const r=e.add(2*a);return m(c(d,0).shl(3).add(a),c(d,a-4),r)}if(a>0){const r=d[0]+(d[a>>1]<<8),t=a+(d[a-1]<<2);return o(e.mul(r).xor(n.mul(t))).mul(e)}return e}function x(d,a=d.length){const r=e.add(2*a),t=f(d,0).mul(u),n=f(d,8),o=f(d,a-8).mul(r),l=f(d,a-16).mul(e);return m(i(t.add(n),43).add(i(o,30)).add(l),t.add(i(n.add(e),18)).add(o),r)}function b(d,a=d.length){const r=e.add(2*a),t=f(d,0).mul(e),n=f(d,8),u=f(d,a-8).mul(r),o=f(d,a-16).mul(e),l=i(t.add(n),43).add(i(u,30)).add(o),c=m(l,t.add(i(n.add(e),18)).add(u),r),s=f(d,16).mul(r),h=f(d,24),p=l.add(f(d,a-32)).mul(r),x=c.add(f(d,a-24)).mul(r);return m(i(s.add(h),43).add(i(p,30)).add(x),s.add(i(h.add(t),18)).add(p),r)}function g(d,a=d.length){const t=r.fromNumber(81,!0);if(a<=32)return a<=16?p(d,a):x(d,a);if(a<=64)return b(d,a);let l=t,c=t.mul(u).add(113),s=o(c.mul(e).add(113)).mul(e),g=[r.UZERO,r.UZERO],y=[r.UZERO,r.UZERO];l=l.mul(e).add(f(d,0));let O=0;const _=64*(a-1>>6),w=_+(a-1&63)-63;do{l=i(l.add(c).add(g[0]).add(f(d,O+8)),37).mul(u),c=i(c.add(g[1]).add(f(d,O+48)),42).mul(u),l=l.xor(y[1]),c=c.add(g[0]).add(f(d,O+40)),s=i(s.add(y[0]),33).mul(u),g=h(d,O,g[1].mul(u),l.add(y[0])),y=h(d,O+32,s.add(y[1]),c.add(f(d,O+16))),[s,l]=[l,s],O+=64}while(O!==_);const M=u.add(s.and(255).shl(1));return O=w,y[0]=y[0].add(a-1&63),g[0]=g[0].add(y[0]),y[0]=y[0].add(g[0]),l=i(l.add(c).add(g[0]).add(f(d,O+8)),37).mul(M),c=i(c.add(g[1]).add(f(d,O+48)),42).mul(M),l=l.xor(y[1].mul(9)),c=c.add(g[0].mul(9).add(f(d,O+40))),s=i(s.add(y[0]),33).mul(M),g=h(d,O,g[1].mul(M),l.add(y[0])),y=h(d,O+32,s.add(y[1]),c.add(f(d,O+16))),[s,l]=[l,s],m(m(g[0],y[0],M).add(o(c).mul(n)).add(s),m(g[1],y[1],M).add(l),M)}
},{"long":"YvD4"}],"XXxQ":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0});var e={createScalarValue:!0,toTypedArray:!0,now:!0,fetch:!0,encodeString:!0,decodeString:!0,isTypedArray:!0,flatten:!0};exports.createScalarValue=f,exports.decodeString=p,exports.encodeString=c,exports.fetch=s,exports.flatten=d,exports.isTypedArray=y,exports.now=l,exports.toTypedArray=u;var r=require("./environment"),t=require("./platforms/is_typed_array_browser"),n=a(require("./util_base"));Object.keys(n).forEach(function(r){"default"!==r&&"__esModule"!==r&&(Object.prototype.hasOwnProperty.call(e,r)||r in exports&&exports[r]===n[r]||Object.defineProperty(exports,r,{enumerable:!0,get:function(){return n[r]}}))});var o=require("./hash_util");function a(e,r){if("function"==typeof WeakMap)var t=new WeakMap,n=new WeakMap;return(a=function(e,r){if(!r&&e&&e.__esModule)return e;var o,a,f={__proto__:null,default:e};if(null===e||"object"!=typeof e&&"function"!=typeof e)return f;if(o=r?n:t){if(o.has(e))return o.get(e);o.set(e,f)}for(const t in e)"default"!==t&&{}.hasOwnProperty.call(e,t)&&((a=(o=Object.defineProperty)&&Object.getOwnPropertyDescriptor(e,t))&&(a.get||a.set)?o(f,t,a):f[t]=e[t]);return f})(e,r)}function f(e,r){return"string"===r?c(e):u([e],r)}function i(e,r){return e instanceof Float32Array&&"float32"===r||e instanceof Int32Array&&"int32"===r||e instanceof Uint8Array&&"bool"===r}function u(e,t){if("string"===t)throw new Error("Cannot convert a string[] to a TypedArray");if(Array.isArray(e)&&(e=d(e)),(0,r.env)().getBool("DEBUG")&&n.checkConversionForErrors(e,t),i(e,t))return e;if(null==t||"float32"===t||"complex64"===t)return new Float32Array(e);if("int32"===t)return new Int32Array(e);if("bool"===t){const r=new Uint8Array(e.length);for(let t=0;t<r.length;++t)0!==Math.round(e[t])&&(r[t]=1);return r}throw new Error(`Unknown data type ${t}`)}function l(){return(0,r.env)().platform.now()}function s(e,t){return(0,r.env)().platform.fetch(e,t)}function c(e,t="utf-8"){return t=t||"utf-8",(0,r.env)().platform.encode(e,t)}function p(e,t="utf-8"){return t=t||"utf-8",(0,r.env)().platform.decode(e,t)}function y(e){return null!=(0,r.env)().platform.isTypedArray?(0,r.env)().platform.isTypedArray(e):(0,t.isTypedArrayBrowser)(e)}function d(e,r=[],t=!1){if(null==r&&(r=[]),"boolean"==typeof e||"number"==typeof e||"string"==typeof e||n.isPromise(e)||null==e||y(e)&&t)r.push(e);else if(Array.isArray(e)||y(e))for(let n=0;n<e.length;++n)d(e[n],r,t);else{let n=-1;for(const r of Object.keys(e))/^([1-9]+[0-9]*|0)$/.test(r)&&(n=Math.max(n,Number(r)));for(let o=0;o<=n;o++)d(e[o],r,t)}return r}Object.keys(o).forEach(function(r){"default"!==r&&"__esModule"!==r&&(Object.prototype.hasOwnProperty.call(e,r)||r in exports&&exports[r]===o[r]||Object.defineProperty(exports,r,{enumerable:!0,get:function(){return o[r]}}))});
},{"./environment":"vpgN","./platforms/is_typed_array_browser":"lKzY","./util_base":"uID4","./hash_util":"rAgb"}],"g3XT":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.Profiler=exports.Logger=void 0,exports.checkComputationForErrors=n;var e=require("./environment"),t=r(require("./util"));function r(e,t){if("function"==typeof WeakMap)var o=new WeakMap,n=new WeakMap;return(r=function(e,t){if(!t&&e&&e.__esModule)return e;var r,l,i={__proto__:null,default:e};if(null===e||"object"!=typeof e&&"function"!=typeof e)return i;if(r=t?n:o){if(r.has(e))return r.get(e);r.set(e,i)}for(const o in e)"default"!==o&&{}.hasOwnProperty.call(e,o)&&((l=(r=Object.defineProperty)&&Object.getOwnPropertyDescriptor(e,o))&&(l.get||l.set)?r(i,o,l):i[o]=e[o]);return i})(e,t)}class o{constructor(e,t){this.backendTimer=e,this.logger=t,null==t&&(this.logger=new l)}profileKernel(r,o,l){let i;const s=()=>{i=l()};let a;const c=t.now();if(this.backendTimer.timerAvailable())a=this.backendTimer.time(s);else{s();for(const e of i)e.dataSync();a=Promise.resolve({kernelMs:t.now()-c})}if((0,e.env)().getBool("CHECK_COMPUTATION_FOR_ERRORS"))for(let e=0;e<i.length;e++){const t=i[e];t.data().then(e=>{n(e,t.dtype,r)})}return{kernelName:r,outputs:i,inputs:o,timeMs:a.then(e=>e.kernelMs),extraInfo:a.then(e=>null!=e.getExtraProfileInfo?e.getExtraProfileInfo():"")}}logKernelProfile(e){const{kernelName:t,outputs:r,timeMs:o,inputs:n,extraInfo:l}=e;r.forEach(e=>{Promise.all([e.data(),o,l]).then(r=>{this.logger.logKernelProfile(t,e,r[0],r[1],n,r[2])})})}}function n(e,t,r){if("float32"!==t)return!1;for(let o=0;o<e.length;o++){const t=e[o];if(isNaN(t)||!isFinite(t))return console.warn(`Found ${t} in the result of '${r}'`),!0}return!1}exports.Profiler=o;class l{logKernelProfile(e,r,o,n,l,i){const s="number"==typeof n?t.rightPad(`${n}ms`,9):n.error,a=t.rightPad(e,25),c=r.rank,f=r.size,u=t.rightPad(r.shape.toString(),14);let g="";for(const t in l){const e=l[t];if(null!=e){const o=e.shape||r.shape,n=o.length;g+=`${t}: ${n}D ${n>0?o:""} `}}console.log(`%c${a}\t%c${s}\t%c${c}D ${u}\t%c${f}\t%c${g}\t%c${i}`,"font-weight:bold","color:red","color:blue","color: orange","color: green","color: steelblue")}}exports.Logger=l;
},{"./environment":"vpgN","./util":"XXxQ"}],"s88o":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.backpropagateGradients=o,exports.getFilteredNodesXToY=n;var t=e(require("./util"));function e(t,n){if("function"==typeof WeakMap)var o=new WeakMap,r=new WeakMap;return(e=function(t,e){if(!e&&t&&t.__esModule)return t;var n,i,s={__proto__:null,default:t};if(null===t||"object"!=typeof t&&"function"!=typeof t)return s;if(n=e?r:o){if(n.has(t))return n.get(t);n.set(t,s)}for(const o in t)"default"!==o&&{}.hasOwnProperty.call(t,o)&&((i=(n=Object.defineProperty)&&Object.getOwnPropertyDescriptor(t,o))&&(i.get||i.set)?n(s,o,i):s[o]=t[o]);return s})(t,n)}function n(t,e,n){const o={},r={};for(let a=0;a<e.length;a++)o[e[a].id]=!0;for(let a=0;a<t.length;a++){const n=t[a],i=n.inputs;for(const t in i){const s=i[t];let u=!1;for(let t=0;t<e.length;t++)if(o[s.id]){n.outputs.forEach(t=>o[t.id]=!0),u=!0,r[n.id]=!0;break}if(u)break}}const i={};i[n.id]=!0;const s={};for(let a=t.length-1;a>=0;a--){const e=t[a],n=e.inputs;for(let t=0;t<e.outputs.length;t++)if(i[e.outputs[t].id]){for(const t in n)i[n[t].id]=!0,s[e.id]=!0;break}}const u=[];for(let a=0;a<t.length;a++){const e=t[a];if(r[e.id]&&s[e.id]){const t={};for(const r in e.inputs){const n=e.inputs[r];o[n.id]&&(t[r]=n)}const n=Object.assign({},e);n.inputs=t,n.outputs=e.outputs,u.push(n)}}return u}function o(e,n,o,r){for(let i=n.length-1;i>=0;i--){const s=n[i],u=[];if(s.outputs.forEach(t=>{const n=e[t.id];null!=n?u.push(n):u.push(null)}),null==s.gradient)throw new Error("Cannot compute gradient: gradient function not found "+`for ${s.kernelName}.`);const a=s.gradient(u);for(const n in s.inputs){if(!(n in a))throw new Error(`Cannot backprop through input ${n}. `+`Available gradients found: ${Object.keys(a)}.`);const i=o(()=>a[n]());if("float32"!==i.dtype)throw new Error(`Error in gradient for op ${s.kernelName}. The gradient of input `+`${n} must have 'float32' dtype, but has '${i.dtype}'`);const u=s.inputs[n];if(!t.arraysEqual(i.shape,u.shape))throw new Error(`Error in gradient for op ${s.kernelName}. The gradient of input `+`'${n}' has shape '${i.shape}', which does not match `+`the shape of the input '${u.shape}'`);if(null==e[u.id])e[u.id]=i;else{const t=e[u.id];e[u.id]=r(t,i),t.dispose()}}}}
},{"./util":"XXxQ"}],"MlMg":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.tensorToString=o;var e=require("./util");const t=20,r=3,n=7;function o(t,r,n,o){const l=(0,e.computeStrides)(r),i=s(t,r,n,l),c=r.length,p=u(t,r,n,l,i),a=["Tensor"];return o&&(a.push(`  dtype: ${n}`),a.push(`  rank: ${c}`),a.push(`  shape: [${r}]`),a.push("  values:")),a.push(p.map(e=>"    "+e).join("\n")),a.join("\n")}function s(t,r,n,o){const s=(0,e.sizeFromShape)(r),i=o[o.length-1],u=new Array(i).fill(0),p=r.length,a="complex64"===n?c(t):t;if(p>1)for(let e=0;e<s/i;e++){const t=e*i;for(let e=0;e<i;e++)u[e]=Math.max(u[e],l(a[t+e],0,n).length)}return u}function l(t,r,o){let s;return s=Array.isArray(t)?`${parseFloat(t[0].toFixed(n))} + `+`${parseFloat(t[1].toFixed(n))}j`:(0,e.isString)(t)?`'${t}'`:"bool"===o?i(t):parseFloat(t.toFixed(n)).toString(),(0,e.rightPad)(s,r)}function i(e){return 0===e?"false":"true"}function u(e,n,o,s,p,a=!0){const f="complex64"===o?2:1,h=n[0],m=n.length;if(0===m){if("complex64"===o){return[l(c(e)[0],0,o)]}return"bool"===o?[i(e[0])]:[e[0].toString()]}if(1===m){if(h>t){const t=r*f;let n=Array.from(e.slice(0,t)),s=Array.from(e.slice((h-r)*f,h*f));return"complex64"===o&&(n=c(n),s=c(s)),["["+n.map((e,t)=>l(e,p[t],o)).join(", ")+", ..., "+s.map((e,t)=>l(e,p[h-r+t],o)).join(", ")+"]"]}return["["+("complex64"===o?c(e):Array.from(e)).map((e,t)=>l(e,p[t],o)).join(", ")+"]"]}const g=n.slice(1),x=s.slice(1),d=s[0]*f,y=[];if(h>t){for(let t=0;t<r;t++){const r=t*d,n=r+d;y.push(...u(e.slice(r,n),g,o,x,p,!1))}y.push("...");for(let t=h-r;t<h;t++){const r=t*d,n=r+d;y.push(...u(e.slice(r,n),g,o,x,p,t===h-1))}}else for(let t=0;t<h;t++){const r=t*d,n=r+d;y.push(...u(e.slice(r,n),g,o,x,p,t===h-1))}const j=2===m?",":"";y[0]="["+(h>0?y[0]+j:"");for(let t=1;t<y.length-1;t++)y[t]=" "+y[t]+j;let F=",\n";for(let t=2;t<m;t++)F+="\n";return y[y.length-1]=" "+y[y.length-1]+"]"+(a?"":F),y}function c(e){const t=[];for(let r=0;r<e.length;r+=2)t.push([e[r],e[r+1]]);return t}
},{"./util":"XXxQ"}],"eFW4":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.Variable=exports.TensorBuffer=exports.Tensor=void 0,exports.getGlobalTensorClass=c,exports.setDeprecationWarningFn=p,exports.setOpHandler=l,exports.setTensorTracker=d;var t=require("./global_util"),e=require("./tensor_format"),s=i(require("./util")),r=s;function i(t,e){if("function"==typeof WeakMap)var s=new WeakMap,r=new WeakMap;return(i=function(t,e){if(!e&&t&&t.__esModule)return t;var i,n,a={__proto__:null,default:t};if(null===t||"object"!=typeof t&&"function"!=typeof t)return a;if(i=e?r:s){if(i.has(t))return i.get(t);i.set(t,a)}for(const s in t)"default"!==s&&{}.hasOwnProperty.call(t,s)&&((n=(i=Object.defineProperty)&&Object.getOwnPropertyDescriptor(t,s))&&(n.get||n.set)?i(a,s,n):a[s]=t[s]);return a})(t,e)}class n{constructor(t,e,i){if(this.dtype=e,this.shape=t.slice(),this.size=r.sizeFromShape(t),null!=i){const t=i.length;r.assert(t===this.size,()=>`Length of values '${t}' does not match the size `+`inferred by the shape '${this.size}'.`)}if("complex64"===e)throw new Error("complex64 dtype TensorBuffers are not supported. Please create a TensorBuffer for the real and imaginary parts separately and call tf.complex(real, imag).");this.values=i||r.getArrayFromDType(e,this.size),this.strides=(0,s.computeStrides)(t)}set(t,...e){0===e.length&&(e=[0]),r.assert(e.length===this.rank,()=>`The number of provided coordinates (${e.length}) must `+`match the rank (${this.rank})`);const s=this.locToIndex(e);this.values[s]=t}get(...t){0===t.length&&(t=[0]);let e=0;for(const r of t){if(r<0||r>=this.shape[e]){const e=`Requested out of range element at ${t}. `+`  Buffer shape=${this.shape}`;throw new Error(e)}e++}let s=t[t.length-1];for(let r=0;r<t.length-1;++r)s+=this.strides[r]*t[r];return this.values[s]}locToIndex(t){if(0===this.rank)return 0;if(1===this.rank)return t[0];let e=t[t.length-1];for(let s=0;s<t.length-1;++s)e+=this.strides[s]*t[s];return e}indexToLoc(t){if(0===this.rank)return[];if(1===this.rank)return[t];const e=new Array(this.shape.length);for(let s=0;s<e.length-1;++s)e[s]=Math.floor(t/this.strides[s]),t-=e[s]*this.strides[s];return e[e.length-1]=t,e}get rank(){return this.shape.length}toTensor(){return a().makeTensor(this.values,this.shape,this.dtype)}}exports.TensorBuffer=n;let a=null,o=null,h=null;function d(t){a=t}function l(t){o=t}function p(t){h=t}class u{constructor(t,e,i,n){this.kept=!1,this.isDisposedInternal=!1,this.shape=t.slice(),this.dtype=e||"float32",this.size=r.sizeFromShape(t),this.strides=(0,s.computeStrides)(t),this.dataId=i,this.id=n,this.rankType=this.rank<5?this.rank.toString():"higher"}get rank(){return this.shape.length}async buffer(){const t=await this.data();return o.buffer(this.shape,this.dtype,t)}bufferSync(){return o.buffer(this.shape,this.dtype,this.dataSync())}async array(){const t=await this.data();return(0,s.toNestedArray)(this.shape,t,"complex64"===this.dtype)}arraySync(){return(0,s.toNestedArray)(this.shape,this.dataSync(),"complex64"===this.dtype)}async data(){this.throwIfDisposed();const t=a().read(this.dataId);if("string"===this.dtype){const s=await t;try{return s.map(t=>r.decodeString(t))}catch(e){throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}}return t}dataToGPU(t){return this.throwIfDisposed(),a().readToGPU(this.dataId,t)}dataSync(){this.throwIfDisposed();const t=a().readSync(this.dataId);if("string"===this.dtype)try{return t.map(t=>r.decodeString(t))}catch(e){throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}return t}async bytes(){this.throwIfDisposed();const t=await a().read(this.dataId);return"string"===this.dtype?t:new Uint8Array(t.buffer)}dispose(){this.isDisposed||(this.kerasMask&&this.kerasMask.dispose(),a().disposeTensor(this),this.isDisposedInternal=!0)}get isDisposed(){return this.isDisposedInternal}throwIfDisposed(){if(this.isDisposed)throw new Error("Tensor is disposed.")}print(t=!1){return o.print(this,t)}clone(){return this.throwIfDisposed(),o.clone(this)}toString(t=!1){const s=this.dataSync();return(0,e.tensorToString)(s,this.shape,this.dtype,t)}cast(t){return this.throwIfDisposed(),o.cast(this,t)}variable(t=!0,e,s){return this.throwIfDisposed(),a().makeVariable(this,t,e,s)}}function c(){return(0,t.getGlobal)("Tensor",()=>u)}exports.Tensor=u,Object.defineProperty(u,Symbol.hasInstance,{value:t=>!!t&&null!=t.data&&null!=t.dataSync&&null!=t.throwIfDisposed}),c();class f extends u{constructor(t,e,s,r){super(t.shape,t.dtype,t.dataId,r),this.trainable=e,this.name=s}assign(t){if(t.dtype!==this.dtype)throw new Error(`dtype of the new value (${t.dtype}) and `+`previous value (${this.dtype}) must match`);if(!r.arraysEqual(t.shape,this.shape))throw new Error(`shape of the new value (${t.shape}) and `+`previous value (${this.shape}) must match`);a().disposeTensor(this),this.dataId=t.dataId,a().incRef(this,null)}dispose(){a().disposeVariable(this),this.isDisposedInternal=!0}}exports.Variable=f,Object.defineProperty(f,Symbol.hasInstance,{value:t=>t instanceof u&&null!=t.assign&&t.assign instanceof Function});
},{"./global_util":"TJmh","./tensor_format":"MlMg","./util":"XXxQ"}],"xhfJ":[function(require,module,exports) {
"use strict";var t,o,e,n,r;Object.defineProperty(exports,"__esModule",{value:!0}),exports.Rank=void 0,exports.isWebGLData=u,exports.isWebGPUData=c,exports.sumOutType=l,exports.upcastType=i,function(t){t.R0="R0",t.R1="R1",t.R2="R2",t.R3="R3",t.R4="R4",t.R5="R5",t.R6="R6"}(t||(exports.Rank=t={})),function(t){t.float32="float32",t.int32="int32",t.bool="int32",t.complex64="complex64"}(o||(o={})),function(t){t.float32="float32",t.int32="int32",t.bool="bool",t.complex64="complex64"}(e||(e={})),function(t){t.float32="float32",t.int32="float32",t.bool="float32",t.complex64="complex64"}(n||(n={})),function(t){t.float32="complex64",t.int32="complex64",t.bool="complex64",t.complex64="complex64"}(r||(r={}));const f={float32:n,int32:o,bool:e,complex64:r};function i(t,o){if("string"===t||"string"===o){if("string"===t&&"string"===o)return"string";throw new Error(`Can not upcast ${t} with ${o}`)}return f[t][o]}function l(t){return i(t,"int32")}function u(t){return null!=t&&"object"==typeof t&&"texture"in t&&t.texture instanceof WebGLTexture}function c(t){return"undefined"!=typeof GPUBuffer&&null!=t&&"object"==typeof t&&"buffer"in t&&t.buffer instanceof GPUBuffer}
},{}],"wtFc":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.assertTypesMatch=s,exports.getTensorsInContainer=i,exports.isTensorInList=o,exports.makeTypesMatch=n;var t=require("./tensor"),e=require("./types"),r=require("./util");function n(t,r){if(t.dtype===r.dtype)return[t,r];const n=(0,e.upcastType)(t.dtype,r.dtype);return[t.cast(n),r.cast(n)]}function s(t,e){(0,r.assert)(t.dtype===e.dtype,()=>`The dtypes of the first(${t.dtype}) and`+` second(${e.dtype}) input must match`)}function o(t,e){return e.some(e=>e.id===t.id)}function i(t){const e=[];return u(t,e,new Set),e}function u(e,r,n){if(null==e)return;if(e instanceof t.Tensor)return void r.push(e);if(!p(e))return;const s=e;for(const t in s){const e=s[t];n.has(e)||(n.add(e),u(e,r,n))}}function p(t){return Array.isArray(t)||"object"==typeof t}
},{"./tensor":"eFW4","./types":"xhfJ","./util":"XXxQ"}],"phT7":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.Engine=exports.ENGINE=void 0,exports.add=b,exports.getOrMakeEngine=g;var e=require("./backends/backend"),t=require("./environment"),s=require("./global_util"),n=require("./kernel_names"),r=require("./kernel_registry"),a=u(require("./log")),i=require("./profiler"),o=require("./tape"),c=require("./tensor"),d=require("./tensor_util"),h=u(require("./util")),l=h;function u(e,t){if("function"==typeof WeakMap)var s=new WeakMap,n=new WeakMap;return(u=function(e,t){if(!t&&e&&e.__esModule)return e;var r,a,i={__proto__:null,default:e};if(null===e||"object"!=typeof e&&"function"!=typeof e)return i;if(r=t?n:s){if(r.has(e))return r.get(e);r.set(e,i)}for(const s in e)"default"!==s&&{}.hasOwnProperty.call(e,s)&&((a=(r=Object.defineProperty)&&Object.getOwnPropertyDescriptor(e,s))&&(a.get||a.set)?r(i,s,a):i[s]=e[s]);return i})(e,t)}function p(e){return null!=e.kernelName}class f{constructor(){this.registeredVariables={},this.nextTapeNodeId=0,this.numBytes=0,this.numTensors=0,this.numStringTensors=0,this.numDataBuffers=0,this.gradientDepth=0,this.kernelDepth=0,this.scopeStack=[],this.numDataMovesStack=[],this.nextScopeId=0,this.tensorInfo=new WeakMap,this.profiling=!1,this.activeProfile={newBytes:0,newTensors:0,peakBytes:0,kernels:[],result:null,get kernelNames(){return Array.from(new Set(this.kernels.map(e=>e.name)))}}}dispose(){for(const e in this.registeredVariables)this.registeredVariables[e].dispose()}}class k{constructor(e){this.ENV=e,this.registry={},this.registryFactory={},this.pendingBackendInitId=0,this.state=new f}async ready(){if(null!=this.pendingBackendInit)return this.pendingBackendInit.then(()=>{});if(null!=this.backendInstance)return;const e=this.getSortedBackends();for(let t=0;t<e.length;t++){const s=e[t];if(await this.initializeBackend(s).success)return void(await this.setBackend(s))}throw new Error("Could not initialize any backends, all backend initializations failed.")}get backend(){if(null!=this.pendingBackendInit)throw new Error(`Backend '${this.backendName}' has not yet been initialized. Make `+"sure to await tf.ready() or await tf.setBackend() before calling other methods");if(null==this.backendInstance){const{name:e,asyncInit:t}=this.initializeBackendsAndReturnBest();if(t)throw new Error(`The highest priority backend '${e}' has not yet been `+"initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods");this.setBackend(e)}return this.backendInstance}backendNames(){return Object.keys(this.registryFactory)}findBackend(e){if(!(e in this.registry)){if(!(e in this.registryFactory))return null;{const{asyncInit:t}=this.initializeBackend(e);if(t)return null}}return this.registry[e]}findBackendFactory(e){return e in this.registryFactory?this.registryFactory[e].factory:null}registerBackend(e,t,s=1){return e in this.registryFactory?(a.warn(`${e} backend was already registered. `+"Reusing existing backend factory."),!1):(this.registryFactory[e]={factory:t,priority:s},!0)}async setBackend(e){if(null==this.registryFactory[e])throw new Error(`Backend name '${e}' not found in registry`);if(this.backendName=e,null==this.registry[e]){this.backendInstance=null;const{success:t,asyncInit:s}=this.initializeBackend(e);if(!(s?await t:t))return!1}return this.backendInstance=this.registry[e],this.setupRegisteredKernels(),this.profiler=new i.Profiler(this.backendInstance),!0}setupRegisteredKernels(){(0,r.getKernelsForBackend)(this.backendName).forEach(e=>{null!=e.setupFunc&&e.setupFunc(this.backendInstance)})}disposeRegisteredKernels(e){(0,r.getKernelsForBackend)(e).forEach(t=>{null!=t.disposeFunc&&t.disposeFunc(this.registry[e])})}initializeBackend(t){const s=this.registryFactory[t];if(null==s)throw new Error(`Cannot initialize backend ${t}, no registration found.`);try{const r=s.factory();if(!r||r instanceof e.KernelBackend||"function"!=typeof r.then)return this.registry[t]=r,{success:!0,asyncInit:!1};{const e=++this.pendingBackendInitId,s=r.then(s=>!(e<this.pendingBackendInitId)&&(this.registry[t]=s,this.pendingBackendInit=null,!0)).catch(s=>!(e<this.pendingBackendInitId)&&(this.pendingBackendInit=null,a.warn(`Initialization of backend ${t} failed`),a.warn(s.stack||s.message),!1));return this.pendingBackendInit=s,{success:s,asyncInit:!0}}}catch(n){return a.warn(`Initialization of backend ${t} failed`),a.warn(n.stack||n.message),{success:!1,asyncInit:!1}}}removeBackend(e){if(!(e in this.registryFactory))throw new Error(`${e} backend not found in registry`);this.backendName===e&&null!=this.pendingBackendInit&&this.pendingBackendInitId++,e in this.registry&&(this.disposeRegisteredKernels(e),this.registry[e].dispose(),delete this.registry[e]),delete this.registryFactory[e],this.backendName===e&&(this.pendingBackendInit=null,this.backendName=null,this.backendInstance=null)}getSortedBackends(){if(0===Object.keys(this.registryFactory).length)throw new Error("No backend found in registry.");return Object.keys(this.registryFactory).sort((e,t)=>this.registryFactory[t].priority-this.registryFactory[e].priority)}initializeBackendsAndReturnBest(){const e=this.getSortedBackends();for(let t=0;t<e.length;t++){const s=e[t],{success:n,asyncInit:r}=this.initializeBackend(s);if(r||n)return{name:s,asyncInit:r}}throw new Error("Could not initialize any backends, all backend initializations failed.")}moveData(e,t){const s=this.state.tensorInfo.get(t),n=s.backend,r=this.readSync(t),a=n.refCount(t);n.disposeData(t,!0),s.backend=e,e.move(t,r,s.shape,s.dtype,a),this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack[this.state.numDataMovesStack.length-1]++}tidy(e,t){let s,n=null;if(null==t){if("function"!=typeof e)throw new Error("Please provide a function to tidy()");t=e}else{if("string"!=typeof e&&!(e instanceof String))throw new Error("When calling with two arguments, the first argument to tidy() must be a string");if("function"!=typeof t)throw new Error("When calling with two arguments, the 2nd argument to tidy() must be a function");n=e}return this.scopedRun(()=>this.startScope(n),()=>this.endScope(s),()=>((s=t())instanceof Promise&&console.error("Cannot return a Promise inside of tidy."),s))}scopedRun(e,t,s){e();try{const e=s();return t(),e}catch(n){throw t(),n}}nextTensorId(){return k.nextTensorId++}nextVariableId(){return k.nextVariableId++}clone(e){const t=m.runKernel(n.Identity,{x:e}),s={x:e};return this.addTapeNode(this.state.activeScope.name,s,[t],e=>({x:()=>{const t={x:e},s={dtype:"float32"};return m.runKernel(n.Cast,t,s)}}),[],{}),t}runKernel(e,t,s){if(null==this.backendName&&this.backend,!(null!=(0,r.getKernel)(e,this.backendName)))throw new Error(`Kernel '${e}' not registered for backend '${this.backendName}'`);return this.runKernelFunc({kernelName:e,inputs:t,attrs:s})}shouldCheckForMemLeaks(){return this.ENV.getBool("IS_TEST")}checkKernelForMemLeak(e,t,s){const n=this.backend.numDataIds();let r=0;s.forEach(e=>{r+="complex64"===e.dtype?3:1});const a=this.state.numDataMovesStack[this.state.numDataMovesStack.length-1],i=n-t-r-a;if(i>0)throw new Error(`Backend '${this.backendName}' has an internal memory leak `+`(${i} data ids) after running '${e}'`)}runKernelFunc(e){let t,s=[];const n=this.isTapeOn(),a=this.state.numBytes,i=this.state.numTensors;let o,c;this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack.push(0),null==this.backendName&&this.backend;const d=p(e)?e.kernelName:null!=this.state.activeScope?this.state.activeScope.name:"";if(p(e)){const{kernelName:t,inputs:a,attrs:i}=e;null==this.backendName&&this.backend;const d=(0,r.getKernel)(t,this.backendName);l.assert(null!=d,()=>`Cannot find registered kernel '${t}' for backend '${this.backendName}'`),o=(()=>{const e=this.backend.numDataIds();c=d.kernelFunc({inputs:a,attrs:i,backend:this.backend});const r=Array.isArray(c)?c:[c];this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(t,e,r);const o=r.map(e=>null!=e.rank?e:this.makeTensorFromTensorInfo(e));if(n){const e=this.getTensorsForGradient(t,a,o);s=this.saveTensorsForBackwardMode(e)}return o})}else{const{forwardFunc:t}=e,r=e=>{n&&(s=e.map(e=>this.keep(this.clone(e))))};o=(()=>{const e=this.backend.numDataIds();c=this.tidy(()=>t(this.backend,r));const s=Array.isArray(c)?c:[c];return this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(d,e,s),s})}const{inputs:h,attrs:u}=e,f=p(e)?null:e.backwardsFunc;let k;return this.scopedRun(()=>this.state.kernelDepth++,()=>this.state.kernelDepth--,()=>{this.ENV.getBool("DEBUG")||this.state.profiling?(k=this.profiler.profileKernel(d,h,()=>o()),this.ENV.getBool("DEBUG")&&this.profiler.logKernelProfile(k),t=k.outputs):t=o()}),n&&this.addTapeNode(d,h,t,f,s,u),this.state.profiling&&this.state.activeProfile.kernels.push({name:d,bytesAdded:this.state.numBytes-a,totalBytesSnapshot:this.state.numBytes,tensorsAdded:this.state.numTensors-i,totalTensorsSnapshot:this.state.numTensors,inputShapes:Object.keys(h).map(e=>null!=h[e]?h[e].shape:null),outputShapes:t.map(e=>e.shape),kernelTimeMs:k.timeMs,extraInfo:k.extraInfo}),Array.isArray(c)?t:t[0]}saveTensorsForBackwardMode(e){return e.map(e=>this.keep(this.clone(e)))}getTensorsForGradient(e,t,s){const n=(0,r.getGradient)(e);if(null!=n){const e=n.inputsToSave||[],r=n.outputsToSave||[];let a;n.saveAllInputs?(l.assert(Array.isArray(t),()=>"saveAllInputs is true, expected inputs to be an array."),a=Object.keys(t).map(e=>t[e])):a=e.map(e=>t[e]);const i=s.filter((e,t)=>r[t]);return a.concat(i)}return[]}makeTensor(e,t,s,n){if(null==e)throw new Error("Values passed to engine.makeTensor() are null");s=s||"float32",n=n||this.backend;let r=e;"string"===s&&l.isString(e[0])&&(r=e.map(e=>l.encodeString(e)));const a=n.write(r,t,s),i=new c.Tensor(t,s,a,this.nextTensorId());if(this.trackTensor(i,n),"string"===s){const e=this.state.tensorInfo.get(a),t=(0,h.bytesFromStringArray)(r);this.state.numBytes+=t-e.bytes,e.bytes=t}return i}makeTensorFromDataId(e,t,s,n){const r={dataId:e,shape:t,dtype:s=s||"float32"};return this.makeTensorFromTensorInfo(r,n)}makeTensorFromTensorInfo(e,t){const{dataId:s,shape:n,dtype:r}=e,a=new c.Tensor(n,r,s,this.nextTensorId());return this.trackTensor(a,t),a}makeVariable(e,t=!0,s,n){s=s||this.nextVariableId().toString(),null!=n&&n!==e.dtype&&(e=e.cast(n));const r=new c.Variable(e,t,s,this.nextTensorId());if(null!=this.state.registeredVariables[r.name])throw new Error(`Variable with name ${r.name} was already registered`);return this.state.registeredVariables[r.name]=r,this.incRef(r,this.backend),r}trackTensor(e,t){this.state.numTensors++,"string"===e.dtype&&this.state.numStringTensors++;let s=0;"complex64"!==e.dtype&&"string"!==e.dtype&&(s=e.size*l.bytesPerElement(e.dtype)),this.state.numBytes+=s,this.state.tensorInfo.has(e.dataId)||(this.state.numDataBuffers++,this.state.tensorInfo.set(e.dataId,{backend:t||this.backend,dtype:e.dtype,shape:e.shape,bytes:s})),e instanceof c.Variable||this.track(e)}incRef(e,t){this.trackTensor(e,t),this.backend.incRef(e.dataId)}removeDataId(e,t){this.state.tensorInfo.has(e)&&this.state.tensorInfo.get(e).backend===t&&(this.state.tensorInfo.delete(e),this.state.numDataBuffers--)}disposeTensor(e){if(!this.state.tensorInfo.has(e.dataId))return;const t=this.state.tensorInfo.get(e.dataId);if(this.state.numTensors--,"string"===e.dtype&&(this.state.numStringTensors--,this.state.numBytes-=t.bytes),"complex64"!==e.dtype&&"string"!==e.dtype){const t=e.size*l.bytesPerElement(e.dtype);this.state.numBytes-=t}t.backend.disposeData(e.dataId)&&this.removeDataId(e.dataId,t.backend)}disposeVariables(){for(const e in this.state.registeredVariables){const t=this.state.registeredVariables[e];this.disposeVariable(t)}}disposeVariable(e){this.disposeTensor(e),null!=this.state.registeredVariables[e.name]&&delete this.state.registeredVariables[e.name]}memory(){const e=this.backend.memory();return e.numTensors=this.state.numTensors,e.numDataBuffers=this.state.numDataBuffers,e.numBytes=this.state.numBytes,this.state.numStringTensors>0&&(e.unreliable=!0,null==e.reasons&&(e.reasons=[]),e.reasons.push("Memory usage by string tensors is approximate (2 bytes per character)")),e}async profile(e){this.state.profiling=!0;const t=this.state.numBytes,s=this.state.numTensors;this.state.activeProfile.kernels=[],this.state.activeProfile.result=await e(),this.state.profiling=!1,this.state.activeProfile.peakBytes=Math.max(...this.state.activeProfile.kernels.map(e=>e.totalBytesSnapshot)),this.state.activeProfile.newBytes=this.state.numBytes-t,this.state.activeProfile.newTensors=this.state.numTensors-s;for(const n of this.state.activeProfile.kernels)n.kernelTimeMs=await n.kernelTimeMs,n.extraInfo=await n.extraInfo;return this.state.activeProfile}isTapeOn(){return this.state.gradientDepth>0&&0===this.state.kernelDepth}addTapeNode(e,t,s,n,a,i){const o={id:this.state.nextTapeNodeId++,kernelName:e,inputs:t,outputs:s,saved:a},c=(0,r.getGradient)(e);null!=c&&(n=c.gradFunc),null!=n&&(o.gradient=(e=>(e=e.map((e,t)=>{if(null==e){const e=s[t],n=l.makeZerosTypedArray(e.size,e.dtype);return this.makeTensor(n,e.shape,e.dtype)}return e}),n(e.length>1?e:e[0],a,i)))),this.state.activeTape.push(o)}keep(e){return e.kept=!0,e}startTape(){0===this.state.gradientDepth&&(this.state.activeTape=[]),this.state.gradientDepth++}endTape(){this.state.gradientDepth--}startScope(e){const t={track:[],name:"unnamed scope",id:this.state.nextScopeId++};e&&(t.name=e),this.state.scopeStack.push(t),this.state.activeScope=t}endScope(e){const t=(0,d.getTensorsInContainer)(e),s=new Set(t.map(e=>e.id));for(let r=0;r<this.state.activeScope.track.length;r++){const e=this.state.activeScope.track[r];e.kept||s.has(e.id)||e.dispose()}const n=this.state.scopeStack.pop();this.state.activeScope=0===this.state.scopeStack.length?null:this.state.scopeStack[this.state.scopeStack.length-1],t.forEach(e=>{e.kept||e.scopeId!==n.id||this.track(e)})}gradients(e,t,s,n=!1){if(l.assert(t.length>0,()=>"gradients() received an empty list of xs."),null!=s&&"float32"!==s.dtype)throw new Error(`dy must have 'float32' dtype, but has '${s.dtype}'`);const r=this.scopedRun(()=>this.startTape(),()=>this.endTape(),()=>this.tidy("forward",e));l.assert(r instanceof c.Tensor,()=>"The result y returned by f() must be a tensor.");const a=(0,o.getFilteredNodesXToY)(this.state.activeTape,t,r);if(!n&&0===a.length&&t.length>0)throw new Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that the f you passed encloses all operations that lead from x to y.");return this.tidy("backward",()=>{const e={};e[r.id]=null==s?y(r.shape):s,(0,o.backpropagateGradients)(e,a,e=>this.tidy(e),b);const n=t.map(t=>e[t.id]);return 0===this.state.gradientDepth&&(this.state.activeTape.forEach(e=>{for(const t of e.saved)t.dispose()}),this.state.activeTape=null),{value:r,grads:n}})}customGrad(e){return l.assert(l.isFunction(e),()=>"The f passed in customGrad(f) must be a function."),(...t)=>{let s;l.assert(t.every(e=>e instanceof c.Tensor),()=>"The args passed in customGrad(f)(x1, x2,...) must all be tensors");const n={};t.forEach((e,t)=>{n[t]=e});return this.runKernelFunc({forwardFunc:(n,r)=>(s=e(...t,r),l.assert(s.value instanceof c.Tensor,()=>"The function f passed in customGrad(f) must return an object where `obj.value` is a tensor"),l.assert(l.isFunction(s.gradFunc),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function."),s.value),backwardsFunc:(e,n)=>{const r=s.gradFunc(e,n),a=Array.isArray(r)?r:[r];l.assert(a.length===t.length,()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns the same number of tensors as inputs passed to f(...)."),l.assert(a.every(e=>e instanceof c.Tensor),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns a list of only tensors.");const i={};return a.forEach((e,t)=>{i[t]=(()=>e)}),i},inputs:n})}}readSync(e){return this.state.tensorInfo.get(e).backend.readSync(e)}read(e){return this.state.tensorInfo.get(e).backend.read(e)}readToGPU(e,t){return this.state.tensorInfo.get(e).backend.readToGPU(e,t)}async time(e){const t=(0,h.now)(),s=await this.backend.time(e);return s.wallMs=(0,h.now)()-t,s}track(e){return null!=this.state.activeScope&&(e.scopeId=this.state.activeScope.id,this.state.activeScope.track.push(e)),e}get registeredVariables(){return this.state.registeredVariables}reset(){this.pendingBackendInitId++,this.state.dispose(),this.ENV.reset(),this.state=new f;for(const e in this.registry)this.disposeRegisteredKernels(e),this.registry[e].dispose(),delete this.registry[e];this.backendName=null,this.backendInstance=null,this.pendingBackendInit=null}}function y(e){const t=(0,h.makeOnesTypedArray)((0,h.sizeFromShape)(e),"float32");return m.makeTensor(t,e,"float32")}function g(){const e=(0,s.getGlobalNamespace)();if(null==e._tfengine){const s=new t.Environment(e);e._tfengine=new k(s)}return(0,t.setEnvironmentGlobal)(e._tfengine.ENV),(0,c.setTensorTracker)(()=>e._tfengine),e._tfengine}exports.Engine=k,k.nextTensorId=0,k.nextVariableId=0;const m=exports.ENGINE=g();function b(e,t){const s={a:e,b:t};return m.runKernel(n.Add,s)}
},{"./backends/backend":"Sk1f","./environment":"vpgN","./global_util":"TJmh","./kernel_names":"rJl6","./kernel_registry":"PlaY","./log":"kMIn","./profiler":"g3XT","./tape":"s88o","./tensor":"eFW4","./tensor_util":"wtFc","./util":"XXxQ"}],"g3Z1":[function(require,module,exports) {
"use strict";function e(){return"undefined"!=typeof navigator&&null!=navigator}let i;function o(e){i=e}function t(o){if(void 0!==i)return i;if(o||e()){if(o||(o=navigator),"ReactNative"===o.product)return!0;const e=o.userAgent||o.vendor||("undefined"!=typeof window?window.opera:"");if(!e){const e=o;return e.userAgentData&&e.userAgentData.mobile}return/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(e)||/1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(e.substr(0,4))}return!1}function a(){return"undefined"!=typeof window&&null!=window.document||"undefined"!=typeof WorkerGlobalScope}Object.defineProperty(exports,"__esModule",{value:!0}),exports.isBrowser=a,exports.isMobile=t,exports.mockIsMobile=o;
},{}],"lELk":[function(require,module,exports) {
var process = require("process");
var e=require("process");require("./engine");var r=n(require("./device_util")),t=require("./environment");function n(e,r){if("function"==typeof WeakMap)var t=new WeakMap,i=new WeakMap;return(n=function(e,r){if(!r&&e&&e.__esModule)return e;var n,a,o={__proto__:null,default:e};if(null===e||"object"!=typeof e&&"function"!=typeof e)return o;if(n=r?i:t){if(n.has(e))return n.get(e);n.set(e,o)}for(const t in e)"default"!==t&&{}.hasOwnProperty.call(e,t)&&((a=(n=Object.defineProperty)&&Object.getOwnPropertyDescriptor(e,t))&&(a.get||a.set)?n(o,t,a):o[t]=e[t]);return o})(e,r)}const i=(0,t.env)();i.registerFlag("DEBUG",()=>!1,e=>{e&&console.warn("Debugging mode is ON. The output of every math call will be downloaded to CPU and checked for NaNs. This significantly impacts performance.")}),i.registerFlag("IS_BROWSER",()=>r.isBrowser()),i.registerFlag("IS_NODE",()=>void 0!==e&&void 0!==e.versions&&void 0!==e.versions.node),i.registerFlag("IS_CHROME",()=>"undefined"!=typeof navigator&&null!=navigator&&null!=navigator.userAgent&&/Chrome/.test(navigator.userAgent)&&/Google Inc/.test(navigator.vendor)),i.registerFlag("IS_SAFARI",()=>"undefined"!=typeof navigator&&null!=navigator&&null!=navigator.userAgent&&/Safari/.test(navigator.userAgent)&&/Apple/.test(navigator.vendor)),i.registerFlag("PROD",()=>!1),i.registerFlag("TENSORLIKE_CHECK_SHAPE_CONSISTENCY",()=>i.getBool("DEBUG")),i.registerFlag("DEPRECATION_WARNINGS_ENABLED",()=>!0),i.registerFlag("IS_TEST",()=>!1),i.registerFlag("CHECK_COMPUTATION_FOR_ERRORS",()=>i.getBool("DEBUG")),i.registerFlag("WRAP_TO_IMAGEBITMAP",()=>!1),i.registerFlag("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU",()=>!1),i.registerFlag("USE_SETTIMEOUTCUSTOM",()=>!1);
},{"./engine":"phT7","./device_util":"g3Z1","./environment":"vpgN","process":"YATK"}],"y4X4":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.convertToTensor=l,exports.convertToTensorArray=y,exports.inferShape=o;var r=require("./engine"),e=require("./environment"),t=require("./tensor"),n=require("./types"),s=require("./util"),i=require("./util_base");function o(r,t){let o=r;if((0,s.isTypedArray)(r))return"string"===t?[]:[r.length];if((0,n.isWebGLData)(r)){const e=r.channels||"RGBA";return[r.height,r.width*e.length]}if((0,n.isWebGPUData)(r))return[r.buffer.size/(null==t?4:(0,i.bytesPerElement)(t))];if(!Array.isArray(r))return[];const u=[];for(;Array.isArray(o)||(0,s.isTypedArray)(o)&&"string"!==t;)u.push(o.length),o=o[0];return Array.isArray(r)&&(0,e.env)().getBool("TENSORLIKE_CHECK_SHAPE_CONSISTENCY")&&a(r,u,[]),u}function a(r,e,t){if(t=t||[],!Array.isArray(r)&&!(0,s.isTypedArray)(r))return void(0,s.assert)(0===e.length,()=>`Element arr[${t.join("][")}] is a primitive, `+`but should be an array/TypedArray of ${e[0]} elements`);(0,s.assert)(e.length>0,()=>`Element arr[${t.join("][")}] should be a primitive, `+`but is an array of ${r.length} elements`),(0,s.assert)(r.length===e[0],()=>`Element arr[${t.join("][")}] should have ${e[0]} `+`elements, but has ${r.length} elements`);const n=e.slice(1);for(let s=0;s<r.length;++s)a(r[s],n,t.concat(s))}function u(r,e,t,n){if("string_or_numeric"!==r){if(null==r)throw new Error("Expected dtype cannot be null.");if("numeric"!==r&&r!==e||"numeric"===r&&"string"===e)throw new Error(`Argument '${t}' passed to '${n}' must `+`be ${r} tensor, but got ${e} tensor`)}}function l(e,n,i,a="numeric"){if(e instanceof(0,t.getGlobalTensorClass)())return u(a,e.dtype,n,i),e;let l=(0,s.inferDtype)(e);if("string"!==l&&["bool","int32","float32"].indexOf(a)>=0&&(l=a),u(a,l,n,i),null==e||!(0,s.isTypedArray)(e)&&!Array.isArray(e)&&"number"!=typeof e&&"boolean"!=typeof e&&"string"!=typeof e){const r=null==e?"null":e.constructor.name;throw new Error(`Argument '${n}' passed to '${i}' must be a `+`Tensor or TensorLike, but got '${r}'`)}const y=o(e,l);(0,s.isTypedArray)(e)||Array.isArray(e)||(e=[e]);const f="string"!==l?(0,s.toTypedArray)(e,l):(0,s.flatten)(e,[],!0);return r.ENGINE.makeTensor(f,y,l)}function y(r,e,t,n="numeric"){if(!Array.isArray(r))throw new Error(`Argument ${e} passed to ${t} must be a `+"`Tensor[]` or `TensorLike[]`");return r.map((r,s)=>l(r,`${e}[${s}]`,t,n))}
},{"./engine":"phT7","./environment":"vpgN","./tensor":"eFW4","./types":"xhfJ","./util":"XXxQ","./util_base":"uID4"}],"uE86":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.OP_SCOPE_SUFFIX=void 0,exports.op=n;var e=require("../engine"),t=require("../util");const o=exports.OP_SCOPE_SUFFIX="__op";function n(n){const r=Object.keys(n);if(1!==r.length)throw new Error("Please provide an object with a single key (operation name) mapping to a function. Got an object with "+`${r.length} keys.`);let i=r[0];const s=n[i];i.endsWith("_")&&(i=i.substring(0,i.length-1)),i+=o;const c=(...o)=>{e.ENGINE.startScope(i);try{const r=s(...o);return(0,t.isPromise)(r)&&console.error("Cannot return a Promise inside of tidy."),e.ENGINE.endScope(r),r}catch(n){throw e.ENGINE.endScope(null),n}};return Object.defineProperty(c,"name",{value:i,configurable:!0}),c}
},{"../engine":"phT7","../util":"XXxQ"}],"e4je":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.complex=void 0;var e=require("../engine"),r=require("../kernel_names"),t=require("../tensor_util_env"),n=a(require("../util")),o=require("./operation");function a(e,r){if("function"==typeof WeakMap)var t=new WeakMap,n=new WeakMap;return(a=function(e,r){if(!r&&e&&e.__esModule)return e;var o,a,p={__proto__:null,default:e};if(null===e||"object"!=typeof e&&"function"!=typeof e)return p;if(o=r?n:t){if(o.has(e))return o.get(e);o.set(e,p)}for(const t in e)"default"!==t&&{}.hasOwnProperty.call(e,t)&&((a=(o=Object.defineProperty)&&Object.getOwnPropertyDescriptor(e,t))&&(a.get||a.set)?o(p,t,a):p[t]=e[t]);return p})(e,r)}function p(o,a){const p=(0,t.convertToTensor)(o,"real","complex"),s=(0,t.convertToTensor)(a,"imag","complex");n.assertShapesMatch(p.shape,s.shape,`real and imag shapes, ${p.shape} and ${s.shape}, `+"must match in call to tf.complex().");const i={real:p,imag:s};return e.ENGINE.runKernel(r.Complex,i)}const s=exports.complex=(0,o.op)({complex_:p});
},{"../engine":"phT7","../kernel_names":"rJl6","../tensor_util_env":"y4X4","../util":"XXxQ","./operation":"uE86"}],"HKvD":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.makeTensor=s;var e=require("../engine"),r=require("../types"),t=require("../util");function s(s,a,o,n){if(null==n)n=(0,t.inferDtype)(s);else if("complex64"===n)throw new Error("Cannot construct a complex64 tensor directly. Please use tf.complex(real, imag).");if((0,r.isWebGPUData)(s)||(0,r.isWebGLData)(s)){if("float32"!==n&&"int32"!==n)throw new Error("Creating tensor from GPU data only supports "+`'float32'|'int32' dtype, while the dtype is ${n}.`);return e.ENGINE.backend.createTensorFromGPUData(s,a||o,n)}if(!(0,t.isTypedArray)(s)&&!Array.isArray(s)&&"number"!=typeof s&&"boolean"!=typeof s&&"string"!=typeof s)throw new Error("values passed to tensor(values) must be a number/boolean/string or an array of numbers/booleans/strings, or a TypedArray");if(null!=a){(0,t.assertNonNegativeIntegerDimensions)(a);const e=(0,t.sizeFromShape)(a),r=(0,t.sizeFromShape)(o);(0,t.assert)(e===r,()=>`Based on the provided shape, [${a}], the tensor should have `+`${e} values but has ${r}`);for(let s=0;s<o.length;++s){const e=o[s],r=s!==o.length-1||e!==(0,t.sizeFromShape)(a.slice(s));(0,t.assert)(o[s]===a[s]||!r,()=>"Error creating a new Tensor. Inferred shape "+`(${o}) does not match the provided `+`shape (${a}). `)}}return(0,t.isTypedArray)(s)||Array.isArray(s)||(s=[s]),a=a||o,s="string"!==n?(0,t.toTypedArray)(s,n):(0,t.flatten)(s,[],!0),e.ENGINE.makeTensor(s,a,n)}
},{"../engine":"phT7","../types":"xhfJ","../util":"XXxQ"}],"woAd":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.tensor=t;var e=require("../tensor_util_env"),r=require("./tensor_ops_util");function t(t,n,o){const s=(0,e.inferShape)(t,o);return(0,r.makeTensor)(t,n,s,o)}
},{"../tensor_util_env":"y4X4","./tensor_ops_util":"HKvD"}],"tjMC":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.DTYPE_VALUE_SIZE_MAP=void 0;const t=exports.DTYPE_VALUE_SIZE_MAP={float32:4,float16:2,int32:4,uint16:2,uint8:1,bool:1,complex64:8};
},{}],"THI4":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.CompositeArrayBuffer=void 0,exports.search=n;var t=e(require("../util"));function e(t,r){if("function"==typeof WeakMap)var n=new WeakMap,s=new WeakMap;return(e=function(t,e){if(!e&&t&&t.__esModule)return t;var r,i,h={__proto__:null,default:t};if(null===t||"object"!=typeof t&&"function"!=typeof t)return h;if(r=e?s:n){if(r.has(t))return r.get(t);r.set(t,h)}for(const n in t)"default"!==n&&{}.hasOwnProperty.call(t,n)&&((i=(r=Object.defineProperty)&&Object.getOwnPropertyDescriptor(t,n))&&(i.get||i.set)?r(h,n,i):h[n]=t[n]);return h})(t,r)}class r{static join(t){return new r(t).slice()}constructor(e){if(this.shards=[],this.previousShardIndex=0,null==e)return;if(e instanceof Array||(e=[e]),0===(e=e.map(e=>t.isTypedArray(e)?e.buffer:e)).length)return;this.bufferUniformSize=e[0].byteLength;let r=0;for(let t=0;t<e.length;t++){const n=e[t];t!==e.length-1&&n.byteLength!==this.bufferUniformSize&&(this.bufferUniformSize=void 0);const s=r+n.byteLength;this.shards.push({buffer:n,start:r,end:s}),r=s}0===this.shards.length&&(this.byteLength=0),this.byteLength=this.shards[this.shards.length-1].end}slice(t=0,e=this.byteLength){if(0===this.shards.length)return new ArrayBuffer(0);if(t=isNaN(Number(t))?0:t,e=isNaN(Number(e))?0:e,t=Math.max(0,t),(e=Math.min(this.byteLength,e))<=t)return new ArrayBuffer(0);const r=this.findShardForByte(t);if(-1===r)throw new Error(`Could not find start shard for byte ${t}`);const n=new ArrayBuffer(e-t),s=new Uint8Array(n);let i=0;for(let h=r;h<this.shards.length;h++){const r=this.shards[h],n=t+i-r.start,f=i,o=Math.min(e,r.end)-r.start,a=new Uint8Array(r.buffer,n,o-n);if(s.set(a,f),i+=a.length,e<r.end)break}return n}findShardForByte(t){if(0===this.shards.length||t<0||t>=this.byteLength)return-1;if(null!=this.bufferUniformSize)return this.previousShardIndex=Math.floor(t/this.bufferUniformSize),this.previousShardIndex;function e(e){return t<e.start?-1:t>=e.end?1:0}if(0===e(this.shards[this.previousShardIndex]))return this.previousShardIndex;const r=n(this.shards,e);return-1===r?-1:(this.previousShardIndex=r,this.previousShardIndex)}}function n(t,e){let r=0,n=t.length;for(;r<=n;){const s=Math.floor((n-r)/2)+r,i=e(t[s]);if(0===i)return s;i<0?n=s:r=s+1}return-1}exports.CompositeArrayBuffer=r;
},{"../util":"XXxQ"}],"TsQp":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.backend=m,exports.deprecationWarn=a,exports.disableDeprecationWarnings=s,exports.dispose=p,exports.disposeVariables=c,exports.enableDebugMode=i,exports.enableProdMode=o,exports.engine=u,exports.findBackend=B,exports.findBackendFactory=b,exports.getBackend=G,exports.keep=f,exports.memory=E,exports.profile=d,exports.ready=l,exports.registerBackend=g,exports.removeBackend=k,exports.setBackend=I,exports.setPlatform=v,exports.tidy=N,exports.time=x;var e=require("./engine"),n=require("./environment"),r=require("./tensor"),t=require("./tensor_util");function o(){(0,n.env)().set("PROD",!0)}function i(){(0,n.env)().set("DEBUG",!0)}function s(){(0,n.env)().set("DEPRECATION_WARNINGS_ENABLED",!1),console.warn("TensorFlow.js deprecation warnings have been disabled.")}function a(e){(0,n.env)().getBool("DEPRECATION_WARNINGS_ENABLED")&&console.warn(e+" You can disable deprecation warnings with tf.disableDeprecationWarnings().")}function c(){e.ENGINE.disposeVariables()}function u(){return e.ENGINE}function E(){return e.ENGINE.memory()}function d(n){return e.ENGINE.profile(n)}function N(n,r){return e.ENGINE.tidy(n,r)}function p(e){(0,t.getTensorsInContainer)(e).forEach(e=>e.dispose())}function f(n){return e.ENGINE.keep(n)}function x(n){return e.ENGINE.time(n)}function I(n){return e.ENGINE.setBackend(n)}function l(){return e.ENGINE.ready()}function G(){return e.ENGINE.backendName}function k(n){e.ENGINE.removeBackend(n)}function B(n){return e.ENGINE.findBackend(n)}function b(n){return e.ENGINE.findBackendFactory(n)}function g(n,r,t=1){return e.ENGINE.registerBackend(n,r,t)}function m(){return e.ENGINE.backend}function v(e,r){(0,n.env)().setPlatform(e,r)}(0,r.setDeprecationWarningFn)(a);
},{"./engine":"phT7","./environment":"vpgN","./tensor":"eFW4","./tensor_util":"wtFc"}],"mj9H":[function(require,module,exports) {
"use strict";exports.byteLength=u,exports.toByteArray=i,exports.fromByteArray=d;for(var r=[],t=[],e="undefined"!=typeof Uint8Array?Uint8Array:Array,n="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",o=0,a=n.length;o<a;++o)r[o]=n[o],t[n.charCodeAt(o)]=o;function h(r){var t=r.length;if(t%4>0)throw new Error("Invalid string. Length must be a multiple of 4");var e=r.indexOf("=");return-1===e&&(e=t),[e,e===t?0:4-e%4]}function u(r){var t=h(r),e=t[0],n=t[1];return 3*(e+n)/4-n}function c(r,t,e){return 3*(t+e)/4-e}function i(r){var n,o,a=h(r),u=a[0],i=a[1],f=new e(c(r,u,i)),A=0,d=i>0?u-4:u;for(o=0;o<d;o+=4)n=t[r.charCodeAt(o)]<<18|t[r.charCodeAt(o+1)]<<12|t[r.charCodeAt(o+2)]<<6|t[r.charCodeAt(o+3)],f[A++]=n>>16&255,f[A++]=n>>8&255,f[A++]=255&n;return 2===i&&(n=t[r.charCodeAt(o)]<<2|t[r.charCodeAt(o+1)]>>4,f[A++]=255&n),1===i&&(n=t[r.charCodeAt(o)]<<10|t[r.charCodeAt(o+1)]<<4|t[r.charCodeAt(o+2)]>>2,f[A++]=n>>8&255,f[A++]=255&n),f}function f(t){return r[t>>18&63]+r[t>>12&63]+r[t>>6&63]+r[63&t]}function A(r,t,e){for(var n,o=[],a=t;a<e;a+=3)n=(r[a]<<16&16711680)+(r[a+1]<<8&65280)+(255&r[a+2]),o.push(f(n));return o.join("")}function d(t){for(var e,n=t.length,o=n%3,a=[],h=0,u=n-o;h<u;h+=16383)a.push(A(t,h,h+16383>u?u:h+16383));return 1===o?(e=t[n-1],a.push(r[e>>2]+r[e<<4&63]+"==")):2===o&&(e=(t[n-2]<<8)+t[n-1],a.push(r[e>>10]+r[e>>4&63]+r[e<<2&63]+"=")),a.join("")}t["-".charCodeAt(0)]=62,t["_".charCodeAt(0)]=63;
},{}],"M6fQ":[function(require,module,exports) {
exports.read=function(a,o,t,r,h){var M,p,w=8*h-r-1,f=(1<<w)-1,e=f>>1,i=-7,N=t?h-1:0,n=t?-1:1,s=a[o+N];for(N+=n,M=s&(1<<-i)-1,s>>=-i,i+=w;i>0;M=256*M+a[o+N],N+=n,i-=8);for(p=M&(1<<-i)-1,M>>=-i,i+=r;i>0;p=256*p+a[o+N],N+=n,i-=8);if(0===M)M=1-e;else{if(M===f)return p?NaN:1/0*(s?-1:1);p+=Math.pow(2,r),M-=e}return(s?-1:1)*p*Math.pow(2,M-r)},exports.write=function(a,o,t,r,h,M){var p,w,f,e=8*M-h-1,i=(1<<e)-1,N=i>>1,n=23===h?Math.pow(2,-24)-Math.pow(2,-77):0,s=r?0:M-1,u=r?1:-1,l=o<0||0===o&&1/o<0?1:0;for(o=Math.abs(o),isNaN(o)||o===1/0?(w=isNaN(o)?1:0,p=i):(p=Math.floor(Math.log(o)/Math.LN2),o*(f=Math.pow(2,-p))<1&&(p--,f*=2),(o+=p+N>=1?n/f:n*Math.pow(2,1-N))*f>=2&&(p++,f/=2),p+N>=i?(w=0,p=i):p+N>=1?(w=(o*f-1)*Math.pow(2,h),p+=N):(w=o*Math.pow(2,N-1)*Math.pow(2,h),p=0));h>=8;a[t+s]=255&w,s+=u,w/=256,h-=8);for(p=p<<h|w,e+=h;e>0;a[t+s]=255&p,s+=u,p/=256,e-=8);a[t+s-u]|=128*l};
},{}],"drgB":[function(require,module,exports) {
var r={}.toString;module.exports=Array.isArray||function(t){return"[object Array]"==r.call(t)};
},{}],"RTGM":[function(require,module,exports) {

var global = arguments[3];
var t=arguments[3],r=require("base64-js"),e=require("ieee754"),n=require("isarray");function i(){try{var t=new Uint8Array(1);return t.__proto__={__proto__:Uint8Array.prototype,foo:function(){return 42}},42===t.foo()&&"function"==typeof t.subarray&&0===t.subarray(1,1).byteLength}catch(r){return!1}}function o(){return f.TYPED_ARRAY_SUPPORT?2147483647:1073741823}function u(t,r){if(o()<r)throw new RangeError("Invalid typed array length");return f.TYPED_ARRAY_SUPPORT?(t=new Uint8Array(r)).__proto__=f.prototype:(null===t&&(t=new f(r)),t.length=r),t}function f(t,r,e){if(!(f.TYPED_ARRAY_SUPPORT||this instanceof f))return new f(t,r,e);if("number"==typeof t){if("string"==typeof r)throw new Error("If encoding is specified then the first argument must be a string");return c(this,t)}return s(this,t,r,e)}function s(t,r,e,n){if("number"==typeof r)throw new TypeError('"value" argument must not be a number');return"undefined"!=typeof ArrayBuffer&&r instanceof ArrayBuffer?g(t,r,e,n):"string"==typeof r?l(t,r,e):y(t,r)}function h(t){if("number"!=typeof t)throw new TypeError('"size" argument must be a number');if(t<0)throw new RangeError('"size" argument must not be negative')}function a(t,r,e,n){return h(r),r<=0?u(t,r):void 0!==e?"string"==typeof n?u(t,r).fill(e,n):u(t,r).fill(e):u(t,r)}function c(t,r){if(h(r),t=u(t,r<0?0:0|w(r)),!f.TYPED_ARRAY_SUPPORT)for(var e=0;e<r;++e)t[e]=0;return t}function l(t,r,e){if("string"==typeof e&&""!==e||(e="utf8"),!f.isEncoding(e))throw new TypeError('"encoding" must be a valid string encoding');var n=0|v(r,e),i=(t=u(t,n)).write(r,e);return i!==n&&(t=t.slice(0,i)),t}function p(t,r){var e=r.length<0?0:0|w(r.length);t=u(t,e);for(var n=0;n<e;n+=1)t[n]=255&r[n];return t}function g(t,r,e,n){if(r.byteLength,e<0||r.byteLength<e)throw new RangeError("'offset' is out of bounds");if(r.byteLength<e+(n||0))throw new RangeError("'length' is out of bounds");return r=void 0===e&&void 0===n?new Uint8Array(r):void 0===n?new Uint8Array(r,e):new Uint8Array(r,e,n),f.TYPED_ARRAY_SUPPORT?(t=r).__proto__=f.prototype:t=p(t,r),t}function y(t,r){if(f.isBuffer(r)){var e=0|w(r.length);return 0===(t=u(t,e)).length?t:(r.copy(t,0,0,e),t)}if(r){if("undefined"!=typeof ArrayBuffer&&r.buffer instanceof ArrayBuffer||"length"in r)return"number"!=typeof r.length||W(r.length)?u(t,0):p(t,r);if("Buffer"===r.type&&n(r.data))return p(t,r.data)}throw new TypeError("First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.")}function w(t){if(t>=o())throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x"+o().toString(16)+" bytes");return 0|t}function d(t){return+t!=t&&(t=0),f.alloc(+t)}function v(t,r){if(f.isBuffer(t))return t.length;if("undefined"!=typeof ArrayBuffer&&"function"==typeof ArrayBuffer.isView&&(ArrayBuffer.isView(t)||t instanceof ArrayBuffer))return t.byteLength;"string"!=typeof t&&(t=""+t);var e=t.length;if(0===e)return 0;for(var n=!1;;)switch(r){case"ascii":case"latin1":case"binary":return e;case"utf8":case"utf-8":case void 0:return $(t).length;case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return 2*e;case"hex":return e>>>1;case"base64":return K(t).length;default:if(n)return $(t).length;r=(""+r).toLowerCase(),n=!0}}function E(t,r,e){var n=!1;if((void 0===r||r<0)&&(r=0),r>this.length)return"";if((void 0===e||e>this.length)&&(e=this.length),e<=0)return"";if((e>>>=0)<=(r>>>=0))return"";for(t||(t="utf8");;)switch(t){case"hex":return x(this,r,e);case"utf8":case"utf-8":return Y(this,r,e);case"ascii":return L(this,r,e);case"latin1":case"binary":return D(this,r,e);case"base64":return S(this,r,e);case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return C(this,r,e);default:if(n)throw new TypeError("Unknown encoding: "+t);t=(t+"").toLowerCase(),n=!0}}function b(t,r,e){var n=t[r];t[r]=t[e],t[e]=n}function R(t,r,e,n,i){if(0===t.length)return-1;if("string"==typeof e?(n=e,e=0):e>2147483647?e=2147483647:e<-2147483648&&(e=-2147483648),e=+e,isNaN(e)&&(e=i?0:t.length-1),e<0&&(e=t.length+e),e>=t.length){if(i)return-1;e=t.length-1}else if(e<0){if(!i)return-1;e=0}if("string"==typeof r&&(r=f.from(r,n)),f.isBuffer(r))return 0===r.length?-1:_(t,r,e,n,i);if("number"==typeof r)return r&=255,f.TYPED_ARRAY_SUPPORT&&"function"==typeof Uint8Array.prototype.indexOf?i?Uint8Array.prototype.indexOf.call(t,r,e):Uint8Array.prototype.lastIndexOf.call(t,r,e):_(t,[r],e,n,i);throw new TypeError("val must be string, number or Buffer")}function _(t,r,e,n,i){var o,u=1,f=t.length,s=r.length;if(void 0!==n&&("ucs2"===(n=String(n).toLowerCase())||"ucs-2"===n||"utf16le"===n||"utf-16le"===n)){if(t.length<2||r.length<2)return-1;u=2,f/=2,s/=2,e/=2}function h(t,r){return 1===u?t[r]:t.readUInt16BE(r*u)}if(i){var a=-1;for(o=e;o<f;o++)if(h(t,o)===h(r,-1===a?0:o-a)){if(-1===a&&(a=o),o-a+1===s)return a*u}else-1!==a&&(o-=o-a),a=-1}else for(e+s>f&&(e=f-s),o=e;o>=0;o--){for(var c=!0,l=0;l<s;l++)if(h(t,o+l)!==h(r,l)){c=!1;break}if(c)return o}return-1}function A(t,r,e,n){e=Number(e)||0;var i=t.length-e;n?(n=Number(n))>i&&(n=i):n=i;var o=r.length;if(o%2!=0)throw new TypeError("Invalid hex string");n>o/2&&(n=o/2);for(var u=0;u<n;++u){var f=parseInt(r.substr(2*u,2),16);if(isNaN(f))return u;t[e+u]=f}return u}function m(t,r,e,n){return Q($(r,t.length-e),t,e,n)}function P(t,r,e,n){return Q(G(r),t,e,n)}function T(t,r,e,n){return P(t,r,e,n)}function B(t,r,e,n){return Q(K(r),t,e,n)}function U(t,r,e,n){return Q(H(r,t.length-e),t,e,n)}function S(t,e,n){return 0===e&&n===t.length?r.fromByteArray(t):r.fromByteArray(t.slice(e,n))}function Y(t,r,e){e=Math.min(t.length,e);for(var n=[],i=r;i<e;){var o,u,f,s,h=t[i],a=null,c=h>239?4:h>223?3:h>191?2:1;if(i+c<=e)switch(c){case 1:h<128&&(a=h);break;case 2:128==(192&(o=t[i+1]))&&(s=(31&h)<<6|63&o)>127&&(a=s);break;case 3:o=t[i+1],u=t[i+2],128==(192&o)&&128==(192&u)&&(s=(15&h)<<12|(63&o)<<6|63&u)>2047&&(s<55296||s>57343)&&(a=s);break;case 4:o=t[i+1],u=t[i+2],f=t[i+3],128==(192&o)&&128==(192&u)&&128==(192&f)&&(s=(15&h)<<18|(63&o)<<12|(63&u)<<6|63&f)>65535&&s<1114112&&(a=s)}null===a?(a=65533,c=1):a>65535&&(a-=65536,n.push(a>>>10&1023|55296),a=56320|1023&a),n.push(a),i+=c}return O(n)}exports.Buffer=f,exports.SlowBuffer=d,exports.INSPECT_MAX_BYTES=50,f.TYPED_ARRAY_SUPPORT=void 0!==t.TYPED_ARRAY_SUPPORT?t.TYPED_ARRAY_SUPPORT:i(),exports.kMaxLength=o(),f.poolSize=8192,f._augment=function(t){return t.__proto__=f.prototype,t},f.from=function(t,r,e){return s(null,t,r,e)},f.TYPED_ARRAY_SUPPORT&&(f.prototype.__proto__=Uint8Array.prototype,f.__proto__=Uint8Array,"undefined"!=typeof Symbol&&Symbol.species&&f[Symbol.species]===f&&Object.defineProperty(f,Symbol.species,{value:null,configurable:!0})),f.alloc=function(t,r,e){return a(null,t,r,e)},f.allocUnsafe=function(t){return c(null,t)},f.allocUnsafeSlow=function(t){return c(null,t)},f.isBuffer=function(t){return!(null==t||!t._isBuffer)},f.compare=function(t,r){if(!f.isBuffer(t)||!f.isBuffer(r))throw new TypeError("Arguments must be Buffers");if(t===r)return 0;for(var e=t.length,n=r.length,i=0,o=Math.min(e,n);i<o;++i)if(t[i]!==r[i]){e=t[i],n=r[i];break}return e<n?-1:n<e?1:0},f.isEncoding=function(t){switch(String(t).toLowerCase()){case"hex":case"utf8":case"utf-8":case"ascii":case"latin1":case"binary":case"base64":case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return!0;default:return!1}},f.concat=function(t,r){if(!n(t))throw new TypeError('"list" argument must be an Array of Buffers');if(0===t.length)return f.alloc(0);var e;if(void 0===r)for(r=0,e=0;e<t.length;++e)r+=t[e].length;var i=f.allocUnsafe(r),o=0;for(e=0;e<t.length;++e){var u=t[e];if(!f.isBuffer(u))throw new TypeError('"list" argument must be an Array of Buffers');u.copy(i,o),o+=u.length}return i},f.byteLength=v,f.prototype._isBuffer=!0,f.prototype.swap16=function(){var t=this.length;if(t%2!=0)throw new RangeError("Buffer size must be a multiple of 16-bits");for(var r=0;r<t;r+=2)b(this,r,r+1);return this},f.prototype.swap32=function(){var t=this.length;if(t%4!=0)throw new RangeError("Buffer size must be a multiple of 32-bits");for(var r=0;r<t;r+=4)b(this,r,r+3),b(this,r+1,r+2);return this},f.prototype.swap64=function(){var t=this.length;if(t%8!=0)throw new RangeError("Buffer size must be a multiple of 64-bits");for(var r=0;r<t;r+=8)b(this,r,r+7),b(this,r+1,r+6),b(this,r+2,r+5),b(this,r+3,r+4);return this},f.prototype.toString=function(){var t=0|this.length;return 0===t?"":0===arguments.length?Y(this,0,t):E.apply(this,arguments)},f.prototype.equals=function(t){if(!f.isBuffer(t))throw new TypeError("Argument must be a Buffer");return this===t||0===f.compare(this,t)},f.prototype.inspect=function(){var t="",r=exports.INSPECT_MAX_BYTES;return this.length>0&&(t=this.toString("hex",0,r).match(/.{2}/g).join(" "),this.length>r&&(t+=" ... ")),"<Buffer "+t+">"},f.prototype.compare=function(t,r,e,n,i){if(!f.isBuffer(t))throw new TypeError("Argument must be a Buffer");if(void 0===r&&(r=0),void 0===e&&(e=t?t.length:0),void 0===n&&(n=0),void 0===i&&(i=this.length),r<0||e>t.length||n<0||i>this.length)throw new RangeError("out of range index");if(n>=i&&r>=e)return 0;if(n>=i)return-1;if(r>=e)return 1;if(this===t)return 0;for(var o=(i>>>=0)-(n>>>=0),u=(e>>>=0)-(r>>>=0),s=Math.min(o,u),h=this.slice(n,i),a=t.slice(r,e),c=0;c<s;++c)if(h[c]!==a[c]){o=h[c],u=a[c];break}return o<u?-1:u<o?1:0},f.prototype.includes=function(t,r,e){return-1!==this.indexOf(t,r,e)},f.prototype.indexOf=function(t,r,e){return R(this,t,r,e,!0)},f.prototype.lastIndexOf=function(t,r,e){return R(this,t,r,e,!1)},f.prototype.write=function(t,r,e,n){if(void 0===r)n="utf8",e=this.length,r=0;else if(void 0===e&&"string"==typeof r)n=r,e=this.length,r=0;else{if(!isFinite(r))throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");r|=0,isFinite(e)?(e|=0,void 0===n&&(n="utf8")):(n=e,e=void 0)}var i=this.length-r;if((void 0===e||e>i)&&(e=i),t.length>0&&(e<0||r<0)||r>this.length)throw new RangeError("Attempt to write outside buffer bounds");n||(n="utf8");for(var o=!1;;)switch(n){case"hex":return A(this,t,r,e);case"utf8":case"utf-8":return m(this,t,r,e);case"ascii":return P(this,t,r,e);case"latin1":case"binary":return T(this,t,r,e);case"base64":return B(this,t,r,e);case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return U(this,t,r,e);default:if(o)throw new TypeError("Unknown encoding: "+n);n=(""+n).toLowerCase(),o=!0}},f.prototype.toJSON=function(){return{type:"Buffer",data:Array.prototype.slice.call(this._arr||this,0)}};var I=4096;function O(t){var r=t.length;if(r<=I)return String.fromCharCode.apply(String,t);for(var e="",n=0;n<r;)e+=String.fromCharCode.apply(String,t.slice(n,n+=I));return e}function L(t,r,e){var n="";e=Math.min(t.length,e);for(var i=r;i<e;++i)n+=String.fromCharCode(127&t[i]);return n}function D(t,r,e){var n="";e=Math.min(t.length,e);for(var i=r;i<e;++i)n+=String.fromCharCode(t[i]);return n}function x(t,r,e){var n=t.length;(!r||r<0)&&(r=0),(!e||e<0||e>n)&&(e=n);for(var i="",o=r;o<e;++o)i+=Z(t[o]);return i}function C(t,r,e){for(var n=t.slice(r,e),i="",o=0;o<n.length;o+=2)i+=String.fromCharCode(n[o]+256*n[o+1]);return i}function M(t,r,e){if(t%1!=0||t<0)throw new RangeError("offset is not uint");if(t+r>e)throw new RangeError("Trying to access beyond buffer length")}function k(t,r,e,n,i,o){if(!f.isBuffer(t))throw new TypeError('"buffer" argument must be a Buffer instance');if(r>i||r<o)throw new RangeError('"value" argument is out of bounds');if(e+n>t.length)throw new RangeError("Index out of range")}function N(t,r,e,n){r<0&&(r=65535+r+1);for(var i=0,o=Math.min(t.length-e,2);i<o;++i)t[e+i]=(r&255<<8*(n?i:1-i))>>>8*(n?i:1-i)}function z(t,r,e,n){r<0&&(r=4294967295+r+1);for(var i=0,o=Math.min(t.length-e,4);i<o;++i)t[e+i]=r>>>8*(n?i:3-i)&255}function F(t,r,e,n,i,o){if(e+n>t.length)throw new RangeError("Index out of range");if(e<0)throw new RangeError("Index out of range")}function j(t,r,n,i,o){return o||F(t,r,n,4,3.4028234663852886e38,-3.4028234663852886e38),e.write(t,r,n,i,23,4),n+4}function q(t,r,n,i,o){return o||F(t,r,n,8,1.7976931348623157e308,-1.7976931348623157e308),e.write(t,r,n,i,52,8),n+8}f.prototype.slice=function(t,r){var e,n=this.length;if((t=~~t)<0?(t+=n)<0&&(t=0):t>n&&(t=n),(r=void 0===r?n:~~r)<0?(r+=n)<0&&(r=0):r>n&&(r=n),r<t&&(r=t),f.TYPED_ARRAY_SUPPORT)(e=this.subarray(t,r)).__proto__=f.prototype;else{var i=r-t;e=new f(i,void 0);for(var o=0;o<i;++o)e[o]=this[o+t]}return e},f.prototype.readUIntLE=function(t,r,e){t|=0,r|=0,e||M(t,r,this.length);for(var n=this[t],i=1,o=0;++o<r&&(i*=256);)n+=this[t+o]*i;return n},f.prototype.readUIntBE=function(t,r,e){t|=0,r|=0,e||M(t,r,this.length);for(var n=this[t+--r],i=1;r>0&&(i*=256);)n+=this[t+--r]*i;return n},f.prototype.readUInt8=function(t,r){return r||M(t,1,this.length),this[t]},f.prototype.readUInt16LE=function(t,r){return r||M(t,2,this.length),this[t]|this[t+1]<<8},f.prototype.readUInt16BE=function(t,r){return r||M(t,2,this.length),this[t]<<8|this[t+1]},f.prototype.readUInt32LE=function(t,r){return r||M(t,4,this.length),(this[t]|this[t+1]<<8|this[t+2]<<16)+16777216*this[t+3]},f.prototype.readUInt32BE=function(t,r){return r||M(t,4,this.length),16777216*this[t]+(this[t+1]<<16|this[t+2]<<8|this[t+3])},f.prototype.readIntLE=function(t,r,e){t|=0,r|=0,e||M(t,r,this.length);for(var n=this[t],i=1,o=0;++o<r&&(i*=256);)n+=this[t+o]*i;return n>=(i*=128)&&(n-=Math.pow(2,8*r)),n},f.prototype.readIntBE=function(t,r,e){t|=0,r|=0,e||M(t,r,this.length);for(var n=r,i=1,o=this[t+--n];n>0&&(i*=256);)o+=this[t+--n]*i;return o>=(i*=128)&&(o-=Math.pow(2,8*r)),o},f.prototype.readInt8=function(t,r){return r||M(t,1,this.length),128&this[t]?-1*(255-this[t]+1):this[t]},f.prototype.readInt16LE=function(t,r){r||M(t,2,this.length);var e=this[t]|this[t+1]<<8;return 32768&e?4294901760|e:e},f.prototype.readInt16BE=function(t,r){r||M(t,2,this.length);var e=this[t+1]|this[t]<<8;return 32768&e?4294901760|e:e},f.prototype.readInt32LE=function(t,r){return r||M(t,4,this.length),this[t]|this[t+1]<<8|this[t+2]<<16|this[t+3]<<24},f.prototype.readInt32BE=function(t,r){return r||M(t,4,this.length),this[t]<<24|this[t+1]<<16|this[t+2]<<8|this[t+3]},f.prototype.readFloatLE=function(t,r){return r||M(t,4,this.length),e.read(this,t,!0,23,4)},f.prototype.readFloatBE=function(t,r){return r||M(t,4,this.length),e.read(this,t,!1,23,4)},f.prototype.readDoubleLE=function(t,r){return r||M(t,8,this.length),e.read(this,t,!0,52,8)},f.prototype.readDoubleBE=function(t,r){return r||M(t,8,this.length),e.read(this,t,!1,52,8)},f.prototype.writeUIntLE=function(t,r,e,n){(t=+t,r|=0,e|=0,n)||k(this,t,r,e,Math.pow(2,8*e)-1,0);var i=1,o=0;for(this[r]=255&t;++o<e&&(i*=256);)this[r+o]=t/i&255;return r+e},f.prototype.writeUIntBE=function(t,r,e,n){(t=+t,r|=0,e|=0,n)||k(this,t,r,e,Math.pow(2,8*e)-1,0);var i=e-1,o=1;for(this[r+i]=255&t;--i>=0&&(o*=256);)this[r+i]=t/o&255;return r+e},f.prototype.writeUInt8=function(t,r,e){return t=+t,r|=0,e||k(this,t,r,1,255,0),f.TYPED_ARRAY_SUPPORT||(t=Math.floor(t)),this[r]=255&t,r+1},f.prototype.writeUInt16LE=function(t,r,e){return t=+t,r|=0,e||k(this,t,r,2,65535,0),f.TYPED_ARRAY_SUPPORT?(this[r]=255&t,this[r+1]=t>>>8):N(this,t,r,!0),r+2},f.prototype.writeUInt16BE=function(t,r,e){return t=+t,r|=0,e||k(this,t,r,2,65535,0),f.TYPED_ARRAY_SUPPORT?(this[r]=t>>>8,this[r+1]=255&t):N(this,t,r,!1),r+2},f.prototype.writeUInt32LE=function(t,r,e){return t=+t,r|=0,e||k(this,t,r,4,4294967295,0),f.TYPED_ARRAY_SUPPORT?(this[r+3]=t>>>24,this[r+2]=t>>>16,this[r+1]=t>>>8,this[r]=255&t):z(this,t,r,!0),r+4},f.prototype.writeUInt32BE=function(t,r,e){return t=+t,r|=0,e||k(this,t,r,4,4294967295,0),f.TYPED_ARRAY_SUPPORT?(this[r]=t>>>24,this[r+1]=t>>>16,this[r+2]=t>>>8,this[r+3]=255&t):z(this,t,r,!1),r+4},f.prototype.writeIntLE=function(t,r,e,n){if(t=+t,r|=0,!n){var i=Math.pow(2,8*e-1);k(this,t,r,e,i-1,-i)}var o=0,u=1,f=0;for(this[r]=255&t;++o<e&&(u*=256);)t<0&&0===f&&0!==this[r+o-1]&&(f=1),this[r+o]=(t/u>>0)-f&255;return r+e},f.prototype.writeIntBE=function(t,r,e,n){if(t=+t,r|=0,!n){var i=Math.pow(2,8*e-1);k(this,t,r,e,i-1,-i)}var o=e-1,u=1,f=0;for(this[r+o]=255&t;--o>=0&&(u*=256);)t<0&&0===f&&0!==this[r+o+1]&&(f=1),this[r+o]=(t/u>>0)-f&255;return r+e},f.prototype.writeInt8=function(t,r,e){return t=+t,r|=0,e||k(this,t,r,1,127,-128),f.TYPED_ARRAY_SUPPORT||(t=Math.floor(t)),t<0&&(t=255+t+1),this[r]=255&t,r+1},f.prototype.writeInt16LE=function(t,r,e){return t=+t,r|=0,e||k(this,t,r,2,32767,-32768),f.TYPED_ARRAY_SUPPORT?(this[r]=255&t,this[r+1]=t>>>8):N(this,t,r,!0),r+2},f.prototype.writeInt16BE=function(t,r,e){return t=+t,r|=0,e||k(this,t,r,2,32767,-32768),f.TYPED_ARRAY_SUPPORT?(this[r]=t>>>8,this[r+1]=255&t):N(this,t,r,!1),r+2},f.prototype.writeInt32LE=function(t,r,e){return t=+t,r|=0,e||k(this,t,r,4,2147483647,-2147483648),f.TYPED_ARRAY_SUPPORT?(this[r]=255&t,this[r+1]=t>>>8,this[r+2]=t>>>16,this[r+3]=t>>>24):z(this,t,r,!0),r+4},f.prototype.writeInt32BE=function(t,r,e){return t=+t,r|=0,e||k(this,t,r,4,2147483647,-2147483648),t<0&&(t=4294967295+t+1),f.TYPED_ARRAY_SUPPORT?(this[r]=t>>>24,this[r+1]=t>>>16,this[r+2]=t>>>8,this[r+3]=255&t):z(this,t,r,!1),r+4},f.prototype.writeFloatLE=function(t,r,e){return j(this,t,r,!0,e)},f.prototype.writeFloatBE=function(t,r,e){return j(this,t,r,!1,e)},f.prototype.writeDoubleLE=function(t,r,e){return q(this,t,r,!0,e)},f.prototype.writeDoubleBE=function(t,r,e){return q(this,t,r,!1,e)},f.prototype.copy=function(t,r,e,n){if(e||(e=0),n||0===n||(n=this.length),r>=t.length&&(r=t.length),r||(r=0),n>0&&n<e&&(n=e),n===e)return 0;if(0===t.length||0===this.length)return 0;if(r<0)throw new RangeError("targetStart out of bounds");if(e<0||e>=this.length)throw new RangeError("sourceStart out of bounds");if(n<0)throw new RangeError("sourceEnd out of bounds");n>this.length&&(n=this.length),t.length-r<n-e&&(n=t.length-r+e);var i,o=n-e;if(this===t&&e<r&&r<n)for(i=o-1;i>=0;--i)t[i+r]=this[i+e];else if(o<1e3||!f.TYPED_ARRAY_SUPPORT)for(i=0;i<o;++i)t[i+r]=this[i+e];else Uint8Array.prototype.set.call(t,this.subarray(e,e+o),r);return o},f.prototype.fill=function(t,r,e,n){if("string"==typeof t){if("string"==typeof r?(n=r,r=0,e=this.length):"string"==typeof e&&(n=e,e=this.length),1===t.length){var i=t.charCodeAt(0);i<256&&(t=i)}if(void 0!==n&&"string"!=typeof n)throw new TypeError("encoding must be a string");if("string"==typeof n&&!f.isEncoding(n))throw new TypeError("Unknown encoding: "+n)}else"number"==typeof t&&(t&=255);if(r<0||this.length<r||this.length<e)throw new RangeError("Out of range index");if(e<=r)return this;var o;if(r>>>=0,e=void 0===e?this.length:e>>>0,t||(t=0),"number"==typeof t)for(o=r;o<e;++o)this[o]=t;else{var u=f.isBuffer(t)?t:$(new f(t,n).toString()),s=u.length;for(o=0;o<e-r;++o)this[o+r]=u[o%s]}return this};var V=/[^+\/0-9A-Za-z-_]/g;function X(t){if((t=J(t).replace(V,"")).length<2)return"";for(;t.length%4!=0;)t+="=";return t}function J(t){return t.trim?t.trim():t.replace(/^\s+|\s+$/g,"")}function Z(t){return t<16?"0"+t.toString(16):t.toString(16)}function $(t,r){var e;r=r||1/0;for(var n=t.length,i=null,o=[],u=0;u<n;++u){if((e=t.charCodeAt(u))>55295&&e<57344){if(!i){if(e>56319){(r-=3)>-1&&o.push(239,191,189);continue}if(u+1===n){(r-=3)>-1&&o.push(239,191,189);continue}i=e;continue}if(e<56320){(r-=3)>-1&&o.push(239,191,189),i=e;continue}e=65536+(i-55296<<10|e-56320)}else i&&(r-=3)>-1&&o.push(239,191,189);if(i=null,e<128){if((r-=1)<0)break;o.push(e)}else if(e<2048){if((r-=2)<0)break;o.push(e>>6|192,63&e|128)}else if(e<65536){if((r-=3)<0)break;o.push(e>>12|224,e>>6&63|128,63&e|128)}else{if(!(e<1114112))throw new Error("Invalid code point");if((r-=4)<0)break;o.push(e>>18|240,e>>12&63|128,e>>6&63|128,63&e|128)}}return o}function G(t){for(var r=[],e=0;e<t.length;++e)r.push(255&t.charCodeAt(e));return r}function H(t,r){for(var e,n,i,o=[],u=0;u<t.length&&!((r-=2)<0);++u)n=(e=t.charCodeAt(u))>>8,i=e%256,o.push(i),o.push(n);return o}function K(t){return r.toByteArray(X(t))}function Q(t,r,e,n){for(var i=0;i<n&&!(i+e>=r.length||i>=t.length);++i)r[i+e]=t[i];return i}function W(t){return t!=t}
},{"base64-js":"mj9H","ieee754":"M6fQ","isarray":"drgB","buffer":"RTGM"}],"kOer":[function(require,module,exports) {
var Buffer = require("buffer").Buffer;
var e=require("buffer").Buffer;Object.defineProperty(exports,"__esModule",{value:!0}),exports.arrayBufferToBase64String=m,exports.base64StringToArrayBuffer=b,exports.basename=E,exports.concatenateArrayBuffers=S,exports.concatenateTypedArrays=h,exports.decodeWeights=u,exports.decodeWeightsStream=g,exports.encodeWeights=f,exports.getFloat16Decoder=q,exports.getModelArtifactsForJSON=B,exports.getModelArtifactsForJSONSync=z,exports.getModelArtifactsInfoForJSON=_,exports.getModelJSONForModelArtifacts=U,exports.getWeightSpecs=M,exports.stringByteLength=A;var t=require("../ops/complex"),n=require("../ops/tensor"),r=require("../util"),o=require("./types"),i=require("./composite_array_buffer"),a=require("../globals"),s=require("../environment");const l=4;async function f(e,t){const n=[],r=[],o=Array.isArray(e)?e.map(e=>e.name):Object.keys(e);for(let i=0;i<o.length;++i){const a=o[i],s=Array.isArray(e)?e[i].tensor:e[a];if("float32"!==s.dtype&&"int32"!==s.dtype&&"bool"!==s.dtype&&"string"!==s.dtype&&"complex64"!==s.dtype)throw new Error(`Unsupported dtype in weight '${a}': ${s.dtype}`);const f={name:a,shape:s.shape,dtype:s.dtype};if("string"===s.dtype){const e=new Promise(async e=>{const t=await s.bytes(),n=t.reduce((e,t)=>e+t.length,0)+l*t.length,r=new Uint8Array(n);let o=0;for(let i=0;i<t.length;i++){const e=t[i],n=new Uint8Array(new Uint32Array([e.length]).buffer);r.set(n,o),o+=l,r.set(e,o),o+=e.length}e(r)});r.push(e)}else r.push(s.data());null!=t&&(f.group=t),n.push(f)}return{data:h(await Promise.all(r)),specs:n}}function u(e,t){const n=new i.CompositeArrayBuffer(e),r={};let o=0;for(const i of t){const e=y(i,(e,t)=>n.slice(o+e,o+t));r[i.name]=p(i,n.slice(o,o+e)),o+=e}return r}function y(e,t){const n=(0,r.sizeFromShape)(e.shape);let i;if("quantization"in e){const t=e.quantization;i=o.DTYPE_VALUE_SIZE_MAP[t.dtype]}else{if("string"===e.dtype){let e=0;for(let r=0;r<n;r++)e+=l+new Uint32Array(t(e,e+l))[0];return e}i=o.DTYPE_VALUE_SIZE_MAP[e.dtype]}return n*i}async function c(e,t){const n=(0,r.sizeFromShape)(e.shape);let i;if("quantization"in e){const t=e.quantization;i=o.DTYPE_VALUE_SIZE_MAP[t.dtype]}else{if("string"===e.dtype){let e=0;for(let r=0;r<n;r++)e+=l+new Uint32Array(await t(e,e+l))[0];return e}i=o.DTYPE_VALUE_SIZE_MAP[e.dtype]}return n*i}function p(e,i){const a=e.name,s=e.dtype,f=e.shape,u=(0,r.sizeFromShape)(f);let y,c=0;if("quantization"in e){const t=e.quantization;if("uint8"===t.dtype||"uint16"===t.dtype){if(!("min"in t&&"scale"in t))throw new Error(`Weight ${e.name} with quantization ${t.dtype} `+"doesn't have corresponding metadata min and scale.")}else{if("float16"!==t.dtype)throw new Error(`Weight ${e.name} has unknown `+`quantization dtype ${t.dtype}. `+"Supported quantization dtypes are: 'uint8', 'uint16', and 'float16'.");if("float32"!==s)throw new Error(`Weight ${e.name} is quantized with ${t.dtype} `+`which only supports weights of type float32 not ${s}.`)}const n=o.DTYPE_VALUE_SIZE_MAP[t.dtype],r="uint8"===t.dtype?new Uint8Array(i):new Uint16Array(i);if("float32"===s)if("uint8"===t.dtype||"uint16"===t.dtype){y=new Float32Array(r.length);for(let e=0;e<r.length;e++){const n=r[e];y[e]=n*t.scale+t.min}}else{if("float16"!==t.dtype)throw new Error(`Unsupported quantization type ${t.dtype} `+"for weight type float32.");y=q()(r)}else{if("int32"!==s)throw new Error(`Unsupported dtype in weight '${a}': ${s}`);if("uint8"!==t.dtype&&"uint16"!==t.dtype)throw new Error(`Unsupported quantization type ${t.dtype} `+"for weight type int32.");y=new Int32Array(r.length);for(let e=0;e<r.length;e++){const n=r[e];y[e]=Math.round(n*t.scale+t.min)}}c+=u*n}else if("string"===s){const t=(0,r.sizeFromShape)(e.shape);y=[];for(let e=0;e<t;e++){const e=new Uint32Array(i.slice(c,c+l))[0];c+=l;const t=new Uint8Array(i.slice(c,c+e));y.push(t),c+=e}}else{const e=o.DTYPE_VALUE_SIZE_MAP[s];if("float32"===s)y=new Float32Array(i);else if("int32"===s)y=new Int32Array(i);else{if("bool"!==s){if("complex64"===s){y=new Float32Array(i);const e=new Float32Array(y.length/2),r=new Float32Array(y.length/2);for(let t=0;t<e.length;t++)e[t]=y[2*t],r[t]=y[2*t+1];const o=(0,n.tensor)(e,f,"float32"),a=(0,n.tensor)(r,f,"float32"),s=(0,t.complex)(o,a);return o.dispose(),a.dispose(),s}throw new Error(`Unsupported dtype in weight '${a}': ${s}`)}y=new Uint8Array(i)}c+=u*e}return(0,n.tensor)(y,f,s)}async function d(e,t,n){let r=new Uint8Array(t);for(;r.byteLength<n;){const{done:t,value:o}=await e.read();if(t&&null==o){const e=n-r.byteLength;throw new Error(`Reader is done but ${e} bytes are still expected`)}const i=new Uint8Array(r.length+o.byteLength);i.set(r,0),i.set(new Uint8Array(o),r.length),r=i}return r.buffer}async function g(e,t){const n={},o=e.getReader();let i=new ArrayBuffer(0);for(const l of t){const e=await c(l,async(e,t)=>(i=await d(o,i,t)).slice(e,t)),t=(i=await d(o,i,e)).slice(0,e);i=i.slice(e);const f=p(l,t);if(n[l.name]=f,"webgpu"===(0,a.getBackend)()){const e=(0,a.backend)();"uploadToGPU"in e&&(0,r.sizeFromShape)(f.shape)>=(0,s.env)().get("WEBGPU_CPU_HANDOFF_SIZE_THRESHOLD")&&e.uploadToGPU(f.dataId)}}return n}function h(e){if(null===e)throw new Error(`Invalid input value: ${JSON.stringify(e)}`);let t=0;const n=[];e.forEach(e=>{if(t+=e.byteLength,n.push(e.byteLength===e.buffer.byteLength?e:new e.constructor(e)),!(e instanceof Float32Array||e instanceof Int32Array||e instanceof Uint8Array))throw new Error(`Unsupported TypedArray subtype: ${e.constructor.name}`)});const r=new Uint8Array(t);let o=0;return n.forEach(e=>{r.set(new Uint8Array(e.buffer),o),o+=e.byteLength}),r.buffer}const w=void 0!==e&&("undefined"==typeof Blob||"undefined"==typeof atob||"undefined"==typeof btoa);function A(t){return w?e.byteLength(t,"utf8"):new Blob([t]).size}function m(t){if(w)return e.from(t).toString("base64");const n=new Uint8Array(t);let r="";for(let e=0,o=n.length;e<o;e++)r+=String.fromCharCode(n[e]);return btoa(r)}function b(t){if(w){const n=e.from(t,"base64");return n.buffer.slice(n.byteOffset,n.byteOffset+n.byteLength)}const n=atob(t),r=new Uint8Array(n.length);for(let e=0;e<n.length;++e)r.set([n.charCodeAt(e)],e);return r.buffer}function S(e){return i.CompositeArrayBuffer.join(e)}function E(e){for(e=e.trim();e.endsWith("/");)e=e.slice(0,e.length-1);const t=e.split("/");return t[t.length-1]}function U(e,t){const n={modelTopology:e.modelTopology,format:e.format,generatedBy:e.generatedBy,convertedBy:e.convertedBy,weightsManifest:t};return null!=e.signature&&(n.signature=e.signature),null!=e.userDefinedMetadata&&(n.userDefinedMetadata=e.userDefinedMetadata),null!=e.modelInitializer&&(n.modelInitializer=e.modelInitializer),null!=e.initializerSignature&&(n.initializerSignature=e.initializerSignature),null!=e.trainingConfig&&(n.trainingConfig=e.trainingConfig),n}function z(e,t,n){const r={modelTopology:e.modelTopology,format:e.format,generatedBy:e.generatedBy,convertedBy:e.convertedBy};if(null!=e.trainingConfig&&(r.trainingConfig=e.trainingConfig),null!=e.weightsManifest){if(!t)throw new Error("modelJSON has weightsManifest but weightSpecs is null");if(!n)throw new Error("modelJSON has weightsManifest but weightData is null");r.weightSpecs=t,r.weightData=n}return null!=e.signature&&(r.signature=e.signature),null!=e.userDefinedMetadata&&(r.userDefinedMetadata=e.userDefinedMetadata),null!=e.modelInitializer&&(r.modelInitializer=e.modelInitializer),null!=e.initializerSignature&&(r.initializerSignature=e.initializerSignature),r}async function B(e,t){let n,r;return null!=e.weightsManifest&&([n,r]=await t(e.weightsManifest)),z(e,n,r)}function _(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("Expected JSON model topology, received ArrayBuffer.");return{dateSaved:new Date,modelTopologyType:"JSON",modelTopologyBytes:null==e.modelTopology?0:A(JSON.stringify(e.modelTopology)),weightSpecsBytes:null==e.weightSpecs?0:A(JSON.stringify(e.weightSpecs)),weightDataBytes:null==e.weightData?0:new i.CompositeArrayBuffer(e.weightData).byteLength}}function M(e){const t=[];for(const n of e)t.push(...n.weights);return t}function T(){const e=e=>{let t=e<<13,n=0;for(;0==(8388608&t);)n-=8388608,t<<=1;return(t&=-8388609)|(n+=947912704)},t=new Uint32Array(2048);t[0]=0;for(let n=1;n<1024;n++)t[n]=e(n);for(let n=1024;n<2048;n++)t[n]=939524096+(n-1024<<13);return t}function x(){const e=new Uint32Array(64);e[0]=0,e[31]=1199570944,e[32]=2147483648,e[63]=3347054592;for(let t=1;t<31;t++)e[t]=t<<23;for(let t=33;t<63;t++)e[t]=2147483648+(t-32<<23);return e}function D(){const e=new Uint32Array(64);for(let t=0;t<64;t++)e[t]=1024;return e[0]=e[32]=0,e}function q(){const e=T(),t=x(),n=D();return r=>{const o=new ArrayBuffer(4*r.length),i=new Uint32Array(o);for(let a=0;a<r.length;a++){const o=r[a],s=e[n[o>>10]+(1023&o)]+t[o>>10];i[a]=s}return new Float32Array(o)}}
},{"../ops/complex":"e4je","../ops/tensor":"woAd","../util":"XXxQ","./types":"tjMC","./composite_array_buffer":"THI4","../globals":"TsQp","../environment":"vpgN","buffer":"RTGM"}],"XmHK":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.registerSaveRouter=exports.registerLoadRouter=exports.getSaveHandlers=exports.getLoadHandlers=exports.IORouterRegistry=void 0;class e{constructor(){this.saveRouters=[],this.loadRouters=[]}static getInstance(){return null==e.instance&&(e.instance=new e),e.instance}static registerSaveRouter(t){e.getInstance().saveRouters.push(t)}static registerLoadRouter(t){e.getInstance().loadRouters.push(t)}static getSaveHandlers(t){return e.getHandlers(t,"save")}static getLoadHandlers(t,s){return e.getHandlers(t,"load",s)}static getHandlers(t,s,r){const a=[];return("load"===s?e.getInstance().loadRouters:e.getInstance().saveRouters).forEach(e=>{const s=e(t,r);null!==s&&a.push(s)}),a}}exports.IORouterRegistry=e;const t=t=>e.registerSaveRouter(t);exports.registerSaveRouter=t;const s=t=>e.registerLoadRouter(t);exports.registerLoadRouter=s;const r=t=>e.getSaveHandlers(t);exports.getSaveHandlers=r;const a=(t,s)=>e.getLoadHandlers(t,s);exports.getLoadHandlers=a;
},{}],"XHfa":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.BrowserIndexedDBManager=exports.BrowserIndexedDB=void 0,exports.browserIndexedDB=m,exports.deleteDatabase=a,exports.indexedDBRouter=void 0,require("../flags");var e=require("../environment"),o=require("./io_utils"),r=require("./router_registry"),t=require("./composite_array_buffer");const n="tensorflowjs",s=1,c="models_store",d="model_info_store";async function a(){const e=l();return new Promise((o,r)=>{const t=e.deleteDatabase(n);t.onsuccess=(()=>o()),t.onerror=(e=>r(e))})}function l(){if(!(0,e.env)().getBool("IS_BROWSER"))throw new Error("Failed to obtain IndexedDB factory because the current environmentis not a web browser.");const o="undefined"==typeof window?self:window,r=o.indexedDB||o.mozIndexedDB||o.webkitIndexedDB||o.msIndexedDB||o.shimIndexedDB;if(null==r)throw new Error("The current browser does not appear to support IndexedDB.");return r}function i(e){const o=e.result;o.createObjectStore(c,{keyPath:"modelPath"}),o.createObjectStore(d,{keyPath:"modelPath"})}class u{constructor(e){if(this.indexedDB=l(),null==e||!e)throw new Error("For IndexedDB, modelPath must not be null, undefined or empty.");this.modelPath=e}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");return this.databaseAction(this.modelPath,e)}async load(){return this.databaseAction(this.modelPath)}databaseAction(e,r){return new Promise((e,a)=>{const l=this.indexedDB.open(n,s);l.onupgradeneeded=(()=>i(l)),l.onsuccess=(()=>{const n=l.result;if(null==r){const o=n.transaction(c,"readonly"),r=o.objectStore(c).get(this.modelPath);r.onsuccess=(()=>{if(null==r.result)return n.close(),a(new Error(`Cannot find model with path '${this.modelPath}' `+"in IndexedDB."));e(r.result.modelArtifacts)}),r.onerror=(e=>(n.close(),a(r.error))),o.oncomplete=(()=>n.close())}else{r.weightData=t.CompositeArrayBuffer.join(r.weightData);const l=(0,o.getModelArtifactsInfoForJSON)(r),i=n.transaction(d,"readwrite");let u,h,m=i.objectStore(d);try{u=m.put({modelPath:this.modelPath,modelArtifactsInfo:l})}catch(s){return a(s)}u.onsuccess=(()=>{const o=(h=n.transaction(c,"readwrite")).objectStore(c);let t;try{t=o.put({modelPath:this.modelPath,modelArtifacts:r,modelArtifactsInfo:l})}catch(s){return a(s)}t.onsuccess=(()=>e({modelArtifactsInfo:l})),t.onerror=(e=>{const o=(m=i.objectStore(d)).delete(this.modelPath);o.onsuccess=(()=>(n.close(),a(t.error))),o.onerror=(e=>(n.close(),a(t.error)))})}),u.onerror=(e=>(n.close(),a(u.error))),i.oncomplete=(()=>{null==h?n.close():h.oncomplete=(()=>n.close())})}}),l.onerror=(e=>a(l.error))})}}exports.BrowserIndexedDB=u,u.URL_SCHEME="indexeddb://";const h=o=>(0,e.env)().getBool("IS_BROWSER")&&!Array.isArray(o)&&o.startsWith(u.URL_SCHEME)?m(o.slice(u.URL_SCHEME.length)):null;function m(e){return new u(e)}function f(e){return e.startsWith(u.URL_SCHEME)?e.slice(u.URL_SCHEME.length):e}exports.indexedDBRouter=h,r.IORouterRegistry.registerSaveRouter(h),r.IORouterRegistry.registerLoadRouter(h);class p{constructor(){this.indexedDB=l()}async listModels(){return new Promise((e,o)=>{const r=this.indexedDB.open(n,s);r.onupgradeneeded=(()=>i(r)),r.onsuccess=(()=>{const t=r.result,n=t.transaction(d,"readonly"),s=n.objectStore(d).getAll();s.onsuccess=(()=>{const o={};for(const e of s.result)o[e.modelPath]=e.modelArtifactsInfo;e(o)}),s.onerror=(e=>(t.close(),o(s.error))),n.oncomplete=(()=>t.close())}),r.onerror=(e=>o(r.error))})}async removeModel(e){return e=f(e),new Promise((o,r)=>{const t=this.indexedDB.open(n,s);t.onupgradeneeded=(()=>i(t)),t.onsuccess=(()=>{const n=t.result,s=n.transaction(d,"readwrite"),a=s.objectStore(d),l=a.get(e);let i;l.onsuccess=(()=>{if(null==l.result)return n.close(),r(new Error(`Cannot find model with path '${e}' `+"in IndexedDB."));{const t=a.delete(e),s=()=>{const t=(i=n.transaction(c,"readwrite")).objectStore(c).delete(e);t.onsuccess=(()=>o(l.result.modelArtifactsInfo)),t.onerror=(e=>r(l.error))};t.onsuccess=s,t.onerror=(e=>(s(),n.close(),r(l.error)))}}),l.onerror=(e=>(n.close(),r(l.error))),s.oncomplete=(()=>{null==i?n.close():i.oncomplete=(()=>n.close())})}),t.onerror=(e=>r(t.error))})}}exports.BrowserIndexedDBManager=p;
},{"../flags":"lELk","../environment":"vpgN","./io_utils":"kOer","./router_registry":"XmHK","./composite_array_buffer":"THI4"}],"bqqF":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.BrowserLocalStorageManager=exports.BrowserLocalStorage=void 0,exports.browserLocalStorage=p,exports.localStorageRouter=void 0,exports.purgeLocalStorageArtifacts=h,require("../flags");var e=require("../environment"),t=require("../util"),o=require("./io_utils"),r=require("./composite_array_buffer"),i=require("./router_registry");const n="/",s="tensorflowjs_models",a="info",l="model_topology",g="weight_specs",d="weight_data",u="model_metadata";function h(){if(!(0,e.env)().getBool("IS_BROWSER")||"undefined"==typeof window||void 0===window.localStorage)throw new Error("purgeLocalStorageModels() cannot proceed because local storage is unavailable in the current environment.");const t=window.localStorage,o=[];for(let e=0;e<t.length;++e){const r=t.key(e),i=s+n;if(r.startsWith(i)&&r.length>i.length){t.removeItem(r);const e=S(r);-1===o.indexOf(e)&&o.push(e)}}return o}function c(e){return{info:[s,e,a].join(n),topology:[s,e,l].join(n),weightSpecs:[s,e,g].join(n),weightData:[s,e,d].join(n),modelMetadata:[s,e,u].join(n)}}function f(e){for(const t of Object.values(e))window.localStorage.removeItem(t)}function S(e){const t=e.split(n);if(t.length<3)throw new Error(`Invalid key format: ${e}`);return t.slice(1,t.length-1).join(n)}function w(e){return e.startsWith(m.URL_SCHEME)?e.slice(m.URL_SCHEME.length):e}class m{constructor(t){if(!(0,e.env)().getBool("IS_BROWSER")||"undefined"==typeof window||void 0===window.localStorage)throw new Error("The current environment does not support local storage.");if(this.LS=window.localStorage,null==t||!t)throw new Error("For local storage, modelPath must not be null, undefined or empty.");this.modelPath=t,this.keys=c(this.modelPath)}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");{const i=JSON.stringify(e.modelTopology),n=JSON.stringify(e.weightSpecs),s=(0,o.getModelArtifactsInfoForJSON)(e),a=r.CompositeArrayBuffer.join(e.weightData);try{this.LS.setItem(this.keys.info,JSON.stringify(s)),this.LS.setItem(this.keys.topology,i),this.LS.setItem(this.keys.weightSpecs,n),this.LS.setItem(this.keys.weightData,(0,o.arrayBufferToBase64String)(a));const r={format:e.format,generatedBy:e.generatedBy,convertedBy:e.convertedBy,signature:null!=e.signature?e.signature:void 0,userDefinedMetadata:null!=e.userDefinedMetadata?e.userDefinedMetadata:void 0,modelInitializer:null!=e.modelInitializer?e.modelInitializer:void 0,initializerSignature:null!=e.initializerSignature?e.initializerSignature:void 0,trainingConfig:null!=e.trainingConfig?e.trainingConfig:void 0};return this.LS.setItem(this.keys.modelMetadata,JSON.stringify(r)),{modelArtifactsInfo:s}}catch(t){throw f(this.keys),new Error(`Failed to save model '${this.modelPath}' to local storage: `+"size quota being exceeded is a possible cause of this failure: "+`modelTopologyBytes=${s.modelTopologyBytes}, `+`weightSpecsBytes=${s.weightSpecsBytes}, `+`weightDataBytes=${s.weightDataBytes}.`)}}}async load(){const e=JSON.parse(this.LS.getItem(this.keys.info));if(null==e)throw new Error(`In local storage, there is no model with name '${this.modelPath}'`);if("JSON"!==e.modelTopologyType)throw new Error("BrowserLocalStorage does not support loading non-JSON model topology yet.");const t={},r=JSON.parse(this.LS.getItem(this.keys.topology));if(null==r)throw new Error(`In local storage, the topology of model '${this.modelPath}' `+"is missing.");t.modelTopology=r;const i=JSON.parse(this.LS.getItem(this.keys.weightSpecs));if(null==i)throw new Error(`In local storage, the weight specs of model '${this.modelPath}' `+"are missing.");t.weightSpecs=i;const n=this.LS.getItem(this.keys.modelMetadata);if(null!=n){const e=JSON.parse(n);t.format=e.format,t.generatedBy=e.generatedBy,t.convertedBy=e.convertedBy,null!=e.signature&&(t.signature=e.signature),null!=e.userDefinedMetadata&&(t.userDefinedMetadata=e.userDefinedMetadata),null!=e.modelInitializer&&(t.modelInitializer=e.modelInitializer),null!=e.initializerSignature&&(t.initializerSignature=e.initializerSignature),null!=e.trainingConfig&&(t.trainingConfig=e.trainingConfig)}const s=this.LS.getItem(this.keys.weightData);if(null==s)throw new Error("In local storage, the binary weight values of model "+`'${this.modelPath}' are missing.`);return t.weightData=(0,o.base64StringToArrayBuffer)(s),t}}exports.BrowserLocalStorage=m,m.URL_SCHEME="localstorage://";const y=t=>(0,e.env)().getBool("IS_BROWSER")&&!Array.isArray(t)&&t.startsWith(m.URL_SCHEME)?p(t.slice(m.URL_SCHEME.length)):null;function p(e){return new m(e)}exports.localStorageRouter=y,i.IORouterRegistry.registerSaveRouter(y),i.IORouterRegistry.registerLoadRouter(y);class v{constructor(){(0,t.assert)((0,e.env)().getBool("IS_BROWSER"),()=>"Current environment is not a web browser"),(0,t.assert)("undefined"==typeof window||void 0!==window.localStorage,()=>"Current browser does not appear to support localStorage"),this.LS=window.localStorage}async listModels(){const e={},t=s+n,o=n+a;for(let r=0;r<this.LS.length;++r){const i=this.LS.key(r);if(i.startsWith(t)&&i.endsWith(o)){e[S(i)]=JSON.parse(this.LS.getItem(i))}}return e}async removeModel(e){const t=c(e=w(e));if(null==this.LS.getItem(t.info))throw new Error(`Cannot find model at path '${e}'`);const o=JSON.parse(this.LS.getItem(t.info));return f(t),o}}exports.BrowserLocalStorageManager=v;
},{"../flags":"lELk","../environment":"vpgN","../util":"XXxQ","./io_utils":"kOer","./composite_array_buffer":"THI4","./router_registry":"XmHK"}],"xu20":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.ModelStoreManagerRegistry=void 0,exports.copyModel=c,exports.listModels=o,exports.moveModel=l,exports.removeModel=i;var e=require("../util"),t=require("./router_registry");const n="://";class s{constructor(){this.managers={}}static getInstance(){return null==s.instance&&(s.instance=new s),s.instance}static registerManager(t,r){(0,e.assert)(null!=t,()=>"scheme must not be undefined or null."),t.endsWith(n)&&(t=t.slice(0,t.indexOf(n))),(0,e.assert)(t.length>0,()=>"scheme must not be an empty string.");const a=s.getInstance();(0,e.assert)(null==a.managers[t],()=>`A model store manager is already registered for scheme '${t}'.`),a.managers[t]=r}static getManager(e){const t=s.getInstance().managers[e];if(null==t)throw new Error(`Cannot find model manager for scheme '${e}'`);return t}static getSchemes(){return Object.keys(s.getInstance().managers)}}function r(e){if(-1===e.indexOf(n))throw new Error("The url string provided does not contain a scheme. Supported schemes are: "+`${s.getSchemes().join(",")}`);return{scheme:e.split(n)[0],path:e.split(n)[1]}}async function a(n,a,o=!1){(0,e.assert)(n!==a,()=>`Old path and new path are the same: '${n}'`);const i=t.IORouterRegistry.getLoadHandlers(n);(0,e.assert)(i.length>0,()=>`Copying failed because no load handler is found for source URL ${n}.`),(0,e.assert)(i.length<2,()=>`Copying failed because more than one (${i.length}) `+`load handlers for source URL ${n}.`);const c=i[0],l=t.IORouterRegistry.getSaveHandlers(a);(0,e.assert)(l.length>0,()=>"Copying failed because no save handler is found for destination "+`URL ${a}.`),(0,e.assert)(l.length<2,()=>`Copying failed because more than one (${i.length}) `+`save handlers for destination URL ${a}.`);const g=l[0],d=r(n).scheme,u=r(n).path,h=d===r(n).scheme,m=await c.load();o&&h&&await s.getManager(d).removeModel(u);const f=await g.save(m);return o&&!h&&await s.getManager(d).removeModel(u),f.modelArtifactsInfo}async function o(){const e=s.getSchemes(),t={};for(const r of e){const e=await s.getManager(r).listModels();for(const s in e){t[r+n+s]=e[s]}}return t}async function i(e){const t=r(e);return s.getManager(t.scheme).removeModel(t.path)}async function c(e,t){return a(e,t,!1)}async function l(e,t){return a(e,t,!0)}exports.ModelStoreManagerRegistry=s;
},{"../util":"XXxQ","./router_registry":"XmHK"}],"GYfU":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.PlatformBrowser=void 0,require("../flags");var e=require("../environment"),t=require("../io/indexed_db"),r=require("../io/local_storage"),s=require("../io/model_management"),n=require("./is_typed_array_browser");class o{constructor(){this.messageName="setTimeoutCustom",this.functionRefs=[],this.handledMessageCount=0,this.hasEventListener=!1}fetch(e,t){return fetch(e,t)}now(){return performance.now()}encode(e,t){if("utf-8"!==t&&"utf8"!==t)throw new Error(`Browser's encoder only supports utf-8, but got ${t}`);return null==this.textEncoder&&(this.textEncoder=new TextEncoder),this.textEncoder.encode(e)}decode(e,t){return new TextDecoder(t).decode(e)}setTimeoutCustom(t,r){"undefined"!=typeof window&&(0,e.env)().getBool("USE_SETTIMEOUTCUSTOM")?(this.functionRefs.push(t),setTimeout(()=>{window.postMessage({name:this.messageName,index:this.functionRefs.length-1},"*")},r),this.hasEventListener||(this.hasEventListener=!0,window.addEventListener("message",e=>{if(e.source===window&&e.data.name===this.messageName){e.stopPropagation(),(0,this.functionRefs[e.data.index])(),this.handledMessageCount++,this.handledMessageCount===this.functionRefs.length&&(this.functionRefs=[],this.handledMessageCount=0)}},!0))):setTimeout(t,r)}isTypedArray(e){return(0,n.isTypedArrayBrowser)(e)}}if(exports.PlatformBrowser=o,(0,e.env)().get("IS_BROWSER")){(0,e.env)().setPlatform("browser",new o);try{s.ModelStoreManagerRegistry.registerManager(r.BrowserLocalStorage.URL_SCHEME,new r.BrowserLocalStorageManager)}catch(i){}try{s.ModelStoreManagerRegistry.registerManager(t.BrowserIndexedDB.URL_SCHEME,new t.BrowserIndexedDBManager)}catch(i){}}
},{"../flags":"lELk","../environment":"vpgN","../io/indexed_db":"XHfa","../io/local_storage":"bqqF","../io/model_management":"xu20","./is_typed_array_browser":"lKzY"}],"ZOa0":[function(require,module,exports) {

},{}],"kCxW":[function(require,module,exports) {
var process = require("process");
var e=require("process");Object.defineProperty(exports,"__esModule",{value:!0}),exports.getNodeFetch=exports.PlatformNode=void 0,exports.getSystemFetch=i,exports.resetSystemFetch=n,exports.setSystemFetch=s;var t=require("../environment");const r=exports.getNodeFetch={importFetch:()=>require("node-fetch")};let o;function n(){o=null}function s(e){o=e}function i(){return o}class u{constructor(){this.util=require("util"),this.textEncoder=new this.util.TextEncoder}fetch(e,n){return null!=(0,t.env)().global.fetch?(0,t.env)().global.fetch(e,n):(null==o&&(o=r.importFetch()),o(e,n))}now(){const t=e.hrtime();return 1e3*t[0]+t[1]/1e6}encode(e,t){if("utf-8"!==t&&"utf8"!==t)throw new Error(`Node built-in encoder only supports utf-8, but got ${t}`);return this.textEncoder.encode(e)}decode(e,t){return 0===e.length?"":new this.util.TextDecoder(t).decode(e)}isTypedArray(e){return this.util.types.isFloat32Array(e)||this.util.types.isInt32Array(e)||this.util.types.isUint8Array(e)||this.util.types.isUint8ClampedArray(e)}}exports.PlatformNode=u,(0,t.env)().get("IS_NODE")&&!(0,t.env)().get("IS_BROWSER")&&(0,t.env)().setPlatform("node",new u);
},{"../environment":"vpgN","node-fetch":"ZOa0","util":"ZOa0","process":"YATK"}],"GfO2":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.buffer=n;var e=require("../tensor"),t=r(require("../util"));function r(e,t){if("function"==typeof WeakMap)var n=new WeakMap,o=new WeakMap;return(r=function(e,t){if(!t&&e&&e.__esModule)return e;var r,f,u={__proto__:null,default:e};if(null===e||"object"!=typeof e&&"function"!=typeof e)return u;if(r=t?o:n){if(r.has(e))return r.get(e);r.set(e,u)}for(const n in e)"default"!==n&&{}.hasOwnProperty.call(e,n)&&((f=(r=Object.defineProperty)&&Object.getOwnPropertyDescriptor(e,n))&&(f.get||f.set)?r(u,n,f):u[n]=e[n]);return u})(e,t)}function n(r,n="float32",o){return n=n||"float32",t.assertNonNegativeIntegerDimensions(r),new e.TensorBuffer(r,n,o)}
},{"../tensor":"eFW4","../util":"XXxQ"}],"qnzc":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.cast=void 0;var e=require("../engine"),t=require("../kernel_names"),r=require("../tensor_util_env"),n=i(require("../util")),o=require("./operation");function i(e,t){if("function"==typeof WeakMap)var r=new WeakMap,n=new WeakMap;return(i=function(e,t){if(!t&&e&&e.__esModule)return e;var o,i,s={__proto__:null,default:e};if(null===e||"object"!=typeof e&&"function"!=typeof e)return s;if(o=t?n:r){if(o.has(e))return o.get(e);o.set(e,s)}for(const r in e)"default"!==r&&{}.hasOwnProperty.call(e,r)&&((i=(o=Object.defineProperty)&&Object.getOwnPropertyDescriptor(e,r))&&(i.get||i.set)?o(s,r,i):s[r]=e[r]);return s})(e,t)}function s(o,i){const s=(0,r.convertToTensor)(o,"x","cast");if(!n.isValidDtype(i))throw new Error(`Failed to cast to unknown dtype ${i}`);if("string"===i&&"string"!==s.dtype||"string"!==i&&"string"===s.dtype)throw new Error("Only strings can be casted to strings");const u={x:s},a={dtype:i};return e.ENGINE.runKernel(t.Cast,u,a)}const u=exports.cast=(0,o.op)({cast_:s});
},{"../engine":"phT7","../kernel_names":"rJl6","../tensor_util_env":"y4X4","../util":"XXxQ","./operation":"uE86"}],"Ot88":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.clone=void 0;var e=require("../engine"),r=require("../kernel_names"),n=require("../tensor_util_env"),o=require("./operation");function t(o){const t={x:(0,n.convertToTensor)(o,"x","clone","string_or_numeric")};return e.ENGINE.runKernel(r.Identity,t)}const i=exports.clone=(0,o.op)({clone_:t});
},{"../engine":"phT7","../kernel_names":"rJl6","../tensor_util_env":"y4X4","./operation":"uE86"}],"avTA":[function(require,module,exports) {
"use strict";function e(e,t=!1){console.log(e.toString(t))}Object.defineProperty(exports,"__esModule",{value:!0}),exports.print=e;
},{}],"viUI":[function(require,module,exports) {
"use strict";var r=require("./engine");require("./flags"),require("./platforms/platform_browser"),require("./platforms/platform_node");var e=require("./ops/buffer"),s=require("./ops/cast"),t=require("./ops/clone"),i=require("./ops/print"),o=require("./tensor");(0,r.getOrMakeEngine)();const n={buffer:e.buffer,cast:s.cast,clone:t.clone,print:i.print};(0,o.setOpHandler)(n);
},{"./engine":"phT7","./flags":"lELk","./platforms/platform_browser":"GYfU","./platforms/platform_node":"kCxW","./ops/buffer":"GfO2","./ops/cast":"qnzc","./ops/clone":"Ot88","./ops/print":"avTA","./tensor":"eFW4"}],"N73o":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.add=void 0;var e=require("../engine"),r=require("../kernel_names"),n=require("../tensor_util"),o=require("../tensor_util_env"),t=require("./operation");function d(t,d){let s=(0,o.convertToTensor)(t,"a","add"),a=(0,o.convertToTensor)(d,"b","add");[s,a]=(0,n.makeTypesMatch)(s,a);const i={a:s,b:a};return e.ENGINE.runKernel(r.Add,i)}const s=exports.add=(0,t.op)({add_:d});
},{"../engine":"phT7","../kernel_names":"rJl6","../tensor_util":"wtFc","../tensor_util_env":"y4X4","./operation":"uE86"}],"OIz3":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.floorDiv=void 0;var e=require("../engine"),r=require("../kernel_names"),o=require("../tensor_util"),n=require("../tensor_util_env"),t=require("./operation");function i(t,i){let s=(0,n.convertToTensor)(t,"a","floorDiv"),l=(0,n.convertToTensor)(i,"b","floorDiv");[s,l]=(0,o.makeTypesMatch)(s,l);const u={a:s,b:l};return e.ENGINE.runKernel(r.FloorDiv,u)}const s=exports.floorDiv=(0,t.op)({floorDiv_:i});
},{"../engine":"phT7","../kernel_names":"rJl6","../tensor_util":"wtFc","../tensor_util_env":"y4X4","./operation":"uE86"}],"S2L5":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.div=void 0;var e=require("../engine"),r=require("../kernel_names"),i=require("../tensor_util"),t=require("../tensor_util_env"),o=require("./floorDiv"),n=require("./operation");function u(n,u){let s=(0,t.convertToTensor)(n,"a","div"),v=(0,t.convertToTensor)(u,"b","div");if([s,v]=(0,i.makeTypesMatch)(s,v),"int32"===s.dtype&&"int32"===v.dtype)return(0,o.floorDiv)(s,v);const d={a:s,b:v};return e.ENGINE.runKernel(r.RealDiv,d,{})}const s=exports.div=(0,n.op)({div_:u});
},{"../engine":"phT7","../kernel_names":"rJl6","../tensor_util":"wtFc","../tensor_util_env":"y4X4","./floorDiv":"OIz3","./operation":"uE86"}],"tBJ4":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.mul=void 0;var e=require("../engine"),r=require("../kernel_names"),t=require("../tensor_util"),n=require("../tensor_util_env"),o=require("./operation");function u(o,u){let i=(0,n.convertToTensor)(o,"a","mul"),l=(0,n.convertToTensor)(u,"b","mul");[i,l]=(0,t.makeTypesMatch)(i,l);const s={a:i,b:l};return e.ENGINE.runKernel(r.Multiply,s)}const i=exports.mul=(0,o.op)({mul_:u});
},{"../engine":"phT7","../kernel_names":"rJl6","../tensor_util":"wtFc","../tensor_util_env":"y4X4","./operation":"uE86"}],"U9d5":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.abs=void 0;var e=require("../engine"),r=require("../kernel_names"),n=require("../tensor_util_env"),o=require("./operation");function s(o){const s=(0,n.convertToTensor)(o,"x","abs");if("complex64"===s.dtype){const n={x:s};return e.ENGINE.runKernel(r.ComplexAbs,n)}{const n={x:s};return e.ENGINE.runKernel(r.Abs,n)}}const t=exports.abs=(0,o.op)({abs_:s});
},{"../engine":"phT7","../kernel_names":"rJl6","../tensor_util_env":"y4X4","./operation":"uE86"}],"hDnd":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.acos=void 0;var e=require("../engine"),r=require("../kernel_names"),o=require("../tensor_util_env"),n=require("./operation");function s(n){const s={x:(0,o.convertToTensor)(n,"x","acos")};return e.ENGINE.runKernel(r.Acos,s)}const t=exports.acos=(0,n.op)({acos_:s});
},{"../engine":"phT7","../kernel_names":"rJl6","../tensor_util_env":"y4X4","./operation":"uE86"}],"zTvf":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.acosh=void 0;var e=require("../engine"),r=require("../kernel_names"),o=require("../tensor_util_env"),n=require("./operation");function s(n){const s={x:(0,o.convertToTensor)(n,"x","acosh")};return e.ENGINE.runKernel(r.Acosh,s)}const t=exports.acosh=(0,n.op)({acosh_:s});
},{"../engine":"phT7","../kernel_names":"rJl6","../tensor_util_env":"y4X4","./operation":"uE86"}],"rS0T":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.addN=void 0;var e=require("../engine"),t=require("../kernel_names"),r=require("../tensor_util_env"),s=n(require("../util")),o=require("./operation");function n(e,t){if("function"==typeof WeakMap)var r=new WeakMap,s=new WeakMap;return(n=function(e,t){if(!t&&e&&e.__esModule)return e;var o,n,a={__proto__:null,default:e};if(null===e||"object"!=typeof e&&"function"!=typeof e)return a;if(o=t?s:r){if(o.has(e))return o.get(e);o.set(e,a)}for(const r in e)"default"!==r&&{}.hasOwnProperty.call(e,r)&&((n=(o=Object.defineProperty)&&Object.getOwnPropertyDescriptor(e,r))&&(n.get||n.set)?o(a,r,n):a[r]=e[r]);return a})(e,t)}function a(o){s.assert(Array.isArray(o),()=>"The argument passed to tf.addN() must be a list of tensors"),s.assert(o.length>=1,()=>"Must pass at least one tensor to tf.addN(), but got "+`${o.length}`);const n=o.map((e,t)=>(0,r.convertToTensor)(e,`tensors${t}`,"addN")),a=n[0];n.forEach(e=>{if(e.dtype!==a.dtype)throw new Error("All tensors passed to tf.addN() must have the same dtype")}),n.forEach(e=>{if(!s.arraysEqual(e.shape,a.shape))throw new Error("All tensors passed to tf.addN() must have the same shape")});const u=n;return e.ENGINE.runKernel(t.AddN,u)}const u=exports.addN=(0,o.op)({addN_:a});
},{"../engine":"phT7","../kernel_names":"rJl6","../tensor_util_env":"y4X4","../util":"XXxQ","./operation":"uE86"}],"zHmK":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.all=void 0;var e=require("../engine"),r=require("../kernel_names"),l=require("../tensor_util_env"),n=require("./operation");function o(n,o=null,t=!1){const i={x:(0,l.convertToTensor)(n,"x","all","bool")},s={axis:o,keepDims:t};return e.ENGINE.runKernel(r.All,i,s)}const t=exports.all=(0,n.op)({all_:o});
},{"../engine":"phT7","../kernel_names":"rJl6","../tensor_util_env":"y4X4","./operation":"uE86"}],"XocL":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.any=void 0;var e=require("../engine"),r=require("../kernel_names"),n=require("../tensor_util_env"),o=require("./operation");function t(o,t=null,i=!1){const s={x:(0,n.convertToTensor)(o,"x","any","bool")},u={axis:t,keepDims:i};return e.ENGINE.runKernel(r.Any,s,u)}const i=exports.any=(0,o.op)({any_:t});
},{"../engine":"phT7","../kernel_names":"rJl6","../tensor_util_env":"y4X4","./operation":"uE86"}],"dv7u":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.argMax=void 0;var e=require("../engine"),r=require("../kernel_names"),n=require("../tensor_util_env"),o=require("./operation");function t(o,t=0){const a={x:(0,n.convertToTensor)(o,"x","argMax")},i={axis:t};return e.ENGINE.runKernel(r.ArgMax,a,i)}const a=exports.argMax=(0,o.op)({argMax_:t});
},{"../engine":"phT7","../kernel_names":"rJl6","../tensor_util_env":"y4X4","./operation":"uE86"}],"y2ST":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.argMin=void 0;var e=require("../engine"),r=require("../kernel_names"),n=require("../tensor_util_env"),i=require("./operation");function o(i,o=0){const t={x:(0,n.convertToTensor)(i,"x","argMin")},s={axis:o};return e.ENGINE.runKernel(r.ArgMin,t,s)}const t=exports.argMin=(0,i.op)({argMin_:o});
},{"../engine":"phT7","../kernel_names":"rJl6","../tensor_util_env":"y4X4","./operation":"uE86"}],"kcJ4":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.asin=void 0;var e=require("../engine"),r=require("../kernel_names"),n=require("../tensor_util_env"),i=require("./operation");function o(i){const o={x:(0,n.convertToTensor)(i,"x","asin")};return e.ENGINE.runKernel(r.Asin,o)}const s=exports.asin=(0,i.op)({asin_:o});
},{"../engine":"phT7","../kernel_names":"rJl6","../tensor_util_env":"y4X4","./operation":"uE86"}],"mK5f":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.asinh=void 0;var e=require("../engine"),r=require("../kernel_names"),n=require("../tensor_util_env"),i=require("./operation");function o(i){const o={x:(0,n.convertToTensor)(i,"x","asinh")};return e.ENGINE.runKernel(r.Asinh,o)}const s=exports.asinh=(0,i.op)({asinh_:o});
},{"../engine":"phT7","../kernel_names":"rJl6","../tensor_util_env":"y4X4","./operation":"uE86"}],"Qawb":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.atan=void 0;var e=require("../engine"),r=require("../kernel_names"),n=require("../tensor_util_env"),t=require("./operation");function o(t){const o={x:(0,n.convertToTensor)(t,"x","atan")};return e.ENGINE.runKernel(r.Atan,o)}const a=exports.atan=(0,t.op)({atan_:o});
},{"../engine":"phT7","../kernel_names":"rJl6","../tensor_util_env":"y4X4","./operation":"uE86"}],"lkDZ":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.atan2=void 0;var e=require("../engine"),r=require("../kernel_names"),n=require("../tensor_util"),t=require("../tensor_util_env"),o=require("./operation");function a(o,a){let s=(0,t.convertToTensor)(o,"a","atan2"),i=(0,t.convertToTensor)(a,"b","atan2");[s,i]=(0,n.makeTypesMatch)(s,i);const u={a:s,b:i};return e.ENGINE.runKernel(r.Atan2,u)}const s=exports.atan2=(0,o.op)({atan2_:a});
},{"../engine":"phT7","../kernel_names":"rJl6","../tensor_util":"wtFc","../tensor_util_env":"y4X4","./operation":"uE86"}],"c4nq":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.atanh=void 0;var e=require("../engine"),r=require("../kernel_names"),n=require("../tensor_util_env"),t=require("./operation");function o(t){const o={x:(0,n.convertToTensor)(t,"x","atanh")};return e.ENGINE.runKernel(r.Atanh,o)}const a=exports.atanh=(0,t.op)({atanh_:o});
},{"../engine":"phT7","../kernel_names":"rJl6","../tensor_util_env":"y4X4","./operation":"uE86"}],"PhWH":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.checkPadOnDimRoundingMode=b,exports.computeConv2DInfo=i,exports.computeConv3DInfo=a,exports.computeDefaultPad=l,exports.computeDilation2DInfo=n,exports.computePool2DInfo=o,exports.computePool3DInfo=r,exports.convertConv2DDataFormat=D,exports.eitherStridesOrDilationsAreOne=w,exports.stridesOrDilationsArePositive=M,exports.tupleValuesAreOne=m;var t=e(require("../util"));function e(t,n){if("function"==typeof WeakMap)var o=new WeakMap,r=new WeakMap;return(e=function(t,e){if(!e&&t&&t.__esModule)return t;var n,i,a={__proto__:null,default:t};if(null===t||"object"!=typeof t&&"function"!=typeof t)return a;if(n=e?r:o){if(n.has(t))return n.get(t);n.set(t,a)}for(const o in t)"default"!==o&&{}.hasOwnProperty.call(t,o)&&((i=(n=Object.defineProperty)&&Object.getOwnPropertyDescriptor(t,o))&&(i.get||i.set)?n(a,o,i):a[o]=t[o]);return a})(t,n)}function n(t,e,n,o,r="NHWC",a){return i(t,[...e,t[3]],n,a,o,null,null,D(r))}function o(t,e,n,o,r,a,s="channelsLast"){const[h,l]=u(e);let f;if("channelsLast"===s)f=[h,l,t[3],t[3]];else{if("channelsFirst"!==s)throw new Error(`Unknown dataFormat ${s}`);f=[h,l,t[1],t[1]]}return i(t,f,n,o,r,a,!1,s)}function r(t,e,n,o,r,i,s="NDHWC"){const[h,l,u]=f(e);let c,p;if("NDHWC"===s)p="channelsLast",c=[h,l,u,t[4],t[4]];else{if("NCDHW"!==s)throw new Error(`Unknown dataFormat ${s}`);p="channelsFirst",c=[h,l,u,t[1],t[1]]}return a(t,c,n,o,r,!1,p,i)}function i(t,e,n,o,r,i,a=!1,s="channelsLast"){let[h,l,f,d]=[-1,-1,-1,-1];if("channelsLast"===s)[h,l,f,d]=t;else{if("channelsFirst"!==s)throw new Error(`Unknown dataFormat ${s}`);[h,d,l,f]=t}const[g,m,,w]=e,[M,D]=u(n),[b,W]=u(o),y=c(g,b),H=c(m,W),{padInfo:E,outHeight:F,outWidth:I}=p(r,l,f,M,D,y,H,i,s),L=a?w*d:w;let $;return"channelsFirst"===s?$=[h,L,F,I]:"channelsLast"===s&&($=[h,F,I,L]),{batchSize:h,dataFormat:s,inHeight:l,inWidth:f,inChannels:d,outHeight:F,outWidth:I,outChannels:L,padInfo:E,strideHeight:M,strideWidth:D,filterHeight:g,filterWidth:m,effectiveFilterHeight:y,effectiveFilterWidth:H,dilationHeight:b,dilationWidth:W,inShape:t,outShape:$,filterShape:e}}function a(t,e,n,o,r,i=!1,a="channelsLast",s){let[h,l,u,p,g]=[-1,-1,-1,-1,-1];if("channelsLast"===a)[h,l,u,p,g]=t;else{if("channelsFirst"!==a)throw new Error(`Unknown dataFormat ${a}`);[h,g,l,u,p]=t}const[m,w,M,,D]=e,[b,W,y]=f(n),[H,E,F]=f(o),I=c(m,H),L=c(w,E),$=c(M,F),{padInfo:v,outDepth:k,outHeight:x,outWidth:C}=d(r,l,u,p,b,W,y,I,L,$,s),S=i?D*g:D;let U;return"channelsFirst"===a?U=[h,S,k,x,C]:"channelsLast"===a&&(U=[h,k,x,C,S]),{batchSize:h,dataFormat:a,inDepth:l,inHeight:u,inWidth:p,inChannels:g,outDepth:k,outHeight:x,outWidth:C,outChannels:S,padInfo:v,strideDepth:b,strideHeight:W,strideWidth:y,filterDepth:m,filterHeight:w,filterWidth:M,effectiveFilterDepth:I,effectiveFilterHeight:L,effectiveFilterWidth:$,dilationDepth:H,dilationHeight:E,dilationWidth:F,inShape:t,outShape:U,filterShape:e}}function s(t,e,n,o,r){null==o&&(o=l(t,e,n));const i=t[0],a=t[1];return[g((i-e+2*o)/n+1,r),g((a-e+2*o)/n+1,r)]}function h(t,e,n,o,r,i){null==r&&(r=l(t,e[0],o[0]));const a=[0,0,0,n];for(let s=0;s<3;s++)t[s]+2*r>=e[s]&&(a[s]=g((t[s]-e[s]+2*r)/o[s]+1,i));return a}function l(t,e,n,o=1){const r=c(e,o);return Math.floor((t[0]*(n-1)-n+r)/2)}function u(t){return"number"==typeof t?[t,t,t]:2===t.length?[t[0],t[1],1]:t}function f(t){return"number"==typeof t?[t,t,t]:t}function c(t,e){return e<=1?t:t+(t-1)*(e-1)}function p(t,e,n,o,r,i,a,h,l){let u,f,c;if("number"==typeof t){u={top:t,bottom:t,left:t,right:t,type:0===t?"VALID":"NUMBER"};const r=s([e,n],i,o,t,h);f=r[0],c=r[1]}else if("same"===t){f=Math.ceil(e/o),c=Math.ceil(n/r);const t=Math.max(0,(f-1)*o+i-e),s=Math.max(0,(c-1)*r+a-n),h=Math.floor(t/2),l=t-h,p=Math.floor(s/2);u={top:h,bottom:l,left:p,right:s-p,type:"SAME"}}else if("valid"===t)u={top:0,bottom:0,left:0,right:0,type:"VALID"},f=Math.ceil((e-i+1)/o),c=Math.ceil((n-a+1)/r);else{if("object"!=typeof t)throw Error(`Unknown padding parameter: ${t}`);{const s="channelsLast"===l?t[1][0]:t[2][0],p="channelsLast"===l?t[1][1]:t[2][1],d="channelsLast"===l?t[2][0]:t[3][0],m="channelsLast"===l?t[2][1]:t[3][1];u={top:s,bottom:p,left:d,right:m,type:0===s&&0===p&&0===d&&0===m?"VALID":"EXPLICIT"},f=g((e-i+s+p)/o+1,h),c=g((n-a+d+m)/r+1,h)}}return{padInfo:u,outHeight:f,outWidth:c}}function d(t,e,n,o,r,i,a,s,l,u,f){let c,p,d,g;if("valid"===t&&(t=0),"number"==typeof t){c={top:t,bottom:t,left:t,right:t,front:t,back:t,type:0===t?"VALID":"NUMBER"};const m=h([e,n,o,1],[s,l,u],1,[r,i,a],t,f);p=m[0],d=m[1],g=m[2]}else{if("same"!==t)throw Error(`Unknown padding parameter: ${t}`);{const t=((p=Math.ceil(e/r))-1)*r+s-e,h=((d=Math.ceil(n/i))-1)*i+l-n,f=((g=Math.ceil(o/a))-1)*a+u-o,m=Math.floor(t/2),w=t-m,M=Math.floor(h/2),D=h-M,b=Math.floor(f/2);c={top:M,bottom:D,left:b,right:f-b,front:m,back:w,type:"SAME"}}}return{padInfo:c,outDepth:p,outHeight:d,outWidth:g}}function g(t,e){if(!e)return Math.trunc(t);switch(e){case"round":return Math.round(t);case"ceil":return Math.ceil(t);case"floor":return Math.floor(t);default:throw new Error(`Unknown roundingMode ${e}`)}}function m(t){const[e,n,o]=u(t);return 1===e&&1===n&&1===o}function w(t,e){return m(t)||m(e)}function M(t){return u(t).every(t=>t>0)}function D(t){if("NHWC"===t)return"channelsLast";if("NCHW"===t)return"channelsFirst";throw new Error(`Unknown dataFormat ${t}`)}function b(e,n,o){if(null!=o){if("string"==typeof n)throw Error(`Error in ${e}: pad must be an integer when using `+`dimRoundingMode ${o} but got pad ${n}.`);if("number"==typeof n)t.assert(t.isInt(n),()=>`Error in ${e}: pad must be an integer when using `+`dimRoundingMode ${o} but got pad ${n}.`);else{if("object"!=typeof n)throw Error(`Error in ${e}: Unknown padding parameter: ${n}`);n.forEach(n=>{n.forEach(n=>{t.assert(t.isInt(n),()=>`Error in ${e}: pad must be an integer when using `+`dimRoundingMode ${o} but got pad ${n}.`)})})}}}
},{"../util":"XXxQ"}],"F0cm":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.reshape=void 0;var e=require("../engine"),r=require("../kernel_names"),n=require("../tensor_util_env"),s=require("./operation");function o(s,o){const t={x:(0,n.convertToTensor)(s,"x","reshape","string_or_numeric")},i={shape:o};return e.ENGINE.runKernel(r.Reshape,t,i)}const t=exports.reshape=(0,s.op)({reshape_:o});
},{"../engine":"phT7","../kernel_names":"rJl6","../tensor_util_env":"y4X4","./operation":"uE86"}],"LNDu":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.avgPool=void 0;var e=require("../engine"),r=require("../kernel_names"),t=require("../tensor_util_env"),o=u(require("../util")),n=require("./cast"),a=u(require("./conv_util")),i=require("./operation"),s=require("./reshape");function u(e,r){if("function"==typeof WeakMap)var t=new WeakMap,o=new WeakMap;return(u=function(e,r){if(!r&&e&&e.__esModule)return e;var n,a,i={__proto__:null,default:e};if(null===e||"object"!=typeof e&&"function"!=typeof e)return i;if(n=r?o:t){if(n.has(e))return n.get(e);n.set(e,i)}for(const t in e)"default"!==t&&{}.hasOwnProperty.call(e,t)&&((a=(n=Object.defineProperty)&&Object.getOwnPropertyDescriptor(e,t))&&(a.get||a.set)?n(i,t,a):i[t]=e[t]);return i})(e,r)}function l(i,u,l,p,c){const d=(0,t.convertToTensor)(i,"x","avgPool","float32");o.assert(a.eitherStridesOrDilationsAreOne(l,1),()=>"Error in avgPool: Either strides or dilations must be 1. "+`Got strides ${l} and dilations '1'`);let f=d,v=!1;3===d.rank&&(v=!0,f=(0,s.reshape)(d,[1,d.shape[0],d.shape[1],d.shape[2]])),o.assert(4===f.rank,()=>`Error in avgPool: x must be rank 4 but got rank ${f.rank}.`),a.checkPadOnDimRoundingMode("avgPool",p,c);const g={x:f},h={filterSize:u,strides:l,pad:p,dimRoundingMode:c};let P=e.ENGINE.runKernel(r.AvgPool,g,h);return P=(0,n.cast)(P,d.dtype),v?(0,s.reshape)(P,[P.shape[1],P.shape[2],P.shape[3]]):P}const p=exports.avgPool=(0,i.op)({avgPool_:l});
},{"../engine":"phT7","../kernel_names":"rJl6","../tensor_util_env":"y4X4","../util":"XXxQ","./cast":"qnzc","./conv_util":"PhWH","./operation":"uE86","./reshape":"F0cm"}],"gUgG":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.avgPool3d=void 0;var e=require("../engine"),r=require("../kernel_names"),t=require("../tensor_util_env"),o=u(require("../util")),a=require("./cast"),n=require("./conv_util"),s=require("./operation"),i=require("./reshape");function u(e,r){if("function"==typeof WeakMap)var t=new WeakMap,o=new WeakMap;return(u=function(e,r){if(!r&&e&&e.__esModule)return e;var a,n,s={__proto__:null,default:e};if(null===e||"object"!=typeof e&&"function"!=typeof e)return s;if(a=r?o:t){if(a.has(e))return a.get(e);a.set(e,s)}for(const t in e)"default"!==t&&{}.hasOwnProperty.call(e,t)&&((n=(a=Object.defineProperty)&&Object.getOwnPropertyDescriptor(e,t))&&(n.get||n.set)?a(s,t,n):s[t]=e[t]);return s})(e,r)}function p(s,u,p,l,d,c="NDHWC"){const f=(0,t.convertToTensor)(s,"x","avgPool3d","float32");let g=f,v=!1;4===f.rank&&(v=!0,g=(0,i.reshape)(f,[1,f.shape[0],f.shape[1],f.shape[2],f.shape[3]])),o.assert(5===g.rank,()=>`Error in avgPool3d: x must be rank 5 but got rank ${g.rank}.`),o.assert("NDHWC"===c,()=>"Error in avgPool3d: Only NDHWC is currently supported, "+`but got dataFormat of ${c}`),o.assert("number"==typeof p&&p>0||Array.isArray(p)&&p[0]>0&&p[1]>0&&p[2]>0,()=>`Error in avgPool3d: Stride must be > 0, but got '${p}'`),(0,n.checkPadOnDimRoundingMode)("avgPool3d",l,d);const h={x:g},P={filterSize:u,strides:p,pad:l,dimRoundingMode:d,dataFormat:c};let y=e.ENGINE.runKernel(r.AvgPool3D,h,P);return y=(0,a.cast)(y,g.dtype),v?(0,i.reshape)(y,[y.shape[1],y.shape[2],y.shape[3],y.shape[4]]):y}const l=exports.avgPool3d=(0,s.op)({avgPool3d_:p});
},{"../engine":"phT7","../kernel_names":"rJl6","../tensor_util_env":"y4X4","../util":"XXxQ","./cast":"qnzc","./conv_util":"PhWH","./operation":"uE86","./reshape":"F0cm"}],"V5Ij":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.concat=void 0;var e=require("../engine"),r=require("../kernel_names"),t=require("../tensor_util_env"),n=require("../util"),o=require("./clone"),c=require("./operation");function s(c,s=0){(0,n.assert)(c.length>=1,()=>"Pass at least one tensor to concat");const a=(0,t.convertToTensorArray)(c,"tensors","concat","string_or_numeric");if("complex64"===a[0].dtype&&a.forEach(e=>{if("complex64"!==e.dtype)throw new Error(`Cannot concatenate complex64 tensors with a tensor\n          with dtype ${e.dtype}. `)}),1===a.length)return(0,o.clone)(a[0]);const i=a,u={axis:s};return e.ENGINE.runKernel(r.Concat,i,u)}const a=exports.concat=(0,c.op)({concat_:s});
},{"../engine":"phT7","../kernel_names":"rJl6","../tensor_util_env":"y4X4","../util":"XXxQ","./clone":"Ot88","./operation":"uE86"}],"zVDr":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.matMul=void 0;var e=require("../engine"),r=require("../kernel_names"),t=require("../tensor_util"),n=require("../tensor_util_env"),o=require("./operation");function u(o,u,s=!1,a=!1){let i=(0,n.convertToTensor)(o,"a","matMul"),l=(0,n.convertToTensor)(u,"b","matMul");[i,l]=(0,t.makeTypesMatch)(i,l);const c={a:i,b:l},p={transposeA:s,transposeB:a};return e.ENGINE.runKernel(r.BatchMatMul,c,p)}const s=exports.matMul=(0,o.op)({matMul_:u});
},{"../engine":"phT7","../kernel_names":"rJl6","../tensor_util":"wtFc","../tensor_util_env":"y4X4","./operation":"uE86"}],"DbGB":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.sigmoid=void 0;var e=require("../engine"),r=require("../kernel_names"),o=require("../tensor_util_env"),i=require("./operation");function n(i){const n={x:(0,o.convertToTensor)(i,"x","sigmoid","float32")};return e.ENGINE.runKernel(r.Sigmoid,n)}const t=exports.sigmoid=(0,i.op)({sigmoid_:n});
},{"../engine":"phT7","../kernel_names":"rJl6","../tensor_util_env":"y4X4","./operation":"uE86"}],"wIos":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.slice=void 0;var e=require("../engine"),r=require("../kernel_names"),i=require("../tensor_util_env"),n=require("./operation");function o(n,o,s){const t=(0,i.convertToTensor)(n,"x","slice","string_or_numeric");if(0===t.rank)throw new Error("Slicing scalar is not possible");const c={x:t},l={begin:o,size:s};return e.ENGINE.runKernel(r.Slice,c,l)}const s=exports.slice=(0,n.op)({slice_:o});
},{"../engine":"phT7","../kernel_names":"rJl6","../tensor_util_env":"y4X4","./operation":"uE86"}],"djih":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.tanh=void 0;var e=require("../engine"),r=require("../kernel_names"),n=require("../tensor_util_env"),t=require("./operation");function o(t){const o={x:(0,n.convertToTensor)(t,"x","tanh","float32")};return e.ENGINE.runKernel(r.Tanh,o)}const i=exports.tanh=(0,t.op)({tanh_:o});
},{"../engine":"phT7","../kernel_names":"rJl6","../tensor_util_env":"y4X4","./operation":"uE86"}],"IrGh":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.basicLSTMCell=void 0;var e=require("../tensor_util_env"),r=require("./add"),i=require("./concat"),s=require("./mat_mul"),o=require("./mul"),l=require("./operation"),t=require("./sigmoid"),c=require("./slice"),a=require("./tanh");function n(l,n,u,T,d,m){const M=(0,e.convertToTensor)(l,"forgetBias","basicLSTMCell"),b=(0,e.convertToTensor)(n,"lstmKernel","basicLSTMCell"),v=(0,e.convertToTensor)(u,"lstmBias","basicLSTMCell"),q=(0,e.convertToTensor)(T,"data","basicLSTMCell"),C=(0,e.convertToTensor)(d,"c","basicLSTMCell"),L=(0,e.convertToTensor)(m,"h","basicLSTMCell"),S=(0,i.concat)([q,L],1),p=(0,s.matMul)(S,b),h=(0,r.add)(p,v),_=h.shape[0],g=h.shape[1]/4,f=[_,g],x=(0,c.slice)(h,[0,0],f),B=(0,c.slice)(h,[0,g],f),j=(0,c.slice)(h,[0,2*g],f),y=(0,c.slice)(h,[0,3*g],f),K=(0,r.add)((0,o.mul)((0,t.sigmoid)(x),(0,a.tanh)(B)),(0,o.mul)(C,(0,t.sigmoid)((0,r.add)(M,j))));return[K,(0,o.mul)((0,a.tanh)(K),(0,t.sigmoid)(y))]}const u=exports.basicLSTMCell=(0,l.op)({basicLSTMCell_:n});
},{"../tensor_util_env":"y4X4","./add":"N73o","./concat":"V5Ij","./mat_mul":"zVDr","./mul":"tBJ4","./operation":"uE86","./sigmoid":"DbGB","./slice":"wIos","./tanh":"djih"}],"vEiD":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.batchToSpaceND=void 0;var e=require("../engine"),t=require("../kernel_names"),n=require("../tensor_util_env"),r=a(require("../util")),o=require("./operation");function a(e,t){if("function"==typeof WeakMap)var n=new WeakMap,r=new WeakMap;return(a=function(e,t){if(!t&&e&&e.__esModule)return e;var o,a,s={__proto__:null,default:e};if(null===e||"object"!=typeof e&&"function"!=typeof e)return s;if(o=t?r:n){if(o.has(e))return o.get(e);o.set(e,s)}for(const n in e)"default"!==n&&{}.hasOwnProperty.call(e,n)&&((a=(o=Object.defineProperty)&&Object.getOwnPropertyDescriptor(e,n))&&(a.get||a.set)?o(s,n,a):s[n]=e[n]);return s})(e,t)}function s(o,a,s){const u=(0,n.convertToTensor)(o,"x","batchToSpaceND"),c=a.reduce((e,t)=>e*t);r.assert(u.rank>=1+a.length,()=>`input rank is ${u.rank} but should be > than blockShape.length ${a.length}`),r.assert(s.length===a.length,()=>`crops.length is ${s.length} but should be equal to blockShape.length  ${a.length}`),r.assert(u.shape[0]%c==0,()=>`input tensor batch is ${u.shape[0]} but is not divisible by the product of `+`the elements of blockShape ${a.join(" * ")} === ${c}`);const i={x:u},l={blockShape:a,crops:s};return e.ENGINE.runKernel(t.BatchToSpaceND,i,l)}const u=exports.batchToSpaceND=(0,o.op)({batchToSpaceND_:s});
},{"../engine":"phT7","../kernel_names":"rJl6","../tensor_util_env":"y4X4","../util":"XXxQ","./operation":"uE86"}],"voqZ":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.xAs4D=r;var e=require("./reshape");function r(r){let s;return s=0===r.rank||1===r.rank?(0,e.reshape)(r,[1,1,1,r.size]):2===r.rank?(0,e.reshape)(r,[1,1,r.shape[0],r.shape[1]]):3===r.rank?(0,e.reshape)(r,[1,r.shape[0],r.shape[1],r.shape[2]]):r}
},{"./reshape":"F0cm"}],"gYII":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.batchNorm=void 0;var e=require("../engine"),r=require("../kernel_names"),n=require("../tensor_util_env"),a=i(require("../util")),t=require("./batchnorm_util"),o=require("./operation"),s=require("./reshape");function i(e,r){if("function"==typeof WeakMap)var n=new WeakMap,a=new WeakMap;return(i=function(e,r){if(!r&&e&&e.__esModule)return e;var t,o,s={__proto__:null,default:e};if(null===e||"object"!=typeof e&&"function"!=typeof e)return s;if(t=r?a:n){if(t.has(e))return t.get(e);t.set(e,s)}for(const n in e)"default"!==n&&{}.hasOwnProperty.call(e,n)&&((o=(t=Object.defineProperty)&&Object.getOwnPropertyDescriptor(e,n))&&(o.get||o.set)?t(s,n,o):s[n]=e[n]);return s})(e,r)}function u(o,i,u,c,l,f){null==f&&(f=.001);const h=(0,n.convertToTensor)(o,"x","batchNorm"),p=(0,n.convertToTensor)(i,"mean","batchNorm"),m=(0,n.convertToTensor)(u,"variance","batchNorm");let v,d;null!=l&&(v=(0,n.convertToTensor)(l,"scale","batchNorm")),null!=c&&(d=(0,n.convertToTensor)(c,"offset","batchNorm")),a.assert(p.rank===m.rank,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),a.assert(null==d||p.rank===d.rank,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),a.assert(null==v||p.rank===v.rank,()=>"Batch normalization gradient requires mean and scale to have equal ranks.");const b={x:(0,t.xAs4D)(h),scale:v,offset:d,mean:p,variance:m},k={varianceEpsilon:f},q=e.ENGINE.runKernel(r.FusedBatchNorm,b,k);return(0,s.reshape)(q,h.shape)}const c=exports.batchNorm=(0,o.op)({batchNorm_:u});
},{"../engine":"phT7","../kernel_names":"rJl6","../tensor_util_env":"y4X4","../util":"XXxQ","./batchnorm_util":"voqZ","./operation":"uE86","./reshape":"F0cm"}],"PwSx":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.batchNorm2d=void 0;var r=require("../tensor_util_env"),t=o(require("../util")),e=require("./batchnorm"),n=require("./operation");function o(r,t){if("function"==typeof WeakMap)var e=new WeakMap,n=new WeakMap;return(o=function(r,t){if(!t&&r&&r.__esModule)return r;var o,a,s={__proto__:null,default:r};if(null===r||"object"!=typeof r&&"function"!=typeof r)return s;if(o=t?n:e){if(o.has(r))return o.get(r);o.set(r,s)}for(const e in r)"default"!==e&&{}.hasOwnProperty.call(r,e)&&((a=(o=Object.defineProperty)&&Object.getOwnPropertyDescriptor(r,e))&&(a.get||a.set)?o(s,e,a):s[e]=r[e]);return s})(r,t)}function a(n,o,a,s,c,u){const k=(0,r.convertToTensor)(n,"x","batchNorm"),i=(0,r.convertToTensor)(o,"mean","batchNorm"),b=(0,r.convertToTensor)(a,"variance","batchNorm");let l,f;return null!=c&&(l=(0,r.convertToTensor)(c,"scale","batchNorm")),null!=s&&(f=(0,r.convertToTensor)(s,"offset","batchNorm")),t.assert(2===k.rank,()=>"Error in batchNorm2D: x must be rank 2 but got rank "+`${k.rank}.`),t.assert(2===i.rank||1===i.rank,()=>"Error in batchNorm2D: mean must be rank 2 or rank 1 but "+`got rank ${i.rank}.`),t.assert(2===b.rank||1===b.rank,()=>"Error in batchNorm2D: variance must be rank 2 or rank 1 "+`but got rank ${b.rank}.`),null!=l&&t.assert(2===l.rank||1===l.rank,()=>"Error in batchNorm2D: scale must be rank 2 or rank 1 "+`but got rank ${l.rank}.`),null!=f&&t.assert(2===f.rank||1===f.rank,()=>"Error in batchNorm2D: offset must be rank 2 or rank 1 "+`but got rank ${f.rank}.`),(0,e.batchNorm)(k,i,b,f,l,u)}const s=exports.batchNorm2d=(0,n.op)({batchNorm2d_:a});
},{"../tensor_util_env":"y4X4","../util":"XXxQ","./batchnorm":"gYII","./operation":"uE86"}],"zSL9":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.batchNorm3d=void 0;var r=require("../tensor_util_env"),t=o(require("../util")),e=require("./batchnorm"),n=require("./operation");function o(r,t){if("function"==typeof WeakMap)var e=new WeakMap,n=new WeakMap;return(o=function(r,t){if(!t&&r&&r.__esModule)return r;var o,a,s={__proto__:null,default:r};if(null===r||"object"!=typeof r&&"function"!=typeof r)return s;if(o=t?n:e){if(o.has(r))return o.get(r);o.set(r,s)}for(const e in r)"default"!==e&&{}.hasOwnProperty.call(r,e)&&((a=(o=Object.defineProperty)&&Object.getOwnPropertyDescriptor(r,e))&&(a.get||a.set)?o(s,e,a):s[e]=r[e]);return s})(r,t)}function a(n,o,a,s,c,u){const k=(0,r.convertToTensor)(n,"x","batchNorm"),i=(0,r.convertToTensor)(o,"mean","batchNorm"),b=(0,r.convertToTensor)(a,"variance","batchNorm");let l,f;return null!=c&&(l=(0,r.convertToTensor)(c,"scale","batchNorm")),null!=s&&(f=(0,r.convertToTensor)(s,"offset","batchNorm")),t.assert(3===k.rank,()=>"Error in batchNorm3D: x must be rank 3 but got rank "+`${k.rank}.`),t.assert(3===i.rank||1===i.rank,()=>"Error in batchNorm3D: mean must be rank 3 or rank 1 but "+`got rank ${i.rank}.`),t.assert(3===b.rank||1===b.rank,()=>"Error in batchNorm3D: variance must be rank 3 or rank 1 "+`but got rank ${b.rank}.`),null!=l&&t.assert(3===l.rank||1===l.rank,()=>"Error in batchNorm3D: scale must be rank 3 or rank 1 "+`but got rank ${l.rank}.`),null!=f&&t.assert(3===f.rank||1===f.rank,()=>"Error in batchNorm3D: offset must be rank 3 or rank 1 "+`but got rank ${f.rank}.`),(0,e.batchNorm)(k,i,b,f,l,u)}const s=exports.batchNorm3d=(0,n.op)({batchNorm3d_:a});
},{"../tensor_util_env":"y4X4","../util":"XXxQ","./batchnorm":"gYII","./operation":"uE86"}],"PGAU":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.batchNorm4d=void 0;var r=require("../tensor_util_env"),t=o(require("../util")),e=require("./batchnorm"),n=require("./operation");function o(r,t){if("function"==typeof WeakMap)var e=new WeakMap,n=new WeakMap;return(o=function(r,t){if(!t&&r&&r.__esModule)return r;var o,a,s={__proto__:null,default:r};if(null===r||"object"!=typeof r&&"function"!=typeof r)return s;if(o=t?n:e){if(o.has(r))return o.get(r);o.set(r,s)}for(const e in r)"default"!==e&&{}.hasOwnProperty.call(r,e)&&((a=(o=Object.defineProperty)&&Object.getOwnPropertyDescriptor(r,e))&&(a.get||a.set)?o(s,e,a):s[e]=r[e]);return s})(r,t)}function a(n,o,a,s,c,u){const k=(0,r.convertToTensor)(n,"x","batchNorm"),i=(0,r.convertToTensor)(o,"mean","batchNorm"),b=(0,r.convertToTensor)(a,"variance","batchNorm");let l,f;return null!=c&&(l=(0,r.convertToTensor)(c,"scale","batchNorm")),null!=s&&(f=(0,r.convertToTensor)(s,"offset","batchNorm")),t.assert(4===k.rank,()=>"Error in batchNorm4D: x must be rank 4 but got rank "+`${k.rank}.`),t.assert(4===i.rank||1===i.rank,()=>"Error in batchNorm4D: mean must be rank 4 or rank 1 but "+`got rank ${i.rank}.`),t.assert(4===b.rank||1===b.rank,()=>"Error in batchNorm4D: variance must be rank 4 or rank 1 "+`but got rank ${b.rank}.`),null!=l&&t.assert(4===l.rank||1===l.rank,()=>"Error in batchNorm4D: scale must be rank 4 or rank 1 "+`but got rank ${l.rank}.`),null!=f&&t.assert(4===f.rank||1===f.rank,()=>"Error in batchNorm4D: offset must be rank 4 or rank 1 "+`but got rank ${f.rank}.`),(0,e.batchNorm)(k,i,b,f,l,u)}const s=exports.batchNorm4d=(0,n.op)({batchNorm4d_:a});
},{"../tensor_util_env":"y4X4","../util":"XXxQ","./batchnorm":"gYII","./operation":"uE86"}],"rYQ1":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.bincount=void 0;var e=require("../engine"),t=require("../kernel_names"),n=require("../tensor_util_env"),r=i(require("../util")),o=require("./operation");function i(e,t){if("function"==typeof WeakMap)var n=new WeakMap,r=new WeakMap;return(i=function(e,t){if(!t&&e&&e.__esModule)return e;var o,i,s={__proto__:null,default:e};if(null===e||"object"!=typeof e&&"function"!=typeof e)return s;if(o=t?r:n){if(o.has(e))return o.get(e);o.set(e,s)}for(const n in e)"default"!==n&&{}.hasOwnProperty.call(e,n)&&((i=(o=Object.defineProperty)&&Object.getOwnPropertyDescriptor(e,n))&&(i.get||i.set)?o(s,n,i):s[n]=e[n]);return s})(e,t)}function s(o,i,s){const u=(0,n.convertToTensor)(o,"x","bincount"),a=(0,n.convertToTensor)(i,"weights","bincount");r.assert("int32"===u.dtype,()=>"Error in bincount: input "+`dtype must be int32, but got ${u.dtype}`),r.assert(s>=0,()=>`size must be non-negative, but got ${s}.`),r.assert(a.size===u.size||0===a.size,()=>"Error in bincount: weights must have the same size as input or"+`0-length, but got input shape: ${u.shape}, weights shape: `+`${a.shape}.`);const p={x:u,weights:a},c={size:s};return e.ENGINE.runKernel(t.Bincount,p,c)}const u=exports.bincount=(0,o.op)({bincount_:s});
},{"../engine":"phT7","../kernel_names":"rJl6","../tensor_util_env":"y4X4","../util":"XXxQ","./operation":"uE86"}],"bonT":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.bitwiseAnd=void 0;var e=require("../engine"),r=require("../kernel_names"),t=require("../tensor_util_env"),n=require("../util_base"),s=require("./operation");function i(s,i){const o=(0,t.convertToTensor)(s,"x","bitwiseAnd"),p=(0,t.convertToTensor)(i,"y","bitwiseAnd");if(!(0,n.arraysEqual)(o.shape,p.shape))throw new Error(`BitwiseAnd: Tensors must have the same shape. x: ${o.shape}, y: ${p.shape}`);if("int32"!==o.dtype||"int32"!==p.dtype)throw new Error(`BitwiseAnd: Only supports 'int32' values in tensor, found type of x: ${o.dtype} and type of y: ${p.dtype}`);const a={a:o,b:p};return e.ENGINE.runKernel(r.BitwiseAnd,a)}const o=exports.bitwiseAnd=(0,s.op)({bitwiseAnd_:i});
},{"../engine":"phT7","../kernel_names":"rJl6","../tensor_util_env":"y4X4","../util_base":"uID4","./operation":"uE86"}],"PJAz":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.broadcastArgs=void 0;var r=require("../engine"),e=require("../kernel_names"),s=require("../tensor_util_env"),t=require("./operation");function n(t,n){const o=(0,s.convertToTensor)(t,"s0","broadcastArgs","int32"),a=(0,s.convertToTensor)(n,"s1","broadcastArgs","int32");if(1!==o.rank)throw new Error("broadcastArgs(): first input must be a vector (rank=1). "+`Has rank ${o.rank}`);if(1!==a.rank)throw new Error("broadcastArgs(): second input must be a vector (rank=1). "+`Has rank ${a.rank}`);const c={s0:o,s1:a};return r.ENGINE.runKernel(e.BroadcastArgs,c)}const o=exports.broadcastArgs=(0,t.op)({broadcastArgs_:n});
},{"../engine":"phT7","../kernel_names":"rJl6","../tensor_util_env":"y4X4","./operation":"uE86"}],"ZDfb":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.broadcastTo=void 0;var e=require("../engine"),r=require("../kernel_names"),t=require("../tensor_util_env"),n=require("../util_base"),o=require("./clone"),s=require("./operation"),a=require("./reshape");function i(s,i){let l=(0,t.convertToTensor)(s,"broadcastTo","x");const c=l.shape;if((0,n.assertNonNegativeIntegerDimensions)(i),i.length<l.rank)throw new Error(`broadcastTo(): shape.length=${i.length} < input.rank=${l.rank}.`);if(i.length>l.rank){const e=l.shape.slice();for(;e.length<i.length;)e.unshift(1);l=(0,a.reshape)(l,e)}const h=l.shape,u=Array.from(i);for(let e=i.length-1;e>=0;e--)if(h[e]===i[e])u[e]=1;else if(1!==l.shape[e])throw new Error(`broadcastTo(): [${c}] cannot be broadcast to [${i}].`);if(0===u.map((e,r)=>e>1?r:-1).filter(e=>e>=0).length)return(0,o.clone)(l);const p={x:l},f={reps:u};return e.ENGINE.runKernel(r.Tile,p,f)}const l=exports.broadcastTo=(0,s.op)({broadcastTo_:i});
},{"../engine":"phT7","../kernel_names":"rJl6","../tensor_util_env":"y4X4","../util_base":"uID4","./clone":"Ot88","./operation":"uE86","./reshape":"F0cm"}],"VBn4":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.ceil=void 0;var e=require("../engine"),r=require("../kernel_names"),n=require("../tensor_util_env"),o=require("./operation");function i(o){const i={x:(0,n.convertToTensor)(o,"x","ceil","float32")};return e.ENGINE.runKernel(r.Ceil,i)}const t=exports.ceil=(0,o.op)({ceil_:i});
},{"../engine":"phT7","../kernel_names":"rJl6","../tensor_util_env":"y4X4","./operation":"uE86"}],"gaCw":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.fill=t;var e=require("../engine"),r=require("../kernel_names"),i=require("../util"),n=require("../util_base");function t(t,s,u){(0,n.assertNonNegativeIntegerDimensions)(t);const l={shape:t,value:s,dtype:u=u||(0,i.inferDtype)(s)};return e.ENGINE.runKernel(r.Fill,{},l)}
},{"../engine":"phT7","../kernel_names":"rJl6","../util":"XXxQ","../util_base":"uID4"}],"OIQo":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.clipByValue=void 0;var e=require("../engine"),r=require("../kernel_names"),t=require("../tensor_util_env"),n=o(require("../util")),i=require("./fill"),u=require("./operation");function o(e,r){if("function"==typeof WeakMap)var t=new WeakMap,n=new WeakMap;return(o=function(e,r){if(!r&&e&&e.__esModule)return e;var i,u,o={__proto__:null,default:e};if(null===e||"object"!=typeof e&&"function"!=typeof e)return o;if(i=r?n:t){if(i.has(e))return i.get(e);i.set(e,o)}for(const t in e)"default"!==t&&{}.hasOwnProperty.call(e,t)&&((u=(i=Object.defineProperty)&&Object.getOwnPropertyDescriptor(e,t))&&(u.get||u.set)?i(o,t,u):o[t]=e[t]);return o})(e,r)}function l(u,o,l){const a=(0,t.convertToTensor)(u,"x","clipByValue");if(n.assert(o<=l,()=>`Error in clip: min (${o}) must be `+`less than or equal to max (${l}).`),o===l)return(0,i.fill)(a.shape,o,a.dtype);const p={x:a},s={clipValueMin:o,clipValueMax:l};return e.ENGINE.runKernel(r.ClipByValue,p,s)}const a=exports.clipByValue=(0,u.op)({clipByValue_:l});
},{"../engine":"phT7","../kernel_names":"rJl6","../tensor_util_env":"y4X4","../util":"XXxQ","./fill":"gaCw","./operation":"uE86"}],"SY4F":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.concat1d=void 0;var e=require("./concat"),o=require("./operation");function t(o){return(0,e.concat)(o,0)}const c=exports.concat1d=(0,o.op)({concat1d_:t});
},{"./concat":"V5Ij","./operation":"uE86"}],"rep6":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.concat2d=void 0;var e=require("./concat"),o=require("./operation");function t(o,t){return(0,e.concat)(o,t)}const c=exports.concat2d=(0,o.op)({concat2d_:t});
},{"./concat":"V5Ij","./operation":"uE86"}],"La3N":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.concat3d=void 0;var e=require("./concat"),o=require("./operation");function t(o,t){return(0,e.concat)(o,t)}const c=exports.concat3d=(0,o.op)({concat3d_:t});
},{"./concat":"V5Ij","./operation":"uE86"}],"UYxl":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.concat4d=void 0;var e=require("./concat"),o=require("./operation");function t(o,t){return(0,e.concat)(o,t)}const c=exports.concat4d=(0,o.op)({concat4d_:t});
},{"./concat":"V5Ij","./operation":"uE86"}],"CVMs":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.conv2d=void 0;var e=require("../engine"),r=require("../kernel_names"),t=require("../tensor_util_env"),n=a(require("../util")),o=a(require("./conv_util")),s=require("./operation"),i=require("./reshape");function a(e,r){if("function"==typeof WeakMap)var t=new WeakMap,n=new WeakMap;return(a=function(e,r){if(!r&&e&&e.__esModule)return e;var o,s,i={__proto__:null,default:e};if(null===e||"object"!=typeof e&&"function"!=typeof e)return i;if(o=r?n:t){if(o.has(e))return o.get(e);o.set(e,i)}for(const t in e)"default"!==t&&{}.hasOwnProperty.call(e,t)&&((s=(o=Object.defineProperty)&&Object.getOwnPropertyDescriptor(e,t))&&(s.get||s.set)?o(i,t,s):i[t]=e[t]);return i})(e,r)}function u(s,a,u,d,p="NHWC",c=[1,1],l){const f=(0,t.convertToTensor)(s,"x","conv2d","float32"),h=(0,t.convertToTensor)(a,"filter","conv2d","float32");let v=f,k=!1;3===f.rank&&(k=!0,v=(0,i.reshape)(f,[1,f.shape[0],f.shape[1],f.shape[2]])),n.assert(4===v.rank,()=>`Error in conv2d: input must be rank 4, but got rank ${v.rank}.`),n.assert(4===h.rank,()=>"Error in conv2d: filter must be rank 4, but got rank "+`${h.rank}.`),o.checkPadOnDimRoundingMode("conv2d",d,l);const _="NHWC"===p?v.shape[3]:v.shape[1];n.assert(_===h.shape[2],()=>`Error in conv2d: depth of input (${_}) must match `+`input depth for filter ${h.shape[2]}.`),n.assert(o.eitherStridesOrDilationsAreOne(u,c),()=>"Error in conv2D: Either strides or dilations must be 1. "+`Got strides ${u} and dilations '${c}'`),n.assert(o.stridesOrDilationsArePositive(c),()=>"Error in conv2D: Dilated rates should be larger than 0."),n.assert(o.stridesOrDilationsArePositive(u),()=>"Error in conv2D: Strides should be larger than 0.");const b={x:v,filter:h},g={strides:u,pad:d,dataFormat:p,dilations:c,dimRoundingMode:l},D=e.ENGINE.runKernel(r.Conv2D,b,g);return k?(0,i.reshape)(D,[D.shape[1],D.shape[2],D.shape[3]]):D}const d=exports.conv2d=(0,s.op)({conv2d_:u});
},{"../engine":"phT7","../kernel_names":"rJl6","../tensor_util_env":"y4X4","../util":"XXxQ","./conv_util":"PhWH","./operation":"uE86","./reshape":"F0cm"}],"RZoo":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.conv1d=void 0;var e=require("../tensor_util_env"),r=a(require("../util")),t=require("./conv2d"),n=a(require("./conv_util")),o=require("./operation"),s=require("./reshape");function a(e,r){if("function"==typeof WeakMap)var t=new WeakMap,n=new WeakMap;return(a=function(e,r){if(!r&&e&&e.__esModule)return e;var o,s,a={__proto__:null,default:e};if(null===e||"object"!=typeof e&&"function"!=typeof e)return a;if(o=r?n:t){if(o.has(e))return o.get(e);o.set(e,a)}for(const t in e)"default"!==t&&{}.hasOwnProperty.call(e,t)&&((s=(o=Object.defineProperty)&&Object.getOwnPropertyDescriptor(e,t))&&(s.get||s.set)?o(a,t,s):a[t]=e[t]);return a})(e,r)}function i(o,a,i,p,u="NWC",c=1,d){const h=(0,e.convertToTensor)(o,"x","conv1d"),l=(0,e.convertToTensor)(a,"filter","conv1d");let v=h,f=!1;2===h.rank&&(f=!0,v=(0,s.reshape)(h,[1,h.shape[0],h.shape[1]])),r.assert(3===v.rank,()=>`Error in conv1d: input must be rank 3, but got rank ${v.rank}.`),r.assert(3===l.rank,()=>"Error in conv1d: filter must be rank 3, but got rank "+`${l.rank}.`),n.checkPadOnDimRoundingMode("conv1d",p,d),r.assert(v.shape[2]===l.shape[1],()=>`Error in conv1d: depth of input (${v.shape[2]}) must match `+`input depth for filter ${l.shape[1]}.`),r.assert(n.eitherStridesOrDilationsAreOne(i,c),()=>"Error in conv1D: Either stride or dilation must be 1. "+`Got stride ${i} and dilation '${c}'`),r.assert(n.stridesOrDilationsArePositive(c),()=>"Error in conv1D: Dilated rates should be larger than 0."),r.assert(n.stridesOrDilationsArePositive(i),()=>"Error in conv1D: Stride should be larger than 0."),r.assert("NWC"===u,()=>`Error in conv1d: got dataFormat of ${u} but only NWC is currently supported.`);const k=(0,s.reshape)(l,[1,l.shape[0],l.shape[1],l.shape[2]]),b=(0,s.reshape)(v,[v.shape[0],1,v.shape[1],v.shape[2]]),_=[1,i],O=[1,c],g=(0,t.conv2d)(b,k,_,p,"NHWC",O,d);return f?(0,s.reshape)(g,[g.shape[2],g.shape[3]]):(0,s.reshape)(g,[g.shape[0],g.shape[2],g.shape[3]])}const p=exports.conv1d=(0,o.op)({conv1d_:i});
},{"../tensor_util_env":"y4X4","../util":"XXxQ","./conv2d":"CVMs","./conv_util":"PhWH","./operation":"uE86","./reshape":"F0cm"}],"sf3S":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.conv2DBackpropInput=void 0;var e=require("../engine"),r=require("../kernel_names"),t=p(require("../util")),n=p(require("./conv_util")),a=require("./operation"),o=require("./reshape");function p(e,r){if("function"==typeof WeakMap)var t=new WeakMap,n=new WeakMap;return(p=function(e,r){if(!r&&e&&e.__esModule)return e;var a,o,p={__proto__:null,default:e};if(null===e||"object"!=typeof e&&"function"!=typeof e)return p;if(a=r?n:t){if(a.has(e))return a.get(e);a.set(e,p)}for(const t in e)"default"!==t&&{}.hasOwnProperty.call(e,t)&&((o=(a=Object.defineProperty)&&Object.getOwnPropertyDescriptor(e,t))&&(o.get||o.set)?a(p,t,o):p[t]=e[t]);return p})(e,r)}function u(a,p,u,s,i,c="NHWC",h){t.assert(a.length===p.rank,()=>"Length of inShape "+`(${a.length}) and rank of dy (${p.rank}) must match`);let d=a,f=p,l=!1;3===p.rank&&(l=!0,f=(0,o.reshape)(p,[1,p.shape[0],p.shape[1],p.shape[2]]),d=[1,a[0],a[1],a[2]]),t.assert(4===d.length,()=>"Error in conv2dDerInput: inShape must be length 4, but got length "+`${d.length}.`),t.assert(4===f.rank,()=>"Error in conv2dDerInput: dy must be rank 4, but got "+`rank ${f.rank}`),t.assert(4===u.rank,()=>"Error in conv2dDerInput: filter must be rank 4, but got "+`rank ${u.rank}`);const k="NHWC"===c?d[3]:d[1],g="NHWC"===c?f.shape[3]:f.shape[1];t.assert(k===u.shape[2],()=>`Error in conv2dDerInput: depth of input (${k}) must `+`match input depth for filter ${u.shape[2]}.`),t.assert(g===u.shape[3],()=>`Error in conv2dDerInput: depth of output (${g}) must `+`match output depth for filter ${u.shape[3]}.`),n.checkPadOnDimRoundingMode("conv2dDerInput",i,h);const v={dy:f,filter:u},m={strides:s,pad:i,dataFormat:c,dimRoundingMode:h,inputShape:d},D=e.ENGINE.runKernel(r.Conv2DBackpropInput,v,m);return l?(0,o.reshape)(D,[D.shape[1],D.shape[2],D.shape[3]]):D}const s=exports.conv2DBackpropInput=(0,a.op)({conv2DBackpropInput_:u});
},{"../engine":"phT7","../kernel_names":"rJl6","../util":"XXxQ","./conv_util":"PhWH","./operation":"uE86","./reshape":"F0cm"}],"v80f":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.conv2dTranspose=void 0;var o=require("../tensor_util_env"),e=require("./conv2d_backprop_input"),r=require("./operation");function n(r,n,s,t,p,c){const v=(0,o.convertToTensor)(r,"x","conv2dTranspose"),i=(0,o.convertToTensor)(n,"filter","conv2dTranspose");return(0,e.conv2DBackpropInput)(s,v,i,t,p,"NHWC",c)}const s=exports.conv2dTranspose=(0,r.op)({conv2dTranspose_:n});
},{"../tensor_util_env":"y4X4","./conv2d_backprop_input":"sf3S","./operation":"uE86"}],"uOsG":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.conv3d=void 0;var e=require("../engine"),r=require("../kernel_names"),t=require("../tensor_util_env"),n=i(require("../util")),o=require("./conv_util"),s=require("./operation"),a=require("./reshape");function i(e,r){if("function"==typeof WeakMap)var t=new WeakMap,n=new WeakMap;return(i=function(e,r){if(!r&&e&&e.__esModule)return e;var o,s,a={__proto__:null,default:e};if(null===e||"object"!=typeof e&&"function"!=typeof e)return a;if(o=r?n:t){if(o.has(e))return o.get(e);o.set(e,a)}for(const t in e)"default"!==t&&{}.hasOwnProperty.call(e,t)&&((s=(o=Object.defineProperty)&&Object.getOwnPropertyDescriptor(e,t))&&(s.get||s.set)?o(a,t,s):a[t]=e[t]);return a})(e,r)}function u(s,i,u,p,d="NDHWC",l=[1,1,1]){const c=(0,t.convertToTensor)(s,"x","conv3d"),h=(0,t.convertToTensor)(i,"filter","conv3d");let f=c,v=!1;4===c.rank&&(v=!0,f=(0,a.reshape)(c,[1,c.shape[0],c.shape[1],c.shape[2],c.shape[3]])),n.assert(5===f.rank,()=>`Error in conv3d: input must be rank 5, but got rank ${f.rank}.`),n.assert(5===h.rank,()=>"Error in conv3d: filter must be rank 5, but got rank "+`${h.rank}.`),n.assert(f.shape[4]===h.shape[3],()=>`Error in conv3d: depth of input (${f.shape[4]}) must match `+`input depth for filter ${h.shape[3]}.`),n.assert((0,o.eitherStridesOrDilationsAreOne)(u,l),()=>"Error in conv3D: Either strides or dilations must be 1. "+`Got strides ${u} and dilations '${l}'`),n.assert("NDHWC"===d,()=>`Error in conv3d: got dataFormat of ${d} but only NDHWC is currently supported.`),n.assert((0,o.stridesOrDilationsArePositive)(l),()=>"Error in conv3D: Dilated rates should be larger than 0."),n.assert((0,o.stridesOrDilationsArePositive)(u),()=>"Error in conv3D: Strides should be larger than 0.");const k={x:f,filter:h},_={strides:u,pad:p,dataFormat:d,dilations:l},b=e.ENGINE.runKernel(r.Conv3D,k,_);return v?(0,a.reshape)(b,[b.shape[1],b.shape[2],b.shape[3],b.shape[4]]):b}const p=exports.conv3d=(0,s.op)({conv3d_:u});
},{"../engine":"phT7","../kernel_names":"rJl6","../tensor_util_env":"y4X4","../util":"XXxQ","./conv_util":"PhWH","./operation":"uE86","./reshape":"F0cm"}],"uMVO":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.conv3DBackpropInput=void 0;var e=require("../engine"),r=require("../kernel_names"),t=p(require("../util")),n=require("./operation"),a=require("./reshape");function p(e,r){if("function"==typeof WeakMap)var t=new WeakMap,n=new WeakMap;return(p=function(e,r){if(!r&&e&&e.__esModule)return e;var a,p,o={__proto__:null,default:e};if(null===e||"object"!=typeof e&&"function"!=typeof e)return o;if(a=r?n:t){if(a.has(e))return a.get(e);a.set(e,o)}for(const t in e)"default"!==t&&{}.hasOwnProperty.call(e,t)&&((p=(a=Object.defineProperty)&&Object.getOwnPropertyDescriptor(e,t))&&(p.get||p.set)?a(o,t,p):o[t]=e[t]);return o})(e,r)}function o(n,p,o,s,u){t.assert(n.length===p.rank,()=>"Length of inShape "+`(${n.length}) and rank of dy (${p.rank}) must match`);let i=n,h=p,c=!1;4===p.rank&&(c=!0,h=(0,a.reshape)(p,[1,p.shape[0],p.shape[1],p.shape[2],p.shape[3]]),i=[1,n[0],n[1],n[2],n[3]]);const f=i[4],l=h.shape[4];t.assert(5===i.length,()=>"Error in conv3dDerInput: inShape must be length 5, but got length "+`${i.length}.`),t.assert(5===h.rank,()=>"Error in conv3dDerInput: dy must be rank 5, but got "+`rank ${h.rank}`),t.assert(5===o.rank,()=>"Error in conv3dDerInput: filter must be rank 5, but got "+`rank ${o.rank}`),t.assert(f===o.shape[3],()=>`Error in conv3dDerInput: depth of input (${f}) must `+`match input depth for filter ${o.shape[3]}.`),t.assert(l===o.shape[4],()=>`Error in conv3dDerInput: depth of output (${l}) must `+`match output depth for filter ${o.shape[4]}.`);const d={dy:h,filter:o},k={pad:u,strides:s,inputShape:i},g=e.ENGINE.runKernel(r.Conv3DBackpropInputV2,d,k);return c?(0,a.reshape)(g,[g.shape[1],g.shape[2],g.shape[3],g.shape[4]]):g}const s=exports.conv3DBackpropInput=(0,n.op)({conv3DBackpropInput_:o});
},{"../engine":"phT7","../kernel_names":"rJl6","../util":"XXxQ","./operation":"uE86","./reshape":"F0cm"}],"ndAv":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.conv3dTranspose=void 0;var o=require("../tensor_util_env"),e=require("./conv3d_backprop_input"),r=require("./operation");function n(r,n,s,t,p){const c=(0,o.convertToTensor)(r,"x","conv3dTranspose"),v=(0,o.convertToTensor)(n,"filter","conv3dTranspose");return(0,e.conv3DBackpropInput)(s,c,v,t,p)}const s=exports.conv3dTranspose=(0,r.op)({conv3dTranspose_:n});
},{"../tensor_util_env":"y4X4","./conv3d_backprop_input":"uMVO","./operation":"uE86"}],"gHiU":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.cos=void 0;var e=require("../engine"),r=require("../kernel_names"),o=require("../tensor_util_env"),n=require("./operation");function s(n){const s={x:(0,o.convertToTensor)(n,"x","cos","float32")};return e.ENGINE.runKernel(r.Cos,s)}const t=exports.cos=(0,n.op)({cos_:s});
},{"../engine":"phT7","../kernel_names":"rJl6","../tensor_util_env":"y4X4","./operation":"uE86"}],"dWiz":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.cosh=void 0;var e=require("../engine"),r=require("../kernel_names"),o=require("../tensor_util_env"),n=require("./operation");function s(n){const s={x:(0,o.convertToTensor)(n,"x","cosh","float32")};return e.ENGINE.runKernel(r.Cosh,s)}const t=exports.cosh=(0,n.op)({cosh_:s});
},{"../engine":"phT7","../kernel_names":"rJl6","../tensor_util_env":"y4X4","./operation":"uE86"}],"CZnL":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.cumprod=void 0;var e=require("../engine"),r=require("../kernel_names"),o=require("../tensor_util_env"),n=require("./operation");function u(n,u=0,t=!1,s=!1){const i={x:(0,o.convertToTensor)(n,"x","cumprod")},c={axis:u,exclusive:t,reverse:s};return e.ENGINE.runKernel(r.Cumprod,i,c)}const t=exports.cumprod=(0,n.op)({cumprod_:u});
},{"../engine":"phT7","../kernel_names":"rJl6","../tensor_util_env":"y4X4","./operation":"uE86"}],"s2nI":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.cumsum=void 0;var e=require("../engine"),r=require("../kernel_names"),u=require("../tensor_util_env"),s=require("./operation");function n(s,n=0,o=!1,t=!1){const i={x:(0,u.convertToTensor)(s,"x","cumsum")},c={axis:n,exclusive:o,reverse:t};return e.ENGINE.runKernel(r.Cumsum,i,c)}const o=exports.cumsum=(0,s.op)({cumsum_:n});
},{"../engine":"phT7","../kernel_names":"rJl6","../tensor_util_env":"y4X4","./operation":"uE86"}],"IzLf":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.denseBincount=void 0;var e=require("../engine"),t=require("../kernel_names"),n=require("../tensor_util_env"),r=o(require("../util")),s=require("./operation");function o(e,t){if("function"==typeof WeakMap)var n=new WeakMap,r=new WeakMap;return(o=function(e,t){if(!t&&e&&e.__esModule)return e;var s,o,i={__proto__:null,default:e};if(null===e||"object"!=typeof e&&"function"!=typeof e)return i;if(s=t?r:n){if(s.has(e))return s.get(e);s.set(e,i)}for(const n in e)"default"!==n&&{}.hasOwnProperty.call(e,n)&&((o=(s=Object.defineProperty)&&Object.getOwnPropertyDescriptor(e,n))&&(o.get||o.set)?s(i,n,o):i[n]=e[n]);return i})(e,t)}function i(s,o,i,u=!1){const a=(0,n.convertToTensor)(s,"x","denseBincount"),p=(0,n.convertToTensor)(o,"weights","denseBincount");r.assert("int32"===a.dtype,()=>"Error in denseBincount: input "+`dtype must be int32, but got ${a.dtype}`),r.assert(a.rank<=2,()=>"Error in denseBincount: input must be at most rank 2, but got "+`rank ${a.rank}.`),r.assert(i>=0,()=>`size must be non-negative, but got ${i}.`),r.assert(p.size===a.size||0===p.size,()=>"Error in denseBincount: weights must have the same shape as x or "+`0-length, but got x shape: ${a.shape}, weights shape: `+`${p.shape}.`);const c={x:a,weights:p},d={size:i,binaryOutput:u};return e.ENGINE.runKernel(t.DenseBincount,c,d)}const u=exports.denseBincount=(0,s.op)({denseBincount_:i});
},{"../engine":"phT7","../kernel_names":"rJl6","../tensor_util_env":"y4X4","../util":"XXxQ","./operation":"uE86"}],"o3IO":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.depthToSpace=void 0;var e=require("../engine"),t=require("../kernel_names"),n=require("../tensor_util_env"),o=a(require("../util")),r=require("./operation");function a(e,t){if("function"==typeof WeakMap)var n=new WeakMap,o=new WeakMap;return(a=function(e,t){if(!t&&e&&e.__esModule)return e;var r,a,i={__proto__:null,default:e};if(null===e||"object"!=typeof e&&"function"!=typeof e)return i;if(r=t?o:n){if(r.has(e))return r.get(e);r.set(e,i)}for(const n in e)"default"!==n&&{}.hasOwnProperty.call(e,n)&&((a=(r=Object.defineProperty)&&Object.getOwnPropertyDescriptor(e,n))&&(a.get||a.set)?r(i,n,a):i[n]=e[n]);return i})(e,t)}function i(r,a,i="NHWC"){const p=(0,n.convertToTensor)(r,"x","depthToSpace","float32"),s="NHWC"===i?p.shape[1]:p.shape[2],u="NHWC"===i?p.shape[2]:p.shape[3],c="NHWC"===i?p.shape[3]:p.shape[1];o.assert(a>1,()=>`blockSize should be > 1 for depthToSpace, but was: ${a}`),o.assert(s*a>=0,()=>`Negative dimension size caused by overflow when multiplying\n    ${s} and ${a}  for depthToSpace with input shape\n    ${p.shape}`),o.assert(u*a>=0,()=>`Negative dimension size caused by overflow when multiplying\n    ${u} and ${a} for depthToSpace with input shape\n        ${p.shape}`),o.assert(c%(a*a)==0,()=>`Dimension size must be evenly divisible by ${a*a} but is ${c} for depthToSpace with input shape ${p.shape}`);const h={x:p},l={blockSize:a,dataFormat:i};return e.ENGINE.runKernel(t.DepthToSpace,h,l)}const p=exports.depthToSpace=(0,r.op)({depthToSpace_:i});
},{"../engine":"phT7","../kernel_names":"rJl6","../tensor_util_env":"y4X4","../util":"XXxQ","./operation":"uE86"}],"HEHz":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.depthwiseConv2d=void 0;var e=require("../engine"),r=require("../kernel_names"),t=require("../tensor_util_env"),n=a(require("../util")),o=a(require("./conv_util")),i=require("./operation"),s=require("./reshape");function a(e,r){if("function"==typeof WeakMap)var t=new WeakMap,n=new WeakMap;return(a=function(e,r){if(!r&&e&&e.__esModule)return e;var o,i,s={__proto__:null,default:e};if(null===e||"object"!=typeof e&&"function"!=typeof e)return s;if(o=r?n:t){if(o.has(e))return o.get(e);o.set(e,s)}for(const t in e)"default"!==t&&{}.hasOwnProperty.call(e,t)&&((i=(o=Object.defineProperty)&&Object.getOwnPropertyDescriptor(e,t))&&(i.get||i.set)?o(s,t,i):s[t]=e[t]);return s})(e,r)}function p(i,a,p,u,d="NHWC",h=[1,1],l){const f=(0,t.convertToTensor)(i,"x","depthwiseConv2d","float32"),c=(0,t.convertToTensor)(a,"filter","depthwiseConv2d","float32");let v=f,k=!1;3===f.rank&&(k=!0,v=(0,s.reshape)(f,[1,f.shape[0],f.shape[1],f.shape[2]])),n.assert(4===v.rank,()=>"Error in depthwiseConv2d: input must be rank 4, but got "+`rank ${v.rank}.`),n.assert(4===c.rank,()=>"Error in depthwiseConv2d: filter must be rank 4, but got rank "+`${c.rank}.`);const w="NHWC"===d?v.shape[3]:v.shape[1];n.assert(w===c.shape[2],()=>"Error in depthwiseConv2d: number of input channels "+`(${w}) must match the inChannels dimension in `+`filter ${c.shape[2]}.`),o.checkPadOnDimRoundingMode("depthwiseConv2d",u,l);const C={x:v,filter:c},_={strides:p,pad:u,dataFormat:d,dilations:h,dimRoundingMode:l},m=e.ENGINE.runKernel(r.DepthwiseConv2dNative,C,_);return k?(0,s.reshape)(m,[m.shape[1],m.shape[2],m.shape[3]]):m}const u=exports.depthwiseConv2d=(0,i.op)({depthwiseConv2d_:p});
},{"../engine":"phT7","../kernel_names":"rJl6","../tensor_util_env":"y4X4","../util":"XXxQ","./conv_util":"PhWH","./operation":"uE86","./reshape":"F0cm"}],"Qz11":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.diag=void 0;var e=require("../engine"),r=require("../kernel_names"),n=require("../tensor_util_env"),i=require("./operation");function o(i){const o={x:(0,n.convertToTensor)(i,"x","diag")};return e.ENGINE.runKernel(r.Diag,o)}const t=exports.diag=(0,i.op)({diag_:o});
},{"../engine":"phT7","../kernel_names":"rJl6","../tensor_util_env":"y4X4","./operation":"uE86"}],"XEeh":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.dilation2d=void 0;var e=require("../engine"),r=require("../kernel_names"),t=require("../tensor_util_env"),n=o(require("../util")),a=require("./operation"),i=require("./reshape");function o(e,r){if("function"==typeof WeakMap)var t=new WeakMap,n=new WeakMap;return(o=function(e,r){if(!r&&e&&e.__esModule)return e;var a,i,o={__proto__:null,default:e};if(null===e||"object"!=typeof e&&"function"!=typeof e)return o;if(a=r?n:t){if(a.has(e))return a.get(e);a.set(e,o)}for(const t in e)"default"!==t&&{}.hasOwnProperty.call(e,t)&&((i=(a=Object.defineProperty)&&Object.getOwnPropertyDescriptor(e,t))&&(i.get||i.set)?a(o,t,i):o[t]=e[t]);return o})(e,r)}function s(a,o,s,u,p=[1,1],l="NHWC"){const d=(0,t.convertToTensor)(a,"x","dilation2d"),f=(0,t.convertToTensor)(o,"filter","dilation2d");n.assert(3===d.rank||4===d.rank,()=>"Error in dilation2d: input must be rank 3 or 4, but got rank "+`${d.rank}.`),n.assert(3===f.rank,()=>"Error in dilation2d: filter must be rank 3, but got rank "+`${f.rank}.`),n.assert("NHWC"===l,()=>"Error in dilation2d: Only NHWC is currently supported, "+`but got dataFormat of ${l}`);let c=d,h=!1;3===d.rank&&(c=(0,i.reshape)(d,[1,d.shape[0],d.shape[1],d.shape[2]]),h=!0),n.assert(c.shape[3]===f.shape[2],()=>`Error in dilation2d:  input and filter must have the same depth: ${c.shape[3]} vs ${f.shape[2]}`);const k={x:c,filter:f},_={strides:s,pad:u,dilations:p},v=e.ENGINE.runKernel(r.Dilation2D,k,_);return h?(0,i.reshape)(v,[v.shape[1],v.shape[2],v.shape[3]]):v}const u=exports.dilation2d=(0,a.op)({dilation2d_:s});
},{"../engine":"phT7","../kernel_names":"rJl6","../tensor_util_env":"y4X4","../util":"XXxQ","./operation":"uE86","./reshape":"F0cm"}],"fD2T":[function(require,module,exports) {
"use strict";function t(t,e){const n=t.length,r=[];for(let o=0;o<n;o++){const s=n-1-o,l=t[s]||1;(e[e.length-1-o]||1)>1&&1===l&&r.unshift(s)}return r}function e(t,e){const n=[];for(let r=0;r<e.length;r++){const o=t[t.length-r-1],s=e.length-r-1,l=e[s];(null==o||1===o&&l>1)&&n.unshift(s)}return n}function n(t,e){const n=Math.max(t.length,e.length),r=new Array(n);for(let o=0;o<n;o++){let s=t[t.length-o-1];null==s&&(s=1);let l=e[e.length-o-1];if(null==l&&(l=1),1===s)r[n-o-1]=l;else if(1===l)r[n-o-1]=s;else{if(s!==l){throw Error("Operands could not be broadcast together with shapes "+`${t} and ${e}.`)}r[n-o-1]=s}}return r}Object.defineProperty(exports,"__esModule",{value:!0}),exports.assertAndGetBroadcastShape=n,exports.getBroadcastDims=t,exports.getReductionAxes=e;
},{}],"haNF":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.equal=void 0;var e=require("../engine"),r=require("../kernel_names"),t=require("../tensor_util"),n=require("../tensor_util_env"),o=require("./broadcast_util"),u=require("./operation");function a(u,a){let s=(0,n.convertToTensor)(u,"a","equal","string_or_numeric"),i=(0,n.convertToTensor)(a,"b","equal","string_or_numeric");[s,i]=(0,t.makeTypesMatch)(s,i),(0,o.assertAndGetBroadcastShape)(s.shape,i.shape);const l={a:s,b:i};return e.ENGINE.runKernel(r.Equal,l)}const s=exports.equal=(0,u.op)({equal_:a});
},{"../engine":"phT7","../kernel_names":"rJl6","../tensor_util":"wtFc","../tensor_util_env":"y4X4","./broadcast_util":"fD2T","./operation":"uE86"}],"TsgC":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.where=void 0;var e=require("../engine"),r=require("../kernel_names"),o=require("../tensor_util_env"),t=require("./broadcast_to"),n=require("./broadcast_util"),s=require("./operation");function a(s,a,c){const i=(0,o.convertToTensor)(a,"a","where"),d=(0,o.convertToTensor)(c,"b","where"),u=(0,o.convertToTensor)(s,"condition","where","bool"),h=(0,n.assertAndGetBroadcastShape)((0,n.assertAndGetBroadcastShape)(u.shape,i.shape),d.shape),p={condition:(0,t.broadcastTo)(u,h),t:(0,t.broadcastTo)(i,h),e:(0,t.broadcastTo)(d,h)};return e.ENGINE.runKernel(r.Select,p)}const c=exports.where=(0,s.op)({where_:a});
},{"../engine":"phT7","../kernel_names":"rJl6","../tensor_util_env":"y4X4","./broadcast_to":"ZDfb","./broadcast_util":"fD2T","./operation":"uE86"}],"qY0o":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.zerosLike=void 0;var e=require("../engine"),r=require("../kernel_names"),o=require("../tensor_util_env"),n=require("./operation");function i(n){const i={x:(0,o.convertToTensor)(n,"x","zerosLike")};return e.ENGINE.runKernel(r.ZerosLike,i)}const s=exports.zerosLike=(0,n.op)({zerosLike_:i});
},{"../engine":"phT7","../kernel_names":"rJl6","../tensor_util_env":"y4X4","./operation":"uE86"}],"VrTr":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.divNoNan=void 0;var e=require("../tensor_util"),r=require("../tensor_util_env"),o=require("./div"),i=require("./equal"),t=require("./operation"),n=require("./where"),u=require("./zeros_like");function s(t,s){let v=(0,r.convertToTensor)(t,"a","div"),a=(0,r.convertToTensor)(s,"b","div");[v,a]=(0,e.makeTypesMatch)(v,a);const d=(0,o.div)(v,a),q=(0,u.zerosLike)(d),c=(0,i.equal)(a,q);return(0,n.where)(c,q,d)}const v=exports.divNoNan=(0,t.op)({divNoNan_:s});
},{"../tensor_util":"wtFc","../tensor_util_env":"y4X4","./div":"S2L5","./equal":"haNF","./operation":"uE86","./where":"TsgC","./zeros_like":"qY0o"}],"M98r":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.dot=void 0;var e=require("../tensor_util_env"),r=o(require("../util")),t=require("./mat_mul"),n=require("./operation"),a=require("./reshape");function o(e,r){if("function"==typeof WeakMap)var t=new WeakMap,n=new WeakMap;return(o=function(e,r){if(!r&&e&&e.__esModule)return e;var a,o,s={__proto__:null,default:e};if(null===e||"object"!=typeof e&&"function"!=typeof e)return s;if(a=r?n:t){if(a.has(e))return a.get(e);a.set(e,s)}for(const t in e)"default"!==t&&{}.hasOwnProperty.call(e,t)&&((o=(a=Object.defineProperty)&&Object.getOwnPropertyDescriptor(e,t))&&(o.get||o.set)?a(s,t,o):s[t]=e[t]);return s})(e,r)}function s(n,o){const s=(0,e.convertToTensor)(n,"t1","dot"),u=(0,e.convertToTensor)(o,"t2","dot");r.assert(!(1!==s.rank&&2!==s.rank||1!==u.rank&&2!==u.rank),()=>"Error in dot: inputs must all be rank 1 or 2, but got ranks "+`${s.rank} and ${u.rank}.`);const i=1===s.rank?s.size:s.shape[1],p=1===u.rank?u.size:u.shape[0];if(r.assert(i===p,()=>"Error in dot: inner dimensions of inputs must match, but got "+`${i} and ${p}.`),1===s.rank&&1===u.rank){const e=(0,a.reshape)(s,[1,-1]),r=(0,a.reshape)(u,[-1,1]),n=(0,t.matMul)(e,r);return(0,a.reshape)(n,[])}if(1===s.rank&&2===u.rank){const e=(0,a.reshape)(s,[1,-1]),r=(0,a.reshape)(u,[u.shape[0],u.shape[1]]),n=(0,t.matMul)(e,r);return(0,a.reshape)(n,[n.size])}if(2===s.rank&&1===u.rank){const e=(0,a.reshape)(u,[-1,1]),r=(0,t.matMul)(s,e);return(0,a.reshape)(r,[r.size])}{const e=(0,a.reshape)(u,[u.shape[0],u.shape[1]]);return(0,t.matMul)(s,e)}}const u=exports.dot=(0,n.op)({dot_:s});
},{"../tensor_util_env":"y4X4","../util":"XXxQ","./mat_mul":"zVDr","./operation":"uE86","./reshape":"F0cm"}],"aqvb":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.einsum=void 0,exports.einsum_=o;var e=require("../engine"),r=require("../kernel_names"),n=require("../tensor_util_env"),s=require("./operation");function o(s,...o){const i=o.map((e,r)=>(0,n.convertToTensor)(e,`tensors${r}`,"einsum")),t={equation:s};return e.ENGINE.runKernel(r.Einsum,i,t)}const i=exports.einsum=(0,s.op)({einsum_:o});
},{"../engine":"phT7","../kernel_names":"rJl6","../tensor_util_env":"y4X4","./operation":"uE86"}],"qSof":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.elu=void 0;var e=require("../engine"),r=require("../kernel_names"),n=require("../tensor_util_env"),o=require("./operation");function t(o){const t={x:(0,n.convertToTensor)(o,"x","elu","float32")};return e.ENGINE.runKernel(r.Elu,t)}const u=exports.elu=(0,o.op)({elu_:t});
},{"../engine":"phT7","../kernel_names":"rJl6","../tensor_util_env":"y4X4","./operation":"uE86"}],"QNP3":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.ensureShape=void 0;var e=require("../tensor_util_env"),r=require("../util_base"),t=require("./operation");function o(t,o){const s=(0,e.convertToTensor)(t,"x","ensureShape","string_or_numeric");if(!(0,r.arraysEqualWithNull)(s.shape,o))throw new Error(`EnsureShape: Shape of tensor ${s.shape} is not compatible with expected shape ${o}`);return t}const s=exports.ensureShape=(0,t.op)({ensureShape_:o});
},{"../tensor_util_env":"y4X4","../util_base":"uID4","./operation":"uE86"}],"Ng3O":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.erf=void 0;var e=require("../engine"),t=require("../kernel_names"),r=require("../tensor_util_env"),n=i(require("../util")),o=require("./cast"),u=require("./operation");function i(e,t){if("function"==typeof WeakMap)var r=new WeakMap,n=new WeakMap;return(i=function(e,t){if(!t&&e&&e.__esModule)return e;var o,u,i={__proto__:null,default:e};if(null===e||"object"!=typeof e&&"function"!=typeof e)return i;if(o=t?n:r){if(o.has(e))return o.get(e);o.set(e,i)}for(const r in e)"default"!==r&&{}.hasOwnProperty.call(e,r)&&((u=(o=Object.defineProperty)&&Object.getOwnPropertyDescriptor(e,r))&&(u.get||u.set)?o(i,r,u):i[r]=e[r]);return i})(e,t)}function f(u){let i=(0,r.convertToTensor)(u,"x","erf");n.assert("int32"===i.dtype||"float32"===i.dtype,()=>"Input dtype must be `int32` or `float32`."),"int32"===i.dtype&&(i=(0,o.cast)(i,"float32"));const f={x:i};return e.ENGINE.runKernel(t.Erf,f)}const a=exports.erf=(0,u.op)({erf_:f});
},{"../engine":"phT7","../kernel_names":"rJl6","../tensor_util_env":"y4X4","../util":"XXxQ","./cast":"qnzc","./operation":"uE86"}],"mPwf":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.assertAxesAreInnerMostDims=u,exports.axesAreInnerMostDims=n,exports.combineLocations=r,exports.computeOutAndReduceShapes=o,exports.expandShapeToKeepDim=s,exports.getAxesPermutation=p,exports.getInnerMostAxes=f,exports.getUndoAxesPermutation=i;var e=t(require("../util"));function t(e,n){if("function"==typeof WeakMap)var r=new WeakMap,o=new WeakMap;return(t=function(e,t){if(!t&&e&&e.__esModule)return e;var n,s,u={__proto__:null,default:e};if(null===e||"object"!=typeof e&&"function"!=typeof e)return u;if(n=t?o:r){if(n.has(e))return n.get(e);n.set(e,u)}for(const r in e)"default"!==r&&{}.hasOwnProperty.call(e,r)&&((s=(n=Object.defineProperty)&&Object.getOwnPropertyDescriptor(e,r))&&(s.get||s.set)?n(u,r,s):u[r]=e[r]);return u})(e,n)}function n(e,t){for(let n=0;n<e.length;++n)if(e[e.length-n-1]!==t-1-n)return!1;return!0}function r(e,t,n){const r=e.length+t.length,o=[];let s=0,u=0;for(let p=0;p<r;p++)-1===n.indexOf(p)?o.push(e[s++]):o.push(t[u++]);return o}function o(e,t){const n=[],r=e.length;for(let o=0;o<r;o++)-1===t.indexOf(o)&&n.push(e[o]);return[n,t.map(t=>e[t])]}function s(e,t){return r(e,t.map(e=>1),t)}function u(t,r,o){e.assert(n(r,o),()=>`${t} supports only inner-most axes for now. `+`Got axes ${r} and rank-${o} input.`)}function p(e,t){if(n(e,t))return null;const r=[];for(let n=0;n<t;++n)-1===e.indexOf(n)&&r.push(n);return e.forEach(e=>r.push(e)),r}function i(e){return e.map((e,t)=>[t,e]).sort((e,t)=>e[1]-t[1]).map(e=>e[0])}function f(e,t){const n=[];for(let r=t-e;r<t;++r)n.push(r);return n}
},{"../util":"XXxQ"}],"KIVY":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.max=void 0;var e=require("../engine"),r=require("../kernel_names"),n=require("../tensor_util_env"),o=require("./operation");function t(o,t=null,i=!1){const s={x:(0,n.convertToTensor)(o,"x","max")},u={reductionIndices:t,keepDims:i};return e.ENGINE.runKernel(r.Max,s,u)}const i=exports.max=(0,o.op)({max_:t});
},{"../engine":"phT7","../kernel_names":"rJl6","../tensor_util_env":"y4X4","./operation":"uE86"}],"pkmC":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.min=void 0;var e=require("../engine"),r=require("../kernel_names"),n=require("../tensor_util_env"),i=require("./operation");function o(i,o=null,t=!1){const s={x:(0,n.convertToTensor)(i,"x","min")},u={axis:o,keepDims:t};return e.ENGINE.runKernel(r.Min,s,u)}const t=exports.min=(0,i.op)({min_:o});
},{"../engine":"phT7","../kernel_names":"rJl6","../tensor_util_env":"y4X4","./operation":"uE86"}],"o2Kl":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.pow=void 0;var e=require("../engine"),r=require("../kernel_names"),o=require("../tensor_util"),n=require("../tensor_util_env"),t=require("./operation");function s(t,s){let i=(0,n.convertToTensor)(t,"base","pow"),p=(0,n.convertToTensor)(s,"exp","pow");[i,p]=(0,o.makeTypesMatch)(i,p);const u={a:i,b:p};return e.ENGINE.runKernel(r.Pow,u)}const i=exports.pow=(0,t.op)({pow_:s});
},{"../engine":"phT7","../kernel_names":"rJl6","../tensor_util":"wtFc","../tensor_util_env":"y4X4","./operation":"uE86"}],"TiGU":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.scalar=t;var r=require("../util"),e=require("./tensor_ops_util");function t(t,a){if(((0,r.isTypedArray)(t)&&"string"!==a||Array.isArray(t))&&"complex64"!==a)throw new Error("Error creating a new Scalar: value must be a primitive (number|boolean|string)");if("string"===a&&(0,r.isTypedArray)(t)&&!(t instanceof Uint8Array))throw new Error("When making a scalar from encoded string, the value must be `Uint8Array`.");return(0,e.makeTensor)(t,[],[],a)}
},{"../util":"XXxQ","./tensor_ops_util":"HKvD"}],"brr7":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.sqrt=void 0;var e=require("../engine"),r=require("../kernel_names"),t=require("../tensor_util_env"),n=require("./operation");function o(n){const o={x:(0,t.convertToTensor)(n,"x","sqrt","float32")};return e.ENGINE.runKernel(r.Sqrt,o)}const s=exports.sqrt=(0,n.op)({sqrt_:o});
},{"../engine":"phT7","../kernel_names":"rJl6","../tensor_util_env":"y4X4","./operation":"uE86"}],"KiGo":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.square=void 0;var e=require("../engine"),r=require("../tensor_util_env"),o=require("./operation");function n(o){const n=(0,r.convertToTensor)(o,"x","square");return e.ENGINE.runKernel("Square",{x:n},{})}const t=exports.square=(0,o.op)({square_:n});
},{"../engine":"phT7","../tensor_util_env":"y4X4","./operation":"uE86"}],"kc8w":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.sum=void 0;var e=require("../engine"),r=require("../kernel_names"),t=require("../tensor_util_env"),n=require("./cast"),s=require("./operation");function o(s,o=null,u=!1){let i=(0,t.convertToTensor)(s,"x","sum");"bool"===i.dtype&&(i=(0,n.cast)(i,"int32"));const l={x:i},c={axis:o,keepDims:u};return e.ENGINE.runKernel(r.Sum,l,c)}const u=exports.sum=(0,s.op)({sum_:o});
},{"../engine":"phT7","../kernel_names":"rJl6","../tensor_util_env":"y4X4","./cast":"qnzc","./operation":"uE86"}],"exuO":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.norm=void 0;var r=require("../tensor_util_env"),e=require("../util"),n=require("./abs"),i=c(require("./axis_util")),t=require("./max"),u=require("./min"),a=require("./operation"),o=require("./pow"),s=require("./reshape"),f=require("./scalar"),l=require("./sqrt"),p=require("./square"),m=require("./sum");function c(r,e){if("function"==typeof WeakMap)var n=new WeakMap,i=new WeakMap;return(c=function(r,e){if(!e&&r&&r.__esModule)return r;var t,u,a={__proto__:null,default:r};if(null===r||"object"!=typeof r&&"function"!=typeof r)return a;if(t=e?i:n){if(t.has(r))return t.get(r);t.set(r,a)}for(const n in r)"default"!==n&&{}.hasOwnProperty.call(r,n)&&((u=(t=Object.defineProperty)&&Object.getOwnPropertyDescriptor(r,n))&&(u.get||u.set)?t(a,n,u):a[n]=r[n]);return a})(r,e)}function q(n,t="euclidean",u=null,a=!1){const o=d(n=(0,r.convertToTensor)(n,"x","norm"),t,u);let f=o.shape;if(a){const r=(0,e.parseAxisParam)(u,n.shape);f=i.expandShapeToKeepDim(o.shape,r)}return(0,s.reshape)(o,f)}function d(r,e,i=null){if(0===r.rank)return(0,n.abs)(r);if(1!==r.rank&&null===i)return d((0,s.reshape)(r,[-1]),e,i);if(1===r.rank||"number"==typeof i||Array.isArray(i)&&1===i.length){if(1===e)return(0,m.sum)((0,n.abs)(r),i);if(e===1/0)return(0,t.max)((0,n.abs)(r),i);if(e===-1/0)return(0,u.min)((0,n.abs)(r),i);if("euclidean"===e||2===e)return(0,l.sqrt)((0,m.sum)((0,o.pow)((0,n.abs)(r),(0,f.scalar)(2,"int32")),i));throw new Error(`Error in norm: invalid ord value: ${e}`)}if(Array.isArray(i)&&2===i.length){if(1===e)return(0,t.max)((0,m.sum)((0,n.abs)(r),i[0]),i[1]-1);if(e===1/0)return(0,t.max)((0,m.sum)((0,n.abs)(r),i[1]),i[0]);if(e===-1/0)return(0,u.min)((0,m.sum)((0,n.abs)(r),i[1]),i[0]);if("fro"===e||"euclidean"===e)return(0,l.sqrt)((0,m.sum)((0,p.square)(r),i));throw new Error(`Error in norm: invalid ord value: ${e}`)}throw new Error(`Error in norm: invalid axis: ${i}`)}const b=exports.norm=(0,a.op)({norm_:q});
},{"../tensor_util_env":"y4X4","../util":"XXxQ","./abs":"U9d5","./axis_util":"mPwf","./max":"KIVY","./min":"pkmC","./operation":"uE86","./pow":"o2Kl","./reshape":"F0cm","./scalar":"TiGU","./sqrt":"brr7","./square":"KiGo","./sum":"kc8w"}],"Qkob":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.euclideanNorm=void 0;var e=require("./norm"),r=require("./operation");function o(r,o=null,n=!1){return(0,e.norm)(r,"euclidean",o,n)}const n=exports.euclideanNorm=(0,r.op)({euclideanNorm_:o});
},{"./norm":"exuO","./operation":"uE86"}],"xcz4":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.exp=void 0;var e=require("../engine"),r=require("../kernel_names"),n=require("../tensor_util_env"),o=require("./operation");function t(o){const t={x:(0,n.convertToTensor)(o,"x","exp")};return e.ENGINE.runKernel(r.Exp,t)}const i=exports.exp=(0,o.op)({exp_:t});
},{"../engine":"phT7","../kernel_names":"rJl6","../tensor_util_env":"y4X4","./operation":"uE86"}],"WqhD":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.expandDims=void 0;var e=require("../engine"),r=require("../kernel_names"),n=require("../tensor_util_env"),t=i(require("../util")),o=require("./operation");function i(e,r){if("function"==typeof WeakMap)var n=new WeakMap,t=new WeakMap;return(i=function(e,r){if(!r&&e&&e.__esModule)return e;var o,i,s={__proto__:null,default:e};if(null===e||"object"!=typeof e&&"function"!=typeof e)return s;if(o=r?t:n){if(o.has(e))return o.get(e);o.set(e,s)}for(const n in e)"default"!==n&&{}.hasOwnProperty.call(e,n)&&((i=(o=Object.defineProperty)&&Object.getOwnPropertyDescriptor(e,n))&&(i.get||i.set)?o(s,n,i):s[n]=e[n]);return s})(e,r)}function s(o,i=0){const s=(0,n.convertToTensor)(o,"x","expandDims","string_or_numeric");t.assert(i<=s.rank,()=>"Axis must be <= rank of the tensor");const u={input:s},a={dim:i};return e.ENGINE.runKernel(r.ExpandDims,u,a)}const u=exports.expandDims=(0,o.op)({expandDims_:s});
},{"../engine":"phT7","../kernel_names":"rJl6","../tensor_util_env":"y4X4","../util":"XXxQ","./operation":"uE86"}],"NE5u":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.expm1=void 0;var e=require("../engine"),r=require("../kernel_names"),n=require("../tensor_util_env"),o=require("./operation");function t(o){const t={x:(0,n.convertToTensor)(o,"x","expm1")};return e.ENGINE.runKernel(r.Expm1,t)}const i=exports.expm1=(0,o.op)({expm1_:t});
},{"../engine":"phT7","../kernel_names":"rJl6","../tensor_util_env":"y4X4","./operation":"uE86"}],"DlNu":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.tile=void 0;var e=require("../engine"),r=require("../kernel_names"),t=require("../tensor_util_env"),n=i(require("../util")),o=require("./operation");function i(e,r){if("function"==typeof WeakMap)var t=new WeakMap,n=new WeakMap;return(i=function(e,r){if(!r&&e&&e.__esModule)return e;var o,i,u={__proto__:null,default:e};if(null===e||"object"!=typeof e&&"function"!=typeof e)return u;if(o=r?n:t){if(o.has(e))return o.get(e);o.set(e,u)}for(const t in e)"default"!==t&&{}.hasOwnProperty.call(e,t)&&((i=(o=Object.defineProperty)&&Object.getOwnPropertyDescriptor(e,t))&&(i.get||i.set)?o(u,t,i):u[t]=e[t]);return u})(e,r)}function u(o,i){const u=(0,t.convertToTensor)(o,"x","tile","string_or_numeric");n.assert(u.rank===i.length,()=>`Error in transpose: rank of input ${u.rank} `+`must match length of reps ${i}.`);const s={x:u},a={reps:i};return e.ENGINE.runKernel(r.Tile,s,a)}const s=exports.tile=(0,o.op)({tile_:u});
},{"../engine":"phT7","../kernel_names":"rJl6","../tensor_util_env":"y4X4","../util":"XXxQ","./operation":"uE86"}],"MP6S":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.eye=void 0;var e=require("./buffer"),r=require("./expand_dims"),t=require("./operation"),n=require("./reshape"),i=require("./tile");function s(t,s,o,u="float32"){null==s&&(s=t);const l=(0,e.buffer)([t,s],u),p=t<=s?t:s;for(let e=0;e<p;++e)l.set(1,e,e);const a=(0,n.reshape)(l.toTensor(),[t,s]);if(null==o)return a;if(1===o.length)return(0,i.tile)((0,r.expandDims)(a,0),[o[0],1,1]);if(2===o.length)return(0,i.tile)((0,r.expandDims)((0,r.expandDims)(a,0),0),[o[0],o[1],1,1]);if(3===o.length)return(0,i.tile)((0,r.expandDims)((0,r.expandDims)((0,r.expandDims)(a,0),0),0),[o[0],o[1],o[2],1,1]);throw new Error("eye() currently supports only 1D and 2D "+`batchShapes, but received ${o.length}D.`)}const o=exports.eye=(0,t.op)({eye_:s});
},{"./buffer":"GfO2","./expand_dims":"WqhD","./operation":"uE86","./reshape":"F0cm","./tile":"DlNu"}],"EeTS":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.floor=void 0;var e=require("../engine"),r=require("../kernel_names"),o=require("../tensor_util_env"),n=require("./operation");function t(n){const t={x:(0,o.convertToTensor)(n,"x","floor","float32")};return e.ENGINE.runKernel(r.Floor,t)}const i=exports.floor=(0,n.op)({floor_:t});
},{"../engine":"phT7","../kernel_names":"rJl6","../tensor_util_env":"y4X4","./operation":"uE86"}],"TfxI":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.gather=void 0;var e=require("../engine"),r=require("../kernel_names"),t=require("../tensor_util_env"),n=require("./operation");function o(n,o,i=0,s=0){const a={x:(0,t.convertToTensor)(n,"x","gather"),indices:(0,t.convertToTensor)(o,"indices","gather","int32")},u={axis:i,batchDims:s};return e.ENGINE.runKernel(r.GatherV2,a,u)}const i=exports.gather=(0,n.op)({gather_:o});
},{"../engine":"phT7","../kernel_names":"rJl6","../tensor_util_env":"y4X4","./operation":"uE86"}],"WT29":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.greater=void 0;var e=require("../engine"),r=require("../kernel_names"),t=require("../tensor_util"),n=require("../tensor_util_env"),o=require("./broadcast_util"),a=require("./operation");function s(a,s){let i=(0,n.convertToTensor)(a,"a","greater","string_or_numeric"),u=(0,n.convertToTensor)(s,"b","greater","string_or_numeric");[i,u]=(0,t.makeTypesMatch)(i,u),(0,o.assertAndGetBroadcastShape)(i.shape,u.shape);const c={a:i,b:u};return e.ENGINE.runKernel(r.Greater,c)}const i=exports.greater=(0,a.op)({greater_:s});
},{"../engine":"phT7","../kernel_names":"rJl6","../tensor_util":"wtFc","../tensor_util_env":"y4X4","./broadcast_util":"fD2T","./operation":"uE86"}],"a6nY":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.greaterEqual=void 0;var e=require("../engine"),r=require("../kernel_names"),t=require("../tensor_util"),a=require("../tensor_util_env"),n=require("./broadcast_util"),o=require("./operation");function u(o,u){let s=(0,a.convertToTensor)(o,"a","greaterEqual","string_or_numeric"),i=(0,a.convertToTensor)(u,"b","greaterEqual","string_or_numeric");[s,i]=(0,t.makeTypesMatch)(s,i),(0,n.assertAndGetBroadcastShape)(s.shape,i.shape);const l={a:s,b:i};return e.ENGINE.runKernel(r.GreaterEqual,l)}const s=exports.greaterEqual=(0,o.op)({greaterEqual_:u});
},{"../engine":"phT7","../kernel_names":"rJl6","../tensor_util":"wtFc","../tensor_util_env":"y4X4","./broadcast_util":"fD2T","./operation":"uE86"}],"eG10":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.imag=void 0;var e=require("../engine"),r=require("../kernel_names"),n=require("../tensor_util_env"),i=require("./operation");function t(i){const t={input:(0,n.convertToTensor)(i,"input","imag")};return e.ENGINE.runKernel(r.Imag,t)}const o=exports.imag=(0,i.op)({imag_:t});
},{"../engine":"phT7","../kernel_names":"rJl6","../tensor_util_env":"y4X4","./operation":"uE86"}],"uXDy":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.isFinite=void 0;var e=require("../engine"),i=require("../kernel_names"),r=require("../tensor_util_env"),n=require("./operation");function t(n){const t={x:(0,r.convertToTensor)(n,"x","isFinite")};return e.ENGINE.runKernel(i.IsFinite,t)}const o=exports.isFinite=(0,n.op)({isFinite_:t});
},{"../engine":"phT7","../kernel_names":"rJl6","../tensor_util_env":"y4X4","./operation":"uE86"}],"d2YA":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.isInf=void 0;var e=require("../engine"),r=require("../kernel_names"),n=require("../tensor_util_env"),o=require("./operation");function s(o){const s={x:(0,n.convertToTensor)(o,"x","isInf")};return e.ENGINE.runKernel(r.IsInf,s)}const i=exports.isInf=(0,o.op)({isInf_:s});
},{"../engine":"phT7","../kernel_names":"rJl6","../tensor_util_env":"y4X4","./operation":"uE86"}],"cHRr":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.isNaN=void 0;var e=require("../engine"),r=require("../kernel_names"),n=require("../tensor_util_env"),o=require("./operation");function s(o){const s={x:(0,n.convertToTensor)(o,"x","isNaN")};return e.ENGINE.runKernel(r.IsNan,s)}const i=exports.isNaN=(0,o.op)({isNaN_:s});
},{"../engine":"phT7","../kernel_names":"rJl6","../tensor_util_env":"y4X4","./operation":"uE86"}],"RYa8":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.leakyRelu=void 0;var e=require("../engine"),r=require("../kernel_names"),n=require("../tensor_util_env"),o=require("./operation");function u(o,u=.2){const l={x:(0,n.convertToTensor)(o,"x","leakyRelu")},t={alpha:u};return e.ENGINE.runKernel(r.LeakyRelu,l,t)}const l=exports.leakyRelu=(0,o.op)({leakyRelu_:u});
},{"../engine":"phT7","../kernel_names":"rJl6","../tensor_util_env":"y4X4","./operation":"uE86"}],"onA7":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.less=void 0;var e=require("../engine"),r=require("../kernel_names"),s=require("../tensor_util"),t=require("../tensor_util_env"),n=require("./broadcast_util"),o=require("./operation");function i(o,i){let u=(0,t.convertToTensor)(o,"a","less","string_or_numeric"),a=(0,t.convertToTensor)(i,"b","less","string_or_numeric");[u,a]=(0,s.makeTypesMatch)(u,a),(0,n.assertAndGetBroadcastShape)(u.shape,a.shape);const l={a:u,b:a};return e.ENGINE.runKernel(r.Less,l)}const u=exports.less=(0,o.op)({less_:i});
},{"../engine":"phT7","../kernel_names":"rJl6","../tensor_util":"wtFc","../tensor_util_env":"y4X4","./broadcast_util":"fD2T","./operation":"uE86"}],"vnhI":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.lessEqual=void 0;var e=require("../engine"),r=require("../kernel_names"),s=require("../tensor_util"),t=require("../tensor_util_env"),n=require("./broadcast_util"),o=require("./operation");function u(o,u){let a=(0,t.convertToTensor)(o,"a","lessEqual","string_or_numeric"),i=(0,t.convertToTensor)(u,"b","lessEqual","string_or_numeric");[a,i]=(0,s.makeTypesMatch)(a,i),(0,n.assertAndGetBroadcastShape)(a.shape,i.shape);const l={a:a,b:i};return e.ENGINE.runKernel(r.LessEqual,l)}const a=exports.lessEqual=(0,o.op)({lessEqual_:u});
},{"../engine":"phT7","../kernel_names":"rJl6","../tensor_util":"wtFc","../tensor_util_env":"y4X4","./broadcast_util":"fD2T","./operation":"uE86"}],"Eb8v":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.linspace=n;var e=require("../engine"),r=require("../kernel_names");function n(n,t,s){if(s<=0)throw new Error("The number of values should be positive.");const o={start:n,stop:t,num:s};return e.ENGINE.runKernel(r.LinSpace,{},o)}
},{"../engine":"phT7","../kernel_names":"rJl6"}],"uT9U":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.localResponseNormalization=void 0;var e=require("../engine"),r=require("../kernel_names"),t=require("../tensor_util_env"),n=s(require("../util")),o=require("./operation"),a=require("./reshape");function s(e,r){if("function"==typeof WeakMap)var t=new WeakMap,n=new WeakMap;return(s=function(e,r){if(!r&&e&&e.__esModule)return e;var o,a,s={__proto__:null,default:e};if(null===e||"object"!=typeof e&&"function"!=typeof e)return s;if(o=r?n:t){if(o.has(e))return o.get(e);o.set(e,s)}for(const t in e)"default"!==t&&{}.hasOwnProperty.call(e,t)&&((a=(o=Object.defineProperty)&&Object.getOwnPropertyDescriptor(e,t))&&(a.get||a.set)?o(s,t,a):s[t]=e[t]);return s})(e,r)}function i(o,s=5,i=1,p=1,l=.5){const u=(0,t.convertToTensor)(o,"x","localResponseNormalization");n.assert(4===u.rank||3===u.rank,()=>`Error in localResponseNormalization: x must be rank 3 or 4 but got\n               rank ${u.rank}.`),n.assert(n.isInt(s),()=>"Error in localResponseNormalization: depthRadius must be an "+`integer but got depthRadius ${s}.`);let c=u,f=!1;3===u.rank&&(f=!0,c=(0,a.reshape)(u,[1,u.shape[0],u.shape[1],u.shape[2]]));const h={x:c},d={depthRadius:s,bias:i,alpha:p,beta:l},_=e.ENGINE.runKernel(r.LRN,h,d);return f?(0,a.reshape)(_,[_.shape[1],_.shape[2],_.shape[3]]):_}const p=exports.localResponseNormalization=(0,o.op)({localResponseNormalization_:i});
},{"../engine":"phT7","../kernel_names":"rJl6","../tensor_util_env":"y4X4","../util":"XXxQ","./operation":"uE86","./reshape":"F0cm"}],"f3PH":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.log=void 0;var e=require("../engine"),r=require("../kernel_names"),o=require("../tensor_util_env"),n=require("./operation");function t(n){const t={x:(0,o.convertToTensor)(n,"x","log","float32")};return e.ENGINE.runKernel(r.Log,t)}const i=exports.log=(0,n.op)({log_:t});
},{"../engine":"phT7","../kernel_names":"rJl6","../tensor_util_env":"y4X4","./operation":"uE86"}],"ODmc":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.log1p=void 0;var e=require("../engine"),r=require("../kernel_names"),o=require("../tensor_util_env"),n=require("./operation");function t(n){const t={x:(0,o.convertToTensor)(n,"x","log1p")};return e.ENGINE.runKernel(r.Log1p,t)}const i=exports.log1p=(0,n.op)({log1p_:t});
},{"../engine":"phT7","../kernel_names":"rJl6","../tensor_util_env":"y4X4","./operation":"uE86"}],"VR5t":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.customGrad=d,exports.grad=t,exports.grads=o,exports.valueAndGrad=u,exports.valueAndGrads=i,exports.variableGrads=l;var e=require("./engine"),r=require("./tensor"),a=require("./tensor_util_env"),s=n(require("./util"));function n(e,r){if("function"==typeof WeakMap)var a=new WeakMap,s=new WeakMap;return(n=function(e,r){if(!r&&e&&e.__esModule)return e;var n,t,o={__proto__:null,default:e};if(null===e||"object"!=typeof e&&"function"!=typeof e)return o;if(n=r?s:a){if(n.has(e))return n.get(e);n.set(e,o)}for(const a in e)"default"!==a&&{}.hasOwnProperty.call(e,a)&&((t=(n=Object.defineProperty)&&Object.getOwnPropertyDescriptor(e,a))&&(t.get||t.set)?n(o,a,t):o[a]=e[a]);return o})(e,r)}function t(r){return s.assert(s.isFunction(r),()=>"The f passed in grad(f) must be a function"),(n,t)=>{const o=(0,a.convertToTensor)(n,"x","tf.grad","string_or_numeric"),u=null!=t?(0,a.convertToTensor)(t,"dy","tf.grad"):null;return e.ENGINE.tidy(()=>{const{value:a,grads:n}=e.ENGINE.gradients(()=>r(o),[o],u);return null!=u&&s.assertShapesMatch(a.shape,u.shape,"The shape of dy passed in grad(f)(x, dy) must match the shape returned by f(x)"),f(n),n[0]})}}function o(r){return s.assert(s.isFunction(r),()=>"The f passed in grads(f) must be a function"),(n,t)=>{s.assert(Array.isArray(n),()=>"The args passed in grads(f)(args) must be an array of `Tensor`s or `TensorLike`s");const o=(0,a.convertToTensorArray)(n,"args","tf.grads","string_or_numeric"),u=null!=t?(0,a.convertToTensor)(t,"dy","tf.grads"):null;return e.ENGINE.tidy(()=>{const{value:a,grads:n}=e.ENGINE.gradients(()=>r(...o),o,u);return null!=u&&s.assertShapesMatch(a.shape,u.shape,"The shape of dy passed in grads(f)([x1,...], dy) must match the shape returned by f([x1,...])"),f(n),n})}}function u(a){return s.assert(s.isFunction(a),()=>"The f passed in valueAndGrad(f) must be a function"),(n,t)=>{s.assert(n instanceof r.Tensor,()=>"The x passed in valueAndGrad(f)(x) must be a tensor"),s.assert(null==t||t instanceof r.Tensor,()=>"The dy passed in valueAndGrad(f)(x, dy) must be a tensor");const{grads:o,value:u}=e.ENGINE.gradients(()=>a(n),[n],t);return f(o),{grad:o[0],value:u}}}function i(a){return s.assert(s.isFunction(a),()=>"The f passed in valueAndGrads(f) must be a function"),(n,t)=>{s.assert(Array.isArray(n)&&n.every(e=>e instanceof r.Tensor),()=>"The args passed in valueAndGrads(f)(args) must be array of tensors"),s.assert(null==t||t instanceof r.Tensor,()=>"The dy passed in valueAndGrads(f)(args, dy) must be a tensor");const o=e.ENGINE.gradients(()=>a(...n),n,t);return null!=t&&s.assertShapesMatch(o.value.shape,t.shape,"The shape of dy passed in valueAndGrads(f)([x1,...], dy) must match the shape returned by f([x1,...])"),f(o.grads),o}}function l(a,n){s.assert(s.isFunction(a),()=>"The f passed in variableGrads(f) must be a function"),s.assert(null==n||Array.isArray(n)&&n.every(e=>e instanceof r.Variable),()=>"The varList passed in variableGrads(f, varList) must be an array of variables");const t=null!=n;if(!t){n=[];for(const r in e.ENGINE.registeredVariables)n.push(e.ENGINE.registeredVariables[r])}const o=t?n.filter(e=>!e.trainable):null,u=n.length;n=n.filter(e=>e.trainable),s.assert(n.length>0,()=>"variableGrads() expects at least one of the input variables to "+`be trainable, but none of the ${u} variables is `+"trainable.");const{value:i,grads:l}=e.ENGINE.gradients(a,n,null,!0);s.assert(l.some(e=>null!=e),()=>"Cannot find a connection between any variable and the result of the loss function y=f(x). Please make sure the operations that use variables are inside the function f passed to minimize()."),s.assert(0===i.rank,()=>"The f passed in variableGrads(f) must return a scalar, but it "+`returned a rank-${i.rank} tensor`);const d={};return n.forEach((e,r)=>{null!=l[r]&&(d[e.name]=l[r])}),null!=o&&o.forEach(e=>d[e.name]=null),{value:i,grads:d}}function d(r){return e.ENGINE.customGrad(r)}function f(e){if(e.filter(e=>null==e).length>0)throw new Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that\n    the f you passed encloses all operations that lead from x to y.")}
},{"./engine":"phT7","./tensor":"eFW4","./tensor_util_env":"y4X4","./util":"XXxQ"}],"i2LN":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.neg=void 0;var e=require("../engine"),r=require("../kernel_names"),n=require("../tensor_util_env"),o=require("./operation");function t(o){const t={x:(0,n.convertToTensor)(o,"x","neg")};return e.ENGINE.runKernel(r.Neg,t)}const i=exports.neg=(0,o.op)({neg_:t});
},{"../engine":"phT7","../kernel_names":"rJl6","../tensor_util_env":"y4X4","./operation":"uE86"}],"TLV5":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.softplus=void 0;var e=require("../engine"),r=require("../kernel_names"),o=require("../tensor_util_env"),s=require("./operation");function t(s){const t={x:(0,o.convertToTensor)(s,"x","softplus")};return e.ENGINE.runKernel(r.Softplus,t)}const n=exports.softplus=(0,s.op)({softplus_:t});
},{"../engine":"phT7","../kernel_names":"rJl6","../tensor_util_env":"y4X4","./operation":"uE86"}],"h4az":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.logSigmoid=void 0;var e=require("../gradients"),r=require("../tensor_util_env"),o=require("./mul"),i=require("./neg"),u=require("./operation"),t=require("./sigmoid"),n=require("./softplus");function s(u){const s=(0,r.convertToTensor)(u,"x","logSigmoid");return(0,e.customGrad)(e=>{return{value:(0,i.neg)((0,n.softplus)((0,i.neg)(e))),gradFunc:r=>{return(0,o.mul)(r,(0,t.sigmoid)((0,i.neg)(e)))}}})(s)}const g=exports.logSigmoid=(0,u.op)({logSigmoid_:s});
},{"../gradients":"VR5t","../tensor_util_env":"y4X4","./mul":"tBJ4","./neg":"i2LN","./operation":"uE86","./sigmoid":"DbGB","./softplus":"TLV5"}],"SgzI":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.sub=void 0;var e=require("../engine"),r=require("../kernel_names"),n=require("../tensor_util"),o=require("../tensor_util_env"),t=require("./operation");function s(t,s){let u=(0,o.convertToTensor)(t,"a","sub"),i=(0,o.convertToTensor)(s,"b","sub");[u,i]=(0,n.makeTypesMatch)(u,i);const b={a:u,b:i};return e.ENGINE.runKernel(r.Sub,b)}const u=exports.sub=(0,t.op)({sub_:s});
},{"../engine":"phT7","../kernel_names":"rJl6","../tensor_util":"wtFc","../tensor_util_env":"y4X4","./operation":"uE86"}],"rVC8":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.logSoftmax=void 0;var r=require("../gradients"),e=require("../tensor_util_env"),o=require("./cast"),t=require("./exp"),s=require("./log"),u=require("./max"),a=require("./mul"),n=require("./operation"),i=require("./sub"),l=require("./sum");function m(n,m=-1){const x=(0,e.convertToTensor)(n,"logits","logSoftmax");if(-1===m&&(m=x.rank-1),m!==x.rank-1)throw Error("Log Softmax along a non-last dimension is not yet supported. "+`Logits was rank ${x.rank} and axis was ${m}`);return(0,r.customGrad)((r,e)=>{const n=(0,u.max)(r,m,!0),x=(0,i.sub)(r,n),c=(0,i.sub)((0,o.cast)(x,"float32"),(0,s.log)((0,l.sum)((0,t.exp)(x),m,!0)));e([c]);return{value:c,gradFunc:(r,e)=>{const[o]=e,s=(0,t.exp)(o);return(0,i.sub)(r,(0,a.mul)((0,l.sum)(r,m,!0),s))}}})(x)}const x=exports.logSoftmax=(0,n.op)({logSoftmax_:m});
},{"../gradients":"VR5t","../tensor_util_env":"y4X4","./cast":"qnzc","./exp":"xcz4","./log":"f3PH","./max":"KIVY","./mul":"tBJ4","./operation":"uE86","./sub":"SgzI","./sum":"kc8w"}],"te98":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.logSumExp=void 0;var e=require("../tensor_util_env"),r=require("../util"),u=require("./add"),o=require("./axis_util"),s=require("./exp"),i=require("./log"),p=require("./max"),a=require("./operation"),t=require("./reshape"),n=require("./sub"),x=require("./sum");function l(a,l=null,q=!1){const m=(0,e.convertToTensor)(a,"x","logSumExp"),d=(0,r.parseAxisParam)(l,m.shape),c=(0,p.max)(m,d,!0),h=(0,n.sub)(m,c),g=(0,s.exp)(h),_=(0,x.sum)(g,d),v=(0,i.log)(_),S=(0,u.add)((0,t.reshape)(c,v.shape),v);if(q){const e=(0,o.expandShapeToKeepDim)(S.shape,d);return(0,t.reshape)(S,e)}return S}const q=exports.logSumExp=(0,a.op)({logSumExp_:l});
},{"../tensor_util_env":"y4X4","../util":"XXxQ","./add":"N73o","./axis_util":"mPwf","./exp":"xcz4","./log":"f3PH","./max":"KIVY","./operation":"uE86","./reshape":"F0cm","./sub":"SgzI","./sum":"kc8w"}],"sHir":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.logicalAnd=void 0;var e=require("../engine"),o=require("../kernel_names"),r=require("../tensor_util_env"),n=require("./broadcast_util"),t=require("./operation");function a(t,a){const i=(0,r.convertToTensor)(t,"a","logicalAnd","bool"),l=(0,r.convertToTensor)(a,"b","logicalAnd","bool");(0,n.assertAndGetBroadcastShape)(i.shape,l.shape);const s={a:i,b:l};return e.ENGINE.runKernel(o.LogicalAnd,s)}const i=exports.logicalAnd=(0,t.op)({logicalAnd_:a});
},{"../engine":"phT7","../kernel_names":"rJl6","../tensor_util_env":"y4X4","./broadcast_util":"fD2T","./operation":"uE86"}],"jt3a":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.logicalNot=void 0;var e=require("../engine"),o=require("../kernel_names"),r=require("../tensor_util_env"),t=require("./operation");function n(t){const n={x:(0,r.convertToTensor)(t,"x","logicalNot","bool")};return e.ENGINE.runKernel(o.LogicalNot,n)}const i=exports.logicalNot=(0,t.op)({logicalNot_:n});
},{"../engine":"phT7","../kernel_names":"rJl6","../tensor_util_env":"y4X4","./operation":"uE86"}],"cBH6":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.logicalOr=void 0;var e=require("../engine"),r=require("../kernel_names"),o=require("../tensor_util_env"),t=require("./broadcast_util"),n=require("./operation");function a(n,a){const i=(0,o.convertToTensor)(n,"a","logicalOr","bool"),l=(0,o.convertToTensor)(a,"b","logicalOr","bool");(0,t.assertAndGetBroadcastShape)(i.shape,l.shape);const s={a:i,b:l};return e.ENGINE.runKernel(r.LogicalOr,s)}const i=exports.logicalOr=(0,n.op)({logicalOr_:a});
},{"../engine":"phT7","../kernel_names":"rJl6","../tensor_util_env":"y4X4","./broadcast_util":"fD2T","./operation":"uE86"}],"RGME":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.logicalXor=void 0;var o=require("../tensor_util_env"),r=require("./broadcast_util"),e=require("./logical_and"),l=require("./logical_not"),a=require("./logical_or"),i=require("./operation");function t(i,t){const c=(0,o.convertToTensor)(i,"a","logicalXor","bool"),n=(0,o.convertToTensor)(t,"b","logicalXor","bool");return(0,r.assertAndGetBroadcastShape)(c.shape,n.shape),(0,e.logicalAnd)((0,a.logicalOr)(i,t),(0,l.logicalNot)((0,e.logicalAnd)(i,t)))}const c=exports.logicalXor=(0,i.op)({logicalXor_:t});
},{"../tensor_util_env":"y4X4","./broadcast_util":"fD2T","./logical_and":"sHir","./logical_not":"jt3a","./logical_or":"cBH6","./operation":"uE86"}],"izso":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.searchSorted=void 0;var e=require("../engine"),r=require("../kernel_names"),s=require("../tensor_util_env"),t=require("../util_base"),o=require("./operation"),n=require("./reshape");const a=2147483648;function i(o,i,u="left"){const h=(0,s.convertToTensor)(o,"sortedSequence","searchSorted"),p=(0,s.convertToTensor)(i,"values","searchSorted"),c=h.shape[h.shape.length-1],d=p.shape[p.shape.length-1],l=(0,n.reshape)(h,[-1,c]),S=(0,n.reshape)(p,[-1,d]);if(l.rank<2)throw new Error("Sorted input argument must be at least 2-dimensional");if(l.shape[0]!==S.shape[0])throw new Error("Leading dimension of 'sortedSequence' and 'values' must match.");if((0,t.sizeFromShape)(S.shape)>=a)throw new Error(`values tensor size must less than ${a}`);if(l.shape[1]>=a)throw new Error(`trailing dim_size must less than ${a} for int32 output type, was ${l.shape[1]}`);const m={sortedSequence:l,values:S},v={side:u};return e.ENGINE.runKernel(r.SearchSorted,m,v)}const u=exports.searchSorted=(0,o.op)({searchSorted_:i});
},{"../engine":"phT7","../kernel_names":"rJl6","../tensor_util_env":"y4X4","../util_base":"uID4","./operation":"uE86","./reshape":"F0cm"}],"EiM8":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.lowerBound=r;var e=require("./search_sorted");function r(r,t){return(0,e.searchSorted)(r,t,"left")}
},{"./search_sorted":"izso"}],"g3Dm":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.maxPool=void 0;var e=require("../engine"),r=require("../kernel_names"),t=require("../tensor_util_env"),o=s(require("../util")),n=s(require("./conv_util")),i=require("./operation"),a=require("./reshape");function s(e,r){if("function"==typeof WeakMap)var t=new WeakMap,o=new WeakMap;return(s=function(e,r){if(!r&&e&&e.__esModule)return e;var n,i,a={__proto__:null,default:e};if(null===e||"object"!=typeof e&&"function"!=typeof e)return a;if(n=r?o:t){if(n.has(e))return n.get(e);n.set(e,a)}for(const t in e)"default"!==t&&{}.hasOwnProperty.call(e,t)&&((i=(n=Object.defineProperty)&&Object.getOwnPropertyDescriptor(e,t))&&(i.get||i.set)?n(a,t,i):a[t]=e[t]);return a})(e,r)}function u(i,s,u,l,p){const d=(0,t.convertToTensor)(i,"x","maxPool");let c=d,f=!1;3===d.rank&&(f=!0,c=(0,a.reshape)(d,[1,d.shape[0],d.shape[1],d.shape[2]])),o.assert(4===c.rank,()=>`Error in maxPool: input must be rank 4 but got rank ${c.rank}.`),o.assert(n.eitherStridesOrDilationsAreOne(u,1),()=>"Error in maxPool: Either strides or dilations must be 1. "+`Got strides ${u} and dilations '1'`),n.checkPadOnDimRoundingMode("maxPool",l,p);const h={x:c},x={filterSize:s,strides:u,pad:l,dimRoundingMode:p},P=e.ENGINE.runKernel(r.MaxPool,h,x);return f?(0,a.reshape)(P,[P.shape[1],P.shape[2],P.shape[3]]):P}const l=exports.maxPool=(0,i.op)({maxPool_:u});
},{"../engine":"phT7","../kernel_names":"rJl6","../tensor_util_env":"y4X4","../util":"XXxQ","./conv_util":"PhWH","./operation":"uE86","./reshape":"F0cm"}],"Z3LC":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.maxPool3d=void 0;var e=require("../engine"),r=require("../kernel_names"),o=require("../tensor_util_env"),t=i(require("../util")),n=require("./conv_util"),a=require("./operation"),s=require("./reshape");function i(e,r){if("function"==typeof WeakMap)var o=new WeakMap,t=new WeakMap;return(i=function(e,r){if(!r&&e&&e.__esModule)return e;var n,a,s={__proto__:null,default:e};if(null===e||"object"!=typeof e&&"function"!=typeof e)return s;if(n=r?t:o){if(n.has(e))return n.get(e);n.set(e,s)}for(const o in e)"default"!==o&&{}.hasOwnProperty.call(e,o)&&((a=(n=Object.defineProperty)&&Object.getOwnPropertyDescriptor(e,o))&&(a.get||a.set)?n(s,o,a):s[o]=e[o]);return s})(e,r)}function u(a,i=[1,1,1],u,p,l,d="NDHWC"){const c=(0,o.convertToTensor)(a,"x","maxPool3d");let f=c,h=!1;4===c.rank&&(h=!0,f=(0,s.reshape)(c,[1,c.shape[0],c.shape[1],c.shape[2],c.shape[3]])),t.assert(5===f.rank,()=>`Error in maxPool3d: x must be rank 5 but got rank ${f.rank}.`),t.assert("NDHWC"===d,()=>"Error in maxPool3d: Only NDHWC is currently supported, "+`but got dataFormat of ${d}`),(0,n.checkPadOnDimRoundingMode)("maxPool3d",p,l);const x={x:f},m={filterSize:i,strides:u,pad:p,dimRoundingMode:l,dataFormat:d},P=e.ENGINE.runKernel(r.MaxPool3D,x,m);return h?(0,s.reshape)(P,[P.shape[1],P.shape[2],P.shape[3],P.shape[4]]):P}const p=exports.maxPool3d=(0,a.op)({maxPool3d_:u});
},{"../engine":"phT7","../kernel_names":"rJl6","../tensor_util_env":"y4X4","../util":"XXxQ","./conv_util":"PhWH","./operation":"uE86","./reshape":"F0cm"}],"vORB":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.maxPoolWithArgmax=void 0;var e=require("../engine"),r=require("../kernel_names"),o=require("../tensor_util_env"),t=require("./operation");function i(t,i,n,x,a=!1){const s={x:(0,o.convertToTensor)(t,"x","maxPoolWithArgmax")},l={filterSize:i,strides:n,pad:x,includeBatchInIndex:a},u=e.ENGINE.runKernel(r.MaxPoolWithArgmax,s,l);return{result:u[0],indexes:u[1]}}const n=exports.maxPoolWithArgmax=(0,t.op)({maxPoolWithArgmax_:i});
},{"../engine":"phT7","../kernel_names":"rJl6","../tensor_util_env":"y4X4","./operation":"uE86"}],"E33m":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.maximum=void 0;var e=require("../engine"),r=require("../kernel_names"),t=require("../tensor_util"),a=require("../tensor_util_env"),i=require("./broadcast_util"),o=require("./cast"),n=require("./operation");function s(n,s){let u=(0,a.convertToTensor)(n,"a","maximum"),m=(0,a.convertToTensor)(s,"b","maximum");[u,m]=(0,t.makeTypesMatch)(u,m),"bool"===u.dtype&&(u=(0,o.cast)(u,"int32"),m=(0,o.cast)(m,"int32")),(0,i.assertAndGetBroadcastShape)(u.shape,m.shape);const c={a:u,b:m};return e.ENGINE.runKernel(r.Maximum,c)}const u=exports.maximum=(0,n.op)({maximum_:s});
},{"../engine":"phT7","../kernel_names":"rJl6","../tensor_util":"wtFc","../tensor_util_env":"y4X4","./broadcast_util":"fD2T","./cast":"qnzc","./operation":"uE86"}],"DIOh":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.mean=void 0;var e=require("../engine"),r=require("../kernel_names"),n=require("../tensor_util_env"),o=require("./operation");function t(o,t=null,i=!1){const s={x:(0,n.convertToTensor)(o,"x","mean")},u={axis:t,keepDims:i};return e.ENGINE.runKernel(r.Mean,s,u)}const i=exports.mean=(0,o.op)({mean_:t});
},{"../engine":"phT7","../kernel_names":"rJl6","../tensor_util_env":"y4X4","./operation":"uE86"}],"AsfN":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.zeros=t;var e=require("../engine"),r=require("../util"),o=require("./complex");function t(s,n="float32"){if((0,r.assertNonNegativeIntegerDimensions)(s),"complex64"===n){const e=t(s,"float32"),r=t(s,"float32");return(0,o.complex)(e,r)}const i=(0,r.makeZerosTypedArray)((0,r.sizeFromShape)(s),n);return e.ENGINE.makeTensor(i,s,n)}
},{"../engine":"phT7","../util":"XXxQ","./complex":"e4je"}],"iY3A":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.ones=i;var e=require("../engine"),r=require("../util"),o=require("../util_base"),t=require("./complex"),s=require("./zeros");function i(n,u="float32"){if((0,o.assertNonNegativeIntegerDimensions)(n),"complex64"===u){const e=i(n,"float32"),r=(0,s.zeros)(n,"float32");return(0,t.complex)(e,r)}const a=(0,r.makeOnesTypedArray)((0,r.sizeFromShape)(n),u);return e.ENGINE.makeTensor(a,n,u)}
},{"../engine":"phT7","../util":"XXxQ","../util_base":"uID4","./complex":"e4je","./zeros":"AsfN"}],"OeUD":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.meshgrid=n;var e=require("./mat_mul"),r=require("./ones"),t=require("./reshape"),s=require("../tensor"),o=require("../tensor_util_env"),i=require("../util_base");function n(n,a,{indexing:u="xy"}={}){if("xy"!==u&&"ij"!==u)throw new TypeError(`${u} is not a valid third argument to meshgrid`);if(void 0===n)return[];let p=(0,o.convertToTensor)(n,"x","meshgrid",n instanceof s.Tensor?n.dtype:"float32");if(void 0===a)return[p];let d=(0,o.convertToTensor)(a,"y","meshgrid",a instanceof s.Tensor?a.dtype:"float32");const h=(0,i.sizeFromShape)(p.shape),l=(0,i.sizeFromShape)(d.shape);return"xy"===u?(p=(0,t.reshape)(p,[1,-1]),d=(0,t.reshape)(d,[-1,1]),[(0,e.matMul)((0,r.ones)([l,1],p.dtype),p),(0,e.matMul)(d,(0,r.ones)([1,h],d.dtype))]):(p=(0,t.reshape)(p,[-1,1]),d=(0,t.reshape)(d,[1,-1]),[(0,e.matMul)(p,(0,r.ones)([1,l],p.dtype)),(0,e.matMul)((0,r.ones)([h,1],d.dtype),d)])}
},{"./mat_mul":"zVDr","./ones":"iY3A","./reshape":"F0cm","../tensor":"eFW4","../tensor_util_env":"y4X4","../util_base":"uID4"}],"TKku":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.minimum=void 0;var e=require("../engine"),r=require("../kernel_names"),t=require("../tensor_util"),i=require("../tensor_util_env"),n=require("./broadcast_util"),o=require("./cast"),s=require("./operation");function u(s,u){let a=(0,i.convertToTensor)(s,"a","minimum"),m=(0,i.convertToTensor)(u,"b","minimum");[a,m]=(0,t.makeTypesMatch)(a,m),"bool"===a.dtype&&(a=(0,o.cast)(a,"int32"),m=(0,o.cast)(m,"int32")),(0,n.assertAndGetBroadcastShape)(a.shape,m.shape);const c={a:a,b:m};return e.ENGINE.runKernel(r.Minimum,c)}const a=exports.minimum=(0,s.op)({minimum_:u});
},{"../engine":"phT7","../kernel_names":"rJl6","../tensor_util":"wtFc","../tensor_util_env":"y4X4","./broadcast_util":"fD2T","./cast":"qnzc","./operation":"uE86"}],"y7Tc":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.mirrorPad=void 0;var e=require("../engine"),r=require("../kernel_names"),t=require("../tensor_util_env"),n=a(require("../util")),o=require("./operation");function a(e,r){if("function"==typeof WeakMap)var t=new WeakMap,n=new WeakMap;return(a=function(e,r){if(!r&&e&&e.__esModule)return e;var o,a,i={__proto__:null,default:e};if(null===e||"object"!=typeof e&&"function"!=typeof e)return i;if(o=r?n:t){if(o.has(e))return o.get(e);o.set(e,i)}for(const t in e)"default"!==t&&{}.hasOwnProperty.call(e,t)&&((a=(o=Object.defineProperty)&&Object.getOwnPropertyDescriptor(e,t))&&(a.get||a.set)?o(i,t,a):i[t]=e[t]);return i})(e,r)}function i(o,a,i){n.assert("reflect"===i||"symmetric"===i,()=>"Invalid mode. Mode must be either reflect or symmetric. "+`Got ${i}.`);const s=(0,t.convertToTensor)(o,"x","mirrorPad");if(0===s.rank)throw new Error("mirrorPad(scalar) is not defined. Pass non-scalar to mirrorPad");n.assert(a.length===s.rank,()=>`Padding doesn't match input. Must be ${s.rank}. `+`Got ${a.length}.`);const u="reflect"===i?1:0;for(let e=0;e<s.rank;e++)n.assert(2===a[e].length,()=>"Invalid number of paddings. Must be length of 2 each."),n.assert(a[e][0]>=0&&a[e][0]<=s.shape[e]-u&&a[e][1]>=0&&a[e][1]<=s.shape[e]-u,()=>`Padding in dimension ${e} cannot be greater than or equal `+`to ${s.shape[e]-u} or less than 0 for input of `+`shape ${s.shape}`);const d={paddings:a,mode:i},l={x:s};return e.ENGINE.runKernel(r.MirrorPad,l,d)}const s=exports.mirrorPad=(0,o.op)({mirrorPad_:i});
},{"../engine":"phT7","../kernel_names":"rJl6","../tensor_util_env":"y4X4","../util":"XXxQ","./operation":"uE86"}],"cyrT":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.mod=void 0;var e=require("../engine"),r=require("../kernel_names"),o=require("../tensor_util"),n=require("../tensor_util_env"),t=require("./operation");function s(t,s){let i=(0,n.convertToTensor)(t,"a","mod"),u=(0,n.convertToTensor)(s,"b","mod");[i,u]=(0,o.makeTypesMatch)(i,u);const d={a:i,b:u};return e.ENGINE.runKernel(r.Mod,d)}const i=exports.mod=(0,t.op)({mod_:s});
},{"../engine":"phT7","../kernel_names":"rJl6","../tensor_util":"wtFc","../tensor_util_env":"y4X4","./operation":"uE86"}],"xfMn":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.moments=void 0;var e=require("../tensor_util_env"),r=require("../util"),s=require("./axis_util"),t=require("./cast"),a=require("./mean"),n=require("./operation"),o=require("./reshape"),u=require("./square"),i=require("./sub");function p(n,p=null,m=!1){n=(0,e.convertToTensor)(n,"x","moments");const q=(0,r.parseAxisParam)(p,n.shape),c=(0,a.mean)(n,q,m);let l=c.shape;m||(l=(0,s.expandShapeToKeepDim)(c.shape,q));const x=(0,u.square)((0,i.sub)((0,t.cast)(n,"float32"),(0,o.reshape)(c,l)));return{mean:c,variance:(0,a.mean)(x,q,m)}}const m=exports.moments=(0,n.op)({moments_:p});
},{"../tensor_util_env":"y4X4","../util":"XXxQ","./axis_util":"mPwf","./cast":"qnzc","./mean":"DIOh","./operation":"uE86","./reshape":"F0cm","./square":"KiGo","./sub":"SgzI"}],"C2RS":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.multiRNNCell=void 0;var e=require("../tensor_util_env"),t=require("./operation");function o(t,o,r,l){const n=(0,e.convertToTensor)(o,"data","multiRNNCell"),s=(0,e.convertToTensorArray)(r,"c","multiRNNCell"),u=(0,e.convertToTensorArray)(l,"h","multiRNNCell");let i=n;const c=[];for(let e=0;e<t.length;e++){const o=t[e](i,s[e],u[e]);c.push(o[0]),c.push(o[1]),i=o[1]}const N=[],p=[];for(let e=0;e<c.length;e+=2)N.push(c[e]),p.push(c[e+1]);return[N,p]}const r=exports.multiRNNCell=(0,t.op)({multiRNNCell_:o});
},{"../tensor_util_env":"y4X4","./operation":"uE86"}],"moMD":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.multinomial=void 0;var e=require("../engine"),r=require("../kernel_names"),o=require("../tensor_util_env"),i=require("./operation"),t=require("./reshape");function n(i,n,s,u=!1){const l=(0,o.convertToTensor)(i,"logits","multinomial"),a=l.size,m=l.rank;if(a<2)throw new Error("Error in multinomial: you need at least 2 outcomes, but got "+`${a}.`);if(m>2)throw new Error(`Rank of probabilities must be 1 or 2, but is ${m}`);s=s||Math.random();const p={logits:1===m?(0,t.reshape)(l,[1,-1]):l},c={numSamples:n,seed:s,normalized:u},d=e.ENGINE.runKernel(r.Multinomial,p,c);return 1===m?(0,t.reshape)(d,[d.size]):d}const s=exports.multinomial=(0,i.op)({multinomial_:n});
},{"../engine":"phT7","../kernel_names":"rJl6","../tensor_util_env":"y4X4","./operation":"uE86","./reshape":"F0cm"}],"TOzH":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.notEqual=void 0;var e=require("../engine"),r=require("../kernel_names"),t=require("../tensor_util"),n=require("../tensor_util_env"),o=require("./broadcast_util"),u=require("./operation");function a(u,a){let s=(0,n.convertToTensor)(u,"a","notEqual","string_or_numeric"),i=(0,n.convertToTensor)(a,"b","notEqual","string_or_numeric");[s,i]=(0,t.makeTypesMatch)(s,i),(0,o.assertAndGetBroadcastShape)(s.shape,i.shape);const l={a:s,b:i};return e.ENGINE.runKernel(r.NotEqual,l)}const s=exports.notEqual=(0,u.op)({notEqual_:a});
},{"../engine":"phT7","../kernel_names":"rJl6","../tensor_util":"wtFc","../tensor_util_env":"y4X4","./broadcast_util":"fD2T","./operation":"uE86"}],"HpS0":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.oneHot=void 0;var e=require("../engine"),o=require("../kernel_names"),r=require("../tensor_util_env"),n=require("./operation");function t(n,t,i=1,s=0,u="int32"){if(t<2)throw new Error(`Error in oneHot: depth must be >=2, but it is ${t}`);const p={indices:(0,r.convertToTensor)(n,"indices","oneHot","int32")},c={dtype:u,depth:t,onValue:i,offValue:s};return e.ENGINE.runKernel(o.OneHot,p,c)}const i=exports.oneHot=(0,n.op)({oneHot_:t});
},{"../engine":"phT7","../kernel_names":"rJl6","../tensor_util_env":"y4X4","./operation":"uE86"}],"nMI9":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.onesLike=void 0;var e=require("../engine"),r=require("../kernel_names"),n=require("../tensor_util_env"),o=require("./operation");function i(o){const i={x:(0,n.convertToTensor)(o,"x","onesLike")};return e.ENGINE.runKernel(r.OnesLike,i)}const s=exports.onesLike=(0,o.op)({onesLike_:i});
},{"../engine":"phT7","../kernel_names":"rJl6","../tensor_util_env":"y4X4","./operation":"uE86"}],"mAdl":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.outerProduct=void 0;var e=require("../tensor_util_env"),r=u(require("../util")),t=require("./mat_mul"),o=require("./operation"),n=require("./reshape");function u(e,r){if("function"==typeof WeakMap)var t=new WeakMap,o=new WeakMap;return(u=function(e,r){if(!r&&e&&e.__esModule)return e;var n,u,a={__proto__:null,default:e};if(null===e||"object"!=typeof e&&"function"!=typeof e)return a;if(n=r?o:t){if(n.has(e))return n.get(e);n.set(e,a)}for(const t in e)"default"!==t&&{}.hasOwnProperty.call(e,t)&&((u=(n=Object.defineProperty)&&Object.getOwnPropertyDescriptor(e,t))&&(u.get||u.set)?n(a,t,u):a[t]=e[t]);return a})(e,r)}function a(o,u){const a=(0,e.convertToTensor)(o,"v1","outerProduct"),s=(0,e.convertToTensor)(u,"v2","outerProduct");r.assert(1===a.rank&&1===s.rank,()=>"Error in outerProduct: inputs must be rank 1, but got ranks "+`${a.rank} and ${s.rank}.`);const i=(0,n.reshape)(a,[-1,1]),c=(0,n.reshape)(s,[1,-1]);return(0,t.matMul)(i,c)}const s=exports.outerProduct=(0,o.op)({outerProduct_:a});
},{"../tensor_util_env":"y4X4","../util":"XXxQ","./mat_mul":"zVDr","./operation":"uE86","./reshape":"F0cm"}],"y7nM":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.pad=void 0;var e=require("../engine"),r=require("../kernel_names"),n=require("../tensor_util_env"),o=require("./operation");function t(o,t,a=0){const s=(0,n.convertToTensor)(o,"x","pad");if(0===s.rank)throw new Error("pad(scalar) is not defined. Pass non-scalar to pad");const i={paddings:t,constantValue:a},d={x:s};return e.ENGINE.runKernel(r.PadV2,d,i)}const a=exports.pad=(0,o.op)({pad_:t});
},{"../engine":"phT7","../kernel_names":"rJl6","../tensor_util_env":"y4X4","./operation":"uE86"}],"c4D8":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.pad1d=void 0;var e=require("../util"),r=require("./operation"),t=require("./pad");function d(r,d,o=0){return(0,e.assert)(2===d.length,()=>"Invalid number of paddings. Must be length of 2."),(0,t.pad)(r,[d],o)}const o=exports.pad1d=(0,r.op)({pad1d_:d});
},{"../util":"XXxQ","./operation":"uE86","./pad":"y7nM"}],"Zzwk":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.pad2d=void 0;var e=require("../util"),r=require("./operation"),t=require("./pad");function d(r,d,n=0){return(0,e.assert)(2===d.length&&2===d[0].length&&2===d[1].length,()=>"Invalid number of paddings. Must be length of 2 each."),(0,t.pad)(r,d,n)}const n=exports.pad2d=(0,r.op)({pad2d_:d});
},{"../util":"XXxQ","./operation":"uE86","./pad":"y7nM"}],"DYJf":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.pad3d=void 0;var e=require("../util"),t=require("./operation"),r=require("./pad");function d(t,d,n=0){return(0,e.assert)(3===d.length&&2===d[0].length&&2===d[1].length&&2===d[2].length,()=>"Invalid number of paddings. Must be length of 2 each."),(0,r.pad)(t,d,n)}const n=exports.pad3d=(0,t.op)({pad3d_:d});
},{"../util":"XXxQ","./operation":"uE86","./pad":"y7nM"}],"k9sb":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.pad4d=void 0;var e=require("../util"),t=require("./operation"),r=require("./pad");function n(t,n,d=0){return(0,e.assert)(4===n.length&&2===n[0].length&&2===n[1].length&&2===n[2].length&&2===n[3].length,()=>"Invalid number of paddings. Must be length of 2 each."),(0,r.pad)(t,n,d)}const d=exports.pad4d=(0,t.op)({pad4d_:n});
},{"../util":"XXxQ","./operation":"uE86","./pad":"y7nM"}],"ERrS":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.spaceToBatchND=void 0;var e=require("../engine"),t=require("../kernel_names"),n=require("../tensor_util_env"),r=a(require("../util")),o=require("./operation");function a(e,t){if("function"==typeof WeakMap)var n=new WeakMap,r=new WeakMap;return(a=function(e,t){if(!t&&e&&e.__esModule)return e;var o,a,s={__proto__:null,default:e};if(null===e||"object"!=typeof e&&"function"!=typeof e)return s;if(o=t?r:n){if(o.has(e))return o.get(e);o.set(e,s)}for(const n in e)"default"!==n&&{}.hasOwnProperty.call(e,n)&&((a=(o=Object.defineProperty)&&Object.getOwnPropertyDescriptor(e,n))&&(a.get||a.set)?o(s,n,a):s[n]=e[n]);return s})(e,t)}function s(o,a,s){const i=(0,n.convertToTensor)(o,"x","spaceToBatchND");r.assert(i.rank>=1+a.length,()=>`input rank ${i.rank} should be > than [blockShape] ${a.length}`),r.assert(s.length===a.length,()=>`paddings.shape[0] ${s.length} must be equal to [blockShape] ${a.length}`),r.assert(i.shape.reduce((e,t,n)=>n>0&&n<=a.length?e&&(t+s[n-1][0]+s[n-1][1])%a[n-1]==0:e,!0),()=>`input spatial dimensions ${i.shape.slice(1)} with paddings ${s.toString()} must be divisible by blockShapes ${a.toString()}`);const p={x:i},u={blockShape:a,paddings:s};return e.ENGINE.runKernel(t.SpaceToBatchND,p,u)}const i=exports.spaceToBatchND=(0,o.op)({spaceToBatchND_:s});
},{"../engine":"phT7","../kernel_names":"rJl6","../tensor_util_env":"y4X4","../util":"XXxQ","./operation":"uE86"}],"Zp2S":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.pool=void 0;var e=require("../tensor_util_env"),t=l(require("../util")),o=require("./avg_pool"),r=require("./batch_to_space_nd"),a=l(require("./conv_util")),n=require("./max_pool"),i=require("./operation"),p=require("./reshape"),s=require("./space_to_batch_nd");function l(e,t){if("function"==typeof WeakMap)var o=new WeakMap,r=new WeakMap;return(l=function(e,t){if(!t&&e&&e.__esModule)return e;var a,n,i={__proto__:null,default:e};if(null===e||"object"!=typeof e&&"function"!=typeof e)return i;if(a=t?r:o){if(a.has(e))return a.get(e);a.set(e,i)}for(const o in e)"default"!==o&&{}.hasOwnProperty.call(e,o)&&((n=(a=Object.defineProperty)&&Object.getOwnPropertyDescriptor(e,o))&&(n.get||n.set)?a(i,o,n):i[o]=e[o]);return i})(e,t)}function u(i,l,u,f,d,_,m){null==d&&(d=[1,1]),null==_&&(_=1),0===f&&(f="valid");const v=(0,e.convertToTensor)(i,"x","maxPool");let g=v,q=!1;3===v.rank&&(q=!0,g=(0,p.reshape)(v,[1,v.shape[0],v.shape[1],v.shape[2]])),t.assert(a.eitherStridesOrDilationsAreOne(_,d),()=>"Error in pool: Either strides or dilations must be 1. "+`Got strides ${_} and dilations '${d}'`);const b=a.computePool2DInfo(g.shape,l,_,d,f),P=[b.dilationHeight,b.dilationWidth];let x;x="same"===f?h([b.filterHeight,b.filterWidth],P):[[0,0],[0,0]];const y=1===P[0]&&1===P[1],[O,M]=c([b.inHeight,b.inWidth],P,x),W=y?f:"valid",D=y?g:(0,s.spaceToBatchND)(g,P,O),j=("avg"===u?()=>(0,o.avgPool)(D,l,_,W,m):()=>(0,n.maxPool)(D,l,_,W,m))(),k=y?j:(0,r.batchToSpaceND)(j,P,M);return q?(0,p.reshape)(k,[k.shape[1],k.shape[2],k.shape[3]]):k}function c(e,t,o){const r=o.map(e=>e[0]),a=o.map(e=>e[1]),n=e.concat(r,a),i=t.map((e,t)=>(e-n[t]%e)%e),p=a.map((e,t)=>e+i[t]);return[t.map((e,t)=>[r[t],p[t]]),t.map((e,t)=>[0,i[t]])]}function h(e,t){const o=e.map((e,o)=>e+(e-1)*(t[o]-1)).map(e=>e-1),r=o.map(e=>Math.floor(e/2)),a=o.map((e,t)=>e-r[t]);return o.map((e,t)=>[r[t],a[t]])}const f=exports.pool=(0,i.op)({pool_:u});
},{"../tensor_util_env":"y4X4","../util":"XXxQ","./avg_pool":"LNDu","./batch_to_space_nd":"vEiD","./conv_util":"PhWH","./max_pool":"g3Dm","./operation":"uE86","./reshape":"F0cm","./space_to_batch_nd":"ERrS"}],"Xs9q":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.prelu=void 0;var e=require("../engine"),r=require("../kernel_names"),n=require("../tensor_util_env"),o=require("./operation");function u(o,u){const t={x:(0,n.convertToTensor)(o,"x","prelu"),alpha:(0,n.convertToTensor)(u,"alpha","prelu")};return e.ENGINE.runKernel(r.Prelu,t)}const t=exports.prelu=(0,o.op)({prelu_:u});
},{"../engine":"phT7","../kernel_names":"rJl6","../tensor_util_env":"y4X4","./operation":"uE86"}],"V8As":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.prod=void 0;var e=require("../engine"),r=require("../kernel_names"),o=require("../tensor_util_env"),t=require("./cast"),n=require("./operation");function i(n,i=null,s=!1){let u=(0,o.convertToTensor)(n,"x","prod");"bool"===u.dtype&&(u=(0,t.cast)(u,"int32"));const p={x:u},d={axis:i,keepDims:s};return e.ENGINE.runKernel(r.Prod,p,d)}const s=exports.prod=(0,n.op)({prod_:i});
},{"../engine":"phT7","../kernel_names":"rJl6","../tensor_util_env":"y4X4","./cast":"qnzc","./operation":"uE86"}],"bCWa":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.raggedGather=void 0;var e=require("../engine"),r=require("../kernel_names"),t=require("../tensor_util_env"),n=require("./operation");function s(n,s,a,o){const i={paramsNestedSplits:n.map((e,r)=>(0,t.convertToTensor)(e,`tensors${r}`,"raggedGather","int32")),paramsDenseValues:(0,t.convertToTensor)(s,"paramsDenseValues","raggedGather"),indices:(0,t.convertToTensor)(a,"indices","raggedGather","int32")},u={outputRaggedRank:o},g=e.ENGINE.runKernel(r.RaggedGather,i,u);return{outputNestedSplits:g.slice(0,g.length-1),outputDenseValues:g[g.length-1]}}const a=exports.raggedGather=(0,n.op)({raggedGather_:s});
},{"../engine":"phT7","../kernel_names":"rJl6","../tensor_util_env":"y4X4","./operation":"uE86"}],"gQ0m":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.raggedRange=void 0;var e=require("../engine"),r=require("../kernel_names"),t=require("../tensor_util_env"),n=require("./operation");function s(n,s,a){const g=(0,t.convertToTensor)(n,"starts","raggedRange"),o={starts:g,limits:(0,t.convertToTensor)(s,"limits","raggedRange",g.dtype),deltas:(0,t.convertToTensor)(a,"deltas","raggedRange",g.dtype)},i=e.ENGINE.runKernel(r.RaggedRange,o);return{rtNestedSplits:i[0],rtDenseValues:i[1]}}const a=exports.raggedRange=(0,n.op)({raggedRange_:s});
},{"../engine":"phT7","../kernel_names":"rJl6","../tensor_util_env":"y4X4","./operation":"uE86"}],"yqh4":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.raggedTensorToTensor=void 0;var e=require("../engine"),r=require("../kernel_names"),o=require("../tensor_util_env"),n=require("./operation");function s(n,s,T,t,a){const g=(0,o.convertToTensor)(n,"shape","raggedTensorToTensor","int32"),i=(0,o.convertToTensor)(s,"values","raggedTensorToTensor"),u={shape:g,values:i,defaultValue:(0,o.convertToTensor)(T,"defaultValue","raggedTensorToTensor",i.dtype),rowPartitionTensors:t.map((e,r)=>(0,o.convertToTensor)(e,`tensors${r}`,"raggedTensorToTensor","int32"))},d={rowPartitionTypes:a};return e.ENGINE.runKernel(r.RaggedTensorToTensor,u,d)}const T=exports.raggedTensorToTensor=(0,n.op)({raggedTensorToTensor_:s});
},{"../engine":"phT7","../kernel_names":"rJl6","../tensor_util_env":"y4X4","./operation":"uE86"}],"DOKZ":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.rand=void 0;var e=require("../engine"),r=require("../util"),n=require("../util_base"),t=require("./operation");function o(t,o,i){(0,n.assertNonNegativeIntegerDimensions)(t);const a=(0,r.sizeFromShape)(t);let s=null;if(null==i||"float32"===i)s=new Float32Array(a);else if("int32"===i)s=new Int32Array(a);else{if("bool"!==i)throw new Error(`Unknown data type ${i}`);s=new Uint8Array(a)}for(let e=0;e<a;e++)s[e]=o();return e.ENGINE.makeTensor(s,t,i)}const i=exports.rand=(0,t.op)({rand_:o});
},{"../engine":"phT7","../util":"XXxQ","../util_base":"uID4","./operation":"uE86"}],"SSZJ":[function(require,module,exports) {
var define;
var t;!function(t,n,e){function s(t){var n,e=this,s=(n=4022871197,function(t){t=String(t);for(var e=0;e<t.length;e++){var s=.02519603282416938*(n+=t.charCodeAt(e));s-=n=s>>>0,n=(s*=n)>>>0,n+=4294967296*(s-=n)}return 2.3283064365386963e-10*(n>>>0)});e.next=function(){var t=2091639*e.s0+2.3283064365386963e-10*e.c;return e.s0=e.s1,e.s1=e.s2,e.s2=t-(e.c=0|t)},e.c=1,e.s0=s(" "),e.s1=s(" "),e.s2=s(" "),e.s0-=s(t),e.s0<0&&(e.s0+=1),e.s1-=s(t),e.s1<0&&(e.s1+=1),e.s2-=s(t),e.s2<0&&(e.s2+=1),s=null}function r(t,n){return n.c=t.c,n.s0=t.s0,n.s1=t.s1,n.s2=t.s2,n}function u(t,n){var e=new s(t),u=n&&n.state,o=e.next;return o.int32=function(){return 4294967296*e.next()|0},o.double=function(){return o()+1.1102230246251565e-16*(2097152*o()|0)},o.quick=o,u&&("object"==typeof u&&r(u,e),o.state=function(){return r(e,{})}),o}n&&n.exports?n.exports=u:e&&e.amd?e(function(){return u}):this.alea=u}(0,"object"==typeof module&&module,"function"==typeof t&&t);
},{}],"C6rM":[function(require,module,exports) {
var define;
var t;!function(t,n,e){function r(t){var n=this,e="";n.x=0,n.y=0,n.z=0,n.w=0,n.next=function(){var t=n.x^n.x<<11;return n.x=n.y,n.y=n.z,n.z=n.w,n.w^=n.w>>>19^t^t>>>8},t===(0|t)?n.x=t:e+=t;for(var r=0;r<e.length+64;r++)n.x^=0|e.charCodeAt(r),n.next()}function o(t,n){return n.x=t.x,n.y=t.y,n.z=t.z,n.w=t.w,n}function u(t,n){var e=new r(t),u=n&&n.state,x=function(){return(e.next()>>>0)/4294967296};return x.double=function(){do{var t=((e.next()>>>11)+(e.next()>>>0)/4294967296)/(1<<21)}while(0===t);return t},x.int32=e.next,x.quick=x,u&&("object"==typeof u&&o(u,e),x.state=function(){return o(e,{})}),x}n&&n.exports?n.exports=u:e&&e.amd?e(function(){return u}):this.xor128=u}(0,"object"==typeof module&&module,"function"==typeof t&&t);
},{}],"kkTl":[function(require,module,exports) {
var define;
var t;!function(t,n,e){function o(t){var n=this,e="";n.next=function(){var t=n.x^n.x>>>2;return n.x=n.y,n.y=n.z,n.z=n.w,n.w=n.v,(n.d=n.d+362437|0)+(n.v=n.v^n.v<<4^t^t<<1)|0},n.x=0,n.y=0,n.z=0,n.w=0,n.v=0,t===(0|t)?n.x=t:e+=t;for(var o=0;o<e.length+64;o++)n.x^=0|e.charCodeAt(o),o==e.length&&(n.d=n.x<<10^n.x>>>4),n.next()}function r(t,n){return n.x=t.x,n.y=t.y,n.z=t.z,n.w=t.w,n.v=t.v,n.d=t.d,n}function u(t,n){var e=new o(t),u=n&&n.state,x=function(){return(e.next()>>>0)/4294967296};return x.double=function(){do{var t=((e.next()>>>11)+(e.next()>>>0)/4294967296)/(1<<21)}while(0===t);return t},x.int32=e.next,x.quick=x,u&&("object"==typeof u&&r(u,e),x.state=function(){return r(e,{})}),x}n&&n.exports?n.exports=u:e&&e.amd?e(function(){return u}):this.xorwow=u}(0,"object"==typeof module&&module,"function"==typeof t&&t);
},{}],"rUyN":[function(require,module,exports) {
var define;
var n;!function(n,t,e){function r(n){var t=this;t.next=function(){var n,e,r=t.x,o=t.i;return n=r[o],e=(n^=n>>>7)^n<<24,e^=(n=r[o+1&7])^n>>>10,e^=(n=r[o+3&7])^n>>>3,e^=(n=r[o+4&7])^n<<7,n=r[o+7&7],e^=(n^=n<<13)^n<<9,r[o]=e,t.i=o+1&7,e},function(n,t){var e,r=[];if(t===(0|t))r[0]=t;else for(t=""+t,e=0;e<t.length;++e)r[7&e]=r[7&e]<<15^t.charCodeAt(e)+r[e+1&7]<<13;for(;r.length<8;)r.push(0);for(e=0;e<8&&0===r[e];++e);for(8==e?r[7]=-1:r[e],n.x=r,n.i=0,e=256;e>0;--e)n.next()}(t,n)}function o(n,t){return t.x=n.x.slice(),t.i=n.i,t}function i(n,t){null==n&&(n=+new Date);var e=new r(n),i=t&&t.state,u=function(){return(e.next()>>>0)/4294967296};return u.double=function(){do{var n=((e.next()>>>11)+(e.next()>>>0)/4294967296)/(1<<21)}while(0===n);return n},u.int32=e.next,u.quick=u,i&&(i.x&&o(i,e),u.state=function(){return o(e,{})}),u}t&&t.exports?t.exports=i:e&&e.amd?e(function(){return i}):this.xorshift7=i}(0,"object"==typeof module&&module,"function"==typeof n&&n);
},{}],"nNkA":[function(require,module,exports) {
var define;
var n;!function(n,t,e){function r(n){var t=this;t.next=function(){var n,e,r=t.w,o=t.X,u=t.i;return t.w=r=r+1640531527|0,e=o[u+34&127],n=o[u=u+1&127],e^=e<<13,n^=n<<17,e^=e>>>15,n^=n>>>12,e=o[u]=e^n,t.i=u,e+(r^r>>>16)|0},function(n,t){var e,r,o,u,i,c=[],f=128;for(t===(0|t)?(r=t,t=null):(t+="\0",r=0,f=Math.max(f,t.length)),o=0,u=-32;u<f;++u)t&&(r^=t.charCodeAt((u+32)%t.length)),0===u&&(i=r),r^=r<<10,r^=r>>>15,r^=r<<4,r^=r>>>13,u>=0&&(i=i+1640531527|0,o=0==(e=c[127&u]^=r+i)?o+1:0);for(o>=128&&(c[127&(t&&t.length||0)]=-1),o=127,u=512;u>0;--u)r=c[o+34&127],e=c[o=o+1&127],r^=r<<13,e^=e<<17,r^=r>>>15,e^=e>>>12,c[o]=r^e;n.w=i,n.X=c,n.i=o}(t,n)}function o(n,t){return t.i=n.i,t.w=n.w,t.X=n.X.slice(),t}function u(n,t){null==n&&(n=+new Date);var e=new r(n),u=t&&t.state,i=function(){return(e.next()>>>0)/4294967296};return i.double=function(){do{var n=((e.next()>>>11)+(e.next()>>>0)/4294967296)/(1<<21)}while(0===n);return n},i.int32=e.next,i.quick=i,u&&(u.X&&o(u,e),i.state=function(){return o(e,{})}),i}t&&t.exports?t.exports=u:e&&e.amd?e(function(){return u}):this.xor4096=u}(0,"object"==typeof module&&module,"function"==typeof n&&n);
},{}],"gMhV":[function(require,module,exports) {
var define;
var t;!function(t,n,e){function o(t){var n=this,e="";n.next=function(){var t=n.b,e=n.c,o=n.d,r=n.a;return t=t<<25^t>>>7^e,e=e-o|0,o=o<<24^o>>>8^r,r=r-t|0,n.b=t=t<<20^t>>>12^e,n.c=e=e-o|0,n.d=o<<16^e>>>16^r,n.a=r-t|0},n.a=0,n.b=0,n.c=-1640531527,n.d=1367130551,t===Math.floor(t)?(n.a=t/4294967296|0,n.b=0|t):e+=t;for(var o=0;o<e.length+20;o++)n.b^=0|e.charCodeAt(o),n.next()}function r(t,n){return n.a=t.a,n.b=t.b,n.c=t.c,n.d=t.d,n}function u(t,n){var e=new o(t),u=n&&n.state,c=function(){return(e.next()>>>0)/4294967296};return c.double=function(){do{var t=((e.next()>>>11)+(e.next()>>>0)/4294967296)/(1<<21)}while(0===t);return t},c.int32=e.next,c.quick=c,u&&("object"==typeof u&&r(u,e),c.state=function(){return r(e,{})}),c}n&&n.exports?n.exports=u:e&&e.amd?e(function(){return u}):this.tychei=u}(0,"object"==typeof module&&module,"function"==typeof t&&t);
},{}],"YOzy":[function(require,module,exports) {
var global = arguments[3];
var define;
var n,r=arguments[3];!function(r,t,e){var o,u=256,i=6,a="random",f=e.pow(u,i),c=e.pow(2,52),s=2*c,l=u-1;function p(n,l,p){var m=[],v=d(function n(r,t){var e,o=[],u=typeof r;if(t&&"object"==u)for(e in r)try{o.push(n(r[e],t-1))}catch(i){}return o.length?o:"string"==u?r:r+"\0"}((l=1==l?{entropy:!0}:l||{}).entropy?[n,h(t)]:null==n?function(){try{var n;return o&&(n=o.randomBytes)?n=n(u):(n=new Uint8Array(u),(r.crypto||r.msCrypto).getRandomValues(n)),h(n)}catch(a){var e=r.navigator,i=e&&e.plugins;return[+new Date,r,i,r.screen,h(t)]}}():n,3),m),j=new g(m),S=function(){for(var n=j.g(i),r=f,t=0;n<c;)n=(n+t)*u,r*=u,t=j.g(1);for(;n>=s;)n/=2,r/=2,t>>>=1;return(n+t)/r};return S.int32=function(){return 0|j.g(4)},S.quick=function(){return j.g(4)/4294967296},S.double=S,d(h(j.S),t),(l.pass||p||function(n,r,t,o){return o&&(o.S&&y(o,j),n.state=function(){return y(j,{})}),t?(e[a]=n,r):n})(S,v,"global"in l?l.global:this==e,l.state)}function g(n){var r,t=n.length,e=this,o=0,i=e.i=e.j=0,a=e.S=[];for(t||(n=[t++]);o<u;)a[o]=o++;for(o=0;o<u;o++)a[o]=a[i=l&i+n[o%t]+(r=a[o])],a[i]=r;(e.g=function(n){for(var r,t=0,o=e.i,i=e.j,a=e.S;n--;)r=a[o=l&o+1],t=t*u+a[l&(a[o]=a[i=l&i+r])+(a[i]=r)];return e.i=o,e.j=i,t})(u)}function y(n,r){return r.i=n.i,r.j=n.j,r.S=n.S.slice(),r}function d(n,r){for(var t,e=n+"",o=0;o<e.length;)r[l&o]=l&(t^=19*r[l&o])+e.charCodeAt(o++);return h(r)}function h(n){return String.fromCharCode.apply(0,n)}if(d(e.random(),t),"object"==typeof module&&module.exports){module.exports=p;try{o=require("crypto")}catch(m){}}else"function"==typeof n&&n.amd?n(function(){return p}):e["seed"+a]=p}("undefined"!=typeof self?self:this,[],Math);
},{"crypto":"ZOa0"}],"xt2p":[function(require,module,exports) {
var r=require("./lib/alea"),e=require("./lib/xor128"),i=require("./lib/xorwow"),o=require("./lib/xorshift7"),l=require("./lib/xor4096"),x=require("./lib/tychei"),u=require("./seedrandom");u.alea=r,u.xor128=e,u.xorwow=i,u.xorshift7=o,u.xor4096=l,u.tychei=x,module.exports=u;
},{"./lib/alea":"SSZJ","./lib/xor128":"C6rM","./lib/xorwow":"kkTl","./lib/xorshift7":"rUyN","./lib/xor4096":"nNkA","./lib/tychei":"gMhV","./seedrandom":"YOzy"}],"cFdt":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.TEST_EPSILON_FLOAT16=void 0,exports.createVideoElement=x,exports.encodeStrings=y,exports.expectArrayBuffersEqual=d,exports.expectArraysClose=i,exports.expectArraysEqual=c,exports.expectNumbersClose=p,exports.expectPromiseToFail=l,exports.expectValuesInRange=u,exports.play=h,exports.testEpsilon=a;var e=require("./engine"),t=require("./tensor_util_env"),r=require("./util");const n=.001,o=exports.TEST_EPSILON_FLOAT16=.1;function i(e,t,r){return null==r&&(r=a()),s(e,t,(e,t)=>f(e,t,r))}function a(){return 32===e.ENGINE.backend.floatPrecision()?n:o}function s(e,n,o){let i=!0;if(((0,r.isTypedArray)(e)||(0,r.isTypedArray)(n))&&(i=!1),(0,r.isTypedArray)(e)&&(0,r.isTypedArray)(n)&&(i=!0),i){const t=e.constructor.name,r=n.constructor.name;if(t!==r)throw new Error(`Arrays are of different type. Actual: ${t}. `+`Expected: ${r}`)}if(Array.isArray(e)&&Array.isArray(n)){const o=(0,t.inferShape)(e),i=(0,t.inferShape)(n);if(!(0,r.arraysEqual)(o,i))throw new Error("Arrays have different shapes. "+`Actual: [${o}]. Expected: [${i}]`)}const a=(0,r.isTypedArray)(e)?e:(0,r.flatten)(e),s=(0,r.isTypedArray)(n)?n:(0,r.flatten)(n);if(a.length!==s.length)throw new Error(`Arrays have different lengths actual: ${a.length} vs `+`expected: ${s.length}.\n`+`Actual:   ${a}.\n`+`Expected: ${s}.`);for(let t=0;t<s.length;++t){const e=a[t],r=s[t];if(!o(e,r))throw new Error(`Arrays differ: actual[${t}] = ${e}, expected[${t}] = ${r}.\n`+`Actual:   ${a}.\n`+`Expected: ${s}.`)}"undefined"!=typeof expect&&expect().nothing()}function l(e,t){e().then(()=>t.fail(),()=>t()),"undefined"!=typeof expect&&expect().nothing()}function c(e,t){const n="string"==typeof t||"number"==typeof t||"boolean"==typeof t?[t]:t;return(0,r.isString)(e)||(0,r.isString)(e[0])||(0,r.isString)(t)||(0,r.isString)(t[0])?s(e,n,(e,t)=>e==t):s(e,t,(e,t)=>f(e,t,0))}function p(e,t,r){if(null==r&&(r=a()),!f(e,t,r))throw new Error(`Numbers differ: actual === ${e}, expected === ${t}`);"undefined"!=typeof expect&&expect().nothing()}function f(e,t,r){return!isFinite(e)&&!isFinite(t)||!(isNaN(e)||isNaN(t)||Math.abs(e-t)>r)}function u(e,t,r){for(let n=0;n<e.length;n++)if(e[n]<t||e[n]>r)throw new Error(`Value out of range:${e[n]} low: ${t}, high: ${r}`)}function d(e,t){const r=new Float32Array(e),n=new Float32Array(t);if(r.length!==n.length)throw new Error("Expected ArrayBuffer to be of length "+`${n.length}, but it was ${r.length}`);for(let o=0;o<n.length;o++)if(r[o]!==n[o])throw new Error(`Expected ArrayBuffer value at ${o} to be `+`${n[o]} but got ${r[o]} instead`)}function y(e){for(let t=0;t<e.length;t++){const n=e[t];Array.isArray(n)?y(n):e[t]=(0,r.encodeString)(n)}return e}function x(e){const t=document.createElement("video");return"playsInline"in t&&(t.playsInline=!0),t.muted=!0,t.loop=!0,t.style.position="fixed",t.style.left="0px",t.style.top="0px",t.preload="auto",t.appendChild(e),new Promise(e=>{t.addEventListener("loadeddata",r=>e(t)),t.load()})}async function h(e){await e.play(),"requestVideoFrameCallback"in e&&await new Promise(t=>{e.requestVideoFrameCallback(t)})}
},{"./engine":"phT7","./tensor_util_env":"y4X4","./util":"XXxQ"}],"QLYL":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.UniformRandom=exports.RandGamma=exports.MPRandGauss=void 0,exports.expectArrayInMeanStdRange=i,exports.jarqueBeraNormalityTest=o;var t=n(require("seedrandom")),e=require("../test_util");function n(t,e){if("function"==typeof WeakMap)var r=new WeakMap,a=new WeakMap;return(n=function(t,e){if(!e&&t&&t.__esModule)return t;var n,s,o={__proto__:null,default:t};if(null===t||"object"!=typeof t&&"function"!=typeof t)return o;if(n=e?a:r){if(n.has(t))return n.get(t);n.set(t,o)}for(const r in t)"default"!==r&&{}.hasOwnProperty.call(t,r)&&((s=(n=Object.defineProperty)&&Object.getOwnPropertyDescriptor(t,r))&&(s.get||s.set)?n(o,r,s):o[r]=t[r]);return o})(t,e)}class r{constructor(e,n,r,a,s){this.mean=e,this.stdDev=n,this.dtype=r,this.nextVal=NaN,this.truncated=a,this.truncated&&(this.upper=this.mean+2*this.stdDev,this.lower=this.mean-2*this.stdDev);const o=s||Math.random();this.random=t.alea(o.toString())}nextValue(){if(!isNaN(this.nextVal)){const t=this.nextVal;return this.nextVal=NaN,t}let t,e,n=!1;for(;!n;){let r,a,s;do{s=(r=2*this.random()-1)*r+(a=2*this.random()-1)*a}while(s>=1||0===s);const o=Math.sqrt(-2*Math.log(s)/s);t=this.mean+this.stdDev*r*o,e=this.mean+this.stdDev*a*o,this.truncated&&!this.isValidTruncated(t)||(n=!0)}return this.truncated&&!this.isValidTruncated(e)||(this.nextVal=this.convertValue(e)),this.convertValue(t)}convertValue(t){return null==this.dtype||"float32"===this.dtype?t:Math.round(t)}isValidTruncated(t){return t<=this.upper&&t>=this.lower}}exports.MPRandGauss=r;class a{constructor(e,n,a,s){this.alpha=e,this.beta=1/n,this.dtype=a;const o=s||Math.random();this.randu=t.alea(o.toString()),this.randn=new r(0,1,a,!1,this.randu()),this.d=e<1?e+2/3:e-1/3,this.c=1/Math.sqrt(9*this.d)}nextValue(){let t,e,n,r,a,s;for(;;){do{r=this.randn.nextValue(),s=1+this.c*r}while(s<=0);if(s*=s*s,e=1-.331*(t=r*r)*t,n=.5*t+this.d*(1-s+Math.log(s)),(a=this.randu())<e||Math.log(a)<n)break}return s=1/this.beta*this.d*s,this.alpha<1&&(s*=Math.pow(this.randu(),1/this.alpha)),this.convertValue(s)}convertValue(t){return"float32"===this.dtype?t:Math.round(t)}}exports.RandGamma=a;class s{constructor(e=0,n=1,r,a){if(this.canReturnFloat=(()=>null==this.dtype||"float32"===this.dtype),this.min=e,this.range=n-e,this.dtype=r,null==a&&(a=Math.random()),"number"==typeof a&&(a=a.toString()),!this.canReturnFloat()&&this.range<=1)throw new Error(`The difference between ${e} - ${n} <= 1 and dtype is not float`);this.random=t.alea(a)}convertValue(t){return this.canReturnFloat()?t:Math.round(t)}nextValue(){return this.convertValue(this.min+this.range*this.random())}}function o(t){const e=t.length,n=d(t),r=u(t),a=e/6*(Math.pow(n,2)+.25*Math.pow(r-3,2));if(a>5.991)throw new Error(`Invalid p-value for JB: ${a}`)}function i(t,n,r,a){null==a&&(a=(0,e.testEpsilon)());const s=h(t);(0,e.expectNumbersClose)(s,n,a),(0,e.expectNumbersClose)(l(t,s),r,a)}function h(t){let e=0;for(let n=0;n<t.length;n++)e+=t[n];return e/t.length}function l(t,e){let n=0;for(let r=0;r<t.length;r++){const a=t[r]-e;n+=a*a}return Math.sqrt(n/t.length)}function u(t){const e=h(t),n=t.length;let r=0,a=0;for(let s=0;s<n;s++){const n=t[s]-e;r+=Math.pow(n,2),a+=Math.pow(n,4)}return 1/n*a/Math.pow(1/n*r,2)}function d(t){const e=h(t),n=t.length;let r=0,a=0;for(let s=0;s<n;s++){const n=t[s]-e;r+=Math.pow(n,2),a+=Math.pow(n,3)}return 1/n*a/Math.pow(1/(n-1)*r,1.5)}exports.UniformRandom=s;
},{"seedrandom":"xt2p","../test_util":"cFdt"}],"KZ1e":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.randomGamma=void 0;var e=require("../util_base"),r=require("./buffer"),t=require("./operation"),a=require("./rand_util");function o(t,o,n=1,u="float32",s){if((0,e.assertNonNegativeIntegerDimensions)(t),null==n&&(n=1),null==u&&(u="float32"),"float32"!==u&&"int32"!==u)throw new Error(`Unsupported data type ${u}`);const i=new a.RandGamma(o,n,u,s),l=(0,r.buffer)(t,u);for(let e=0;e<l.values.length;e++)l.values[e]=i.nextValue();return l.toTensor()}const n=exports.randomGamma=(0,t.op)({randomGamma_:o});
},{"../util_base":"uID4","./buffer":"GfO2","./operation":"uE86","./rand_util":"QLYL"}],"aurk":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.randomNormal=void 0;var e=require("../util_base"),r=require("./buffer"),o=require("./operation"),t=require("./rand_util");function n(o,n=0,a=1,s,u){if((0,e.assertNonNegativeIntegerDimensions)(o),null!=s&&"bool"===s)throw new Error(`Unsupported data type ${s}`);const i=new t.MPRandGauss(n,a,s,!1,u),l=(0,r.buffer)(o,s);for(let e=0;e<l.values.length;e++)l.values[e]=i.nextValue();return l.toTensor()}const a=exports.randomNormal=(0,o.op)({randomNormal_:n});
},{"../util_base":"uID4","./buffer":"GfO2","./operation":"uE86","./rand_util":"QLYL"}],"JQkW":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.randomStandardNormal=void 0;var r=require("./operation"),o=require("./random_normal");function a(r,a,e){if(null!=a&&"bool"===a)throw new Error(`Unsupported data type ${a}`);return(0,o.randomNormal)(r,0,1,a,e)}const e=exports.randomStandardNormal=(0,r.op)({randomStandardNormal_:a});
},{"./operation":"uE86","./random_normal":"aurk"}],"Imph":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.randomUniform=void 0;var e=require("../util_base"),r=require("./buffer"),o=require("./operation"),n=require("./rand_util");function t(o,t=0,i=1,u="float32",s){(0,e.assertNonNegativeIntegerDimensions)(o);const a=(0,r.buffer)(o,u),f=new n.UniformRandom(t,i,null,s);for(let e=0;e<a.values.length;e++)a.values[e]=f.nextValue();return a.toTensor()}const i=exports.randomUniform=(0,o.op)({randomUniform_:t});
},{"../util_base":"uID4","./buffer":"GfO2","./operation":"uE86","./rand_util":"QLYL"}],"LZig":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.randomUniformInt=void 0;var r=require("./operation"),o=require("./random_uniform");function n(r,n,e,t){return(0,o.randomUniform)(r,n,e,"int32",t)}const e=exports.randomUniformInt=(0,r.op)({randomUniformInt_:n});
},{"./operation":"uE86","./random_uniform":"Imph"}],"FAHd":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.range=t;var e=require("../engine"),r=require("../kernel_names");function t(t,n,o=1,s="float32"){if(0===o)throw new Error("Cannot have a step of zero");const a={start:t,stop:n,step:o,dtype:s};return e.ENGINE.runKernel(r.Range,{},a)}
},{"../engine":"phT7","../kernel_names":"rJl6"}],"j99O":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.real=void 0;var e=require("../engine"),r=require("../kernel_names"),n=require("../tensor_util_env"),t=require("./operation");function o(t){const o={input:(0,n.convertToTensor)(t,"input","real")};return e.ENGINE.runKernel(r.Real,o)}const i=exports.real=(0,t.op)({real_:o});
},{"../engine":"phT7","../kernel_names":"rJl6","../tensor_util_env":"y4X4","./operation":"uE86"}],"kFd0":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.reciprocal=void 0;var e=require("../engine"),r=require("../kernel_names"),o=require("../tensor_util_env"),n=require("./operation");function c(n){const c={x:(0,o.convertToTensor)(n,"x","reciprocal")};return e.ENGINE.runKernel(r.Reciprocal,c)}const i=exports.reciprocal=(0,n.op)({reciprocal_:c});
},{"../engine":"phT7","../kernel_names":"rJl6","../tensor_util_env":"y4X4","./operation":"uE86"}],"JbIg":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.relu=void 0;var e=require("../engine"),r=require("../kernel_names"),n=require("../tensor_util_env"),o=require("./operation");function u(o){const u={x:(0,n.convertToTensor)(o,"x","relu")};return e.ENGINE.runKernel(r.Relu,u)}const t=exports.relu=(0,o.op)({relu_:u});
},{"../engine":"phT7","../kernel_names":"rJl6","../tensor_util_env":"y4X4","./operation":"uE86"}],"urTr":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.relu6=void 0;var e=require("../engine"),r=require("../kernel_names"),n=require("../tensor_util_env"),o=require("./operation");function u(o){const u={x:(0,n.convertToTensor)(o,"x","relu6")};return e.ENGINE.runKernel(r.Relu6,u)}const t=exports.relu6=(0,o.op)({relu6_:u});
},{"../engine":"phT7","../kernel_names":"rJl6","../tensor_util_env":"y4X4","./operation":"uE86"}],"JJIO":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.reverse=void 0;var e=require("../engine"),r=require("../kernel_names"),n=require("../tensor_util_env"),s=require("./operation");function o(s,o){const t={x:(0,n.convertToTensor)(s,"x","reverse")},i={dims:o};return e.ENGINE.runKernel(r.Reverse,t,i)}const t=exports.reverse=(0,s.op)({reverse_:o});
},{"../engine":"phT7","../kernel_names":"rJl6","../tensor_util_env":"y4X4","./operation":"uE86"}],"AODX":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.reverse1d=void 0;var e=require("../tensor_util_env"),r=o(require("../util")),t=require("./operation"),n=require("./reverse");function o(e,r){if("function"==typeof WeakMap)var t=new WeakMap,n=new WeakMap;return(o=function(e,r){if(!r&&e&&e.__esModule)return e;var o,s,u={__proto__:null,default:e};if(null===e||"object"!=typeof e&&"function"!=typeof e)return u;if(o=r?n:t){if(o.has(e))return o.get(e);o.set(e,u)}for(const t in e)"default"!==t&&{}.hasOwnProperty.call(e,t)&&((s=(o=Object.defineProperty)&&Object.getOwnPropertyDescriptor(e,t))&&(s.get||s.set)?o(u,t,s):u[t]=e[t]);return u})(e,r)}function s(t){const o=(0,e.convertToTensor)(t,"x","reverse");return r.assert(1===o.rank,()=>`Error in reverse1D: x must be rank 1 but got rank ${o.rank}.`),(0,n.reverse)(o,0)}const u=exports.reverse1d=(0,t.op)({reverse1d_:s});
},{"../tensor_util_env":"y4X4","../util":"XXxQ","./operation":"uE86","./reverse":"JJIO"}],"JN76":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.reverse2d=void 0;var e=require("../tensor_util_env"),r=o(require("../util")),t=require("./operation"),n=require("./reverse");function o(e,r){if("function"==typeof WeakMap)var t=new WeakMap,n=new WeakMap;return(o=function(e,r){if(!r&&e&&e.__esModule)return e;var o,s,u={__proto__:null,default:e};if(null===e||"object"!=typeof e&&"function"!=typeof e)return u;if(o=r?n:t){if(o.has(e))return o.get(e);o.set(e,u)}for(const t in e)"default"!==t&&{}.hasOwnProperty.call(e,t)&&((s=(o=Object.defineProperty)&&Object.getOwnPropertyDescriptor(e,t))&&(s.get||s.set)?o(u,t,s):u[t]=e[t]);return u})(e,r)}function s(t,o){const s=(0,e.convertToTensor)(t,"x","reverse");return r.assert(2===s.rank,()=>`Error in reverse2D: x must be rank 2 but got rank ${s.rank}.`),(0,n.reverse)(s,o)}const u=exports.reverse2d=(0,t.op)({reverse2d_:s});
},{"../tensor_util_env":"y4X4","../util":"XXxQ","./operation":"uE86","./reverse":"JJIO"}],"hWz2":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.reverse3d=void 0;var e=require("../tensor_util_env"),r=o(require("../util")),t=require("./operation"),n=require("./reverse");function o(e,r){if("function"==typeof WeakMap)var t=new WeakMap,n=new WeakMap;return(o=function(e,r){if(!r&&e&&e.__esModule)return e;var o,s,u={__proto__:null,default:e};if(null===e||"object"!=typeof e&&"function"!=typeof e)return u;if(o=r?n:t){if(o.has(e))return o.get(e);o.set(e,u)}for(const t in e)"default"!==t&&{}.hasOwnProperty.call(e,t)&&((s=(o=Object.defineProperty)&&Object.getOwnPropertyDescriptor(e,t))&&(s.get||s.set)?o(u,t,s):u[t]=e[t]);return u})(e,r)}function s(t,o){const s=(0,e.convertToTensor)(t,"x","reverse");return r.assert(3===s.rank,()=>`Error in reverse3D: x must be rank 3 but got rank ${s.rank}.`),(0,n.reverse)(s,o)}const u=exports.reverse3d=(0,t.op)({reverse3d_:s});
},{"../tensor_util_env":"y4X4","../util":"XXxQ","./operation":"uE86","./reverse":"JJIO"}],"X21a":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.reverse4d=void 0;var e=require("../tensor_util_env"),r=o(require("../util")),t=require("./operation"),n=require("./reverse");function o(e,r){if("function"==typeof WeakMap)var t=new WeakMap,n=new WeakMap;return(o=function(e,r){if(!r&&e&&e.__esModule)return e;var o,s,u={__proto__:null,default:e};if(null===e||"object"!=typeof e&&"function"!=typeof e)return u;if(o=r?n:t){if(o.has(e))return o.get(e);o.set(e,u)}for(const t in e)"default"!==t&&{}.hasOwnProperty.call(e,t)&&((s=(o=Object.defineProperty)&&Object.getOwnPropertyDescriptor(e,t))&&(s.get||s.set)?o(u,t,s):u[t]=e[t]);return u})(e,r)}function s(t,o){const s=(0,e.convertToTensor)(t,"x","reverse");return r.assert(4===s.rank,()=>`Error in reverse4D: x must be rank 4 but got rank ${s.rank}.`),(0,n.reverse)(s,o)}const u=exports.reverse4d=(0,t.op)({reverse4d_:s});
},{"../tensor_util_env":"y4X4","../util":"XXxQ","./operation":"uE86","./reverse":"JJIO"}],"NMXN":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.round=void 0;var e=require("../engine"),r=require("../kernel_names"),n=require("../tensor_util_env"),o=require("./operation");function u(o){const u={x:(0,n.convertToTensor)(o,"x","round")};return e.ENGINE.runKernel(r.Round,u)}const t=exports.round=(0,o.op)({round_:u});
},{"../engine":"phT7","../kernel_names":"rJl6","../tensor_util_env":"y4X4","./operation":"uE86"}],"gHPL":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.rsqrt=void 0;var r=require("../engine"),e=require("../kernel_names"),t=require("../tensor_util_env"),n=require("./operation");function o(n){const o={x:(0,t.convertToTensor)(n,"x","rsqrt","float32")};return r.ENGINE.runKernel(e.Rsqrt,o)}const s=exports.rsqrt=(0,n.op)({rsqrt_:o});
},{"../engine":"phT7","../kernel_names":"rJl6","../tensor_util_env":"y4X4","./operation":"uE86"}],"HaUr":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.selu=void 0;var e=require("../engine"),r=require("../kernel_names"),n=require("../tensor_util_env"),o=require("./operation");function u(o){const u={x:(0,n.convertToTensor)(o,"x","selu")};return e.ENGINE.runKernel(r.Selu,u)}const s=exports.selu=(0,o.op)({selu_:u});
},{"../engine":"phT7","../kernel_names":"rJl6","../tensor_util_env":"y4X4","./operation":"uE86"}],"PKLM":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.separableConv2d=void 0;var e=require("../tensor_util_env"),r=a(require("../util")),t=require("./conv2d"),n=require("./depthwise_conv2d"),o=require("./operation"),s=require("./reshape");function a(e,r){if("function"==typeof WeakMap)var t=new WeakMap,n=new WeakMap;return(a=function(e,r){if(!r&&e&&e.__esModule)return e;var o,s,a={__proto__:null,default:e};if(null===e||"object"!=typeof e&&"function"!=typeof e)return a;if(o=r?n:t){if(o.has(e))return o.get(e);o.set(e,a)}for(const t in e)"default"!==t&&{}.hasOwnProperty.call(e,t)&&((s=(o=Object.defineProperty)&&Object.getOwnPropertyDescriptor(e,t))&&(s.get||s.set)?o(a,t,s):a[t]=e[t]);return a})(e,r)}function i(o,a,i,p,u,d=[1,1],l="NHWC"){const b=(0,e.convertToTensor)(o,"x","separableConv2d"),f=(0,e.convertToTensor)(a,"depthwiseFilter","separableConv2d"),h=(0,e.convertToTensor)(i,"pointwiseFilter","separableConv2d");let v=b,c=!1;if(3===b.rank&&(c=!0,v=(0,s.reshape)(b,[1,b.shape[0],b.shape[1],b.shape[2]])),"NCHW"===l)throw new Error("separableConv2d currently does not support dataFormat NCHW; only NHWC is supported");r.assert(4===v.rank,()=>"Error in separableConv2d: input must be rank 4, but got "+`rank ${v.rank}.`),r.assert(4===f.rank,()=>"Error in separableConv2d: depthwise filter must be rank 4, but "+`got rank ${f.rank}.`),r.assert(4===h.rank,()=>"Error in separableConv2d: pointwise filter must be rank 4, but "+`got rank ${f.rank}.`),r.assert(1===h.shape[0],()=>"Error in separableConv2d: the first dimension of pointwise filter "+` must be 1, but got ${h.shape[0]}.`),r.assert(1===h.shape[1],()=>"Error in separableConv2d: the second dimension of pointwise "+`filter must be 1, but got ${h.shape[1]}.`);const C=f.shape[2],k=f.shape[3];r.assert(h.shape[2]===C*k,()=>"Error in separableConv2d: the third dimension of pointwise filter "+`must be ${C*k}, `+`but got ${h.shape[2]}.`);const w=(0,n.depthwiseConv2d)(v,f,p,u,l,d),_=(0,t.conv2d)(w,h,1,"valid",l);return c?(0,s.reshape)(_,[_.shape[1],_.shape[2],_.shape[3]]):_}const p=exports.separableConv2d=(0,o.op)({separableConv2d_:i});
},{"../tensor_util_env":"y4X4","../util":"XXxQ","./conv2d":"CVMs","./depthwise_conv2d":"HEHz","./operation":"uE86","./reshape":"F0cm"}],"yk2k":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.setdiff1dAsync=void 0;var e=require("../tensor"),t=require("../tensor_util_env"),r=n(require("../util"));function n(e,t){if("function"==typeof WeakMap)var r=new WeakMap,o=new WeakMap;return(n=function(e,t){if(!t&&e&&e.__esModule)return e;var n,s,a={__proto__:null,default:e};if(null===e||"object"!=typeof e&&"function"!=typeof e)return a;if(n=t?o:r){if(n.has(e))return n.get(e);n.set(e,a)}for(const r in e)"default"!==r&&{}.hasOwnProperty.call(e,r)&&((s=(n=Object.defineProperty)&&Object.getOwnPropertyDescriptor(e,r))&&(s.get||s.set)?n(a,r,s):a[r]=e[r]);return a})(e,t)}async function o(n,o){const s=(0,t.convertToTensor)(n,"x","setdiff1d"),a=(0,t.convertToTensor)(o,"y","setdiff1d");r.assert(s.dtype===a.dtype,()=>`x and y should have the same dtype, but got x (${s.dtype}) and y (${a.dtype}).`),r.assert(1===s.rank,()=>`x should be 1D tensor, but got x (${s.shape}).`),r.assert(1===a.rank,()=>`y should be 1D tensor, but got y (${a.shape}).`);const u=await s.data(),f=await a.data(),d=new Set(f);let i=0;for(let e=0;e<u.length;e++)d.has(u[e])||i++;const l=new e.TensorBuffer([i],s.dtype),p=new e.TensorBuffer([i],"int32");for(let e=0,t=0;e<u.length;e++)d.has(u[e])||(l.values[t]=u[e],p.values[t]=e,t++);return[l.toTensor(),p.toTensor()]}const s=exports.setdiff1dAsync=o;
},{"../tensor":"eFW4","../tensor_util_env":"y4X4","../util":"XXxQ"}],"CH4E":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.sign=void 0;var e=require("../engine"),r=require("../kernel_names"),n=require("../tensor_util_env"),i=require("./operation");function o(i){const o={x:(0,n.convertToTensor)(i,"x","sign")};return e.ENGINE.runKernel(r.Sign,o)}const s=exports.sign=(0,i.op)({sign_:o});
},{"../engine":"phT7","../kernel_names":"rJl6","../tensor_util_env":"y4X4","./operation":"uE86"}],"zDLt":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.sin=void 0;var e=require("../engine"),r=require("../kernel_names"),n=require("../tensor_util_env"),o=require("./operation");function i(o){const i={x:(0,n.convertToTensor)(o,"x","sin","float32")};return e.ENGINE.runKernel(r.Sin,i)}const t=exports.sin=(0,o.op)({sin_:i});
},{"../engine":"phT7","../kernel_names":"rJl6","../tensor_util_env":"y4X4","./operation":"uE86"}],"DmYY":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.sinh=void 0;var e=require("../engine"),r=require("../kernel_names"),n=require("../tensor_util_env"),i=require("./operation");function o(i){const o={x:(0,n.convertToTensor)(i,"x","sinh")};return e.ENGINE.runKernel(r.Sinh,o)}const s=exports.sinh=(0,i.op)({sinh_:o});
},{"../engine":"phT7","../kernel_names":"rJl6","../tensor_util_env":"y4X4","./operation":"uE86"}],"vSl0":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.slice1d=void 0;var e=require("../tensor_util_env"),r=o(require("../util")),t=require("./operation"),n=require("./slice");function o(e,r){if("function"==typeof WeakMap)var t=new WeakMap,n=new WeakMap;return(o=function(e,r){if(!r&&e&&e.__esModule)return e;var o,i,s={__proto__:null,default:e};if(null===e||"object"!=typeof e&&"function"!=typeof e)return s;if(o=r?n:t){if(o.has(e))return o.get(e);o.set(e,s)}for(const t in e)"default"!==t&&{}.hasOwnProperty.call(e,t)&&((i=(o=Object.defineProperty)&&Object.getOwnPropertyDescriptor(e,t))&&(i.get||i.set)?o(s,t,i):s[t]=e[t]);return s})(e,r)}function i(t,o,i){const s=(0,e.convertToTensor)(t,"x","slice1d");return r.assert(1===s.rank,()=>`slice1d expects a rank-1 tensor, but got a rank-${s.rank} tensor`),(0,n.slice)(s,[o],[i])}const s=exports.slice1d=(0,t.op)({slice1d_:i});
},{"../tensor_util_env":"y4X4","../util":"XXxQ","./operation":"uE86","./slice":"wIos"}],"bSki":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.slice2d=void 0;var e=require("../tensor_util_env"),r=o(require("../util")),t=require("./operation"),n=require("./slice");function o(e,r){if("function"==typeof WeakMap)var t=new WeakMap,n=new WeakMap;return(o=function(e,r){if(!r&&e&&e.__esModule)return e;var o,i,s={__proto__:null,default:e};if(null===e||"object"!=typeof e&&"function"!=typeof e)return s;if(o=r?n:t){if(o.has(e))return o.get(e);o.set(e,s)}for(const t in e)"default"!==t&&{}.hasOwnProperty.call(e,t)&&((i=(o=Object.defineProperty)&&Object.getOwnPropertyDescriptor(e,t))&&(i.get||i.set)?o(s,t,i):s[t]=e[t]);return s})(e,r)}function i(t,o,i){const s=(0,e.convertToTensor)(t,"x","slice2d");return r.assert(2===s.rank,()=>`slice2d expects a rank-2 tensor, but got a rank-${s.rank} tensor`),(0,n.slice)(s,o,i)}const s=exports.slice2d=(0,t.op)({slice2d_:i});
},{"../tensor_util_env":"y4X4","../util":"XXxQ","./operation":"uE86","./slice":"wIos"}],"c5n3":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.slice3d=void 0;var e=require("../tensor_util_env"),r=o(require("../util")),t=require("./operation"),n=require("./slice");function o(e,r){if("function"==typeof WeakMap)var t=new WeakMap,n=new WeakMap;return(o=function(e,r){if(!r&&e&&e.__esModule)return e;var o,i,s={__proto__:null,default:e};if(null===e||"object"!=typeof e&&"function"!=typeof e)return s;if(o=r?n:t){if(o.has(e))return o.get(e);o.set(e,s)}for(const t in e)"default"!==t&&{}.hasOwnProperty.call(e,t)&&((i=(o=Object.defineProperty)&&Object.getOwnPropertyDescriptor(e,t))&&(i.get||i.set)?o(s,t,i):s[t]=e[t]);return s})(e,r)}function i(t,o,i){const s=(0,e.convertToTensor)(t,"x","slice3d");return r.assert(3===s.rank,()=>`slice3d expects a rank-3 tensor, but got a rank-${s.rank} tensor`),(0,n.slice)(s,o,i)}const s=exports.slice3d=(0,t.op)({slice3d_:i});
},{"../tensor_util_env":"y4X4","../util":"XXxQ","./operation":"uE86","./slice":"wIos"}],"EHN5":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.slice4d=void 0;var e=require("../tensor_util_env"),r=o(require("../util")),t=require("./operation"),n=require("./slice");function o(e,r){if("function"==typeof WeakMap)var t=new WeakMap,n=new WeakMap;return(o=function(e,r){if(!r&&e&&e.__esModule)return e;var o,i,s={__proto__:null,default:e};if(null===e||"object"!=typeof e&&"function"!=typeof e)return s;if(o=r?n:t){if(o.has(e))return o.get(e);o.set(e,s)}for(const t in e)"default"!==t&&{}.hasOwnProperty.call(e,t)&&((i=(o=Object.defineProperty)&&Object.getOwnPropertyDescriptor(e,t))&&(i.get||i.set)?o(s,t,i):s[t]=e[t]);return s})(e,r)}function i(t,o,i){const s=(0,e.convertToTensor)(t,"x","slice4d");return r.assert(4===s.rank,()=>`slice4d expects a rank-4 tensor, but got a rank-${s.rank} tensor`),(0,n.slice)(s,o,i)}const s=exports.slice4d=(0,t.op)({slice4d_:i});
},{"../tensor_util_env":"y4X4","../util":"XXxQ","./operation":"uE86","./slice":"wIos"}],"TVVR":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.softmax=void 0;var e=require("../engine"),o=require("../kernel_names"),r=require("../tensor_util_env"),t=require("./operation");function n(t,n=-1){const s=(0,r.convertToTensor)(t,"logits","softmax","float32");if(-1===n&&(n=s.rank-1),n!==s.rank-1)throw Error("Softmax along a non-last dimension is not yet supported. "+`Logits was rank ${s.rank} and dim was ${n}`);const a={logits:s},i={dim:n};return e.ENGINE.runKernel(o.Softmax,a,i)}const s=exports.softmax=(0,t.op)({softmax_:n});
},{"../engine":"phT7","../kernel_names":"rJl6","../tensor_util_env":"y4X4","./operation":"uE86"}],"lRSx":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.fft=void 0;var e=require("../../engine"),t=require("../../kernel_names"),r=require("../../util"),o=require("../operation");function n(o){(0,r.assert)("complex64"===o.dtype,()=>"The dtype for tf.spectral.fft() must be complex64 "+`but got ${o.dtype}.`);const n={input:o};return e.ENGINE.runKernel(t.FFT,n)}const u=exports.fft=(0,o.op)({fft_:n});
},{"../../engine":"phT7","../../kernel_names":"rJl6","../../util":"XXxQ","../operation":"uE86"}],"G5kM":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.ifft=void 0;var e=require("../../engine"),t=require("../../kernel_names"),r=require("../../util"),i=require("../operation");function o(i){(0,r.assert)("complex64"===i.dtype,()=>"The dtype for tf.spectral.ifft() must be complex64 "+`but got ${i.dtype}.`);const o={input:i};return e.ENGINE.runKernel(t.IFFT,o)}const n=exports.ifft=(0,i.op)({ifft_:o});
},{"../../engine":"phT7","../../kernel_names":"rJl6","../../util":"XXxQ","../operation":"uE86"}],"Yh9k":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.irfft=void 0;var e=require("../complex"),r=require("../concat"),s=require("../imag"),i=require("../mul"),a=require("../operation"),t=require("../real"),c=require("../reshape"),o=require("../reverse"),p=require("../scalar"),u=require("../slice"),l=require("./ifft");function f(a){const f=a.shape[a.shape.length-1],n=a.size/f;let h;if(f<=2){const e=(0,c.reshape)(a,[n,f]);h=(0,l.ifft)(e)}else{const q=[n,2*(f-1)],m=(0,c.reshape)((0,t.real)(a),[n,f]),v=(0,c.reshape)((0,s.imag)(a),[n,f]),x=(0,o.reverse)((0,u.slice)(m,[0,1],[n,f-2]),1),d=(0,i.mul)((0,o.reverse)((0,u.slice)(v,[0,1],[n,f-2]),1),(0,p.scalar)(-1)),g=(0,r.concat)([m,x],1),_=(0,r.concat)([v,d],1),b=(0,c.reshape)((0,e.complex)(g,_),[q[0],q[1]]);h=(0,l.ifft)(b)}if(h=(0,t.real)(h),3===a.rank&&0!==a.shape[0]){const e=h,r=a.shape[0];h=(0,c.reshape)(h,[r,h.shape[0]/r,h.shape[1]]),e.dispose()}return h}const n=exports.irfft=(0,a.op)({irfft_:f});
},{"../complex":"e4je","../concat":"V5Ij","../imag":"eG10","../mul":"tBJ4","../operation":"uE86","../real":"j99O","../reshape":"F0cm","../reverse":"JJIO","../scalar":"TiGU","../slice":"wIos","./ifft":"G5kM"}],"lgPf":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.split=void 0;var e=require("../engine"),r=require("../kernel_names"),t=require("../tensor_util_env"),i=require("./operation");function n(i,n,s=0){const o={x:(0,t.convertToTensor)(i,"x","split")},p={numOrSizeSplits:n,axis:s};return e.ENGINE.runKernel(r.SplitV,o,p)}const s=exports.split=(0,i.op)({split_:n});
},{"../engine":"phT7","../kernel_names":"rJl6","../tensor_util_env":"y4X4","./operation":"uE86"}],"FMnE":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.rfft=void 0;var e=require("../../util"),r=require("../complex"),t=require("../concat"),s=require("../imag"),l=require("../operation"),p=require("../real"),a=require("../reshape"),i=require("../slice"),o=require("../split"),h=require("../zeros"),u=require("../zeros_like"),n=require("./fft");function f(l,f){(0,e.assert)("float32"===l.dtype,()=>`The dtype for rfft() must be real value but got ${l.dtype}`);let c=l.shape[l.shape.length-1];const q=l.size/c;let g;if(null!=f&&f<c){const e=l.shape.map(e=>0),r=l.shape.map(e=>e);r[l.shape.length-1]=f,g=(0,i.slice)(l,e,r),c=f}else if(null!=f&&f>c){const e=l.shape.map(e=>e);e[l.shape.length-1]=f-c,g=(0,t.concat)([l,(0,h.zeros)(e)],l.shape.length-1),c=f}else g=l;const m=(0,u.zerosLike)(g),d=(0,a.reshape)((0,r.complex)(g,m),[q,c]),x=(0,n.fft)(d),z=Math.floor(c/2)+1,v=(0,p.real)(x),y=(0,s.imag)(x),_=(0,o.split)(v,[z,c-z],v.shape.length-1),b=(0,o.split)(y,[z,c-z],y.shape.length-1),k=g.shape.slice();return k[g.shape.length-1]=z,(0,a.reshape)((0,r.complex)(_[0],b[0]),k)}const c=exports.rfft=(0,l.op)({rfft_:f});
},{"../../util":"XXxQ","../complex":"e4je","../concat":"V5Ij","../imag":"eG10","../operation":"uE86","../real":"j99O","../reshape":"F0cm","../slice":"wIos","../split":"lgPf","../zeros":"AsfN","../zeros_like":"qY0o","./fft":"lRSx"}],"hbAV":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.squaredDifference=void 0;var e=require("../engine"),r=require("../kernel_names"),n=require("../tensor_util"),s=require("../tensor_util_env"),t=require("./broadcast_util"),a=require("./operation");function o(a,o){let i=(0,s.convertToTensor)(a,"a","squaredDifference"),u=(0,s.convertToTensor)(o,"b","squaredDifference");[i,u]=(0,n.makeTypesMatch)(i,u),(0,t.assertAndGetBroadcastShape)(i.shape,u.shape);const c={a:i,b:u};return e.ENGINE.runKernel(r.SquaredDifference,c,{})}const i=exports.squaredDifference=(0,a.op)({squaredDifference_:o});
},{"../engine":"phT7","../kernel_names":"rJl6","../tensor_util":"wtFc","../tensor_util_env":"y4X4","./broadcast_util":"fD2T","./operation":"uE86"}],"pxYL":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.squeeze=void 0;var e=require("../tensor_util_env"),r=require("../util"),s=require("./operation"),o=require("./reshape");function t(s,t){const u=(0,e.convertToTensor)(s,"x","squeeze","string_or_numeric");return(0,o.reshape)(u,(0,r.squeezeShape)(u.shape,t).newShape)}const u=exports.squeeze=(0,s.op)({squeeze_:t});
},{"../tensor_util_env":"y4X4","../util":"XXxQ","./operation":"uE86","./reshape":"F0cm"}],"Wzzr":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.stack=void 0;var e=require("../engine"),t=require("../kernel_names"),r=require("../tensor_util_env"),n=s(require("../util")),o=require("./operation");function s(e,t){if("function"==typeof WeakMap)var r=new WeakMap,n=new WeakMap;return(s=function(e,t){if(!t&&e&&e.__esModule)return e;var o,s,a={__proto__:null,default:e};if(null===e||"object"!=typeof e&&"function"!=typeof e)return a;if(o=t?n:r){if(o.has(e))return o.get(e);o.set(e,a)}for(const r in e)"default"!==r&&{}.hasOwnProperty.call(e,r)&&((s=(o=Object.defineProperty)&&Object.getOwnPropertyDescriptor(e,r))&&(s.get||s.set)?o(a,r,s):a[r]=e[r]);return a})(e,t)}function a(o,s=0){const a=(0,r.convertToTensorArray)(o,"tensors","stack","string_or_numeric");n.assert(a.length>=1,()=>"Pass at least one tensor to tf.stack"),a.length>0&&n.assert(s<=a[0].rank,()=>"Axis must be <= rank of the tensor");const i=a,u={axis:s};return e.ENGINE.runKernel(t.Pack,i,u)}const i=exports.stack=(0,o.op)({stack_:a});
},{"../engine":"phT7","../kernel_names":"rJl6","../tensor_util_env":"y4X4","../util":"XXxQ","./operation":"uE86"}],"vRkD":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.step=void 0;var e=require("../engine"),r=require("../kernel_names"),t=require("../tensor_util_env"),n=require("./operation");function o(n,o=0){const s={x:(0,t.convertToTensor)(n,"x","step")},p={alpha:o};return e.ENGINE.runKernel(r.Step,s,p)}const s=exports.step=(0,n.op)({step_:o});
},{"../engine":"phT7","../kernel_names":"rJl6","../tensor_util_env":"y4X4","./operation":"uE86"}],"quwm":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.stridedSlice=void 0;var e=require("../engine"),r=require("../kernel_names"),i=require("../tensor_util_env"),s=require("./operation");function n(s,n,t,o,d=0,c=0,l=0,u=0,a=0){const _={x:(0,i.convertToTensor)(s,"x","stridedSlice","string_or_numeric")},k={begin:n,end:t,strides:o,beginMask:d,endMask:c,ellipsisMask:l,newAxisMask:u,shrinkAxisMask:a};return e.ENGINE.runKernel(r.StridedSlice,_,k)}const t=exports.stridedSlice=(0,s.op)({stridedSlice_:n});
},{"../engine":"phT7","../kernel_names":"rJl6","../tensor_util_env":"y4X4","./operation":"uE86"}],"fQEZ":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.tan=void 0;var e=require("../engine"),r=require("../kernel_names"),n=require("../tensor_util_env"),t=require("./operation");function o(t){const o={x:(0,n.convertToTensor)(t,"x","tan","float32")};return e.ENGINE.runKernel(r.Tan,o)}const i=exports.tan=(0,t.op)({tan_:o});
},{"../engine":"phT7","../kernel_names":"rJl6","../tensor_util_env":"y4X4","./operation":"uE86"}],"vKgg":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.tensor1d=n;var e=require("../tensor_util_env"),r=require("../util"),t=require("./tensor_ops_util");function n(n,o){(0,r.assertNonNull)(n);const s=(0,e.inferShape)(n,o);if(1!==s.length)throw new Error("tensor1d() requires values to be a flat/TypedArray");return(0,t.makeTensor)(n,null,s,o)}
},{"../tensor_util_env":"y4X4","../util":"XXxQ","./tensor_ops_util":"HKvD"}],"UEzj":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.tensor2d=n;var e=require("../tensor_util_env"),r=require("../util"),t=require("./tensor_ops_util");function n(n,o,s){if((0,r.assertNonNull)(n),null!=o&&2!==o.length)throw new Error("tensor2d() requires shape to have two numbers");const u=(0,e.inferShape)(n,s);if(2!==u.length&&1!==u.length)throw new Error("tensor2d() requires values to be number[][] or flat/TypedArray");if(1===u.length&&null==o)throw new Error("tensor2d() requires shape to be provided when `values` are a flat/TypedArray");return(0,t.makeTensor)(n,o,u,s)}
},{"../tensor_util_env":"y4X4","../util":"XXxQ","./tensor_ops_util":"HKvD"}],"gE0c":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.tensor3d=n;var e=require("../tensor_util_env"),r=require("../util"),t=require("./tensor_ops_util");function n(n,o,s){if((0,r.assertNonNull)(n),null!=o&&3!==o.length)throw new Error("tensor3d() requires shape to have three numbers");const u=(0,e.inferShape)(n,s);if(3!==u.length&&1!==u.length)throw new Error("tensor3d() requires values to be number[][][] or flat/TypedArray");if(1===u.length&&null==o)throw new Error("tensor3d() requires shape to be provided when `values` are a flat array");return(0,t.makeTensor)(n,o,u,s)}
},{"../tensor_util_env":"y4X4","../util":"XXxQ","./tensor_ops_util":"HKvD"}],"CbDo":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.tensor4d=n;var e=require("../tensor_util_env"),r=require("../util"),t=require("./tensor_ops_util");function n(n,o,s){if((0,r.assertNonNull)(n),null!=o&&4!==o.length)throw new Error("tensor4d() requires shape to have four numbers");const u=(0,e.inferShape)(n,s);if(4!==u.length&&1!==u.length)throw new Error("tensor4d() requires values to be number[][][][] or flat/TypedArray");if(1===u.length&&null==o)throw new Error("tensor4d() requires shape to be provided when `values` are a flat array");return(0,t.makeTensor)(n,o,u,s)}
},{"../tensor_util_env":"y4X4","../util":"XXxQ","./tensor_ops_util":"HKvD"}],"ViEa":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.tensor5d=n;var e=require("../tensor_util_env"),r=require("../util"),t=require("./tensor_ops_util");function n(n,o,s){if((0,r.assertNonNull)(n),null!=o&&5!==o.length)throw new Error("tensor5d() requires shape to have five numbers");const u=(0,e.inferShape)(n,s);if(5!==u.length&&1!==u.length)throw new Error("tensor5d() requires values to be number[][][][][] or flat/TypedArray");if(1===u.length&&null==o)throw new Error("tensor5d() requires shape to be provided when `values` are a flat array");return(0,t.makeTensor)(n,o,u,s)}
},{"../tensor_util_env":"y4X4","../util":"XXxQ","./tensor_ops_util":"HKvD"}],"j89l":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.tensor6d=n;var e=require("../tensor_util_env"),r=require("../util"),t=require("./tensor_ops_util");function n(n,o,s){if((0,r.assertNonNull)(n),null!=o&&6!==o.length)throw new Error("tensor6d() requires shape to have six numbers");const u=(0,e.inferShape)(n,s);if(6!==u.length&&1!==u.length)throw new Error("tensor6d() requires values to be number[][][][][][] or flat/TypedArray");if(1===u.length&&null==o)throw new Error("tensor6d() requires shape to be provided when `values` are a flat array");return o=o||u,(0,t.makeTensor)(n,o,u,s)}
},{"../tensor_util_env":"y4X4","../util":"XXxQ","./tensor_ops_util":"HKvD"}],"keWG":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.calculateShapes=a,exports.validateInput=r,exports.validateUpdateShape=t;var e=require("../util");function t(e,t,r){const a=t.rank>1?t.shape[t.rank-1]:1,s=t.rank>1?t.rank-1:1,p="Must have updates.shape = indices.shape[:batchDim] + "+`shape[sliceDim:], got updates.shape: ${r.shape}`+`, indices.shape: ${t.shape}, shape: ${e}`+`, sliceDim: ${a}, and batchDim: ${s}.`;if(r.rank<s)throw new Error(p+` update.rank < ${s}. `);if(e.length<a+(r.rank-s))throw new Error(p+` Output shape length < ${a+(r.rank-s)}`);if(r.rank!==s+e.length-a)throw new Error(p+` update.rank != ${s+e.length-a}`);for(let h=0;h<s;++h)if(r.shape[h]!==t.shape[h])throw new Error(p+` updates.shape[${h}] (${r.shape[h]}) != indices.shape[${h}] (${t.shape[h]}).`);for(let h=0;h<r.rank-s;++h)if(r.shape[h+s]!==e[h+a])throw new Error(p+` updates.shape[${h+s}] (${r.shape[h+s]}) != shape[${h+s}] (${e[h+s]})`)}function r(e,r,a){if(r.rank<1)throw new Error("tf.scatterND() expects the indices to be rank 1 or higher,"+` but the rank was ${r.rank}.`);if(e.rank<1)throw new Error("tf.scatterND() expects the updates to be rank 1 or higher,"+` but the rank was ${e.rank}.`);if("int32"!==r.dtype)throw new Error(`The dtype of 'indices' should be int32, but got dtype: ${r.dtype}`);if(a.length<1)throw new Error(`Output rank must be greater or equal to 1, but got shape: ${a}`);if(0===a.length){if(0===r.size)throw new Error(`Indices specified for empty output. indices shape: ${r.shape}`);if(0===e.size)throw new Error(`Updates specified for empty output. updates shape: ${e.shape}`)}t(a,r,e)}function a(t,r,a){const s=r.shape.length,p=s>1?r.shape[s-1]:1,h=a.length;let n=1;for(let e=p;e<h;++e)n*=a[e];const i=p<1?1:p;return{sliceRank:p,numUpdates:(0,e.sizeFromShape)(r.shape)/i,sliceSize:n,strides:[...(0,e.computeStrides)(a.slice(0,p)),1],outputSize:(0,e.sizeFromShape)(a)}}
},{"../util":"XXxQ"}],"u9R8":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.tensorScatterUpdate=void 0;var e=require("../engine"),t=require("../kernel_names"),r=require("../tensor_util_env"),n=require("./operation"),o=a(require("./scatter_nd_util"));function a(e,t){if("function"==typeof WeakMap)var r=new WeakMap,n=new WeakMap;return(a=function(e,t){if(!t&&e&&e.__esModule)return e;var o,a,s={__proto__:null,default:e};if(null===e||"object"!=typeof e&&"function"!=typeof e)return s;if(o=t?n:r){if(o.has(e))return o.get(e);o.set(e,s)}for(const r in e)"default"!==r&&{}.hasOwnProperty.call(e,r)&&((a=(o=Object.defineProperty)&&Object.getOwnPropertyDescriptor(e,r))&&(a.get||a.set)?o(s,r,a):s[r]=e[r]);return s})(e,t)}function s(n,a,s){const u=(0,r.convertToTensor)(n,"tensor","tensorScatterupdate"),p=(0,r.convertToTensor)(a,"indices","tensorScatterupdate","int32"),i=(0,r.convertToTensor)(s,"updates","tensorScatterupdate");if(o.validateInput(i,p,u.shape),u.dtype!==i.dtype)throw new Error(`tensor and updates must have the same dtype, instead they are ${u.dtype} and ${i.dtype}.`);const c={tensor:u,indices:p,updates:i};return e.ENGINE.runKernel(t.TensorScatterUpdate,c,{})}const u=exports.tensorScatterUpdate=(0,n.op)({tensorScatterUpdate_:s});
},{"../engine":"phT7","../kernel_names":"rJl6","../tensor_util_env":"y4X4","./operation":"uE86","./scatter_nd_util":"keWG"}],"Hv3o":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.topk=void 0;var e=require("../engine"),t=require("../kernel_names"),o=require("../tensor_util_env"),r=require("./operation");function n(r,n=1,s=!0){const i=(0,o.convertToTensor)(r,"x","topk");if(0===i.rank)throw new Error("topk() expects the input to be of rank 1 or higher");const p=i.shape[i.shape.length-1];if(n<0)throw new Error(`'k' passed to topk() must be >= 0 but got ${n}`);if(n>p)throw new Error(`'k' passed to topk() must be <= the last dimension (${p}) `+`but got ${n}`);const u={x:i},k={k:n,sorted:s},[a,c]=e.ENGINE.runKernel(t.TopK,u,k);return{values:a,indices:c}}const s=exports.topk=(0,r.op)({topk_:n});
},{"../engine":"phT7","../kernel_names":"rJl6","../tensor_util_env":"y4X4","./operation":"uE86"}],"YHjl":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.truncatedNormal=void 0;var e=require("../util_base"),r=require("./buffer"),t=require("./operation"),o=require("./rand_util");function n(t,n=0,u=1,a,s){if((0,e.assertNonNegativeIntegerDimensions)(t),null!=a&&"bool"===a)throw new Error("Unsupported data type $ { dtype }");const i=new o.MPRandGauss(n,u,a,!0,s),l=(0,r.buffer)(t,a);for(let e=0;e<l.values.length;e++)l.values[e]=i.nextValue();return l.toTensor()}const u=exports.truncatedNormal=(0,t.op)({truncatedNormal_:n});
},{"../util_base":"uID4","./buffer":"GfO2","./operation":"uE86","./rand_util":"QLYL"}],"LuF4":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.unique=void 0;var e=require("../engine"),r=require("../kernel_names"),n=require("../tensor_util_env"),u=require("../util"),i=require("./operation");function t(i,t=0){const s=(0,n.convertToTensor)(i,"x","unique","string_or_numeric");(0,u.assert)(s.rank>0,()=>"The input tensor must be at least 1D");const o={x:s},a={axis:t},[q,c]=e.ENGINE.runKernel(r.Unique,o,a);return{values:q,indices:c}}const s=exports.unique=(0,i.op)({unique_:t});
},{"../engine":"phT7","../kernel_names":"rJl6","../tensor_util_env":"y4X4","../util":"XXxQ","./operation":"uE86"}],"oY1I":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.unsortedSegmentSum=void 0;var e=require("../engine"),n=require("../kernel_names"),t=require("../tensor_util_env"),r=require("../util"),s=require("./operation");function o(s,o,u){const m=(0,t.convertToTensor)(s,"x","unsortedSegmentSum"),i=(0,t.convertToTensor)(o,"segmentIds","unsortedSegmentSum","int32");(0,r.assert)((0,r.isInt)(u),()=>"numSegments must be of dtype int");const S={x:m,segmentIds:i},d={numSegments:u};return e.ENGINE.runKernel(n.UnsortedSegmentSum,S,d)}const u=exports.unsortedSegmentSum=(0,s.op)({unsortedSegmentSum_:o});
},{"../engine":"phT7","../kernel_names":"rJl6","../tensor_util_env":"y4X4","../util":"XXxQ","./operation":"uE86"}],"Smo9":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.unstack=void 0;var e=require("../engine"),t=require("../kernel_names"),n=require("../tensor_util_env"),r=s(require("../util")),o=require("./operation");function s(e,t){if("function"==typeof WeakMap)var n=new WeakMap,r=new WeakMap;return(s=function(e,t){if(!t&&e&&e.__esModule)return e;var o,s,u={__proto__:null,default:e};if(null===e||"object"!=typeof e&&"function"!=typeof e)return u;if(o=t?r:n){if(o.has(e))return o.get(e);o.set(e,u)}for(const n in e)"default"!==n&&{}.hasOwnProperty.call(e,n)&&((s=(o=Object.defineProperty)&&Object.getOwnPropertyDescriptor(e,n))&&(s.get||s.set)?o(u,n,s):u[n]=e[n]);return u})(e,t)}function u(o,s=0){const u=(0,n.convertToTensor)(o,"x","unstack","string_or_numeric");r.assert(s>=-u.shape.length&&s<u.shape.length,()=>`Axis = ${s} is not in [-${u.shape.length}, ${u.shape.length})`);const i={value:u},a={axis:s};return e.ENGINE.runKernel(t.Unpack,i,a)}const i=exports.unstack=(0,o.op)({unstack_:u});
},{"../engine":"phT7","../kernel_names":"rJl6","../tensor_util_env":"y4X4","../util":"XXxQ","./operation":"uE86"}],"KAw5":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.upperBound=r;var e=require("./search_sorted");function r(r,t){return(0,e.searchSorted)(r,t,"right")}
},{"./search_sorted":"izso"}],"dH8d":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.variable=r;var e=require("../engine");function r(r,t=!0,a,i){return e.ENGINE.makeVariable(r,t,a,i)}
},{"../engine":"phT7"}],"ebhY":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.whereImpl=t;var e=require("../ops/buffer");function t(t,r){const n=[];for(let e=0;e<r.length;e++)r[e]&&n.push(e);const o=(0,e.buffer)(t,"int32"),s=(0,e.buffer)([n.length,t.length],"int32");for(let e=0;e<n.length;e++){const r=o.indexToLoc(n[e]),l=e*t.length;s.values.set(r,l)}return s.toTensor()}
},{"../ops/buffer":"GfO2"}],"moUh":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.whereAsync=void 0;var e=require("../backends/where_impl"),r=require("../tensor_util_env");async function o(o){const s=(0,r.convertToTensor)(o,"condition","whereAsync","bool"),n=await s.data(),t=(0,e.whereImpl)(s.shape,n);return o!==s&&s.dispose(),t}const s=exports.whereAsync=o;
},{"../backends/where_impl":"ebhY","../tensor_util_env":"y4X4"}],"JMVl":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.booleanMaskAsync=void 0;var e=require("../tensor_util_env"),s=a(require("../util")),r=require("./gather"),t=require("./reshape"),o=require("./squeeze"),n=require("./where_async");function a(e,s){if("function"==typeof WeakMap)var r=new WeakMap,t=new WeakMap;return(a=function(e,s){if(!s&&e&&e.__esModule)return e;var o,n,a={__proto__:null,default:e};if(null===e||"object"!=typeof e&&"function"!=typeof e)return a;if(o=s?t:r){if(o.has(e))return o.get(e);o.set(e,a)}for(const r in e)"default"!==r&&{}.hasOwnProperty.call(e,r)&&((n=(o=Object.defineProperty)&&Object.getOwnPropertyDescriptor(e,r))&&(n.get||n.set)?o(a,r,n):a[r]=e[r]);return a})(e,s)}async function i(a,i,c){const u=(0,e.convertToTensor)(a,"tensor","boolMask"),p=(0,e.convertToTensor)(i,"mask","boolMask","bool"),l=null==c?0:c,f=p.rank,h=u.shape;s.assert(f>0,()=>"mask cannot be scalar"),s.assertShapesMatch(h.slice(l,l+f),p.shape,"mask's shape must match the first K dimensions of tensor's shape,");let d=1;for(let e=l;e<l+f;e++)d*=h[e];const y=h.slice(0,l).concat([d],h.slice(l+f)),k=(0,t.reshape)(u,y),_=(0,t.reshape)(p,[-1]),b=await(0,n.whereAsync)(_),M=(0,o.squeeze)(b,[1]),q=(0,r.gather)(k,M,l);return a!==u&&u.dispose(),i!==p&&p.dispose(),M.dispose(),k.dispose(),_.dispose(),b.dispose(),q}const c=exports.booleanMaskAsync=i;
},{"../tensor_util_env":"y4X4","../util":"XXxQ","./gather":"TfxI","./reshape":"F0cm","./squeeze":"pxYL","./where_async":"moUh"}],"JmRY":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.transpose=void 0;var e=require("../engine"),r=require("../globals"),n=require("../kernel_names"),t=require("../tensor_util_env"),o=l(require("../util")),s=require("./complex"),a=require("./imag"),u=require("./neg"),i=require("./operation"),p=require("./real");function l(e,r){if("function"==typeof WeakMap)var n=new WeakMap,t=new WeakMap;return(l=function(e,r){if(!r&&e&&e.__esModule)return e;var o,s,a={__proto__:null,default:e};if(null===e||"object"!=typeof e&&"function"!=typeof e)return a;if(o=r?t:n){if(o.has(e))return o.get(e);o.set(e,a)}for(const n in e)"default"!==n&&{}.hasOwnProperty.call(e,n)&&((s=(o=Object.defineProperty)&&Object.getOwnPropertyDescriptor(e,n))&&(s.get||s.set)?o(a,n,s):a[n]=e[n]);return a})(e,r)}function c(i,l,c){const f=(0,t.convertToTensor)(i,"x","transpose");if(null==l&&(l=f.shape.map((e,r)=>r).reverse()),o.assert(f.rank===l.length,()=>`Error in transpose: rank of input ${f.rank} `+`must match length of perm ${l}.`),l.forEach(e=>{o.assert(e>=0&&e<f.rank,()=>`All entries in 'perm' must be between 0 and ${f.rank-1}`+` but got ${l}`)}),f.rank<=1)return f.clone();const m={x:f},g={perm:l};return"complex64"===f.dtype?(0,r.tidy)(()=>{let r=(0,p.real)(f),t=(0,a.imag)(f);return r=e.ENGINE.runKernel(n.Transpose,{x:r},g),t=e.ENGINE.runKernel(n.Transpose,{x:t},g),c&&(t=(0,u.neg)(t)),(0,s.complex)(r,t)}):e.ENGINE.runKernel(n.Transpose,m,g)}const f=exports.transpose=(0,i.op)({transpose_:c});
},{"../engine":"phT7","../globals":"TsQp","../kernel_names":"rJl6","../tensor_util_env":"y4X4","../util":"XXxQ","./complex":"e4je","./imag":"eG10","./neg":"i2LN","./operation":"uE86","./real":"j99O"}],"SiXR":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.movingAverage=void 0;var e=require("../tensor_util"),r=require("../tensor_util_env"),t=c(require("../util")),o=require("./add"),n=require("./div"),i=require("./mul"),s=require("./operation"),a=require("./pow"),u=require("./scalar"),v=require("./sub");function c(e,r){if("function"==typeof WeakMap)var t=new WeakMap,o=new WeakMap;return(c=function(e,r){if(!r&&e&&e.__esModule)return e;var n,i,s={__proto__:null,default:e};if(null===e||"object"!=typeof e&&"function"!=typeof e)return s;if(n=r?o:t){if(n.has(e))return n.get(e);n.set(e,s)}for(const t in e)"default"!==t&&{}.hasOwnProperty.call(e,t)&&((i=(n=Object.defineProperty)&&Object.getOwnPropertyDescriptor(e,t))&&(i.get||i.set)?n(s,t,i):s[t]=e[t]);return s})(e,r)}function p(s,c,p,l,f=!0){const g=(0,r.convertToTensor)(s,"v","movingAverage"),d=(0,r.convertToTensor)(c,"x","movingAverage"),q=(0,r.convertToTensor)(p,"decay","movingAverage");(0,e.assertTypesMatch)(g,d),t.assert(t.arraysEqual(g.shape,d.shape),()=>"Shape mismatch in v and x");const _=(0,u.scalar)(1),m=(0,v.sub)(_,q);let y=(0,i.mul)((0,v.sub)(d,g),m);if(f){t.assert(null!=l,()=>"When using zeroDebias: true, step is required.");const e=(0,r.convertToTensor)(l,"step","movingAverage");y=(0,n.div)(y,(0,v.sub)(_,(0,a.pow)(q,e)))}return(0,o.add)(g,y)}const l=exports.movingAverage=(0,s.op)({movingAverage_:p});
},{"../tensor_util":"wtFc","../tensor_util_env":"y4X4","../util":"XXxQ","./add":"N73o","./div":"S2L5","./mul":"tBJ4","./operation":"uE86","./pow":"o2Kl","./scalar":"TiGU","./sub":"SgzI"}],"r4bT":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.scatterND=void 0;var e=require("../engine"),t=require("../kernel_names"),r=require("../tensor_util_env"),n=require("../util_base"),o=require("./operation"),i=s(require("./scatter_nd_util"));function s(e,t){if("function"==typeof WeakMap)var r=new WeakMap,n=new WeakMap;return(s=function(e,t){if(!t&&e&&e.__esModule)return e;var o,i,s={__proto__:null,default:e};if(null===e||"object"!=typeof e&&"function"!=typeof e)return s;if(o=t?n:r){if(o.has(e))return o.get(e);o.set(e,s)}for(const r in e)"default"!==r&&{}.hasOwnProperty.call(e,r)&&((i=(o=Object.defineProperty)&&Object.getOwnPropertyDescriptor(e,r))&&(i.get||i.set)?o(s,r,i):s[r]=e[r]);return s})(e,t)}function a(o,s,a){(0,n.assertNonNegativeIntegerDimensions)(a);const u=(0,r.convertToTensor)(o,"indices","scatterND","int32"),c=(0,r.convertToTensor)(s,"updates","scatterND");i.validateInput(c,u,a);const p={indices:u,updates:c},f={shape:a};return e.ENGINE.runKernel(t.ScatterNd,p,f)}const u=exports.scatterND=(0,o.op)({scatterND_:a});
},{"../engine":"phT7","../kernel_names":"rJl6","../tensor_util_env":"y4X4","../util_base":"uID4","./operation":"uE86","./scatter_nd_util":"keWG"}],"M5Dq":[function(require,module,exports) {
"use strict";function e(e,t,r,s){if("int32"!==e.dtype)throw new Error("tf.sparseToDense() expects the indices to be int32 type,"+` but the dtype was ${e.dtype}.`);if(e.rank>2)throw new Error("sparseIndices should be a scalar, vector, or matrix,"+` but got shape ${e.shape}.`);const a=e.rank>0?e.shape[0]:1,o=e.rank>1?e.shape[1]:1;if(r.length!==o)throw new Error("outputShape has incorrect number of elements:,"+` ${r.length}, should be: ${o}.`);const n=t.size;if(0!==t.rank&&(1!==t.rank||n!==a))throw new Error("sparseValues has incorrect shape "+`${t.shape}, should be [] or [${a}]`);if(t.dtype!==s.dtype)throw new Error("sparseValues.dtype must match defaultValues.dtype")}Object.defineProperty(exports,"__esModule",{value:!0}),exports.validateInput=e;
},{}],"s9K8":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.sparseToDense=void 0;var e=require("../engine"),r=require("../kernel_names"),s=a(require("../ops/sparse_to_dense_util")),n=require("../tensor_util_env"),t=require("../util_base"),o=require("./operation");function a(e,r){if("function"==typeof WeakMap)var s=new WeakMap,n=new WeakMap;return(a=function(e,r){if(!r&&e&&e.__esModule)return e;var t,o,a={__proto__:null,default:e};if(null===e||"object"!=typeof e&&"function"!=typeof e)return a;if(t=r?n:s){if(t.has(e))return t.get(e);t.set(e,a)}for(const s in e)"default"!==s&&{}.hasOwnProperty.call(e,s)&&((o=(t=Object.defineProperty)&&Object.getOwnPropertyDescriptor(e,s))&&(o.get||o.set)?t(a,s,o):a[s]=e[s]);return a})(e,r)}function u(o,a,u,i=0){(0,t.assertNonNegativeIntegerDimensions)(u);const p=(0,n.convertToTensor)(o,"sparseIndices","sparseToDense","int32"),l=(0,n.convertToTensor)(a,"sparseValues","sparseToDense","string_or_numeric"),c=(0,n.convertToTensor)(i,"defaultValue","sparseToDense",l.dtype);s.validateInput(p,l,u,c);const f={sparseIndices:p,sparseValues:l,defaultValue:c},_={outputShape:u};return e.ENGINE.runKernel(r.SparseToDense,f,_)}const i=exports.sparseToDense=(0,o.op)({sparseToDense_:u});
},{"../engine":"phT7","../kernel_names":"rJl6","../ops/sparse_to_dense_util":"M5Dq","../tensor_util_env":"y4X4","../util_base":"uID4","./operation":"uE86"}],"PYkI":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.gatherND=void 0;var e=require("../engine"),r=require("../kernel_names"),n=require("../tensor_util_env"),t=require("./operation");function o(t,o){const i=(0,n.convertToTensor)(o,"indices","gatherND","int32"),s={params:(0,n.convertToTensor)(t,"x","gatherND","string_or_numeric"),indices:i};return e.ENGINE.runKernel(r.GatherNd,s)}const i=exports.gatherND=(0,t.op)({gatherND_:o});
},{"../engine":"phT7","../kernel_names":"rJl6","../tensor_util_env":"y4X4","./operation":"uE86"}],"tkiJ":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.getNoiseShape=r;var e=t(require("../util"));function t(e,r){if("function"==typeof WeakMap)var n=new WeakMap,u=new WeakMap;return(t=function(e,t){if(!t&&e&&e.__esModule)return e;var r,a,o={__proto__:null,default:e};if(null===e||"object"!=typeof e&&"function"!=typeof e)return o;if(r=t?u:n){if(r.has(e))return r.get(e);r.set(e,o)}for(const n in e)"default"!==n&&{}.hasOwnProperty.call(e,n)&&((a=(r=Object.defineProperty)&&Object.getOwnPropertyDescriptor(e,n))&&(a.get||a.set)?r(o,n,a):o[n]=e[n]);return o})(e,r)}function r(t,r){if(null==r)return t.shape.slice();if(e.arraysEqual(t.shape,r))return r;if(t.shape.length===r.length){const e=[];for(let n=0;n<t.shape.length;n++)null==r[n]&&null!=t.shape[n]?e.push(t.shape[n]):e.push(r[n]);return e}return r}
},{"../util":"XXxQ"}],"jb36":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.dropout=void 0;var e=require("../tensor"),t=require("../tensor_util_env"),r=p(require("../util")),o=require("./add"),n=require("./div"),i=require("./dropout_util"),u=require("./floor"),a=require("./mul"),s=require("./operation"),f=require("./random_uniform");function p(e,t){if("function"==typeof WeakMap)var r=new WeakMap,o=new WeakMap;return(p=function(e,t){if(!t&&e&&e.__esModule)return e;var n,i,u={__proto__:null,default:e};if(null===e||"object"!=typeof e&&"function"!=typeof e)return u;if(n=t?o:r){if(n.has(e))return n.get(e);n.set(e,u)}for(const r in e)"default"!==r&&{}.hasOwnProperty.call(e,r)&&((i=(n=Object.defineProperty)&&Object.getOwnPropertyDescriptor(e,r))&&(i.get||i.set)?n(u,r,i):u[r]=e[r]);return u})(e,t)}function d(s,p,d,l){const c=(0,t.convertToTensor)(s,"x","dropout");if(r.assert("float32"===c.dtype,()=>"x has to be a floating point tensor since it's going to be "+`scaled, but got a ${c.dtype} tensor instead.`),r.assert(p>=0&&p<1,()=>`rate must be a float in the range [0, 1), but got ${p}.`),0===p)return s instanceof e.Tensor?c.clone():c;const _=(0,i.getNoiseShape)(c,d),g=1-p,q=(0,n.div)((0,u.floor)((0,o.add)((0,f.randomUniform)(_,0,1,"float32",l),g)),g);return(0,a.mul)(c,q)}const l=exports.dropout=(0,s.op)({dropout_:d});
},{"../tensor":"eFW4","../tensor_util_env":"y4X4","../util":"XXxQ","./add":"N73o","./div":"S2L5","./dropout_util":"tkiJ","./floor":"EeTS","./mul":"tBJ4","./operation":"uE86","./random_uniform":"Imph"}],"Ubrm":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.cosineWindow=e,exports.enclosingPowerOfTwo=t;var o=require("./tensor1d");function t(o){return Math.floor(Math.pow(2,Math.ceil(Math.log(o)/Math.log(2))))}function e(t,e,r){const n=1-t%2,s=new Float32Array(t);for(let o=0;o<t;++o){const a=2*Math.PI*o/(t+n-1);s[o]=e-r*Math.cos(a)}return(0,o.tensor1d)(s,"float32")}
},{"./tensor1d":"vKgg"}],"oeUN":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.inTopKAsync=void 0;var e=require("../tensor_util_env"),t=require("../util"),s=require("./tensor");async function r(r,n,o=1){const a=(0,e.convertToTensor)(r,"predictions","inTopK"),i=(0,e.convertToTensor)(n,"targets","inTopK");(0,t.assert)(a.rank>1,()=>"inTopK() expects the predictions to be of rank 2 or higher, "+`but got ${a.rank}`),(0,t.assert)(a.rank-1===i.rank,()=>"predictions rank should be 1 larger than targets rank, but got predictions rank "+`${a.rank} and targets rank ${i.rank}`),(0,t.assertShapesMatch)(a.shape.slice(0,a.shape.length-1),i.shape,"predictions's shape should be align with the targets' shape, except the last dimension.");const p=a.shape[a.shape.length-1];(0,t.assert)(o>0&&o<=p,()=>"'k' passed to inTopK() must be > 0 && <= the predictions last "+`dimension (${p}), but got ${o}`);const h=await a.data(),c=await i.data(),[l,d]=[h.length/p,p],u=(0,t.getTypedArrayFromDType)("bool",l);for(let e=0;e<l;e++){const t=e*d,s=h.subarray(t,t+d),r=[];for(let e=0;e<s.length;e++)r.push({value:s[e],index:e});r.sort((e,t)=>t.value-e.value),u[e]=0;for(let n=0;n<o;n++)if(r[n].index===c[e]){u[e]=1;break}}return r!==a&&a.dispose(),n!==i&&i.dispose(),(0,s.tensor)(u,i.shape,"bool")}const n=exports.inTopKAsync=r;
},{"../tensor_util_env":"y4X4","../util":"XXxQ","./tensor":"woAd"}],"LPa2":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.conv2DBackpropFilter=void 0;var e=require("../engine"),r=require("../kernel_names"),t=i(require("../util")),n=i(require("./conv_util")),o=require("./operation"),a=require("./reshape");function i(e,r){if("function"==typeof WeakMap)var t=new WeakMap,n=new WeakMap;return(i=function(e,r){if(!r&&e&&e.__esModule)return e;var o,a,i={__proto__:null,default:e};if(null===e||"object"!=typeof e&&"function"!=typeof e)return i;if(o=r?n:t){if(o.has(e))return o.get(e);o.set(e,i)}for(const t in e)"default"!==t&&{}.hasOwnProperty.call(e,t)&&((a=(o=Object.defineProperty)&&Object.getOwnPropertyDescriptor(e,t))&&(a.get||a.set)?o(i,t,a):i[t]=e[t]);return i})(e,r)}function p(o,i,p,s,u,c="NHWC",l){let h=o;3===o.rank&&(h=(0,a.reshape)(o,[1,o.shape[0],o.shape[1],o.shape[2]]));let d=i;3===d.rank&&(d=(0,a.reshape)(i,[1,i.shape[0],i.shape[1],i.shape[2]])),t.assert(4===h.rank,()=>"Error in conv2dDerFilter: input must be rank 4, but got shape "+`${h.shape}.`),t.assert(4===d.rank,()=>"Error in conv2dDerFilter: dy must be rank 4, but got shape "+`${d.shape}.`),t.assert(4===p.length,()=>"Error in conv2dDerFilter: filterShape must be length 4, but got "+`${p}.`);const f="NHWC"===c?h.shape[3]:h.shape[1],v="NHWC"===c?d.shape[3]:d.shape[1];t.assert(f===p[2],()=>`Error in conv2dDerFilter: depth of input ${f}) must `+`match input depth in filter (${p[2]}.`),t.assert(v===p[3],()=>`Error in conv2dDerFilter: depth of dy (${v}) must `+`match output depth for filter (${p[3]}).`),n.checkPadOnDimRoundingMode("conv2dDerFilter",u,l);const k={x:h,dy:d},D={strides:s,pad:u,dataFormat:c,dimRoundingMode:l,filterShape:p};return e.ENGINE.runKernel(r.Conv2DBackpropFilter,k,D)}const s=exports.conv2DBackpropFilter=(0,o.op)({conv2DBackpropFilter_:p});
},{"../engine":"phT7","../kernel_names":"rJl6","../util":"XXxQ","./conv_util":"PhWH","./operation":"uE86","./reshape":"F0cm"}],"Pva5":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.applyActivation=h,exports.getFusedBiasGradient=d,exports.getFusedDyActivation=c,exports.shouldFuse=void 0;var e=p(require("./broadcast_util")),r=require("./elu"),t=require("./leaky_relu"),u=require("./mul"),n=require("./prelu"),i=require("./relu"),o=require("./relu6"),l=require("./reshape"),s=require("./sigmoid"),a=require("./step"),f=require("./sum");function p(e,r){if("function"==typeof WeakMap)var t=new WeakMap,u=new WeakMap;return(p=function(e,r){if(!r&&e&&e.__esModule)return e;var n,i,o={__proto__:null,default:e};if(null===e||"object"!=typeof e&&"function"!=typeof e)return o;if(n=r?u:t){if(n.has(e))return n.get(e);n.set(e,o)}for(const t in e)"default"!==t&&{}.hasOwnProperty.call(e,t)&&((i=(n=Object.defineProperty)&&Object.getOwnPropertyDescriptor(e,t))&&(i.get||i.set)?n(o,t,i):o[t]=e[t]);return o})(e,r)}function c(e,r,t){if(null==t||"linear"===t)return e;if("relu"===t)return(0,u.mul)(e,(0,a.step)(r));throw new Error(`Cannot compute gradient for fused activation ${t}.`)}function d(r,t){let u=t;const n=e.getReductionAxes(r.shape,t.shape);return n.length>0&&(u=(0,f.sum)(u,n)),(0,l.reshape)(u,r.shape)}function h(e,u,l,a){if("linear"===u)return e;if("relu"===u)return(0,i.relu)(e);if("elu"===u)return(0,r.elu)(e);if("relu6"===u)return(0,o.relu6)(e);if("prelu"===u)return(0,n.prelu)(e,l);if("leakyrelu"===u)return(0,t.leakyRelu)(e,a);if("sigmoid"===u)return(0,s.sigmoid)(e);throw new Error(`Unknown fused activation ${u}.`)}const y=(e,r)=>{return!(e>0)||"linear"===r};exports.shouldFuse=y;
},{"./broadcast_util":"fD2T","./elu":"qSof","./leaky_relu":"RYa8","./mul":"tBJ4","./prelu":"Xs9q","./relu":"JbIg","./relu6":"urTr","./reshape":"F0cm","./sigmoid":"DbGB","./step":"vRkD","./sum":"kc8w"}],"SiRR":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.conv2d=void 0;var e=require("../../engine"),t=require("../../gradients"),r=require("../../kernel_names"),n=require("../../tensor_util"),o=require("../../tensor_util_env"),a=v(require("../../util")),s=require("../add"),i=v(require("../broadcast_util")),u=require("../conv2d"),d=require("../conv2d_backprop_filter"),p=require("../conv2d_backprop_input"),l=v(require("../conv_util")),c=require("../fused_util"),h=require("../operation"),f=require("../reshape");function v(e,t){if("function"==typeof WeakMap)var r=new WeakMap,n=new WeakMap;return(v=function(e,t){if(!t&&e&&e.__esModule)return e;var o,a,s={__proto__:null,default:e};if(null===e||"object"!=typeof e&&"function"!=typeof e)return s;if(o=t?n:r){if(o.has(e))return o.get(e);o.set(e,s)}for(const r in e)"default"!==r&&{}.hasOwnProperty.call(e,r)&&((a=(o=Object.defineProperty)&&Object.getOwnPropertyDescriptor(e,r))&&(a.get||a.set)?o(s,r,a):s[r]=e[r]);return s})(e,t)}function g({x:h,filter:v,strides:g,pad:b,dataFormat:k="NHWC",dilations:m=[1,1],dimRoundingMode:y,bias:E,activation:_="linear",preluActivationWeights:$,leakyreluAlpha:C}){if(_=_||"linear",!1===(0,c.shouldFuse)(e.ENGINE.state.gradientDepth,_)){a.assert("NHWC"===k,()=>`Error in fused conv2d: got dataFormat of ${k} but `+"only NHWC is currently supported for the case of gradient depth is 0 and the activation is not linear.");let e=(0,u.conv2d)(h,v,g,b,k,m,y);return null!=E&&(e=(0,s.add)(e,E)),(0,c.applyActivation)(e,_,$,C)}const D=(0,o.convertToTensor)(h,"x","conv2d","float32"),q=(0,o.convertToTensor)(v,"filter","conv2d","float32");let N=D,W=!1;3===D.rank&&(W=!0,N=(0,f.reshape)(D,[1,D.shape[0],D.shape[1],D.shape[2]])),a.assert(4===N.rank,()=>"Error in fused conv2d: input must be rank 4, but got rank "+`${N.rank}.`),a.assert(4===q.rank,()=>"Error in fused conv2d: filter must be rank 4, but got rank "+`${q.rank}.`),l.checkPadOnDimRoundingMode("fused conv2d",b,y);const w="NHWC"===k?N.shape[3]:N.shape[1];a.assert(q.shape[2]===w,()=>`Error in conv2d: depth of input (${w}) must match `+`input depth for filter ${q.shape[2]}.`),a.assert(l.eitherStridesOrDilationsAreOne(g,m),()=>"Error in conv2D: Either strides or dilations must be 1. "+`Got strides ${g} and dilations '${m}'`);const F=l.computeConv2DInfo(N.shape,q.shape,g,m,b,y);let T,A;if(null!=E&&(T=(0,o.convertToTensor)(E,"bias","fused conv2d"),[T]=(0,n.makeTypesMatch)(T,D),"NHWC"===k?i.assertAndGetBroadcastShape(F.outShape,T.shape):(a.assert(T.shape.length<=1,()=>"Error in fused conv2d: only supports scalar or 1-D Tensor bias for NCHW format but got the bias of "+`rank-${T.shape.length}.`),a.assert(0===T.shape.length||T.shape[0]===F.outChannels||1===T.shape[0],()=>`Error in fused conv2d: bias shape (${T.shape}) is not `+"compatible with the number of output channels "+`(${F.outChannels})`))),null!=$){const e=$.shape;if(a.assert(e.length<=1||3===e.length,()=>"Error in fused conv2d: only supports scalar, 1-D Tensor or 3-D Tensor PReLU activation weights but got a tensor of "+`rank-${e.length}.`),1===e.length)a.assert(1===e[0]||e[0]===F.outChannels,()=>"Error in fused conv2d: PReLU activation weights "+`(${e}) is not compatible with the number of output `+`channels (${F.outChannels}).`);else if(3===e.length)try{i.assertAndGetBroadcastShape(e,F.outShape)}catch(H){const t=`Error in fused conv2d: PReLU activation weights (${e}) `+"is not compatible with the output shape of the conv2d "+`(${F.outShape}).`;throw Error(t)}A=(0,o.convertToTensor)($,"prelu weights","fused conv2d")}const G=(e,t)=>{a.assert("NHWC"===k,()=>`Error in gradient of fused conv2D: got dataFormat of ${k} but only NHWC is currently supported.`);const[r,n,o,s]=t,i=(0,c.getFusedDyActivation)(e,o,_);a.assert(l.tupleValuesAreOne(m),()=>"Error in gradient of fused conv2D: dilation rates greater than 1 "+`are not yet supported in gradients. Got dilations '${m}'`);const u=[(0,p.conv2DBackpropInput)(n.shape,i,r,g,b),(0,d.conv2DBackpropFilter)(n,i,r.shape,g,b)];if(null!=s){const e=(0,c.getFusedBiasGradient)(s,i);u.push(e)}return u},M={x:N,filter:q,bias:T,preluActivationWeights:A},O={strides:g,pad:b,dataFormat:k,dilations:m,dimRoundingMode:y,activation:_,leakyreluAlpha:C};if(null==E){return(0,t.customGrad)((t,n,o)=>{let a=e.ENGINE.runKernel(r.FusedConv2D,M,O);return o([n,t,a]),W&&(a=(0,f.reshape)(a,[a.shape[1],a.shape[2],a.shape[3]])),{value:a,gradFunc:G}})(N,q)}return(0,t.customGrad)((t,n,o,a)=>{let s=e.ENGINE.runKernel(r.FusedConv2D,M,O);return a([n,t,s,o]),W&&(s=(0,f.reshape)(s,[s.shape[1],s.shape[2],s.shape[3]])),{value:s,gradFunc:G}})(N,q,T)}const b=exports.conv2d=(0,h.op)({fusedConv2d_:g});
},{"../../engine":"phT7","../../gradients":"VR5t","../../kernel_names":"rJl6","../../tensor_util":"wtFc","../../tensor_util_env":"y4X4","../../util":"XXxQ","../add":"N73o","../broadcast_util":"fD2T","../conv2d":"CVMs","../conv2d_backprop_filter":"LPa2","../conv2d_backprop_input":"sf3S","../conv_util":"PhWH","../fused_util":"Pva5","../operation":"uE86","../reshape":"F0cm"}],"QLaB":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.depthwiseConv2dNativeBackpropFilter=void 0;var e=require("../engine"),r=require("../kernel_names"),p=require("./operation"),t=require("./reshape");function i(p,i,a,s,o,n=[1,1],d){let h=p;3===p.rank&&(h=(0,t.reshape)(p,[1,p.shape[0],p.shape[1],p.shape[2]]));let l=i;3===l.rank&&(l=(0,t.reshape)(i,[1,i.shape[0],i.shape[1],i.shape[2]]));const u={x:h,dy:l},v={strides:s,pad:o,dimRoundingMode:d,dilations:n,filterShape:a};return e.ENGINE.runKernel(r.DepthwiseConv2dNativeBackpropFilter,u,v)}const a=exports.depthwiseConv2dNativeBackpropFilter=(0,p.op)({depthwiseConv2dNativeBackpropFilter_:i});
},{"../engine":"phT7","../kernel_names":"rJl6","./operation":"uE86","./reshape":"F0cm"}],"vLIu":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.depthwiseConv2dNativeBackpropInput=void 0;var e=require("../engine"),p=require("../kernel_names"),r=require("./operation"),t=require("./reshape");function n(r,n,a,i,s,o=[1,1],d){let u=n,h=!1;3===n.rank&&(h=!0,u=(0,t.reshape)(n,[1,n.shape[0],n.shape[1],n.shape[2]]));const v={dy:u,filter:a},c={strides:i,pad:s,dimRoundingMode:d,dilations:o,inputShape:r},l=e.ENGINE.runKernel(p.DepthwiseConv2dNativeBackpropInput,v,c);return h?(0,t.reshape)(l,[l.shape[1],l.shape[2],l.shape[3]]):l}const a=exports.depthwiseConv2dNativeBackpropInput=(0,r.op)({depthwiseConv2dNativeBackpropInput_:n});
},{"../engine":"phT7","../kernel_names":"rJl6","./operation":"uE86","./reshape":"F0cm"}],"e8Po":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.depthwiseConv2d=void 0;var e=require("../../engine"),t=require("../../gradients"),r=require("../../kernel_names"),n=require("../../tensor_util"),i=require("../../tensor_util_env"),s=f(require("../../util")),a=require("../add"),o=f(require("../broadcast_util")),d=f(require("../conv_util")),u=require("../depthwise_conv2d"),p=require("../depthwise_conv2d_native_backprop_filter"),l=require("../depthwise_conv2d_native_backprop_input"),h=require("../fused_util"),c=require("../operation"),v=require("../reshape");function f(e,t){if("function"==typeof WeakMap)var r=new WeakMap,n=new WeakMap;return(f=function(e,t){if(!t&&e&&e.__esModule)return e;var i,s,a={__proto__:null,default:e};if(null===e||"object"!=typeof e&&"function"!=typeof e)return a;if(i=t?n:r){if(i.has(e))return i.get(e);i.set(e,a)}for(const r in e)"default"!==r&&{}.hasOwnProperty.call(e,r)&&((s=(i=Object.defineProperty)&&Object.getOwnPropertyDescriptor(e,r))&&(s.get||s.set)?i(a,r,s):a[r]=e[r]);return a})(e,t)}function w({x:c,filter:f,strides:w,pad:_,dataFormat:k="NHWC",dilations:g=[1,1],dimRoundingMode:C,bias:m,activation:b="linear",preluActivationWeights:q,leakyreluAlpha:y}){if(!1===(0,h.shouldFuse)(e.ENGINE.state.gradientDepth,b)){let e=(0,u.depthwiseConv2d)(c,f,w,_,k,g,C);return null!=m&&(e=(0,a.add)(e,m)),(0,h.applyActivation)(e,b,q,y)}const E=(0,i.convertToTensor)(c,"x","depthwiseConv2d","float32"),D=(0,i.convertToTensor)(f,"filter","depthwiseConv2d","float32");let F=E,A=!1;3===E.rank&&(A=!0,F=(0,v.reshape)(E,[1,E.shape[0],E.shape[1],E.shape[2]])),s.assert(4===F.rank,()=>"Error in fused depthwiseConv2d: input must be rank 4, but got "+`rank ${F.rank}.`),s.assert(4===D.rank,()=>"Error in fused depthwiseConv2d: filter must be rank 4, "+`but got rank ${D.rank}.`),s.assert(F.shape[3]===D.shape[2],()=>"Error in fused depthwiseConv2d: number of input channels "+`(${F.shape[3]}) must match the inChannels dimension in `+`filter ${D.shape[2]}.`),null==g&&(g=[1,1]),s.assert(d.eitherStridesOrDilationsAreOne(w,g),()=>"Error in fused depthwiseConv2d: Either strides or dilations must "+`be 1. Got strides ${w} and dilations '${g}'`),d.checkPadOnDimRoundingMode("fused depthwiseConv2d",_,C);const G=d.computeConv2DInfo(F.shape,D.shape,w,g,_,C,!0);let M,N;null!=m&&(M=(0,i.convertToTensor)(m,"bias","fused conv2d"),[M]=(0,n.makeTypesMatch)(M,E),o.assertAndGetBroadcastShape(G.outShape,M.shape)),null!=q&&(N=(0,i.convertToTensor)(q,"prelu weights","fused depthwiseConv2d"));const O=(e,t)=>{s.assert(d.tupleValuesAreOne(g),()=>"Error in gradient of fused depthwiseConv2d: dilation rates greater than 1 are not yet supported. Got dilations "+`'${g}'`);const[r,n,i,a]=t,o=(0,h.getFusedDyActivation)(e,i,b),u=(0,l.depthwiseConv2dNativeBackpropInput)(n.shape,o,r,w,_,g,C),c=(0,p.depthwiseConv2dNativeBackpropFilter)(n,o,r.shape,w,_,g,C);if(null!=a){return[u,c,(0,h.getFusedBiasGradient)(M,o)]}return[u,c]},T={x:F,filter:D,bias:M,preluActivationWeights:N},$={strides:w,pad:_,dataFormat:k,dilations:g,dimRoundingMode:C,activation:b,leakyreluAlpha:y};if(null==m){return(0,t.customGrad)((t,n,i)=>{let s=e.ENGINE.runKernel(r.FusedDepthwiseConv2D,T,$);return i([n,t,s]),A&&(s=(0,v.reshape)(s,[s.shape[1],s.shape[2],s.shape[3]])),{value:s,gradFunc:O}})(F,D)}return(0,t.customGrad)((t,n,i,s)=>{let a=e.ENGINE.runKernel(r.FusedDepthwiseConv2D,T,$);return s([n,t,a,i]),A&&(a=(0,v.reshape)(a,[a.shape[1],a.shape[2],a.shape[3]])),{value:a,gradFunc:O}})(F,D,M)}const _=exports.depthwiseConv2d=(0,c.op)({fusedDepthwiseConv2d_:w});
},{"../../engine":"phT7","../../gradients":"VR5t","../../kernel_names":"rJl6","../../tensor_util":"wtFc","../../tensor_util_env":"y4X4","../../util":"XXxQ","../add":"N73o","../broadcast_util":"fD2T","../conv_util":"PhWH","../depthwise_conv2d":"HEHz","../depthwise_conv2d_native_backprop_filter":"QLaB","../depthwise_conv2d_native_backprop_input":"vLIu","../fused_util":"Pva5","../operation":"uE86","../reshape":"F0cm"}],"PAQD":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.matMul=void 0;var e=require("../../engine"),a=require("../../gradients"),r=require("../../kernel_names"),t=require("../../tensor_util"),s=require("../../tensor_util_env"),n=h(require("../../util")),u=require("../add"),o=h(require("../broadcast_util")),l=require("../fused_util"),i=require("../mat_mul"),p=require("../operation"),c=require("../reshape");function h(e,a){if("function"==typeof WeakMap)var r=new WeakMap,t=new WeakMap;return(h=function(e,a){if(!a&&e&&e.__esModule)return e;var s,n,u={__proto__:null,default:e};if(null===e||"object"!=typeof e&&"function"!=typeof e)return u;if(s=a?t:r){if(s.has(e))return s.get(e);s.set(e,u)}for(const r in e)"default"!==r&&{}.hasOwnProperty.call(e,r)&&((n=(s=Object.defineProperty)&&Object.getOwnPropertyDescriptor(e,r))&&(n.get||n.set)?s(u,r,n):u[r]=e[r]);return u})(e,a)}function d({a:p,b:h,transposeA:d=!1,transposeB:f=!1,bias:M,activation:m="linear",preluActivationWeights:v,leakyreluAlpha:_=.2}){if(!1===(0,l.shouldFuse)(e.ENGINE.state.gradientDepth,m)){let e=(0,i.matMul)(p,h,d,f);return null!=M&&(e=(0,u.add)(e,M)),(0,l.applyActivation)(e,m,v,_)}let k=(0,s.convertToTensor)(p,"a","fused matMul"),g=(0,s.convertToTensor)(h,"b","fused matMul");[k,g]=(0,t.makeTypesMatch)(k,g);const y=d?k.shape[k.rank-2]:k.shape[k.rank-1],q=f?g.shape[g.rank-1]:g.shape[g.rank-2],b=d?k.shape[k.rank-1]:k.shape[k.rank-2],A=f?g.shape[g.rank-2]:g.shape[g.rank-1],T=k.shape.slice(0,-2),F=g.shape.slice(0,-2),G=n.sizeFromShape(T),E=n.sizeFromShape(F);n.assert(y===q,()=>`Error in fused matMul: inner shapes (${y}) and (`+`${q}) of Tensors with shapes ${k.shape} and `+`${g.shape} and transposeA=${d}`+` and transposeB=${f} must match.`);const w=o.assertAndGetBroadcastShape(k.shape.slice(0,-2),g.shape.slice(0,-2)).concat([b,A]),B=d?(0,c.reshape)(k,[G,y,b]):(0,c.reshape)(k,[G,b,y]),N=f?(0,c.reshape)(g,[E,A,q]):(0,c.reshape)(g,[E,q,A]);let $,O;null!=M&&($=(0,s.convertToTensor)(M,"bias","fused matMul"),[$]=(0,t.makeTypesMatch)($,k),o.assertAndGetBroadcastShape(w,$.shape)),null!=v&&(O=(0,s.convertToTensor)(v,"prelu weights","fused matMul"));const W=(e,a)=>{const[r,t,s,n]=a,u=(0,l.getFusedDyActivation)((0,c.reshape)(e,s.shape),s,m);let o,p;if(d||f?!d&&f?(o=(0,i.matMul)(u,t,!1,!1),p=(0,i.matMul)(u,r,!0,!1)):d&&!f?(o=(0,i.matMul)(t,u,!1,!0),p=(0,i.matMul)(r,u,!1,!1)):(o=(0,i.matMul)(t,u,!0,!0),p=(0,i.matMul)(u,r,!0,!0)):(o=(0,i.matMul)(u,t,!1,!0),p=(0,i.matMul)(r,u,!0,!1)),null!=M){return[o,p,(0,l.getFusedBiasGradient)(n,u)]}return[o,p]},j={a:B,b:N,bias:$,preluActivationWeights:O},P={transposeA:d,transposeB:f,activation:m,leakyreluAlpha:_};if(null==M){return(0,a.customGrad)((a,t,s)=>{const n=e.ENGINE.runKernel(r._FusedMatMul,j,P);return s([a,t,n]),{value:(0,c.reshape)(n,w),gradFunc:W}})(B,N)}return(0,a.customGrad)((a,t,s,n)=>{const u=e.ENGINE.runKernel(r._FusedMatMul,j,P);return n([a,t,u,s]),{value:(0,c.reshape)(u,w),gradFunc:W}})(B,N,$)}const f=exports.matMul=(0,p.op)({fusedMatMul_:d});
},{"../../engine":"phT7","../../gradients":"VR5t","../../kernel_names":"rJl6","../../tensor_util":"wtFc","../../tensor_util_env":"y4X4","../../util":"XXxQ","../add":"N73o","../broadcast_util":"fD2T","../fused_util":"Pva5","../mat_mul":"zVDr","../operation":"uE86","../reshape":"F0cm"}],"Z9t3":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),Object.defineProperty(exports,"conv2d",{enumerable:!0,get:function(){return e.conv2d}}),Object.defineProperty(exports,"depthwiseConv2d",{enumerable:!0,get:function(){return r.depthwiseConv2d}}),Object.defineProperty(exports,"matMul",{enumerable:!0,get:function(){return t.matMul}});var e=require("./fused/conv2d"),r=require("./fused/depthwise_conv2d"),t=require("./fused/mat_mul");
},{"./fused/conv2d":"SiRR","./fused/depthwise_conv2d":"e8Po","./fused/mat_mul":"PAQD"}],"HdvD":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.hammingWindow=void 0;var e=require("../operation"),i=require("../signal_ops_util");function o(e){return(0,i.cosineWindow)(e,.54,.46)}const n=exports.hammingWindow=(0,e.op)({hammingWindow_:o});
},{"../operation":"uE86","../signal_ops_util":"Ubrm"}],"bdTr":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.hannWindow=void 0;var e=require("../operation"),n=require("../signal_ops_util");function o(e){return(0,n.cosineWindow)(e,.5,.5)}const i=exports.hannWindow=(0,e.op)({hannWindow_:o});
},{"../operation":"uE86","../signal_ops_util":"Ubrm"}],"Go7t":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.frame=void 0;var e=require("../concat"),r=require("../fill"),s=require("../operation"),t=require("../reshape"),i=require("../slice"),o=require("../tensor2d");function c(s,c,n,u=!1,l=0){let a=0;const f=[];for(;a+c<=s.size;)f.push((0,i.slice)(s,a,c)),a+=n;if(u)for(;a<s.size;){const t=a+c-s.size,o=(0,e.concat)([(0,i.slice)(s,a,c-t),(0,r.fill)([t],l)]);f.push(o),a+=n}return 0===f.length?(0,o.tensor2d)([],[0,c]):(0,t.reshape)((0,e.concat)(f),[f.length,c])}const n=exports.frame=(0,s.op)({frame_:c});
},{"../concat":"V5Ij","../fill":"gaCw","../operation":"uE86","../reshape":"F0cm","../slice":"wIos","../tensor2d":"UEzj"}],"jWvs":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.stft=void 0;var e=require("../mul"),r=require("../operation"),t=require("../signal_ops_util"),o=require("../spectral/rfft"),n=require("./frame"),i=require("./hann_window");function s(r,s,u,f,l=i.hannWindow){null==f&&(f=(0,t.enclosingPowerOfTwo)(s));const a=(0,n.frame)(r,s,u),p=(0,e.mul)(a,l(s));return(0,o.rfft)(p,f)}const u=exports.stft=(0,r.op)({stft_:s});
},{"../mul":"tBJ4","../operation":"uE86","../signal_ops_util":"Ubrm","../spectral/rfft":"FMnE","./frame":"Go7t","./hann_window":"bdTr"}],"su0V":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.cropAndResize=void 0;var e=require("../../engine"),r=require("../../kernel_names"),t=require("../../tensor_util_env"),n=s(require("../../util")),o=require("../operation");function s(e,r){if("function"==typeof WeakMap)var t=new WeakMap,n=new WeakMap;return(s=function(e,r){if(!r&&e&&e.__esModule)return e;var o,s,a={__proto__:null,default:e};if(null===e||"object"!=typeof e&&"function"!=typeof e)return a;if(o=r?n:t){if(o.has(e))return o.get(e);o.set(e,a)}for(const t in e)"default"!==t&&{}.hasOwnProperty.call(e,t)&&((s=(o=Object.defineProperty)&&Object.getOwnPropertyDescriptor(e,t))&&(s.get||s.set)?o(a,t,s):a[t]=e[t]);return a})(e,r)}function a(o,s,a,i,u="bilinear",p=0){const c=(0,t.convertToTensor)(o,"image","cropAndResize"),l=(0,t.convertToTensor)(s,"boxes","cropAndResize","float32"),b=(0,t.convertToTensor)(a,"boxInd","cropAndResize","int32"),d=l.shape[0];n.assert(4===c.rank,()=>"Error in cropAndResize: image must be rank 4,"+`but got rank ${c.rank}.`),n.assert(2===l.rank&&4===l.shape[1],()=>`Error in cropAndResize: boxes must be have size [${d},4] `+`but had shape ${l.shape}.`),n.assert(1===b.rank&&b.shape[0]===d,()=>`Error in cropAndResize: boxInd must be have size [${d}] `+`but had shape ${l.shape}.`),n.assert(2===i.length,()=>"Error in cropAndResize: cropSize must be of length 2, but got "+`length ${i.length}.`),n.assert(i[0]>=1&&i[1]>=1,()=>`cropSize must be atleast [1,1], but was ${i}`),n.assert("bilinear"===u||"nearest"===u,()=>`method must be bilinear or nearest, but was ${u}`);const f={image:c,boxes:l,boxInd:b},h={method:u,extrapolationValue:p,cropSize:i};return e.ENGINE.runKernel(r.CropAndResize,f,h)}const i=exports.cropAndResize=(0,o.op)({cropAndResize_:a});
},{"../../engine":"phT7","../../kernel_names":"rJl6","../../tensor_util_env":"y4X4","../../util":"XXxQ","../operation":"uE86"}],"tSJb":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.flipLeftRight=void 0;var e=require("../../engine"),t=require("../../kernel_names"),r=require("../../tensor_util_env"),n=o(require("../../util")),i=require("../operation");function o(e,t){if("function"==typeof WeakMap)var r=new WeakMap,n=new WeakMap;return(o=function(e,t){if(!t&&e&&e.__esModule)return e;var i,o,f={__proto__:null,default:e};if(null===e||"object"!=typeof e&&"function"!=typeof e)return f;if(i=t?n:r){if(i.has(e))return i.get(e);i.set(e,f)}for(const r in e)"default"!==r&&{}.hasOwnProperty.call(e,r)&&((o=(i=Object.defineProperty)&&Object.getOwnPropertyDescriptor(e,r))&&(o.get||o.set)?i(f,r,o):f[r]=e[r]);return f})(e,t)}function f(i){const o=(0,r.convertToTensor)(i,"image","flipLeftRight","float32");n.assert(4===o.rank,()=>"Error in flipLeftRight: image must be rank 4,"+`but got rank ${o.rank}.`);const f={image:o};return e.ENGINE.runKernel(t.FlipLeftRight,f,{})}const u=exports.flipLeftRight=(0,i.op)({flipLeftRight_:f});
},{"../../engine":"phT7","../../kernel_names":"rJl6","../../tensor_util_env":"y4X4","../../util":"XXxQ","../operation":"uE86"}],"QqQU":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.grayscaleToRGB=void 0;var e=require("../../tensor_util_env"),r=o(require("../../util")),t=require("../operation"),a=require("../tile");function o(e,r){if("function"==typeof WeakMap)var t=new WeakMap,a=new WeakMap;return(o=function(e,r){if(!r&&e&&e.__esModule)return e;var o,n,s={__proto__:null,default:e};if(null===e||"object"!=typeof e&&"function"!=typeof e)return s;if(o=r?a:t){if(o.has(e))return o.get(e);o.set(e,s)}for(const t in e)"default"!==t&&{}.hasOwnProperty.call(e,t)&&((n=(o=Object.defineProperty)&&Object.getOwnPropertyDescriptor(e,t))&&(n.get||n.set)?o(s,t,n):s[t]=e[t]);return s})(e,r)}function n(t){const o=(0,e.convertToTensor)(t,"image","grayscaleToRGB"),n=o.rank-1,s=o.shape[n];r.assert(o.rank>=2,()=>"Error in grayscaleToRGB: images must be at least rank 2, "+`but got rank ${o.rank}.`),r.assert(1===s,()=>"Error in grayscaleToRGB: last dimension of a grayscale image "+`should be size 1, but got size ${s}.`);const i=new Array(o.rank);return i.fill(1,0,n),i[n]=3,(0,a.tile)(o,i)}const s=exports.grayscaleToRGB=(0,t.op)({grayscaleToRGB_:n});
},{"../../tensor_util_env":"y4X4","../../util":"XXxQ","../operation":"uE86","../tile":"DlNu"}],"tEbu":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.rgbToGrayscale=void 0;var e=require("../../tensor_util_env"),r=o(require("../../util")),t=require("../cast"),a=require("../einsum"),n=require("../expand_dims"),s=require("../operation"),i=require("../tensor1d");function o(e,r){if("function"==typeof WeakMap)var t=new WeakMap,a=new WeakMap;return(o=function(e,r){if(!r&&e&&e.__esModule)return e;var n,s,i={__proto__:null,default:e};if(null===e||"object"!=typeof e&&"function"!=typeof e)return i;if(n=r?a:t){if(n.has(e))return n.get(e);n.set(e,i)}for(const t in e)"default"!==t&&{}.hasOwnProperty.call(e,t)&&((s=(n=Object.defineProperty)&&Object.getOwnPropertyDescriptor(e,t))&&(s.get||s.set)?n(i,t,s):i[t]=e[t]);return i})(e,r)}function u(s){const o=(0,e.convertToTensor)(s,"image","RGBToGrayscale"),u=o.rank-1,c=o.shape[u];r.assert(o.rank>=2,()=>"Error in RGBToGrayscale: images must be at least rank 2, "+`but got rank ${o.rank}.`),r.assert(3===c,()=>"Error in RGBToGrayscale: last dimension of an RGB image "+`should be size 3, but got size ${c}.`);const l=o.dtype,k=(0,t.cast)(o,"float32"),f=(0,i.tensor1d)([.2989,.587,.114]);let p;switch(o.rank){case 2:p=(0,a.einsum)("ij,j->i",k,f);break;case 3:p=(0,a.einsum)("ijk,k->ij",k,f);break;case 4:p=(0,a.einsum)("ijkl,l->ijk",k,f);break;case 5:p=(0,a.einsum)("ijklm,m->ijkl",k,f);break;case 6:p=(0,a.einsum)("ijklmn,n->ijklm",k,f);break;default:throw new Error("Not a valid tensor rank.")}return p=(0,n.expandDims)(p,-1),(0,t.cast)(p,l)}const c=exports.rgbToGrayscale=(0,s.op)({rgbToGrayscale_:u});
},{"../../tensor_util_env":"y4X4","../../util":"XXxQ","../cast":"qnzc","../einsum":"aqvb","../expand_dims":"WqhD","../operation":"uE86","../tensor1d":"vKgg"}],"t1ei":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.rotateWithOffset=void 0;var e=require("../../engine"),t=require("../../kernel_names"),r=require("../../tensor_util_env"),n=i(require("../../util")),o=require("../operation");function i(e,t){if("function"==typeof WeakMap)var r=new WeakMap,n=new WeakMap;return(i=function(e,t){if(!t&&e&&e.__esModule)return e;var o,i,a={__proto__:null,default:e};if(null===e||"object"!=typeof e&&"function"!=typeof e)return a;if(o=t?n:r){if(o.has(e))return o.get(e);o.set(e,a)}for(const r in e)"default"!==r&&{}.hasOwnProperty.call(e,r)&&((i=(o=Object.defineProperty)&&Object.getOwnPropertyDescriptor(e,r))&&(i.get||i.set)?o(a,r,i):a[r]=e[r]);return a})(e,t)}function a(o,i,a=0,f=.5){const u=(0,r.convertToTensor)(o,"image","rotateWithOffset","float32");n.assert(4===u.rank,()=>"Error in rotateWithOffset: image must be rank 4,"+`but got rank ${u.rank}.`);const s={image:u},l={radians:i,fillValue:a,center:f};return e.ENGINE.runKernel(t.RotateWithOffset,s,l)}const f=exports.rotateWithOffset=(0,o.op)({rotateWithOffset_:a});
},{"../../engine":"phT7","../../kernel_names":"rJl6","../../tensor_util_env":"y4X4","../../util":"XXxQ","../operation":"uE86"}],"McNH":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.nonMaxSuppSanityCheck=s;var e=t(require("../util"));function t(e,s){if("function"==typeof WeakMap)var r=new WeakMap,a=new WeakMap;return(t=function(e,t){if(!t&&e&&e.__esModule)return e;var s,n,o={__proto__:null,default:e};if(null===e||"object"!=typeof e&&"function"!=typeof e)return o;if(s=t?a:r){if(s.has(e))return s.get(e);s.set(e,o)}for(const r in e)"default"!==r&&{}.hasOwnProperty.call(e,r)&&((n=(s=Object.defineProperty)&&Object.getOwnPropertyDescriptor(e,r))&&(n.get||n.set)?s(o,r,n):o[r]=e[r]);return o})(e,s)}function s(t,s,r,a,n,o){null==a&&(a=.5),null==n&&(n=Number.NEGATIVE_INFINITY),null==o&&(o=0);const u=t.shape[0];return r=Math.min(r,u),e.assert(0<=a&&a<=1,()=>`iouThreshold must be in [0, 1], but was '${a}'`),e.assert(2===t.rank,()=>`boxes must be a 2D tensor, but was of rank '${t.rank}'`),e.assert(4===t.shape[1],()=>`boxes must have 4 columns, but 2nd dimension was ${t.shape[1]}`),e.assert(1===s.rank,()=>"scores must be a 1D tensor"),e.assert(s.shape[0]===u,()=>`scores has incompatible shape with boxes. Expected ${u}, `+`but was ${s.shape[0]}`),e.assert(0<=o&&o<=1,()=>`softNmsSigma must be in [0, 1], but was '${o}'`),{maxOutputSize:r,iouThreshold:a,scoreThreshold:n,softNmsSigma:o}}
},{"../util":"XXxQ"}],"wp0Q":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.nonMaxSuppression=void 0;var e=require("../../engine"),o=require("../../kernel_names"),r=require("../../tensor_util_env"),n=require("../nonmax_util"),s=require("../operation");function u(s,u,i,t=.5,p=Number.NEGATIVE_INFINITY){const a=(0,r.convertToTensor)(s,"boxes","nonMaxSuppression","float32"),x=(0,r.convertToTensor)(u,"scores","nonMaxSuppression","float32"),c=(0,n.nonMaxSuppSanityCheck)(a,x,i,t,p),l={maxOutputSize:i=c.maxOutputSize,iouThreshold:t=c.iouThreshold,scoreThreshold:p=c.scoreThreshold};return e.ENGINE.runKernel(o.NonMaxSuppressionV3,{boxes:a,scores:x},l)}const i=exports.nonMaxSuppression=(0,s.op)({nonMaxSuppression_:u});
},{"../../engine":"phT7","../../kernel_names":"rJl6","../../tensor_util_env":"y4X4","../nonmax_util":"McNH","../operation":"uE86"}],"Xjt4":[function(require,module,exports) {
"use strict";function e(e,n,r){const o=t(e,n,r),c=o<0?-(o+1):o;e.splice(c,0,n)}function t(e,t,o){return r(e,t,o||n)}function n(e,t){return e>t?1:e<t?-1:0}function r(e,t,n){let r=0,o=e.length,c=0,s=!1;for(;r<o;){const u=n(t,e[c=r+(o-r>>>1)]);u>0?r=c+1:(o=c,s=!u)}return s?r:-r-1}Object.defineProperty(exports,"__esModule",{value:!0}),exports.binaryInsert=e,exports.binarySearch=t;
},{}],"awVp":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.nonMaxSuppressionV3Impl=n,exports.nonMaxSuppressionV4Impl=r,exports.nonMaxSuppressionV5Impl=t;var e=require("./non_max_suppression_util");function n(e,n,r,t,o){return s(e,n,r,t,o,0)}function r(e,n,r,t,o,a){return s(e,n,r,t,o,0,!1,a,!0)}function t(e,n,r,t,o,a){return s(e,n,r,t,o,a,!0)}function s(n,r,t,s,c,i,p=!1,x=!1,h=!1){const l=[];for(let e=0;e<r.length;e++)r[e]>c&&l.push({score:r[e],boxIndex:e,suppressBeginIndex:0});l.sort(u);const M=i>0?-.5/i:0,m=[],f=[];for(;m.length<t&&l.length>0;){const r=l.pop(),{score:t,boxIndex:i,suppressBeginIndex:p}=r;if(t<c)break;let x=!1;for(let e=m.length-1;e>=p;--e){const t=o(n,i,m[e]);if(t>=s){x=!0;break}if(r.score=r.score*a(s,M,t),r.score<=c)break}r.suppressBeginIndex=m.length,x||(r.score===t?(m.push(i),f.push(r.score)):r.score>c&&(0,e.binaryInsert)(l,r,u))}const d=m.length,I=t-d;x&&I>0&&(m.push(...new Array(I).fill(0)),f.push(...new Array(I).fill(0)));const b={selectedIndices:m};return p&&(b.selectedScores=f),h&&(b.validOutputs=d),b}function o(e,n,r){const t=e.subarray(4*n,4*n+4),s=e.subarray(4*r,4*r+4),o=Math.min(t[0],t[2]),a=Math.min(t[1],t[3]),u=Math.max(t[0],t[2]),c=Math.max(t[1],t[3]),i=Math.min(s[0],s[2]),p=Math.min(s[1],s[3]),x=Math.max(s[0],s[2]),h=Math.max(s[1],s[3]),l=(u-o)*(c-a),M=(x-i)*(h-p);if(l<=0||M<=0)return 0;const m=Math.max(o,i),f=Math.max(a,p),d=Math.min(u,x),I=Math.min(c,h),b=Math.max(d-m,0)*Math.max(I-f,0);return b/(l+M-b)}function a(e,n,r){const t=Math.exp(n*r*r);return r<=e?t:0}function u(e,n){return e.score-n.score||e.score===n.score&&n.boxIndex-e.boxIndex}
},{"./non_max_suppression_util":"Xjt4"}],"kFcs":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.nonMaxSuppressionAsync=void 0;var e=require("../../backends/non_max_suppression_impl"),n=require("../../tensor_util_env"),s=require("../nonmax_util"),o=require("../tensor1d");async function r(r,t,i,p=.5,u=Number.NEGATIVE_INFINITY){const a=(0,n.convertToTensor)(r,"boxes","nonMaxSuppressionAsync"),c=(0,n.convertToTensor)(t,"scores","nonMaxSuppressionAsync"),d=(0,s.nonMaxSuppSanityCheck)(a,c,i,p,u);i=d.maxOutputSize,p=d.iouThreshold,u=d.scoreThreshold;const x=await Promise.all([a.data(),c.data()]),l=x[0],_=x[1],{selectedIndices:S}=(0,e.nonMaxSuppressionV3Impl)(l,_,i,p,u);return a!==r&&a.dispose(),c!==t&&c.dispose(),(0,o.tensor1d)(S,"int32")}const t=exports.nonMaxSuppressionAsync=r;
},{"../../backends/non_max_suppression_impl":"awVp","../../tensor_util_env":"y4X4","../nonmax_util":"McNH","../tensor1d":"vKgg"}],"KHDA":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.nonMaxSuppressionWithScore=void 0;var e=require("../../engine"),o=require("../../kernel_names"),r=require("../../tensor_util_env"),s=require("../nonmax_util"),n=require("../operation");function i(n,i,t,u=.5,p=Number.NEGATIVE_INFINITY,c=0){const a=(0,r.convertToTensor)(n,"boxes","nonMaxSuppression"),S=(0,r.convertToTensor)(i,"scores","nonMaxSuppression"),x=(0,s.nonMaxSuppSanityCheck)(a,S,t,u,p,c),h={boxes:a,scores:S},l={maxOutputSize:t=x.maxOutputSize,iouThreshold:u=x.iouThreshold,scoreThreshold:p=x.scoreThreshold,softNmsSigma:c=x.softNmsSigma},d=e.ENGINE.runKernel(o.NonMaxSuppressionV5,h,l);return{selectedIndices:d[0],selectedScores:d[1]}}const t=exports.nonMaxSuppressionWithScore=(0,n.op)({nonMaxSuppressionWithScore_:i});
},{"../../engine":"phT7","../../kernel_names":"rJl6","../../tensor_util_env":"y4X4","../nonmax_util":"McNH","../operation":"uE86"}],"t65b":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.nonMaxSuppressionWithScoreAsync=void 0;var e=require("../../backends/non_max_suppression_impl"),s=require("../../tensor_util_env"),n=require("../nonmax_util"),o=require("../tensor1d");async function r(r,t,i,c=.5,p=Number.NEGATIVE_INFINITY,a=0){const u=(0,s.convertToTensor)(r,"boxes","nonMaxSuppressionAsync"),d=(0,s.convertToTensor)(t,"scores","nonMaxSuppressionAsync"),l=(0,n.nonMaxSuppSanityCheck)(u,d,i,c,p,a);i=l.maxOutputSize,c=l.iouThreshold,p=l.scoreThreshold,a=l.softNmsSigma;const x=await Promise.all([u.data(),d.data()]),S=x[0],m=x[1],{selectedIndices:_,selectedScores:T}=(0,e.nonMaxSuppressionV5Impl)(S,m,i,c,p,a);return u!==r&&u.dispose(),d!==t&&d.dispose(),{selectedIndices:(0,o.tensor1d)(_,"int32"),selectedScores:(0,o.tensor1d)(T)}}const t=exports.nonMaxSuppressionWithScoreAsync=r;
},{"../../backends/non_max_suppression_impl":"awVp","../../tensor_util_env":"y4X4","../nonmax_util":"McNH","../tensor1d":"vKgg"}],"zXJN":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.nonMaxSuppressionPadded=void 0;var e=require("../../engine"),o=require("../../kernel_names"),n=require("../../tensor_util_env"),r=require("../nonmax_util"),s=require("../operation");function u(s,u,i,t=.5,p=Number.NEGATIVE_INFINITY,a=!1){const d=(0,n.convertToTensor)(s,"boxes","nonMaxSuppression"),x=(0,n.convertToTensor)(u,"scores","nonMaxSuppression"),c=(0,r.nonMaxSuppSanityCheck)(d,x,i,t,p,null),l={boxes:d,scores:x},S={maxOutputSize:c.maxOutputSize,iouThreshold:c.iouThreshold,scoreThreshold:c.scoreThreshold,padToMaxOutputSize:a},T=e.ENGINE.runKernel(o.NonMaxSuppressionV4,l,S);return{selectedIndices:T[0],validOutputs:T[1]}}const i=exports.nonMaxSuppressionPadded=(0,s.op)({nonMaxSuppressionPadded_:u});
},{"../../engine":"phT7","../../kernel_names":"rJl6","../../tensor_util_env":"y4X4","../nonmax_util":"McNH","../operation":"uE86"}],"sgWJ":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.nonMaxSuppressionPaddedAsync=void 0;var e=require("../../backends/non_max_suppression_impl"),s=require("../../tensor_util_env"),n=require("../nonmax_util"),o=require("../scalar"),r=require("../tensor1d");async function t(t,i,a,u=.5,p=Number.NEGATIVE_INFINITY,d=!1){const c=(0,s.convertToTensor)(t,"boxes","nonMaxSuppressionAsync"),l=(0,s.convertToTensor)(i,"scores","nonMaxSuppressionAsync"),x=(0,n.nonMaxSuppSanityCheck)(c,l,a,u,p,null),_=x.maxOutputSize,v=x.iouThreshold,S=x.scoreThreshold,[T,m]=await Promise.all([c.data(),l.data()]),{selectedIndices:y,validOutputs:I}=(0,e.nonMaxSuppressionV4Impl)(T,m,_,v,S,d);return c!==t&&c.dispose(),l!==i&&l.dispose(),{selectedIndices:(0,r.tensor1d)(y,"int32"),validOutputs:(0,o.scalar)(I,"int32")}}const i=exports.nonMaxSuppressionPaddedAsync=t;
},{"../../backends/non_max_suppression_impl":"awVp","../../tensor_util_env":"y4X4","../nonmax_util":"McNH","../scalar":"TiGU","../tensor1d":"vKgg"}],"JODz":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.resizeBilinear=void 0;var e=require("../../engine"),r=require("../../kernel_names"),n=require("../../tensor_util_env"),i=a(require("../../util")),t=require("../operation"),s=require("../reshape");function a(e,r){if("function"==typeof WeakMap)var n=new WeakMap,i=new WeakMap;return(a=function(e,r){if(!r&&e&&e.__esModule)return e;var t,s,a={__proto__:null,default:e};if(null===e||"object"!=typeof e&&"function"!=typeof e)return a;if(t=r?i:n){if(t.has(e))return t.get(e);t.set(e,a)}for(const n in e)"default"!==n&&{}.hasOwnProperty.call(e,n)&&((s=(t=Object.defineProperty)&&Object.getOwnPropertyDescriptor(e,n))&&(s.get||s.set)?t(a,n,s):a[n]=e[n]);return a})(e,r)}function o(t,a,o=!1,u=!1){const l=(0,n.convertToTensor)(t,"images","resizeBilinear");i.assert(3===l.rank||4===l.rank,()=>"Error in resizeBilinear: x must be rank 3 or 4, but got "+`rank ${l.rank}.`),i.assert(2===a.length,()=>"Error in resizeBilinear: new shape must 2D, but got shape "+`${a}.`),i.assert(!1===u||!1===o,()=>"Error in resizeBilinear: If halfPixelCenters is true, alignCorners must be false.");let p=l,f=!1;3===l.rank&&(f=!0,p=(0,s.reshape)(l,[1,l.shape[0],l.shape[1],l.shape[2]]));const[]=a,c={images:p},h={alignCorners:o,halfPixelCenters:u,size:a},_=e.ENGINE.runKernel(r.ResizeBilinear,c,h);return f?(0,s.reshape)(_,[_.shape[1],_.shape[2],_.shape[3]]):_}const u=exports.resizeBilinear=(0,t.op)({resizeBilinear_:o});
},{"../../engine":"phT7","../../kernel_names":"rJl6","../../tensor_util_env":"y4X4","../../util":"XXxQ","../operation":"uE86","../reshape":"F0cm"}],"rQ9Q":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.resizeNearestNeighbor=void 0;var e=require("../../engine"),r=require("../../kernel_names"),t=require("../../tensor_util_env"),s=i(require("../../util")),n=require("../operation"),a=require("../reshape");function i(e,r){if("function"==typeof WeakMap)var t=new WeakMap,s=new WeakMap;return(i=function(e,r){if(!r&&e&&e.__esModule)return e;var n,a,i={__proto__:null,default:e};if(null===e||"object"!=typeof e&&"function"!=typeof e)return i;if(n=r?s:t){if(n.has(e))return n.get(e);n.set(e,i)}for(const t in e)"default"!==t&&{}.hasOwnProperty.call(e,t)&&((a=(n=Object.defineProperty)&&Object.getOwnPropertyDescriptor(e,t))&&(a.get||a.set)?n(i,t,a):i[t]=e[t]);return i})(e,r)}function o(n,i,o=!1,u=!1){const p=(0,t.convertToTensor)(n,"images","resizeNearestNeighbor");s.assert(3===p.rank||4===p.rank,()=>"Error in resizeNearestNeighbor: x must be rank 3 or 4, but got "+`rank ${p.rank}.`),s.assert(2===i.length,()=>"Error in resizeNearestNeighbor: new shape must 2D, but got shape "+`${i}.`),s.assert("float32"===p.dtype||"int32"===p.dtype,()=>"`images` must have `int32` or `float32` as dtype"),s.assert(!1===u||!1===o,()=>"Error in resizeNearestNeighbor: If halfPixelCenters is true, alignCorners must be false.");let l=p,h=!1;3===p.rank&&(h=!0,l=(0,a.reshape)(p,[1,p.shape[0],p.shape[1],p.shape[2]]));const[]=i,f={images:l},g={alignCorners:o,halfPixelCenters:u,size:i},N=e.ENGINE.runKernel(r.ResizeNearestNeighbor,f,g);return h?(0,a.reshape)(N,[N.shape[1],N.shape[2],N.shape[3]]):N}const u=exports.resizeNearestNeighbor=(0,n.op)({resizeNearestNeighbor_:o});
},{"../../engine":"phT7","../../kernel_names":"rJl6","../../tensor_util_env":"y4X4","../../util":"XXxQ","../operation":"uE86","../reshape":"F0cm"}],"M9mR":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.threshold=void 0;var e=require("../tensor1d"),r=require("../operation"),t=require("../cast"),s=require("../split"),u=require("../bincount"),o=require("../less_equal"),n=require("../greater"),i=require("../sum"),a=require("../add"),l=require("../mul"),d=require("../div"),c=require("../sub"),p=require("../round"),f=require("../where"),h=require("../fill"),m=require("../slice"),q=require("../range"),b=require("../tensor"),g=v(require("../../util")),y=require("../../tensor_util_env");function v(e,r){if("function"==typeof WeakMap)var t=new WeakMap,s=new WeakMap;return(v=function(e,r){if(!r&&e&&e.__esModule)return e;var u,o,n={__proto__:null,default:e};if(null===e||"object"!=typeof e&&"function"!=typeof e)return n;if(u=r?s:t){if(u.has(e))return u.get(e);u.set(e,n)}for(const t in e)"default"!==t&&{}.hasOwnProperty.call(e,t)&&((o=(u=Object.defineProperty)&&Object.getOwnPropertyDescriptor(e,t))&&(o.get||o.set)?u(n,t,o):n[t]=e[t]);return n})(e,r)}function _(r,i="binary",d=!1,c=.5){const f=(0,y.convertToTensor)(r,"image","threshold"),h=f.shape[0]*f.shape[1];let m,q,v,_,k=(0,l.mul)((0,e.tensor1d)([c]),255);if(g.assert(3===f.rank,()=>"Error in threshold: image must be rank 3,"+`but got rank ${f.rank}.`),g.assert(3===f.shape[2]||1===f.shape[2],()=>"Error in threshold: image color channel must be equal to 3 or 1"+`but got ${f.shape[2]}.`),g.assert("int32"===f.dtype||"float32"===f.dtype,()=>"Error in dtype: image dtype must be int32 or float32,"+`but got dtype ${f.dtype}.`),g.assert("otsu"===i||"binary"===i,()=>`Method must be binary or otsu, but was ${i}`),3===f.shape[2]){[m,q,v]=(0,s.split)(f,[1,1,1],-1);const e=(0,l.mul)(m,.2989),r=(0,l.mul)(q,.587),t=(0,l.mul)(v,.114);_=(0,a.add)((0,a.add)(e,r),t)}else _=r;if("otsu"===i){k=w((0,u.bincount)((0,t.cast)((0,p.round)(_),"int32"),(0,b.tensor)([]),256),h)}const M=d?(0,o.lessEqual)(_,k):(0,n.greater)(_,k);return(0,t.cast)((0,l.mul)(M,255),"int32")}function w(r,t){let s,u,o,p,b,g,y=(0,e.tensor1d)([-1]),v=(0,e.tensor1d)([0]),_=(0,e.tensor1d)([0]);for(let w=0;w<r.size-1;w++){s=(0,m.slice)(r,0,w+1),u=(0,m.slice)(r,w+1),b=(0,d.div)((0,i.sum)(s),t),g=(0,d.div)((0,i.sum)(u),t);const k=(0,i.sum)((0,l.mul)(s,(0,q.range)(0,s.size)));o=(0,d.div)(k,(0,i.sum)(s));const M=(0,h.fill)(u.shape,s.size),O=(0,a.add)((0,q.range)(0,u.size),M),j=(0,l.mul)(u,O);p=(0,d.div)((0,i.sum)(j),(0,i.sum)(u));const z=(0,c.sub)(o,p),E=(0,c.sub)(o,p),P=(0,l.mul)(b,g);_=(0,l.mul)((0,l.mul)(P,z),E);const $=(0,n.greater)(_,v);v=(0,f.where)($,_,v),y=(0,f.where)($,(0,e.tensor1d)([w]),y)}return y}const k=exports.threshold=(0,r.op)({threshold_:_});
},{"../tensor1d":"vKgg","../operation":"uE86","../cast":"qnzc","../split":"lgPf","../bincount":"rYQ1","../less_equal":"vnhI","../greater":"WT29","../sum":"kc8w","../add":"N73o","../mul":"tBJ4","../div":"S2L5","../sub":"SgzI","../round":"NMXN","../where":"TsgC","../fill":"gaCw","../slice":"wIos","../range":"FAHd","../tensor":"woAd","../../util":"XXxQ","../../tensor_util_env":"y4X4"}],"cGGF":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.transform=void 0;var r=require("../../engine"),e=require("../../kernel_names"),t=require("../../tensor_util_env"),n=a(require("../../util")),o=require("../operation");function a(r,e){if("function"==typeof WeakMap)var t=new WeakMap,n=new WeakMap;return(a=function(r,e){if(!e&&r&&r.__esModule)return r;var o,a,s={__proto__:null,default:r};if(null===r||"object"!=typeof r&&"function"!=typeof r)return s;if(o=e?n:t){if(o.has(r))return o.get(r);o.set(r,s)}for(const t in r)"default"!==t&&{}.hasOwnProperty.call(r,t)&&((a=(o=Object.defineProperty)&&Object.getOwnPropertyDescriptor(r,t))&&(a.get||a.set)?o(s,t,a):s[t]=r[t]);return s})(r,e)}function s(o,a,s="nearest",u="constant",i=0,f){const l=(0,t.convertToTensor)(o,"image","transform","float32"),p=(0,t.convertToTensor)(a,"transforms","transform","float32");n.assert(4===l.rank,()=>"Error in transform: image must be rank 4,"+`but got rank ${l.rank}.`),n.assert(2===p.rank&&(p.shape[0]===l.shape[0]||1===p.shape[0])&&8===p.shape[1],()=>"Error in transform: Input transform should be batch x 8 or 1 x 8"),n.assert(null==f||2===f.length,()=>"Error in transform: outputShape must be [height, width] or null, "+`but got ${f}.`);const c={image:l,transforms:p},m={interpolation:s,fillMode:u,fillValue:i,outputShape:f};return r.ENGINE.runKernel(e.Transform,c,m)}const u=exports.transform=(0,o.op)({transform_:s});
},{"../../engine":"phT7","../../kernel_names":"rJl6","../../tensor_util_env":"y4X4","../../util":"XXxQ","../operation":"uE86"}],"KELI":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.bandPart=void 0;var e=require("../../tensor_util_env"),r=require("../../util"),t=require("../greater_equal"),n=require("../less"),a=require("../less_equal"),s=require("../logical_and"),u=require("../minimum"),o=require("../neg"),i=require("../operation"),m=require("../range"),p=require("../reshape"),b=require("../stack"),d=require("../sub"),l=require("../unstack"),q=require("../where"),c=require("../zeros");function g(i,g,h){const P=(0,e.convertToTensor)(i,"a","bandPart");(0,r.assert)(P.rank>=2,()=>`bandPart(): Rank must be at least 2, got ${P.rank}.`);const w=P.shape,[y,_]=P.shape.slice(-2);let k,v;"number"==typeof g?((0,r.assert)(g%1==0,()=>`bandPart(): numLower must be an integer, got ${g}.`),(0,r.assert)(g<=y,()=>`bandPart(): numLower (${g})`+` must not be greater than the number of rows (${y}).`),k=(0,e.convertToTensor)(g<0?y:g,"numLower","bandPart")):((0,r.assert)("int32"===g.dtype,()=>"bandPart(): numLower's dtype must be an int32."),k=(0,q.where)((0,n.less)(g,0),y,(0,u.minimum)(g,y))),"number"==typeof h?((0,r.assert)(h%1==0,()=>`bandPart(): numUpper must be an integer, got ${h}.`),(0,r.assert)(h<=_,()=>`bandPart(): numUpper (${h})`+` must not be greater than the number of columns (${_}).`),v=(0,e.convertToTensor)(h<0?_:h,"numUpper","bandPart")):((0,r.assert)("int32"===h.dtype,()=>"bandPart(): numUpper's dtype must be an int32."),v=(0,q.where)((0,n.less)(h,0),_,(0,u.minimum)(h,_)));const $=(0,p.reshape)((0,m.range)(0,y,1,"int32"),[-1,1]),f=(0,m.range)(0,_,1,"int32"),T=(0,d.sub)($,f),L=(0,s.logicalAnd)((0,a.lessEqual)(T,k),(0,t.greaterEqual)(T,(0,o.neg)(v))),U=(0,c.zeros)([y,_],P.dtype);return(0,p.reshape)((0,b.stack)((0,l.unstack)((0,p.reshape)(P,[-1,y,_])).map(e=>(0,q.where)(L,e,U))),w)}const h=exports.bandPart=(0,i.op)({bandPart_:g});
},{"../../tensor_util_env":"y4X4","../../util":"XXxQ","../greater_equal":"a6nY","../less":"onA7","../less_equal":"vnhI","../logical_and":"sHir","../minimum":"TKku","../neg":"i2LN","../operation":"uE86","../range":"FAHd","../reshape":"F0cm","../stack":"Wzzr","../sub":"SgzI","../unstack":"Smo9","../where":"TsgC","../zeros":"AsfN"}],"uAHR":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.gramSchmidt=void 0;var e=require("../../engine"),r=require("../../util"),t=require("../div"),s=require("../mul"),i=require("../norm"),u=require("../operation"),n=require("../split"),o=require("../squeeze"),l=require("../stack"),m=require("../sub"),a=require("../sum");function c(u){let c;if(Array.isArray(u)){c=!1,(0,r.assert)(null!=u&&u.length>0,()=>"Gram-Schmidt process: input must not be null, undefined, or empty");const e=u[0].shape[0];for(let t=1;t<u.length;++t)(0,r.assert)(u[t].shape[0]===e,()=>"Gram-Schmidt: Non-unique lengths found in the input vectors: "+`(${u[t].shape[0]} vs. ${e})`)}else c=!0,u=(0,n.split)(u,u.shape[0],0).map(e=>(0,o.squeeze)(e,[0]));(0,r.assert)(u.length<=u[0].shape[0],()=>`Gram-Schmidt: Number of vectors (${u.length}) exceeds `+`number of dimensions (${u[0].shape[0]}).`);const h=[],p=u;for(let r=0;r<u.length;++r)h.push(e.ENGINE.tidy(()=>{let e=p[r];if(r>0)for(let t=0;t<r;++t){const r=(0,s.mul)((0,a.sum)((0,s.mul)(h[t],e)),h[t]);e=(0,m.sub)(e,r)}return(0,t.div)(e,(0,i.norm)(e,"euclidean"))}));return c?(0,l.stack)(h,0):h}const h=exports.gramSchmidt=(0,u.op)({gramSchmidt_:c});
},{"../../engine":"phT7","../../util":"XXxQ","../div":"S2L5","../mul":"tBJ4","../norm":"exuO","../operation":"uE86","../split":"lgPf","../squeeze":"pxYL","../stack":"Wzzr","../sub":"SgzI","../sum":"kc8w"}],"Ppe5":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.qr=void 0;var e=require("../../engine"),r=require("../../globals"),s=require("../../util"),t=require("../clone"),u=require("../concat"),a=require("../div"),n=require("../eye"),i=require("../greater"),o=require("../mat_mul"),c=require("../mul"),l=require("../neg"),p=require("../norm"),h=require("../operation"),q=require("../reshape"),m=require("../slice"),d=require("../stack"),g=require("../sub"),b=require("../tensor2d"),k=require("../transpose"),M=require("../unstack"),f=require("../where");function v(e,r=!1){if((0,s.assert)(e.rank>=2,()=>`qr() requires input tensor to have a rank >= 2, but got rank ${e.rank}`),2===e.rank)return y(e,r);{const s=e.shape.slice(0,e.shape.length-2).reduce((e,r)=>e*r),t=(0,M.unstack)((0,q.reshape)(e,[s,e.shape[e.shape.length-2],e.shape[e.shape.length-1]]),0),u=[],a=[];return t.forEach(e=>{const[s,t]=y(e,r);u.push(s),a.push(t)}),[(0,q.reshape)((0,d.stack)(u,0),e.shape),(0,q.reshape)((0,d.stack)(a,0),e.shape)]}}function y(h,q=!1){return e.ENGINE.tidy(()=>{(0,s.assert)(2===h.shape.length,()=>`qr2d() requires a 2D Tensor, but got a ${h.shape.length}D Tensor.`);const d=h.shape[0],M=h.shape[1];let v=(0,n.eye)(d),y=(0,t.clone)(h);const E=(0,b.tensor2d)([[1]],[1,1]);let N=(0,t.clone)(E);const _=d>=M?M:d;for(let s=0;s<_;++s){const n=y,h=N,q=v;[N,y,v]=e.ENGINE.tidy(()=>{const e=(0,m.slice)(y,[s,s],[d-s,1]),r=(0,p.norm)(e),n=(0,m.slice)(y,[s,s],[1,1]),h=(0,f.where)((0,i.greater)(n,0),(0,b.tensor2d)([[-1]]),(0,b.tensor2d)([[1]])),q=(0,g.sub)(n,(0,c.mul)(h,r)),_=(0,a.div)(e,q);N=1===_.shape[0]?(0,t.clone)(E):(0,u.concat)([E,(0,m.slice)(_,[1,0],[_.shape[0]-1,_.shape[1]])],0);const x=(0,l.neg)((0,a.div)((0,o.matMul)(h,q),r)),w=(0,m.slice)(y,[s,0],[d-s,M]),D=(0,c.mul)(x,N),G=(0,k.transpose)(N);if(0===s)y=(0,g.sub)(w,(0,o.matMul)(D,(0,o.matMul)(G,w)));else{const e=(0,g.sub)(w,(0,o.matMul)(D,(0,o.matMul)(G,w)));y=(0,u.concat)([(0,m.slice)(y,[0,0],[s,M]),e],0)}const I=(0,k.transpose)(D),T=(0,m.slice)(v,[0,s],[d,v.shape[1]-s]);if(0===s)v=(0,g.sub)(T,(0,o.matMul)((0,o.matMul)(T,N),I));else{const e=(0,g.sub)(T,(0,o.matMul)((0,o.matMul)(T,N),I));v=(0,u.concat)([(0,m.slice)(v,[0,0],[d,s]),e],1)}return[N,y,v]}),(0,r.dispose)([n,h,q])}return!q&&d>M&&(v=(0,m.slice)(v,[0,0],[d,M]),y=(0,m.slice)(y,[0,0],[M,M])),[v,y]})}const E=exports.qr=(0,h.op)({qr_:v});
},{"../../engine":"phT7","../../globals":"TsQp","../../util":"XXxQ","../clone":"Ot88","../concat":"V5Ij","../div":"S2L5","../eye":"MP6S","../greater":"WT29","../mat_mul":"zVDr","../mul":"tBJ4","../neg":"i2LN","../norm":"exuO","../operation":"uE86","../reshape":"F0cm","../slice":"wIos","../stack":"Wzzr","../sub":"SgzI","../tensor2d":"UEzj","../transpose":"JmRY","../unstack":"Smo9","../where":"TsgC"}],"IQtV":[function(require,module,exports) {
"use strict";var e;Object.defineProperty(exports,"__esModule",{value:!0}),exports.Reduction=void 0,function(e){e[e.NONE=0]="NONE",e[e.MEAN=1]="MEAN",e[e.SUM=2]="SUM",e[e.SUM_BY_NONZERO_WEIGHTS=3]="SUM_BY_NONZERO_WEIGHTS"}(e||(exports.Reduction=e={}));
},{}],"WmQQ":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.computeWeightedLoss=void 0;var e=require("../../tensor_util_env"),r=require("../cast"),s=require("../div"),u=require("../loss_ops_utils"),o=require("../mean"),t=require("../mul"),i=require("../not_equal"),n=require("../ones"),c=require("../operation"),l=require("../scalar"),a=require("../sum");function d(c,d,m=u.Reduction.SUM_BY_NONZERO_WEIGHTS){const _=(0,e.convertToTensor)(c,"losses","computeWeightedLoss");let p=null;null!=d&&(p=(0,e.convertToTensor)(d,"weights","computeWeightedLoss"));const q=null==p?_:(0,t.mul)(_,p);if(m===u.Reduction.NONE)return q;if(m===u.Reduction.SUM)return(0,a.sum)(q);if(m===u.Reduction.MEAN){if(null==p)return(0,o.mean)(q);{const e=_.size/p.size,r=(0,s.div)((0,a.sum)(q),(0,a.sum)(p));return e>1?(0,s.div)(r,(0,l.scalar)(e)):r}}if(m===u.Reduction.SUM_BY_NONZERO_WEIGHTS){if(null==p)return(0,s.div)((0,a.sum)(q),(0,l.scalar)(_.size));{const e=(0,t.mul)(p,(0,n.ones)(_.shape)),u=(0,r.cast)((0,a.sum)((0,i.notEqual)(e,(0,l.scalar)(0))),"float32");return(0,s.div)((0,a.sum)(q),u)}}throw Error(`Unknown reduction: ${m}`)}const m=exports.computeWeightedLoss=(0,c.op)({computeWeightedLoss_:d});
},{"../../tensor_util_env":"y4X4","../cast":"qnzc","../div":"S2L5","../loss_ops_utils":"IQtV","../mean":"DIOh","../mul":"tBJ4","../not_equal":"TOzH","../ones":"iY3A","../operation":"uE86","../scalar":"TiGU","../sum":"kc8w"}],"coTE":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.absoluteDifference=void 0;var e=require("../../tensor_util_env"),r=require("../../util"),s=require("../abs"),o=require("../loss_ops_utils"),t=require("../operation"),i=require("../sub"),u=require("./compute_weighted_loss");function n(t,n,c,l=o.Reduction.SUM_BY_NONZERO_WEIGHTS){const a=(0,e.convertToTensor)(t,"labels","absoluteDifference"),f=(0,e.convertToTensor)(n,"predictions","absoluteDifference");let b=null;null!=c&&(b=(0,e.convertToTensor)(c,"weights","absoluteDifference")),(0,r.assertShapesMatch)(a.shape,f.shape,"Error in absoluteDifference: ");const p=(0,s.abs)((0,i.sub)(a,f));return(0,u.computeWeightedLoss)(p,b,l)}const c=exports.absoluteDifference=(0,t.op)({absoluteDifference_:n});
},{"../../tensor_util_env":"y4X4","../../util":"XXxQ","../abs":"U9d5","../loss_ops_utils":"IQtV","../operation":"uE86","../sub":"SgzI","./compute_weighted_loss":"WmQQ"}],"IpNr":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.cosineDistance=void 0;var e=require("../../tensor_util_env"),s=require("../../util"),r=require("../loss_ops_utils"),o=require("../mul"),i=require("../operation"),t=require("../scalar"),n=require("../sub"),c=require("../sum"),u=require("./compute_weighted_loss");function a(i,a,l,p,_=r.Reduction.SUM_BY_NONZERO_WEIGHTS){const q=(0,e.convertToTensor)(i,"labels","cosineDistance"),d=(0,e.convertToTensor)(a,"predictions","cosineDistance");let h=null;null!=p&&(h=(0,e.convertToTensor)(p,"weights","cosineDistance")),(0,s.assertShapesMatch)(q.shape,d.shape,"Error in cosineDistance: ");const v=(0,t.scalar)(1),D=(0,n.sub)(v,(0,c.sum)((0,o.mul)(q,d),l,!0));return(0,u.computeWeightedLoss)(D,h,_)}const l=exports.cosineDistance=(0,i.op)({cosineDistance_:a});
},{"../../tensor_util_env":"y4X4","../../util":"XXxQ","../loss_ops_utils":"IQtV","../mul":"tBJ4","../operation":"uE86","../scalar":"TiGU","../sub":"SgzI","../sum":"kc8w","./compute_weighted_loss":"WmQQ"}],"QDEw":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.hingeLoss=void 0;var e=require("../../tensor_util_env"),s=require("../../util"),r=require("../loss_ops_utils"),o=require("../mul"),t=require("../operation"),i=require("../relu"),u=require("../scalar"),n=require("../sub"),l=require("./compute_weighted_loss");function c(t,c,a,h=r.Reduction.SUM_BY_NONZERO_WEIGHTS){let p=(0,e.convertToTensor)(t,"labels","hingeLoss");const _=(0,e.convertToTensor)(c,"predictions","hingeLoss");let g=null;null!=a&&(g=(0,e.convertToTensor)(a,"weights","hingeLoss")),(0,s.assertShapesMatch)(p.shape,_.shape,"Error in hingeLoss: ");const q=(0,u.scalar)(1);p=(0,n.sub)((0,o.mul)((0,u.scalar)(2),p),q);const L=(0,i.relu)((0,n.sub)(q,(0,o.mul)(p,_)));return(0,l.computeWeightedLoss)(L,g,h)}const a=exports.hingeLoss=(0,t.op)({hingeLoss_:c});
},{"../../tensor_util_env":"y4X4","../../util":"XXxQ","../loss_ops_utils":"IQtV","../mul":"tBJ4","../operation":"uE86","../relu":"JbIg","../scalar":"TiGU","../sub":"SgzI","./compute_weighted_loss":"WmQQ"}],"wWxs":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.huberLoss=void 0;var e=require("../../tensor_util_env"),r=require("../../util"),s=require("../abs"),u=require("../add"),o=require("../loss_ops_utils"),i=require("../minimum"),t=require("../mul"),n=require("../operation"),a=require("../scalar"),l=require("../square"),c=require("../sub"),b=require("./compute_weighted_loss");function h(n,h,q,p=1,_=o.Reduction.SUM_BY_NONZERO_WEIGHTS){const d=(0,e.convertToTensor)(n,"labels","huberLoss"),m=(0,e.convertToTensor)(h,"predictions","huberLoss");let L=null;null!=q&&(L=(0,e.convertToTensor)(q,"weights","huberLoss")),(0,r.assertShapesMatch)(d.shape,m.shape,"Error in huberLoss: ");const v=(0,a.scalar)(p),T=(0,s.abs)((0,c.sub)(m,d)),g=(0,i.minimum)(T,v),x=(0,c.sub)(T,g),E=(0,u.add)((0,t.mul)((0,a.scalar)(.5),(0,l.square)(g)),(0,t.mul)(v,x));return(0,b.computeWeightedLoss)(E,L,_)}const q=exports.huberLoss=(0,n.op)({huberLoss_:h});
},{"../../tensor_util_env":"y4X4","../../util":"XXxQ","../abs":"U9d5","../add":"N73o","../loss_ops_utils":"IQtV","../minimum":"TKku","../mul":"tBJ4","../operation":"uE86","../scalar":"TiGU","../square":"KiGo","../sub":"SgzI","./compute_weighted_loss":"WmQQ"}],"sLE3":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.logLoss=void 0;var e=require("../../tensor_util_env"),s=require("../../util"),o=require("../add"),r=require("../log"),u=require("../loss_ops_utils"),l=require("../mul"),t=require("../neg"),i=require("../operation"),n=require("../scalar"),a=require("../sub"),c=require("./compute_weighted_loss");function g(i,g,d,p=1e-7,_=u.Reduction.SUM_BY_NONZERO_WEIGHTS){const q=(0,e.convertToTensor)(i,"labels","logLoss"),L=(0,e.convertToTensor)(g,"predictions","logLoss");let h=null;null!=d&&(h=(0,e.convertToTensor)(d,"weights","logLoss")),(0,s.assertShapesMatch)(q.shape,L.shape,"Error in logLoss: ");const v=(0,n.scalar)(1),T=(0,n.scalar)(p),b=(0,t.neg)((0,l.mul)(q,(0,r.log)((0,o.add)(L,T)))),m=(0,l.mul)((0,a.sub)(v,q),(0,r.log)((0,o.add)((0,a.sub)(v,L),T))),x=(0,a.sub)(b,m);return(0,c.computeWeightedLoss)(x,h,_)}const d=exports.logLoss=(0,i.op)({logLoss_:g});
},{"../../tensor_util_env":"y4X4","../../util":"XXxQ","../add":"N73o","../log":"f3PH","../loss_ops_utils":"IQtV","../mul":"tBJ4","../neg":"i2LN","../operation":"uE86","../scalar":"TiGU","../sub":"SgzI","./compute_weighted_loss":"WmQQ"}],"ZpcK":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.meanSquaredError=void 0;var e=require("../../tensor_util_env"),r=require("../../util"),o=require("../loss_ops_utils"),s=require("../operation"),n=require("../squared_difference"),t=require("./compute_weighted_loss");function u(s,u,a,i=o.Reduction.SUM_BY_NONZERO_WEIGHTS){const d=(0,e.convertToTensor)(s,"labels","meanSquaredError"),c=(0,e.convertToTensor)(u,"predictions","meanSquaredError");let q=null;null!=a&&(q=(0,e.convertToTensor)(a,"weights","meanSquaredError")),(0,r.assertShapesMatch)(d.shape,c.shape,"Error in meanSquaredError: ");const l=(0,n.squaredDifference)(d,c);return(0,t.computeWeightedLoss)(l,q,i)}const a=exports.meanSquaredError=(0,s.op)({meanSquaredError_:u});
},{"../../tensor_util_env":"y4X4","../../util":"XXxQ","../loss_ops_utils":"IQtV","../operation":"uE86","../squared_difference":"hbAV","./compute_weighted_loss":"WmQQ"}],"E5VI":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.sigmoidCrossEntropy=void 0;var r=require("../../tensor_util_env"),s=require("../../util"),e=require("../abs"),o=require("../add"),i=require("../exp"),t=require("../log1p"),n=require("../loss_ops_utils"),u=require("../mul"),l=require("../neg"),a=require("../operation"),p=require("../relu"),c=require("../scalar"),d=require("../sub"),g=require("./compute_weighted_loss");function m(n,a){const c=(0,r.convertToTensor)(n,"labels","sigmoidCrossEntropyWithLogits"),g=(0,r.convertToTensor)(a,"logits","sigmoidCrossEntropyWithLogits");(0,s.assertShapesMatch)(c.shape,g.shape,"Error in sigmoidCrossEntropyWithLogits: ");const m=(0,p.relu)(g),h=(0,u.mul)(g,c),q=(0,t.log1p)((0,i.exp)((0,l.neg)((0,e.abs)(g))));return(0,o.add)((0,d.sub)(m,h),q)}function h(e,i,t,l=0,a=n.Reduction.SUM_BY_NONZERO_WEIGHTS){let p=(0,r.convertToTensor)(e,"multiClassLabels","sigmoidCrossEntropy");const h=(0,r.convertToTensor)(i,"logits","sigmoidCrossEntropy");let q=null;if(null!=t&&(q=(0,r.convertToTensor)(t,"weights","sigmoidCrossEntropy")),(0,s.assertShapesMatch)(p.shape,h.shape,"Error in sigmoidCrossEntropy: "),l>0){const r=(0,c.scalar)(l),s=(0,c.scalar)(1),e=(0,c.scalar)(.5);p=(0,o.add)((0,u.mul)(p,(0,d.sub)(s,r)),(0,u.mul)(e,r))}const E=m(p,h);return(0,g.computeWeightedLoss)(E,q,a)}const q=exports.sigmoidCrossEntropy=(0,a.op)({sigmoidCrossEntropy_:h});
},{"../../tensor_util_env":"y4X4","../../util":"XXxQ","../abs":"U9d5","../add":"N73o","../exp":"xcz4","../log1p":"ODmc","../loss_ops_utils":"IQtV","../mul":"tBJ4","../neg":"i2LN","../operation":"uE86","../relu":"JbIg","../scalar":"TiGU","../sub":"SgzI","./compute_weighted_loss":"WmQQ"}],"w47l":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.softmaxCrossEntropy=void 0;var e=require("../../gradients"),r=require("../../tensor_util_env"),s=require("../../util"),o=require("../add"),t=require("../axis_util"),a=require("../cast"),n=require("../div"),u=require("../exp"),i=require("../log_sum_exp"),l=require("../loss_ops_utils"),p=require("../mul"),c=require("../neg"),m=require("../operation"),d=require("../reshape"),q=require("../scalar"),x=require("../sub"),f=require("../sum"),h=require("./compute_weighted_loss");function _(r,s,o=-1){if(-1===o&&(o=s.rank-1),o!==s.rank-1)throw Error("Softmax cross entropy along a non-last dimension is not yet "+`supported. Labels / logits was rank ${s.rank} `+`and dim was ${o}`);return(0,e.customGrad)((e,r,s)=>{const n=(0,i.logSumExp)(r,[o],!0),l=(0,x.sub)((0,a.cast)(r,"float32"),n);s([e,l]);const m=(0,c.neg)((0,p.mul)(l,e));return{value:(0,f.sum)(m,[o]),gradFunc:(e,r)=>{const[s,n]=r,i=(0,t.expandShapeToKeepDim)(e.shape,[o]);return[(0,p.mul)((0,d.reshape)(e,i),(0,x.sub)((0,a.cast)(s,"float32"),(0,u.exp)(n))),(0,p.mul)((0,d.reshape)(e,i),(0,x.sub)((0,u.exp)(n),(0,a.cast)(s,"float32")))]}}})(r,s)}function g(e,t,a,u=0,i=l.Reduction.SUM_BY_NONZERO_WEIGHTS){let c=(0,r.convertToTensor)(e,"onehotLabels","softmaxCrossEntropy");const m=(0,r.convertToTensor)(t,"logits","softmaxCrossEntropy");let d=null;if(null!=a&&(d=(0,r.convertToTensor)(a,"weights","softmaxCrossEntropy")),(0,s.assertShapesMatch)(c.shape,m.shape,"Error in softmaxCrossEntropy: "),u>0){const e=(0,q.scalar)(u),r=(0,q.scalar)(1),s=(0,q.scalar)(c.shape[1]);c=(0,o.add)((0,p.mul)(c,(0,x.sub)(r,e)),(0,n.div)(e,s))}const f=_(c,m);return(0,h.computeWeightedLoss)(f,d,i)}const E=exports.softmaxCrossEntropy=(0,m.op)({softmaxCrossEntropy_:g});
},{"../../gradients":"VR5t","../../tensor_util_env":"y4X4","../../util":"XXxQ","../add":"N73o","../axis_util":"mPwf","../cast":"qnzc","../div":"S2L5","../exp":"xcz4","../log_sum_exp":"te98","../loss_ops_utils":"IQtV","../mul":"tBJ4","../neg":"i2LN","../operation":"uE86","../reshape":"F0cm","../scalar":"TiGU","../sub":"SgzI","../sum":"kc8w","./compute_weighted_loss":"WmQQ"}],"mqNF":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.sparseFillEmptyRows=void 0;var e=require("../../engine"),r=require("../../kernel_names"),s=require("../../tensor_util_env"),o=require("../operation");function n(o,n,t,a){const p=(0,s.convertToTensor)(o,"indices","sparseFillEmptyRows","int32"),i=(0,s.convertToTensor)(n,"values","sparseFillEmptyRows"),l=(0,s.convertToTensor)(t,"denseShape","sparseFillEmptyRows","int32"),u=(0,s.convertToTensor)(a,"defaultValue","sparseFillEmptyRows",i.dtype);if(2!==p.rank)throw new Error(`Indices should be Tensor2D but received shape\n        ${p.shape}`);if(1!==i.rank)throw new Error(`Values should be Tensor1D but received shape ${i.shape}`);if(1!==l.rank)throw new Error(`Dense shape should be Tensor1D but received shape ${l.shape}`);if(0!==u.rank)throw new Error(`Default value should be a scalar but received shape ${u.shape}`);const d={indices:p,values:i,denseShape:l,defaultValue:u},c=e.ENGINE.runKernel(r.SparseFillEmptyRows,d);return{outputIndices:c[0],outputValues:c[1],emptyRowIndicator:c[2],reverseIndexMap:c[3]}}const t=exports.sparseFillEmptyRows=(0,o.op)({sparseFillEmptyRows_:n});
},{"../../engine":"phT7","../../kernel_names":"rJl6","../../tensor_util_env":"y4X4","../operation":"uE86"}],"zr2y":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.sparseReshape=void 0;var e=require("../../engine"),r=require("../../kernel_names"),s=require("../../tensor_util_env"),n=require("../operation");function p(n,p,o){const t=(0,s.convertToTensor)(n,"inputIndices","sparseReshape","int32"),a=(0,s.convertToTensor)(p,"inputShape","sparseReshape","int32"),i=(0,s.convertToTensor)(o,"newShape","sparseReshape","int32");if(2!==t.rank)throw new Error(`Input indices should be Tensor2D but received shape\n        ${t.shape}`);if(1!==a.rank)throw new Error(`Input shape should be Tensor1D but received shape ${a.shape}`);if(1!==i.rank)throw new Error(`New shape should be Tensor1D but received shape ${i.shape}`);const u={inputIndices:t,inputShape:a,newShape:i},h=e.ENGINE.runKernel(r.SparseReshape,u);return{outputIndices:h[0],outputShape:h[1]}}const o=exports.sparseReshape=(0,n.op)({sparseReshape_:p});
},{"../../engine":"phT7","../../kernel_names":"rJl6","../../tensor_util_env":"y4X4","../operation":"uE86"}],"CqLM":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.sparseSegmentMean=void 0;var e=require("../../engine"),n=require("../../kernel_names"),r=require("../../tensor_util_env"),s=require("../operation");function t(s,t,a){const o=(0,r.convertToTensor)(s,"data","sparseSegmentMean"),i=(0,r.convertToTensor)(t,"indices","sparseSegmentMean","int32"),d=(0,r.convertToTensor)(a,"segmentIds","sparseSegmentMean","int32");if(o.rank<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==i.rank)throw new Error(`Indices should be Tensor1D but received shape\n          ${i.shape}`);if(1!==d.rank)throw new Error(`Segment ids should be Tensor1D but received shape\n          ${d.shape}`);const p={data:o,indices:i,segmentIds:d};return e.ENGINE.runKernel(n.SparseSegmentMean,p)}const a=exports.sparseSegmentMean=(0,s.op)({sparseSegmentMean_:t});
},{"../../engine":"phT7","../../kernel_names":"rJl6","../../tensor_util_env":"y4X4","../operation":"uE86"}],"bhoc":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.sparseSegmentSum=void 0;var e=require("../../engine"),r=require("../../kernel_names"),n=require("../../tensor_util_env"),s=require("../operation");function t(s,t,o){const a=(0,n.convertToTensor)(s,"data","sparseSegmentSum"),i=(0,n.convertToTensor)(t,"indices","sparseSegmentSum","int32"),u=(0,n.convertToTensor)(o,"segmentIds","sparseSegmentSum","int32");if(a.rank<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==i.rank)throw new Error(`Indices should be Tensor1D but received shape\n         ${i.shape}`);if(1!==u.rank)throw new Error(`Segment ids should be Tensor1D but received shape\n         ${u.shape}`);const m={data:a,indices:i,segmentIds:u};return e.ENGINE.runKernel(r.SparseSegmentSum,m)}const o=exports.sparseSegmentSum=(0,s.op)({sparseSegmentSum_:t});
},{"../../engine":"phT7","../../kernel_names":"rJl6","../../tensor_util_env":"y4X4","../operation":"uE86"}],"IQZI":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.stringNGrams=void 0;var r=require("../../engine"),t=require("../../kernel_names"),e=require("../../tensor_util_env"),s=require("../operation");function a(s,a,n,i,o,p,d,u){const m=(0,e.convertToTensor)(s,"data","stringNGrams","string");if("string"!==m.dtype)throw new Error("Data must be of datatype string");if(1!==m.shape.length)throw new Error(`Data must be a vector, saw: ${m.shape}`);const g=(0,e.convertToTensor)(a,"dataSplits","stringNGrams");if("int32"!==g.dtype)throw new Error("Data splits must be of datatype int32");const c={separator:n,nGramWidths:i,leftPad:o,rightPad:p,padWidth:d,preserveShortSequences:u},l={data:m,dataSplits:g},h=r.ENGINE.runKernel(t.StringNGrams,l,c);return{nGrams:h[0],nGramsSplits:h[1]}}const n=exports.stringNGrams=(0,s.op)({stringNGrams_:a});
},{"../../engine":"phT7","../../kernel_names":"rJl6","../../tensor_util_env":"y4X4","../operation":"uE86"}],"JNPF":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.stringSplit=void 0;var e=require("../../engine"),r=require("../../kernel_names"),t=require("../../tensor_util_env"),i=require("../operation");function n(i,n,s=!0){const o=(0,t.convertToTensor)(i,"input","stringSplit","string"),p=(0,t.convertToTensor)(n,"delimiter","stringSplit","string");if(1!==o.rank)throw new Error(`Input should be Tensor1D but received shape ${o.shape}`);if(0!==p.rank)throw new Error(`Delimiter should be a scalar but received shape ${p.shape}`);const u={skipEmpty:s},l={input:o,delimiter:p},a=e.ENGINE.runKernel(r.StringSplit,l,u);return{indices:a[0],values:a[1],shape:a[2]}}const s=exports.stringSplit=(0,i.op)({stringSplit_:n});
},{"../../engine":"phT7","../../kernel_names":"rJl6","../../tensor_util_env":"y4X4","../operation":"uE86"}],"ouv1":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.stringToHashBucketFast=void 0;var e=require("../../engine"),t=require("../../kernel_names"),r=require("../../tensor_util_env"),s=require("../operation");function n(s,n){const o=(0,r.convertToTensor)(s,"input","stringToHashBucketFast","string"),u={numBuckets:n};if(n<=0)throw new Error("Number of buckets must be at least 1");const i={input:o};return e.ENGINE.runKernel(t.StringToHashBucketFast,i,u)}const o=exports.stringToHashBucketFast=(0,s.op)({stringToHashBucketFast_:n});
},{"../../engine":"phT7","../../kernel_names":"rJl6","../../tensor_util_env":"y4X4","../operation":"uE86"}],"gbgW":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.staticRegexReplace=void 0;var e=require("../../engine"),t=require("../../kernel_names"),r=require("../../tensor_util_env"),n=require("../operation");function i(n,i,a,c=!0){const o=(0,r.convertToTensor)(n,"input","staticRegexReplace","string"),s={pattern:i,rewrite:a,replaceGlobal:c};return e.ENGINE.runKernel(t.StaticRegexReplace,{x:o},s)}const a=exports.staticRegexReplace=(0,n.op)({staticRegexReplace_:i});
},{"../../engine":"phT7","../../kernel_names":"rJl6","../../tensor_util_env":"y4X4","../operation":"uE86"}],"hfXJ":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0});var e={image:!0,linalg:!0,losses:!0,spectral:!0,signal:!0,sparse:!0,string:!0,abs:!0,acos:!0,acosh:!0,add:!0,addN:!0,all:!0,any:!0,argMax:!0,argMin:!0,asin:!0,asinh:!0,atan:!0,atan2:!0,atanh:!0,avgPool:!0,avgPool3d:!0,basicLSTMCell:!0,batchToSpaceND:!0,batchNorm:!0,batchNorm2d:!0,batchNorm3d:!0,batchNorm4d:!0,bincount:!0,bitwiseAnd:!0,broadcastArgs:!0,broadcastTo:!0,buffer:!0,cast:!0,ceil:!0,clipByValue:!0,clone:!0,complex:!0,concat:!0,concat1d:!0,concat2d:!0,concat3d:!0,concat4d:!0,conv1d:!0,conv2d:!0,conv2dTranspose:!0,conv3d:!0,conv3dTranspose:!0,cos:!0,cosh:!0,cumprod:!0,cumsum:!0,denseBincount:!0,depthToSpace:!0,depthwiseConv2d:!0,diag:!0,dilation2d:!0,div:!0,divNoNan:!0,dot:!0,einsum:!0,elu:!0,ensureShape:!0,equal:!0,erf:!0,euclideanNorm:!0,exp:!0,expandDims:!0,expm1:!0,eye:!0,fill:!0,floor:!0,floorDiv:!0,gather:!0,greater:!0,greaterEqual:!0,imag:!0,isFinite:!0,isInf:!0,isNaN:!0,leakyRelu:!0,less:!0,lessEqual:!0,linspace:!0,localResponseNormalization:!0,log:!0,log1p:!0,logSigmoid:!0,logSoftmax:!0,logSumExp:!0,logicalAnd:!0,logicalNot:!0,logicalOr:!0,logicalXor:!0,lowerBound:!0,matMul:!0,max:!0,maxPool:!0,maxPool3d:!0,maxPoolWithArgmax:!0,maximum:!0,mean:!0,meshgrid:!0,min:!0,minimum:!0,mirrorPad:!0,mod:!0,moments:!0,mul:!0,multiRNNCell:!0,multinomial:!0,neg:!0,notEqual:!0,oneHot:!0,ones:!0,onesLike:!0,outerProduct:!0,pad:!0,pad1d:!0,pad2d:!0,pad3d:!0,pad4d:!0,pool:!0,pow:!0,prelu:!0,print:!0,prod:!0,raggedGather:!0,raggedRange:!0,raggedTensorToTensor:!0,rand:!0,randomGamma:!0,randomNormal:!0,randomStandardNormal:!0,randomUniform:!0,randomUniformInt:!0,range:!0,real:!0,reciprocal:!0,relu:!0,relu6:!0,reshape:!0,reverse:!0,reverse1d:!0,reverse2d:!0,reverse3d:!0,reverse4d:!0,round:!0,rsqrt:!0,scalar:!0,selu:!0,separableConv2d:!0,setdiff1dAsync:!0,sigmoid:!0,sign:!0,sin:!0,sinh:!0,slice:!0,slice1d:!0,slice2d:!0,slice3d:!0,slice4d:!0,softmax:!0,softplus:!0,spaceToBatchND:!0,fft:!0,ifft:!0,irfft:!0,rfft:!0,split:!0,sqrt:!0,square:!0,squaredDifference:!0,squeeze:!0,stack:!0,step:!0,stridedSlice:!0,sub:!0,sum:!0,tan:!0,tanh:!0,tensor:!0,tensor1d:!0,tensor2d:!0,tensor3d:!0,tensor4d:!0,tensor5d:!0,tensor6d:!0,tensorScatterUpdate:!0,tile:!0,topk:!0,truncatedNormal:!0,unique:!0,unsortedSegmentSum:!0,unstack:!0,upperBound:!0,variable:!0,where:!0,whereAsync:!0,zeros:!0,zerosLike:!0,op:!0,OP_SCOPE_SUFFIX:!0,fused:!0};Object.defineProperty(exports,"OP_SCOPE_SUFFIX",{enumerable:!0,get:function(){return Xt.OP_SCOPE_SUFFIX}}),Object.defineProperty(exports,"abs",{enumerable:!0,get:function(){return r.abs}}),Object.defineProperty(exports,"acos",{enumerable:!0,get:function(){return t.acos}}),Object.defineProperty(exports,"acosh",{enumerable:!0,get:function(){return n.acosh}}),Object.defineProperty(exports,"add",{enumerable:!0,get:function(){return o.add}}),Object.defineProperty(exports,"addN",{enumerable:!0,get:function(){return u.addN}}),Object.defineProperty(exports,"all",{enumerable:!0,get:function(){return i.all}}),Object.defineProperty(exports,"any",{enumerable:!0,get:function(){return a.any}}),Object.defineProperty(exports,"argMax",{enumerable:!0,get:function(){return s.argMax}}),Object.defineProperty(exports,"argMin",{enumerable:!0,get:function(){return c.argMin}}),Object.defineProperty(exports,"asin",{enumerable:!0,get:function(){return p.asin}}),Object.defineProperty(exports,"asinh",{enumerable:!0,get:function(){return d.asinh}}),Object.defineProperty(exports,"atan",{enumerable:!0,get:function(){return l.atan}}),Object.defineProperty(exports,"atan2",{enumerable:!0,get:function(){return f.atan2}}),Object.defineProperty(exports,"atanh",{enumerable:!0,get:function(){return b.atanh}}),Object.defineProperty(exports,"avgPool",{enumerable:!0,get:function(){return m.avgPool}}),Object.defineProperty(exports,"avgPool3d",{enumerable:!0,get:function(){return g.avgPool3d}}),Object.defineProperty(exports,"basicLSTMCell",{enumerable:!0,get:function(){return x.basicLSTMCell}}),Object.defineProperty(exports,"batchNorm",{enumerable:!0,get:function(){return q.batchNorm}}),Object.defineProperty(exports,"batchNorm2d",{enumerable:!0,get:function(){return O.batchNorm2d}}),Object.defineProperty(exports,"batchNorm3d",{enumerable:!0,get:function(){return P.batchNorm3d}}),Object.defineProperty(exports,"batchNorm4d",{enumerable:!0,get:function(){return j.batchNorm4d}}),Object.defineProperty(exports,"batchToSpaceND",{enumerable:!0,get:function(){return y.batchToSpaceND}}),Object.defineProperty(exports,"bincount",{enumerable:!0,get:function(){return _.bincount}}),Object.defineProperty(exports,"bitwiseAnd",{enumerable:!0,get:function(){return h.bitwiseAnd}}),Object.defineProperty(exports,"broadcastArgs",{enumerable:!0,get:function(){return v.broadcastArgs}}),Object.defineProperty(exports,"broadcastTo",{enumerable:!0,get:function(){return S.broadcastTo}}),Object.defineProperty(exports,"buffer",{enumerable:!0,get:function(){return N.buffer}}),Object.defineProperty(exports,"cast",{enumerable:!0,get:function(){return w.cast}}),Object.defineProperty(exports,"ceil",{enumerable:!0,get:function(){return k.ceil}}),Object.defineProperty(exports,"clipByValue",{enumerable:!0,get:function(){return M.clipByValue}}),Object.defineProperty(exports,"clone",{enumerable:!0,get:function(){return T.clone}}),Object.defineProperty(exports,"complex",{enumerable:!0,get:function(){return E.complex}}),Object.defineProperty(exports,"concat",{enumerable:!0,get:function(){return A.concat}}),Object.defineProperty(exports,"concat1d",{enumerable:!0,get:function(){return R.concat1d}}),Object.defineProperty(exports,"concat2d",{enumerable:!0,get:function(){return z.concat2d}}),Object.defineProperty(exports,"concat3d",{enumerable:!0,get:function(){return B.concat3d}}),Object.defineProperty(exports,"concat4d",{enumerable:!0,get:function(){return D.concat4d}}),Object.defineProperty(exports,"conv1d",{enumerable:!0,get:function(){return C.conv1d}}),Object.defineProperty(exports,"conv2d",{enumerable:!0,get:function(){return L.conv2d}}),Object.defineProperty(exports,"conv2dTranspose",{enumerable:!0,get:function(){return W.conv2dTranspose}}),Object.defineProperty(exports,"conv3d",{enumerable:!0,get:function(){return F.conv3d}}),Object.defineProperty(exports,"conv3dTranspose",{enumerable:!0,get:function(){return G.conv3dTranspose}}),Object.defineProperty(exports,"cos",{enumerable:!0,get:function(){return U.cos}}),Object.defineProperty(exports,"cosh",{enumerable:!0,get:function(){return I.cosh}}),Object.defineProperty(exports,"cumprod",{enumerable:!0,get:function(){return X.cumprod}}),Object.defineProperty(exports,"cumsum",{enumerable:!0,get:function(){return H.cumsum}}),Object.defineProperty(exports,"denseBincount",{enumerable:!0,get:function(){return V.denseBincount}}),Object.defineProperty(exports,"depthToSpace",{enumerable:!0,get:function(){return J.depthToSpace}}),Object.defineProperty(exports,"depthwiseConv2d",{enumerable:!0,get:function(){return K.depthwiseConv2d}}),Object.defineProperty(exports,"diag",{enumerable:!0,get:function(){return Q.diag}}),Object.defineProperty(exports,"dilation2d",{enumerable:!0,get:function(){return Y.dilation2d}}),Object.defineProperty(exports,"div",{enumerable:!0,get:function(){return Z.div}}),Object.defineProperty(exports,"divNoNan",{enumerable:!0,get:function(){return $.divNoNan}}),Object.defineProperty(exports,"dot",{enumerable:!0,get:function(){return ee.dot}}),Object.defineProperty(exports,"einsum",{enumerable:!0,get:function(){return re.einsum}}),Object.defineProperty(exports,"elu",{enumerable:!0,get:function(){return te.elu}}),Object.defineProperty(exports,"ensureShape",{enumerable:!0,get:function(){return ne.ensureShape}}),Object.defineProperty(exports,"equal",{enumerable:!0,get:function(){return oe.equal}}),Object.defineProperty(exports,"erf",{enumerable:!0,get:function(){return ue.erf}}),Object.defineProperty(exports,"euclideanNorm",{enumerable:!0,get:function(){return ie.euclideanNorm}}),Object.defineProperty(exports,"exp",{enumerable:!0,get:function(){return ae.exp}}),Object.defineProperty(exports,"expandDims",{enumerable:!0,get:function(){return se.expandDims}}),Object.defineProperty(exports,"expm1",{enumerable:!0,get:function(){return ce.expm1}}),Object.defineProperty(exports,"eye",{enumerable:!0,get:function(){return pe.eye}}),Object.defineProperty(exports,"fft",{enumerable:!0,get:function(){return Zr.fft}}),Object.defineProperty(exports,"fill",{enumerable:!0,get:function(){return de.fill}}),Object.defineProperty(exports,"floor",{enumerable:!0,get:function(){return le.floor}}),Object.defineProperty(exports,"floorDiv",{enumerable:!0,get:function(){return fe.floorDiv}}),exports.fused=void 0,Object.defineProperty(exports,"gather",{enumerable:!0,get:function(){return be.gather}}),Object.defineProperty(exports,"greater",{enumerable:!0,get:function(){return me.greater}}),Object.defineProperty(exports,"greaterEqual",{enumerable:!0,get:function(){return ge.greaterEqual}}),Object.defineProperty(exports,"ifft",{enumerable:!0,get:function(){return $r.ifft}}),Object.defineProperty(exports,"imag",{enumerable:!0,get:function(){return xe.imag}}),exports.image=void 0,Object.defineProperty(exports,"irfft",{enumerable:!0,get:function(){return et.irfft}}),Object.defineProperty(exports,"isFinite",{enumerable:!0,get:function(){return ye.isFinite}}),Object.defineProperty(exports,"isInf",{enumerable:!0,get:function(){return qe.isInf}}),Object.defineProperty(exports,"isNaN",{enumerable:!0,get:function(){return Oe.isNaN}}),Object.defineProperty(exports,"leakyRelu",{enumerable:!0,get:function(){return Pe.leakyRelu}}),Object.defineProperty(exports,"less",{enumerable:!0,get:function(){return je.less}}),Object.defineProperty(exports,"lessEqual",{enumerable:!0,get:function(){return _e.lessEqual}}),exports.linalg=void 0,Object.defineProperty(exports,"linspace",{enumerable:!0,get:function(){return he.linspace}}),Object.defineProperty(exports,"localResponseNormalization",{enumerable:!0,get:function(){return ve.localResponseNormalization}}),Object.defineProperty(exports,"log",{enumerable:!0,get:function(){return Se.log}}),Object.defineProperty(exports,"log1p",{enumerable:!0,get:function(){return Ne.log1p}}),Object.defineProperty(exports,"logSigmoid",{enumerable:!0,get:function(){return we.logSigmoid}}),Object.defineProperty(exports,"logSoftmax",{enumerable:!0,get:function(){return ke.logSoftmax}}),Object.defineProperty(exports,"logSumExp",{enumerable:!0,get:function(){return Me.logSumExp}}),Object.defineProperty(exports,"logicalAnd",{enumerable:!0,get:function(){return Te.logicalAnd}}),Object.defineProperty(exports,"logicalNot",{enumerable:!0,get:function(){return Ee.logicalNot}}),Object.defineProperty(exports,"logicalOr",{enumerable:!0,get:function(){return Ae.logicalOr}}),Object.defineProperty(exports,"logicalXor",{enumerable:!0,get:function(){return Re.logicalXor}}),exports.losses=void 0,Object.defineProperty(exports,"lowerBound",{enumerable:!0,get:function(){return ze.lowerBound}}),Object.defineProperty(exports,"matMul",{enumerable:!0,get:function(){return Be.matMul}}),Object.defineProperty(exports,"max",{enumerable:!0,get:function(){return De.max}}),Object.defineProperty(exports,"maxPool",{enumerable:!0,get:function(){return Ce.maxPool}}),Object.defineProperty(exports,"maxPool3d",{enumerable:!0,get:function(){return Le.maxPool3d}}),Object.defineProperty(exports,"maxPoolWithArgmax",{enumerable:!0,get:function(){return We.maxPoolWithArgmax}}),Object.defineProperty(exports,"maximum",{enumerable:!0,get:function(){return Fe.maximum}}),Object.defineProperty(exports,"mean",{enumerable:!0,get:function(){return Ge.mean}}),Object.defineProperty(exports,"meshgrid",{enumerable:!0,get:function(){return Ue.meshgrid}}),Object.defineProperty(exports,"min",{enumerable:!0,get:function(){return Ie.min}}),Object.defineProperty(exports,"minimum",{enumerable:!0,get:function(){return Xe.minimum}}),Object.defineProperty(exports,"mirrorPad",{enumerable:!0,get:function(){return He.mirrorPad}}),Object.defineProperty(exports,"mod",{enumerable:!0,get:function(){return Ve.mod}}),Object.defineProperty(exports,"moments",{enumerable:!0,get:function(){return Je.moments}}),Object.defineProperty(exports,"mul",{enumerable:!0,get:function(){return Ke.mul}}),Object.defineProperty(exports,"multiRNNCell",{enumerable:!0,get:function(){return Qe.multiRNNCell}}),Object.defineProperty(exports,"multinomial",{enumerable:!0,get:function(){return Ye.multinomial}}),Object.defineProperty(exports,"neg",{enumerable:!0,get:function(){return Ze.neg}}),Object.defineProperty(exports,"notEqual",{enumerable:!0,get:function(){return $e.notEqual}}),Object.defineProperty(exports,"oneHot",{enumerable:!0,get:function(){return er.oneHot}}),Object.defineProperty(exports,"ones",{enumerable:!0,get:function(){return rr.ones}}),Object.defineProperty(exports,"onesLike",{enumerable:!0,get:function(){return tr.onesLike}}),Object.defineProperty(exports,"op",{enumerable:!0,get:function(){return Xt.op}}),Object.defineProperty(exports,"outerProduct",{enumerable:!0,get:function(){return nr.outerProduct}}),Object.defineProperty(exports,"pad",{enumerable:!0,get:function(){return or.pad}}),Object.defineProperty(exports,"pad1d",{enumerable:!0,get:function(){return ur.pad1d}}),Object.defineProperty(exports,"pad2d",{enumerable:!0,get:function(){return ir.pad2d}}),Object.defineProperty(exports,"pad3d",{enumerable:!0,get:function(){return ar.pad3d}}),Object.defineProperty(exports,"pad4d",{enumerable:!0,get:function(){return sr.pad4d}}),Object.defineProperty(exports,"pool",{enumerable:!0,get:function(){return cr.pool}}),Object.defineProperty(exports,"pow",{enumerable:!0,get:function(){return pr.pow}}),Object.defineProperty(exports,"prelu",{enumerable:!0,get:function(){return dr.prelu}}),Object.defineProperty(exports,"print",{enumerable:!0,get:function(){return lr.print}}),Object.defineProperty(exports,"prod",{enumerable:!0,get:function(){return fr.prod}}),Object.defineProperty(exports,"raggedGather",{enumerable:!0,get:function(){return br.raggedGather}}),Object.defineProperty(exports,"raggedRange",{enumerable:!0,get:function(){return mr.raggedRange}}),Object.defineProperty(exports,"raggedTensorToTensor",{enumerable:!0,get:function(){return gr.raggedTensorToTensor}}),Object.defineProperty(exports,"rand",{enumerable:!0,get:function(){return xr.rand}}),Object.defineProperty(exports,"randomGamma",{enumerable:!0,get:function(){return yr.randomGamma}}),Object.defineProperty(exports,"randomNormal",{enumerable:!0,get:function(){return qr.randomNormal}}),Object.defineProperty(exports,"randomStandardNormal",{enumerable:!0,get:function(){return Or.randomStandardNormal}}),Object.defineProperty(exports,"randomUniform",{enumerable:!0,get:function(){return Pr.randomUniform}}),Object.defineProperty(exports,"randomUniformInt",{enumerable:!0,get:function(){return jr.randomUniformInt}}),Object.defineProperty(exports,"range",{enumerable:!0,get:function(){return _r.range}}),Object.defineProperty(exports,"real",{enumerable:!0,get:function(){return hr.real}}),Object.defineProperty(exports,"reciprocal",{enumerable:!0,get:function(){return vr.reciprocal}}),Object.defineProperty(exports,"relu",{enumerable:!0,get:function(){return Sr.relu}}),Object.defineProperty(exports,"relu6",{enumerable:!0,get:function(){return Nr.relu6}}),Object.defineProperty(exports,"reshape",{enumerable:!0,get:function(){return wr.reshape}}),Object.defineProperty(exports,"reverse",{enumerable:!0,get:function(){return kr.reverse}}),Object.defineProperty(exports,"reverse1d",{enumerable:!0,get:function(){return Mr.reverse1d}}),Object.defineProperty(exports,"reverse2d",{enumerable:!0,get:function(){return Tr.reverse2d}}),Object.defineProperty(exports,"reverse3d",{enumerable:!0,get:function(){return Er.reverse3d}}),Object.defineProperty(exports,"reverse4d",{enumerable:!0,get:function(){return Ar.reverse4d}}),Object.defineProperty(exports,"rfft",{enumerable:!0,get:function(){return rt.rfft}}),Object.defineProperty(exports,"round",{enumerable:!0,get:function(){return Rr.round}}),Object.defineProperty(exports,"rsqrt",{enumerable:!0,get:function(){return zr.rsqrt}}),Object.defineProperty(exports,"scalar",{enumerable:!0,get:function(){return Br.scalar}}),Object.defineProperty(exports,"selu",{enumerable:!0,get:function(){return Dr.selu}}),Object.defineProperty(exports,"separableConv2d",{enumerable:!0,get:function(){return Cr.separableConv2d}}),Object.defineProperty(exports,"setdiff1dAsync",{enumerable:!0,get:function(){return Lr.setdiff1dAsync}}),Object.defineProperty(exports,"sigmoid",{enumerable:!0,get:function(){return Wr.sigmoid}}),Object.defineProperty(exports,"sign",{enumerable:!0,get:function(){return Fr.sign}}),exports.signal=void 0,Object.defineProperty(exports,"sin",{enumerable:!0,get:function(){return Gr.sin}}),Object.defineProperty(exports,"sinh",{enumerable:!0,get:function(){return Ur.sinh}}),Object.defineProperty(exports,"slice",{enumerable:!0,get:function(){return Ir.slice}}),Object.defineProperty(exports,"slice1d",{enumerable:!0,get:function(){return Xr.slice1d}}),Object.defineProperty(exports,"slice2d",{enumerable:!0,get:function(){return Hr.slice2d}}),Object.defineProperty(exports,"slice3d",{enumerable:!0,get:function(){return Vr.slice3d}}),Object.defineProperty(exports,"slice4d",{enumerable:!0,get:function(){return Jr.slice4d}}),Object.defineProperty(exports,"softmax",{enumerable:!0,get:function(){return Kr.softmax}}),Object.defineProperty(exports,"softplus",{enumerable:!0,get:function(){return Qr.softplus}}),Object.defineProperty(exports,"spaceToBatchND",{enumerable:!0,get:function(){return Yr.spaceToBatchND}}),exports.spectral=exports.sparse=void 0,Object.defineProperty(exports,"split",{enumerable:!0,get:function(){return tt.split}}),Object.defineProperty(exports,"sqrt",{enumerable:!0,get:function(){return nt.sqrt}}),Object.defineProperty(exports,"square",{enumerable:!0,get:function(){return ot.square}}),Object.defineProperty(exports,"squaredDifference",{enumerable:!0,get:function(){return ut.squaredDifference}}),Object.defineProperty(exports,"squeeze",{enumerable:!0,get:function(){return it.squeeze}}),Object.defineProperty(exports,"stack",{enumerable:!0,get:function(){return at.stack}}),Object.defineProperty(exports,"step",{enumerable:!0,get:function(){return st.step}}),Object.defineProperty(exports,"stridedSlice",{enumerable:!0,get:function(){return ct.stridedSlice}}),exports.string=void 0,Object.defineProperty(exports,"sub",{enumerable:!0,get:function(){return pt.sub}}),Object.defineProperty(exports,"sum",{enumerable:!0,get:function(){return dt.sum}}),Object.defineProperty(exports,"tan",{enumerable:!0,get:function(){return lt.tan}}),Object.defineProperty(exports,"tanh",{enumerable:!0,get:function(){return ft.tanh}}),Object.defineProperty(exports,"tensor",{enumerable:!0,get:function(){return bt.tensor}}),Object.defineProperty(exports,"tensor1d",{enumerable:!0,get:function(){return mt.tensor1d}}),Object.defineProperty(exports,"tensor2d",{enumerable:!0,get:function(){return gt.tensor2d}}),Object.defineProperty(exports,"tensor3d",{enumerable:!0,get:function(){return xt.tensor3d}}),Object.defineProperty(exports,"tensor4d",{enumerable:!0,get:function(){return yt.tensor4d}}),Object.defineProperty(exports,"tensor5d",{enumerable:!0,get:function(){return qt.tensor5d}}),Object.defineProperty(exports,"tensor6d",{enumerable:!0,get:function(){return Ot.tensor6d}}),Object.defineProperty(exports,"tensorScatterUpdate",{enumerable:!0,get:function(){return Pt.tensorScatterUpdate}}),Object.defineProperty(exports,"tile",{enumerable:!0,get:function(){return jt.tile}}),Object.defineProperty(exports,"topk",{enumerable:!0,get:function(){return _t.topk}}),Object.defineProperty(exports,"truncatedNormal",{enumerable:!0,get:function(){return ht.truncatedNormal}}),Object.defineProperty(exports,"unique",{enumerable:!0,get:function(){return vt.unique}}),Object.defineProperty(exports,"unsortedSegmentSum",{enumerable:!0,get:function(){return St.unsortedSegmentSum}}),Object.defineProperty(exports,"unstack",{enumerable:!0,get:function(){return Nt.unstack}}),Object.defineProperty(exports,"upperBound",{enumerable:!0,get:function(){return wt.upperBound}}),Object.defineProperty(exports,"variable",{enumerable:!0,get:function(){return kt.variable}}),Object.defineProperty(exports,"where",{enumerable:!0,get:function(){return Mt.where}}),Object.defineProperty(exports,"whereAsync",{enumerable:!0,get:function(){return Tt.whereAsync}}),Object.defineProperty(exports,"zeros",{enumerable:!0,get:function(){return Et.zeros}}),Object.defineProperty(exports,"zerosLike",{enumerable:!0,get:function(){return At.zerosLike}});var r=require("./abs"),t=require("./acos"),n=require("./acosh"),o=require("./add"),u=require("./add_n"),i=require("./all"),a=require("./any"),s=require("./arg_max"),c=require("./arg_min"),p=require("./asin"),d=require("./asinh"),l=require("./atan"),f=require("./atan2"),b=require("./atanh"),m=require("./avg_pool"),g=require("./avg_pool_3d"),x=require("./basic_lstm_cell"),y=require("./batch_to_space_nd"),q=require("./batchnorm"),O=require("./batchnorm2d"),P=require("./batchnorm3d"),j=require("./batchnorm4d"),_=require("./bincount"),h=require("./bitwise_and"),v=require("./broadcast_args"),S=require("./broadcast_to"),N=require("./buffer"),w=require("./cast"),k=require("./ceil"),M=require("./clip_by_value"),T=require("./clone"),E=require("./complex"),A=require("./concat"),R=require("./concat_1d"),z=require("./concat_2d"),B=require("./concat_3d"),D=require("./concat_4d"),C=require("./conv1d"),L=require("./conv2d"),W=require("./conv2d_transpose"),F=require("./conv3d"),G=require("./conv3d_transpose"),U=require("./cos"),I=require("./cosh"),X=require("./cumprod"),H=require("./cumsum"),V=require("./dense_bincount"),J=require("./depth_to_space"),K=require("./depthwise_conv2d"),Q=require("./diag"),Y=require("./dilation2d"),Z=require("./div"),$=require("./div_no_nan"),ee=require("./dot"),re=require("./einsum"),te=require("./elu"),ne=require("./ensure_shape"),oe=require("./equal"),ue=require("./erf"),ie=require("./euclidean_norm"),ae=require("./exp"),se=require("./expand_dims"),ce=require("./expm1"),pe=require("./eye"),de=require("./fill"),le=require("./floor"),fe=require("./floorDiv"),be=require("./gather"),me=require("./greater"),ge=require("./greater_equal"),xe=require("./imag"),ye=require("./is_finite"),qe=require("./is_inf"),Oe=require("./is_nan"),Pe=require("./leaky_relu"),je=require("./less"),_e=require("./less_equal"),he=require("./linspace"),ve=require("./local_response_normalization"),Se=require("./log"),Ne=require("./log1p"),we=require("./log_sigmoid"),ke=require("./log_softmax"),Me=require("./log_sum_exp"),Te=require("./logical_and"),Ee=require("./logical_not"),Ae=require("./logical_or"),Re=require("./logical_xor"),ze=require("./lower_bound"),Be=require("./mat_mul"),De=require("./max"),Ce=require("./max_pool"),Le=require("./max_pool_3d"),We=require("./max_pool_with_argmax"),Fe=require("./maximum"),Ge=require("./mean"),Ue=require("./meshgrid"),Ie=require("./min"),Xe=require("./minimum"),He=require("./mirror_pad"),Ve=require("./mod"),Je=require("./moments"),Ke=require("./mul"),Qe=require("./multi_rnn_cell"),Ye=require("./multinomial"),Ze=require("./neg"),$e=require("./not_equal"),er=require("./one_hot"),rr=require("./ones"),tr=require("./ones_like"),nr=require("./outer_product"),or=require("./pad"),ur=require("./pad1d"),ir=require("./pad2d"),ar=require("./pad3d"),sr=require("./pad4d"),cr=require("./pool"),pr=require("./pow"),dr=require("./prelu"),lr=require("./print"),fr=require("./prod"),br=require("./ragged_gather"),mr=require("./ragged_range"),gr=require("./ragged_tensor_to_tensor"),xr=require("./rand"),yr=require("./random_gamma"),qr=require("./random_normal"),Or=require("./random_standard_normal"),Pr=require("./random_uniform"),jr=require("./random_uniform_int"),_r=require("./range"),hr=require("./real"),vr=require("./reciprocal"),Sr=require("./relu"),Nr=require("./relu6"),wr=require("./reshape"),kr=require("./reverse"),Mr=require("./reverse_1d"),Tr=require("./reverse_2d"),Er=require("./reverse_3d"),Ar=require("./reverse_4d"),Rr=require("./round"),zr=require("./rsqrt"),Br=require("./scalar"),Dr=require("./selu"),Cr=require("./separable_conv2d"),Lr=require("./setdiff1d_async"),Wr=require("./sigmoid"),Fr=require("./sign"),Gr=require("./sin"),Ur=require("./sinh"),Ir=require("./slice"),Xr=require("./slice1d"),Hr=require("./slice2d"),Vr=require("./slice3d"),Jr=require("./slice4d"),Kr=require("./softmax"),Qr=require("./softplus"),Yr=require("./space_to_batch_nd"),Zr=require("./spectral/fft"),$r=require("./spectral/ifft"),et=require("./spectral/irfft"),rt=require("./spectral/rfft"),tt=require("./split"),nt=require("./sqrt"),ot=require("./square"),ut=require("./squared_difference"),it=require("./squeeze"),at=require("./stack"),st=require("./step"),ct=require("./strided_slice"),pt=require("./sub"),dt=require("./sum"),lt=require("./tan"),ft=require("./tanh"),bt=require("./tensor"),mt=require("./tensor1d"),gt=require("./tensor2d"),xt=require("./tensor3d"),yt=require("./tensor4d"),qt=require("./tensor5d"),Ot=require("./tensor6d"),Pt=require("./tensor_scatter_update"),jt=require("./tile"),_t=require("./topk"),ht=require("./truncated_normal"),vt=require("./unique"),St=require("./unsorted_segment_sum"),Nt=require("./unstack"),wt=require("./upper_bound"),kt=require("./variable"),Mt=require("./where"),Tt=require("./where_async"),Et=require("./zeros"),At=require("./zeros_like"),Rt=require("./boolean_mask");Object.keys(Rt).forEach(function(r){"default"!==r&&"__esModule"!==r&&(Object.prototype.hasOwnProperty.call(e,r)||r in exports&&exports[r]===Rt[r]||Object.defineProperty(exports,r,{enumerable:!0,get:function(){return Rt[r]}}))});var zt=require("./transpose");Object.keys(zt).forEach(function(r){"default"!==r&&"__esModule"!==r&&(Object.prototype.hasOwnProperty.call(e,r)||r in exports&&exports[r]===zt[r]||Object.defineProperty(exports,r,{enumerable:!0,get:function(){return zt[r]}}))});var Bt=require("./norm");Object.keys(Bt).forEach(function(r){"default"!==r&&"__esModule"!==r&&(Object.prototype.hasOwnProperty.call(e,r)||r in exports&&exports[r]===Bt[r]||Object.defineProperty(exports,r,{enumerable:!0,get:function(){return Bt[r]}}))});var Dt=require("./moving_average");Object.keys(Dt).forEach(function(r){"default"!==r&&"__esModule"!==r&&(Object.prototype.hasOwnProperty.call(e,r)||r in exports&&exports[r]===Dt[r]||Object.defineProperty(exports,r,{enumerable:!0,get:function(){return Dt[r]}}))});var Ct=require("./scatter_nd");Object.keys(Ct).forEach(function(r){"default"!==r&&"__esModule"!==r&&(Object.prototype.hasOwnProperty.call(e,r)||r in exports&&exports[r]===Ct[r]||Object.defineProperty(exports,r,{enumerable:!0,get:function(){return Ct[r]}}))});var Lt=require("./search_sorted");Object.keys(Lt).forEach(function(r){"default"!==r&&"__esModule"!==r&&(Object.prototype.hasOwnProperty.call(e,r)||r in exports&&exports[r]===Lt[r]||Object.defineProperty(exports,r,{enumerable:!0,get:function(){return Lt[r]}}))});var Wt=require("./sparse_to_dense");Object.keys(Wt).forEach(function(r){"default"!==r&&"__esModule"!==r&&(Object.prototype.hasOwnProperty.call(e,r)||r in exports&&exports[r]===Wt[r]||Object.defineProperty(exports,r,{enumerable:!0,get:function(){return Wt[r]}}))});var Ft=require("./gather_nd");Object.keys(Ft).forEach(function(r){"default"!==r&&"__esModule"!==r&&(Object.prototype.hasOwnProperty.call(e,r)||r in exports&&exports[r]===Ft[r]||Object.defineProperty(exports,r,{enumerable:!0,get:function(){return Ft[r]}}))});var Gt=require("./dropout");Object.keys(Gt).forEach(function(r){"default"!==r&&"__esModule"!==r&&(Object.prototype.hasOwnProperty.call(e,r)||r in exports&&exports[r]===Gt[r]||Object.defineProperty(exports,r,{enumerable:!0,get:function(){return Gt[r]}}))});var Ut=require("./signal_ops_util");Object.keys(Ut).forEach(function(r){"default"!==r&&"__esModule"!==r&&(Object.prototype.hasOwnProperty.call(e,r)||r in exports&&exports[r]===Ut[r]||Object.defineProperty(exports,r,{enumerable:!0,get:function(){return Ut[r]}}))});var It=require("./in_top_k");Object.keys(It).forEach(function(r){"default"!==r&&"__esModule"!==r&&(Object.prototype.hasOwnProperty.call(e,r)||r in exports&&exports[r]===It[r]||Object.defineProperty(exports,r,{enumerable:!0,get:function(){return It[r]}}))});var Xt=require("./operation"),Ht=An(require("./fused_ops"));exports.fused=Ht;var Vt=require("./signal/hamming_window"),Jt=require("./signal/hann_window"),Kt=require("./signal/frame"),Qt=require("./signal/stft"),Yt=require("./image/crop_and_resize"),Zt=require("./image/flip_left_right"),$t=require("./image/grayscale_to_rgb"),en=require("./image/rgb_to_grayscale"),rn=require("./image/rotate_with_offset"),tn=require("./image/non_max_suppression"),nn=require("./image/non_max_suppression_async"),on=require("./image/non_max_suppression_with_score"),un=require("./image/non_max_suppression_with_score_async"),an=require("./image/non_max_suppression_padded"),sn=require("./image/non_max_suppression_padded_async"),cn=require("./image/resize_bilinear"),pn=require("./image/resize_nearest_neighbor"),dn=require("./image/threshold"),ln=require("./image/transform"),fn=require("./linalg/band_part"),bn=require("./linalg/gram_schmidt"),mn=require("./linalg/qr"),gn=require("./losses/absolute_difference"),xn=require("./losses/compute_weighted_loss"),yn=require("./losses/cosine_distance"),qn=require("./losses/hinge_loss"),On=require("./losses/huber_loss"),Pn=require("./losses/log_loss"),jn=require("./losses/mean_squared_error"),_n=require("./losses/sigmoid_cross_entropy"),hn=require("./losses/softmax_cross_entropy"),vn=require("./sparse/sparse_fill_empty_rows"),Sn=require("./sparse/sparse_reshape"),Nn=require("./sparse/sparse_segment_mean"),wn=require("./sparse/sparse_segment_sum"),kn=require("./string/string_n_grams"),Mn=require("./string/string_split"),Tn=require("./string/string_to_hash_bucket_fast"),En=require("./string/static_regex_replace");function An(e,r){if("function"==typeof WeakMap)var t=new WeakMap,n=new WeakMap;return(An=function(e,r){if(!r&&e&&e.__esModule)return e;var o,u,i={__proto__:null,default:e};if(null===e||"object"!=typeof e&&"function"!=typeof e)return i;if(o=r?n:t){if(o.has(e))return o.get(e);o.set(e,i)}for(const t in e)"default"!==t&&{}.hasOwnProperty.call(e,t)&&((u=(o=Object.defineProperty)&&Object.getOwnPropertyDescriptor(e,t))&&(u.get||u.set)?o(i,t,u):i[t]=e[t]);return i})(e,r)}const Rn=exports.spectral={fft:Zr.fft,ifft:$r.ifft,rfft:rt.rfft,irfft:et.irfft},zn=exports.signal={hammingWindow:Vt.hammingWindow,hannWindow:Jt.hannWindow,frame:Kt.frame,stft:Qt.stft},Bn=exports.image={flipLeftRight:Zt.flipLeftRight,grayscaleToRGB:$t.grayscaleToRGB,resizeNearestNeighbor:pn.resizeNearestNeighbor,resizeBilinear:cn.resizeBilinear,rgbToGrayscale:en.rgbToGrayscale,rotateWithOffset:rn.rotateWithOffset,cropAndResize:Yt.cropAndResize,nonMaxSuppression:tn.nonMaxSuppression,nonMaxSuppressionAsync:nn.nonMaxSuppressionAsync,nonMaxSuppressionWithScore:on.nonMaxSuppressionWithScore,nonMaxSuppressionWithScoreAsync:un.nonMaxSuppressionWithScoreAsync,nonMaxSuppressionPadded:an.nonMaxSuppressionPadded,nonMaxSuppressionPaddedAsync:sn.nonMaxSuppressionPaddedAsync,threshold:dn.threshold,transform:ln.transform},Dn=exports.linalg={bandPart:fn.bandPart,gramSchmidt:bn.gramSchmidt,qr:mn.qr},Cn=exports.losses={absoluteDifference:gn.absoluteDifference,computeWeightedLoss:xn.computeWeightedLoss,cosineDistance:yn.cosineDistance,hingeLoss:qn.hingeLoss,huberLoss:On.huberLoss,logLoss:Pn.logLoss,meanSquaredError:jn.meanSquaredError,sigmoidCrossEntropy:_n.sigmoidCrossEntropy,softmaxCrossEntropy:hn.softmaxCrossEntropy},Ln=exports.sparse={sparseFillEmptyRows:vn.sparseFillEmptyRows,sparseReshape:Sn.sparseReshape,sparseSegmentMean:Nn.sparseSegmentMean,sparseSegmentSum:wn.sparseSegmentSum},Wn=exports.string={stringNGrams:kn.stringNGrams,stringSplit:Mn.stringSplit,stringToHashBucketFast:Tn.stringToHashBucketFast,staticRegexReplace:En.staticRegexReplace};
},{"./abs":"U9d5","./acos":"hDnd","./acosh":"zTvf","./add":"N73o","./add_n":"rS0T","./all":"zHmK","./any":"XocL","./arg_max":"dv7u","./arg_min":"y2ST","./asin":"kcJ4","./asinh":"mK5f","./atan":"Qawb","./atan2":"lkDZ","./atanh":"c4nq","./avg_pool":"LNDu","./avg_pool_3d":"gUgG","./basic_lstm_cell":"IrGh","./batch_to_space_nd":"vEiD","./batchnorm":"gYII","./batchnorm2d":"PwSx","./batchnorm3d":"zSL9","./batchnorm4d":"PGAU","./bincount":"rYQ1","./bitwise_and":"bonT","./broadcast_args":"PJAz","./broadcast_to":"ZDfb","./buffer":"GfO2","./cast":"qnzc","./ceil":"VBn4","./clip_by_value":"OIQo","./clone":"Ot88","./complex":"e4je","./concat":"V5Ij","./concat_1d":"SY4F","./concat_2d":"rep6","./concat_3d":"La3N","./concat_4d":"UYxl","./conv1d":"RZoo","./conv2d":"CVMs","./conv2d_transpose":"v80f","./conv3d":"uOsG","./conv3d_transpose":"ndAv","./cos":"gHiU","./cosh":"dWiz","./cumprod":"CZnL","./cumsum":"s2nI","./dense_bincount":"IzLf","./depth_to_space":"o3IO","./depthwise_conv2d":"HEHz","./diag":"Qz11","./dilation2d":"XEeh","./div":"S2L5","./div_no_nan":"VrTr","./dot":"M98r","./einsum":"aqvb","./elu":"qSof","./ensure_shape":"QNP3","./equal":"haNF","./erf":"Ng3O","./euclidean_norm":"Qkob","./exp":"xcz4","./expand_dims":"WqhD","./expm1":"NE5u","./eye":"MP6S","./fill":"gaCw","./floor":"EeTS","./floorDiv":"OIz3","./gather":"TfxI","./greater":"WT29","./greater_equal":"a6nY","./imag":"eG10","./is_finite":"uXDy","./is_inf":"d2YA","./is_nan":"cHRr","./leaky_relu":"RYa8","./less":"onA7","./less_equal":"vnhI","./linspace":"Eb8v","./local_response_normalization":"uT9U","./log":"f3PH","./log1p":"ODmc","./log_sigmoid":"h4az","./log_softmax":"rVC8","./log_sum_exp":"te98","./logical_and":"sHir","./logical_not":"jt3a","./logical_or":"cBH6","./logical_xor":"RGME","./lower_bound":"EiM8","./mat_mul":"zVDr","./max":"KIVY","./max_pool":"g3Dm","./max_pool_3d":"Z3LC","./max_pool_with_argmax":"vORB","./maximum":"E33m","./mean":"DIOh","./meshgrid":"OeUD","./min":"pkmC","./minimum":"TKku","./mirror_pad":"y7Tc","./mod":"cyrT","./moments":"xfMn","./mul":"tBJ4","./multi_rnn_cell":"C2RS","./multinomial":"moMD","./neg":"i2LN","./not_equal":"TOzH","./one_hot":"HpS0","./ones":"iY3A","./ones_like":"nMI9","./outer_product":"mAdl","./pad":"y7nM","./pad1d":"c4D8","./pad2d":"Zzwk","./pad3d":"DYJf","./pad4d":"k9sb","./pool":"Zp2S","./pow":"o2Kl","./prelu":"Xs9q","./print":"avTA","./prod":"V8As","./ragged_gather":"bCWa","./ragged_range":"gQ0m","./ragged_tensor_to_tensor":"yqh4","./rand":"DOKZ","./random_gamma":"KZ1e","./random_normal":"aurk","./random_standard_normal":"JQkW","./random_uniform":"Imph","./random_uniform_int":"LZig","./range":"FAHd","./real":"j99O","./reciprocal":"kFd0","./relu":"JbIg","./relu6":"urTr","./reshape":"F0cm","./reverse":"JJIO","./reverse_1d":"AODX","./reverse_2d":"JN76","./reverse_3d":"hWz2","./reverse_4d":"X21a","./round":"NMXN","./rsqrt":"gHPL","./scalar":"TiGU","./selu":"HaUr","./separable_conv2d":"PKLM","./setdiff1d_async":"yk2k","./sigmoid":"DbGB","./sign":"CH4E","./sin":"zDLt","./sinh":"DmYY","./slice":"wIos","./slice1d":"vSl0","./slice2d":"bSki","./slice3d":"c5n3","./slice4d":"EHN5","./softmax":"TVVR","./softplus":"TLV5","./space_to_batch_nd":"ERrS","./spectral/fft":"lRSx","./spectral/ifft":"G5kM","./spectral/irfft":"Yh9k","./spectral/rfft":"FMnE","./split":"lgPf","./sqrt":"brr7","./square":"KiGo","./squared_difference":"hbAV","./squeeze":"pxYL","./stack":"Wzzr","./step":"vRkD","./strided_slice":"quwm","./sub":"SgzI","./sum":"kc8w","./tan":"fQEZ","./tanh":"djih","./tensor":"woAd","./tensor1d":"vKgg","./tensor2d":"UEzj","./tensor3d":"gE0c","./tensor4d":"CbDo","./tensor5d":"ViEa","./tensor6d":"j89l","./tensor_scatter_update":"u9R8","./tile":"DlNu","./topk":"Hv3o","./truncated_normal":"YHjl","./unique":"LuF4","./unsorted_segment_sum":"oY1I","./unstack":"Smo9","./upper_bound":"KAw5","./variable":"dH8d","./where":"TsgC","./where_async":"moUh","./zeros":"AsfN","./zeros_like":"qY0o","./boolean_mask":"JMVl","./transpose":"JmRY","./norm":"exuO","./moving_average":"SiXR","./scatter_nd":"r4bT","./search_sorted":"izso","./sparse_to_dense":"s9K8","./gather_nd":"PYkI","./dropout":"jb36","./signal_ops_util":"Ubrm","./in_top_k":"oeUN","./operation":"uE86","./fused_ops":"Z9t3","./signal/hamming_window":"HdvD","./signal/hann_window":"bdTr","./signal/frame":"Go7t","./signal/stft":"jWvs","./image/crop_and_resize":"su0V","./image/flip_left_right":"tSJb","./image/grayscale_to_rgb":"QqQU","./image/rgb_to_grayscale":"tEbu","./image/rotate_with_offset":"t1ei","./image/non_max_suppression":"wp0Q","./image/non_max_suppression_async":"kFcs","./image/non_max_suppression_with_score":"KHDA","./image/non_max_suppression_with_score_async":"t65b","./image/non_max_suppression_padded":"zXJN","./image/non_max_suppression_padded_async":"sgWJ","./image/resize_bilinear":"JODz","./image/resize_nearest_neighbor":"rQ9Q","./image/threshold":"M9mR","./image/transform":"cGGF","./linalg/band_part":"KELI","./linalg/gram_schmidt":"uAHR","./linalg/qr":"Ppe5","./losses/absolute_difference":"coTE","./losses/compute_weighted_loss":"WmQQ","./losses/cosine_distance":"IpNr","./losses/hinge_loss":"QDEw","./losses/huber_loss":"wWxs","./losses/log_loss":"sLE3","./losses/mean_squared_error":"ZpcK","./losses/sigmoid_cross_entropy":"E5VI","./losses/softmax_cross_entropy":"w47l","./sparse/sparse_fill_empty_rows":"mqNF","./sparse/sparse_reshape":"zr2y","./sparse/sparse_segment_mean":"CqLM","./sparse/sparse_segment_sum":"bhoc","./string/string_n_grams":"IQZI","./string/string_split":"JNPF","./string/string_to_hash_bucket_fast":"ouv1","./string/static_regex_replace":"gbgW"}],"aVHA":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.SerializationMap=exports.Serializable=void 0,exports.getRegisteredName=n,exports.registerClass=i;var e=require("./util");const s=new Map,t=new Map;class a{getClassName(){return this.constructor.className}static fromConfig(e,s){return new e(s)}}exports.Serializable=a;class r{constructor(){this.classNameMap={}}static getMap(){return null==r.instance&&(r.instance=new r),r.instance}static register(e){r.getMap().classNameMap[e.className]=[e,e.fromConfig]}}function i(a,i,n){(0,e.assert)(null!=a.className,()=>"Class being registered does not have the static className property defined."),(0,e.assert)("string"==typeof a.className,()=>"className is required to be a string, but got type "+typeof a.className),(0,e.assert)(a.className.length>0,()=>"Class being registered has an empty-string as its className, which is disallowed."),void 0===i&&(i="Custom"),void 0===n&&(n=a.className);const l=i+">"+n;return r.register(a),s.set(l,a),t.set(a,l),a}function n(e){return t.has(e)?t.get(e):e.className}exports.SerializationMap=r;
},{"./util":"XXxQ"}],"zxzS":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.Optimizer=void 0;var e=require("../globals"),t=require("../gradients"),i=require("../ops/ops"),s=require("../serialization");class r extends s.Serializable{minimize(t,i=!1,s){const{value:r,grads:n}=this.computeGradients(t,s);if(null!=s){const e=s.map(e=>({name:e.name,tensor:n[e.name]}));this.applyGradients(e)}else this.applyGradients(n);return(0,e.dispose)(n),i?r:(r.dispose(),null)}get iterations(){return null==this.iterations_&&(this.iterations_=0),this.iterations_}incrementIterations(){this.iterations_=this.iterations+1}computeGradients(e,i){return(0,t.variableGrads)(e,i)}dispose(){null!=this.iterations_&&(0,e.dispose)(this.iterations_)}async saveIterations(){return null==this.iterations_&&(this.iterations_=0),{name:"iter",tensor:(0,i.scalar)(this.iterations_,"int32")}}async getWeights(){throw new Error("getWeights() is not implemented for this optimizer yet.")}async setWeights(e){throw new Error("setWeights() is not implemented for this optimizer class "+`${this.getClassName()}`)}async extractIterations(e){return this.iterations_=(await e[0].tensor.data())[0],e.slice(1)}}exports.Optimizer=r,Object.defineProperty(r,Symbol.hasInstance,{value:e=>null!=e.minimize&&null!=e.computeGradients&&null!=e.applyGradients});
},{"../globals":"TsQp","../gradients":"VR5t","../ops/ops":"hfXJ","../serialization":"aVHA"}],"WprY":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.AdadeltaOptimizer=void 0;var a=require("../engine"),e=require("../globals"),s=require("../ops/add"),t=require("../ops/div"),i=require("../ops/mul"),r=require("../ops/ops"),l=require("../ops/square"),n=require("../ops/zeros_like"),u=require("./optimizer");class d extends u.Optimizer{static get className(){return"Adadelta"}constructor(e,s,t=null){super(),this.learningRate=e,this.rho=s,this.epsilon=t,this.accumulatedGrads=[],this.accumulatedUpdates=[],null==t&&(this.epsilon=a.ENGINE.backend.epsilon())}applyGradients(u){(Array.isArray(u)?u.map(a=>a.name):Object.keys(u)).forEach((d,o)=>{const c=a.ENGINE.registeredVariables[d];null==this.accumulatedGrads[o]&&(this.accumulatedGrads[o]={originalName:`${d}/accum_grad`,variable:(0,e.tidy)(()=>(0,n.zerosLike)(c).variable(!1))}),null==this.accumulatedUpdates[o]&&(this.accumulatedUpdates[o]={originalName:`${d}/accum_var`,variable:(0,e.tidy)(()=>(0,n.zerosLike)(c).variable(!1))});const m=Array.isArray(u)?u[o].tensor:u[d];if(null==m)return;const h=this.accumulatedGrads[o].variable,p=this.accumulatedUpdates[o].variable;(0,e.tidy)(()=>{const a=(0,s.add)((0,i.mul)(h,this.rho),(0,i.mul)((0,l.square)(m),1-this.rho)),e=(0,i.mul)((0,t.div)((0,r.sqrt)((0,s.add)(p,this.epsilon)),(0,r.sqrt)((0,s.add)(h,this.epsilon))),m),n=(0,s.add)((0,i.mul)(p,this.rho),(0,i.mul)((0,l.square)(e),1-this.rho));h.assign(a),p.assign(n);const u=(0,s.add)((0,i.mul)(e,-this.learningRate),c);c.assign(u)})}),this.incrementIterations()}dispose(){null!=this.accumulatedUpdates&&((0,e.dispose)(this.accumulatedGrads.map(a=>a.variable)),(0,e.dispose)(this.accumulatedUpdates.map(a=>a.variable)))}async getWeights(){const a=[...this.accumulatedGrads,...this.accumulatedUpdates];return[await this.saveIterations()].concat(a.map(a=>({name:a.originalName,tensor:a.variable})))}async setWeights(a){const e=(a=await this.extractIterations(a)).length/2;this.accumulatedGrads=a.slice(0,e).map(a=>({originalName:a.name,variable:a.tensor.variable(!1)})),this.accumulatedUpdates=a.slice(e,2*e).map(a=>({originalName:a.name,variable:a.tensor.variable(!1)}))}getConfig(){return{learningRate:this.learningRate,rho:this.rho,epsilon:this.epsilon}}static fromConfig(a,e){return new a(e.learningRate,e.rho,e.epsilon)}}exports.AdadeltaOptimizer=d;
},{"../engine":"phT7","../globals":"TsQp","../ops/add":"N73o","../ops/div":"S2L5","../ops/mul":"tBJ4","../ops/ops":"hfXJ","../ops/square":"KiGo","../ops/zeros_like":"qY0o","./optimizer":"zxzS"}],"zRFy":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.AdagradOptimizer=void 0;var a=require("../engine"),e=require("../globals"),i=require("../ops/add"),r=require("../ops/div"),t=require("../ops/fill"),s=require("../ops/mul"),l=require("../ops/sqrt"),n=require("../ops/square"),u=require("./optimizer");class c extends u.Optimizer{static get className(){return"Adagrad"}constructor(a,e=.1){super(),this.learningRate=a,this.initialAccumulatorValue=e,this.accumulatedGrads=[]}applyGradients(u){(Array.isArray(u)?u.map(a=>a.name):Object.keys(u)).forEach((c,o)=>{const d=a.ENGINE.registeredVariables[c];if(null==this.accumulatedGrads[o]){const a=!1;this.accumulatedGrads[o]={originalName:`${c}/accumulator`,variable:(0,e.tidy)(()=>(0,t.fill)(d.shape,this.initialAccumulatorValue).variable(a))}}const m=Array.isArray(u)?u[o].tensor:u[c];if(null==m)return;const p=this.accumulatedGrads[o].variable;(0,e.tidy)(()=>{const e=(0,i.add)(p,(0,n.square)(m));p.assign(e);const t=(0,i.add)((0,s.mul)((0,r.div)(m,(0,l.sqrt)((0,i.add)(e,a.ENGINE.backend.epsilon()))),-this.learningRate),d);d.assign(t)})}),this.incrementIterations()}dispose(){null!=this.accumulatedGrads&&(0,e.dispose)(this.accumulatedGrads.map(a=>a.variable))}async getWeights(){return[await this.saveIterations()].concat(this.accumulatedGrads.map(a=>({name:a.originalName,tensor:a.variable})))}async setWeights(a){a=await this.extractIterations(a);this.accumulatedGrads=a.map(a=>({originalName:a.name,variable:a.tensor.variable(!1)}))}getConfig(){return{learningRate:this.learningRate,initialAccumulatorValue:this.initialAccumulatorValue}}static fromConfig(a,e){return new a(e.learningRate,e.initialAccumulatorValue)}}exports.AdagradOptimizer=c;
},{"../engine":"phT7","../globals":"TsQp","../ops/add":"N73o","../ops/div":"S2L5","../ops/fill":"gaCw","../ops/mul":"tBJ4","../ops/sqrt":"brr7","../ops/square":"KiGo","./optimizer":"zxzS"}],"ZLBF":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.AdamOptimizer=void 0;var e=require("../engine"),t=require("../globals"),a=require("../ops/add"),i=require("../ops/div"),s=require("../ops/mul"),r=require("../ops/pow"),n=require("../ops/scalar"),c=require("../ops/sqrt"),o=require("../ops/square"),l=require("../ops/sub"),u=require("../ops/zeros_like"),m=require("./optimizer");class d extends m.Optimizer{static get className(){return"Adam"}constructor(a,i,s,r=null){super(),this.learningRate=a,this.beta1=i,this.beta2=s,this.epsilon=r,this.accumulatedFirstMoment=[],this.accumulatedSecondMoment=[],(0,t.tidy)(()=>{this.accBeta1=(0,n.scalar)(i).variable(),this.accBeta2=(0,n.scalar)(s).variable()}),null==r&&(this.epsilon=e.ENGINE.backend.epsilon())}applyGradients(r){const n=Array.isArray(r)?r.map(e=>e.name):Object.keys(r);(0,t.tidy)(()=>{const m=(0,l.sub)(1,this.accBeta1),d=(0,l.sub)(1,this.accBeta2);n.forEach((n,l)=>{const h=e.ENGINE.registeredVariables[n];null==this.accumulatedFirstMoment[l]&&(this.accumulatedFirstMoment[l]={originalName:`${n}/m`,variable:(0,t.tidy)(()=>(0,u.zerosLike)(h).variable(!1))}),null==this.accumulatedSecondMoment[l]&&(this.accumulatedSecondMoment[l]={originalName:`${n}/v`,variable:(0,t.tidy)(()=>(0,u.zerosLike)(h).variable(!1))});const p=Array.isArray(r)?r[l].tensor:r[n];if(null==p)return;const b=this.accumulatedFirstMoment[l].variable,g=this.accumulatedSecondMoment[l].variable,v=(0,a.add)((0,s.mul)(b,this.beta1),(0,s.mul)(p,1-this.beta1)),M=(0,a.add)((0,s.mul)(g,this.beta2),(0,s.mul)((0,o.square)(p),1-this.beta2)),q=(0,i.div)(v,m),y=(0,i.div)(M,d);b.assign(v),g.assign(M);const B=(0,a.add)((0,s.mul)((0,i.div)(q,(0,a.add)((0,c.sqrt)(y),this.epsilon)),-this.learningRate),h);h.assign(B)}),this.accBeta1.assign((0,s.mul)(this.accBeta1,this.beta1)),this.accBeta2.assign((0,s.mul)(this.accBeta2,this.beta2))}),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.accBeta2.dispose(),null!=this.accumulatedFirstMoment&&(0,t.dispose)(this.accumulatedFirstMoment.map(e=>e.variable)),null!=this.accumulatedSecondMoment&&(0,t.dispose)(this.accumulatedSecondMoment.map(e=>e.variable))}async getWeights(){const e=[...this.accumulatedFirstMoment,...this.accumulatedSecondMoment];return[await this.saveIterations()].concat(e.map(e=>({name:e.originalName,tensor:e.variable})))}async setWeights(e){e=await this.extractIterations(e),(0,t.tidy)(()=>{this.accBeta1.assign((0,r.pow)(this.beta1,this.iterations_+1)),this.accBeta2.assign((0,r.pow)(this.beta2,this.iterations_+1))});const a=e.length/2;this.accumulatedFirstMoment=e.slice(0,a).map(e=>({originalName:e.name,variable:e.tensor.variable(!1)})),this.accumulatedSecondMoment=e.slice(a,2*a).map(e=>({originalName:e.name,variable:e.tensor.variable(!1)}))}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon}}static fromConfig(e,t){return new e(t.learningRate,t.beta1,t.beta2,t.epsilon)}}exports.AdamOptimizer=d;
},{"../engine":"phT7","../globals":"TsQp","../ops/add":"N73o","../ops/div":"S2L5","../ops/mul":"tBJ4","../ops/pow":"o2Kl","../ops/scalar":"TiGU","../ops/sqrt":"brr7","../ops/square":"KiGo","../ops/sub":"SgzI","../ops/zeros_like":"qY0o","./optimizer":"zxzS"}],"eIt3":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.AdamaxOptimizer=void 0;var e=require("../engine"),t=require("../globals"),i=require("../ops/abs"),a=require("../ops/add"),s=require("../ops/div"),r=require("../ops/maximum"),n=require("../ops/mul"),o=require("../ops/scalar"),l=require("../ops/sub"),c=require("../ops/zeros_like"),u=require("./optimizer");class d extends u.Optimizer{static get className(){return"Adamax"}constructor(i,a,s,r=null,n=0){super(),this.learningRate=i,this.beta1=a,this.beta2=s,this.epsilon=r,this.decay=n,this.accumulatedFirstMoment=[],this.accumulatedWeightedInfNorm=[],(0,t.tidy)(()=>{this.iteration=(0,o.scalar)(0).variable(),this.accBeta1=(0,o.scalar)(a).variable()}),null==r&&(this.epsilon=e.ENGINE.backend.epsilon())}applyGradients(o){const u=Array.isArray(o)?o.map(e=>e.name):Object.keys(o);(0,t.tidy)(()=>{const t=(0,l.sub)(1,this.accBeta1),d=(0,s.div)(-this.learningRate,(0,a.add)((0,n.mul)(this.iteration,this.decay),1));u.forEach((l,u)=>{const m=e.ENGINE.registeredVariables[l];null==this.accumulatedFirstMoment[u]&&(this.accumulatedFirstMoment[u]={originalName:`${l}/m`,variable:(0,c.zerosLike)(m).variable(!1)}),null==this.accumulatedWeightedInfNorm[u]&&(this.accumulatedWeightedInfNorm[u]={originalName:`${l}/v`,variable:(0,c.zerosLike)(m).variable(!1)});const h=Array.isArray(o)?o[u].tensor:o[l];if(null==h)return;const p=this.accumulatedFirstMoment[u].variable,b=this.accumulatedWeightedInfNorm[u].variable,g=(0,a.add)((0,n.mul)(p,this.beta1),(0,n.mul)(h,1-this.beta1)),v=(0,n.mul)(b,this.beta2),y=(0,i.abs)(h),f=(0,r.maximum)(v,y);p.assign(g),b.assign(f);const N=(0,a.add)((0,n.mul)((0,s.div)(d,t),(0,s.div)(g,(0,a.add)(f,this.epsilon))),m);m.assign(N)}),this.iteration.assign((0,a.add)(this.iteration,1)),this.accBeta1.assign((0,n.mul)(this.accBeta1,this.beta1))}),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.iteration.dispose(),null!=this.accumulatedFirstMoment&&(0,t.dispose)(this.accumulatedFirstMoment.map(e=>e.variable)),null!=this.accumulatedWeightedInfNorm&&(0,t.dispose)(this.accumulatedWeightedInfNorm.map(e=>e.variable))}async getWeights(){throw new Error("getWeights() is not implemented for Adamax yet.")}async setWeights(e){throw new Error("setWeights() is not implemented for Adamax yet.")}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon,decay:this.decay}}static fromConfig(e,t){return new e(t.learningRate,t.beta1,t.beta2,t.epsilon,t.decay)}}exports.AdamaxOptimizer=d;
},{"../engine":"phT7","../globals":"TsQp","../ops/abs":"U9d5","../ops/add":"N73o","../ops/div":"S2L5","../ops/maximum":"E33m","../ops/mul":"tBJ4","../ops/scalar":"TiGU","../ops/sub":"SgzI","../ops/zeros_like":"qY0o","./optimizer":"zxzS"}],"GrUb":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.SGDOptimizer=void 0;var e=require("../engine"),t=require("../globals"),r=require("../ops/add"),s=require("../ops/mul"),i=require("../ops/scalar"),a=require("./optimizer");class n extends a.Optimizer{static get className(){return"SGD"}constructor(e){super(),this.learningRate=e,this.setLearningRate(e)}applyGradients(i){(Array.isArray(i)?i.map(e=>e.name):Object.keys(i)).forEach((a,n)=>{const o=Array.isArray(i)?i[n].tensor:i[a];if(null==o)return;const c=e.ENGINE.registeredVariables[a];(0,t.tidy)(()=>{const e=(0,r.add)((0,s.mul)(this.c,o),c);c.assign(e)})}),this.incrementIterations()}setLearningRate(e){this.learningRate=e,null!=this.c&&this.c.dispose(),this.c=(0,t.keep)((0,i.scalar)(-e))}dispose(){this.c.dispose()}async getWeights(){return[await this.saveIterations()]}async setWeights(e){if(0!==(e=await this.extractIterations(e)).length)throw new Error("SGD optimizer does not have settable weights.")}getConfig(){return{learningRate:this.learningRate}}static fromConfig(e,t){return new e(t.learningRate)}}exports.SGDOptimizer=n;
},{"../engine":"phT7","../globals":"TsQp","../ops/add":"N73o","../ops/mul":"tBJ4","../ops/scalar":"TiGU","./optimizer":"zxzS"}],"M8Me":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.MomentumOptimizer=void 0;var e=require("../engine"),t=require("../globals"),s=require("../ops/add"),i=require("../ops/mul"),a=require("../ops/scalar"),r=require("../ops/zeros_like"),n=require("./sgd_optimizer");class m extends n.SGDOptimizer{static get className(){return"Momentum"}constructor(e,t,s=!1){super(e),this.learningRate=e,this.momentum=t,this.useNesterov=s,this.accumulations=[],this.m=(0,a.scalar)(this.momentum)}applyGradients(a){(Array.isArray(a)?a.map(e=>e.name):Object.keys(a)).forEach((n,m)=>{const o=e.ENGINE.registeredVariables[n];if(null==this.accumulations[m]){const e=!1;this.accumulations[m]={originalName:`${n}/momentum`,variable:(0,t.tidy)(()=>(0,r.zerosLike)(o).variable(e))}}const u=this.accumulations[m].variable,l=Array.isArray(a)?a[m].tensor:a[n];null!=l&&(0,t.tidy)(()=>{let e;const t=(0,s.add)((0,i.mul)(this.m,u),l);e=this.useNesterov?(0,s.add)((0,i.mul)(this.c,(0,s.add)(l,(0,i.mul)(t,this.m))),o):(0,s.add)((0,i.mul)(this.c,t),o),u.assign(t),o.assign(e)})}),this.incrementIterations()}dispose(){this.m.dispose(),null!=this.accumulations&&(0,t.dispose)(this.accumulations.map(e=>e.variable))}setMomentum(e){this.momentum=e}async getWeights(){return[await this.saveIterations()].concat(this.accumulations.map(e=>({name:e.originalName,tensor:e.variable})))}async setWeights(e){e=await this.extractIterations(e);this.accumulations=e.map(e=>({originalName:e.name,variable:e.tensor.variable(!1)}))}getConfig(){return{learningRate:this.learningRate,momentum:this.momentum,useNesterov:this.useNesterov}}static fromConfig(e,t){return new e(t.learningRate,t.momentum,t.useNesterov)}}exports.MomentumOptimizer=m;
},{"../engine":"phT7","../globals":"TsQp","../ops/add":"N73o","../ops/mul":"tBJ4","../ops/scalar":"TiGU","../ops/zeros_like":"qY0o","./sgd_optimizer":"GrUb"}],"dOmP":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.RMSPropOptimizer=void 0;var e=require("../engine"),a=require("../globals"),s=require("../ops/add"),t=require("../ops/div"),i=require("../ops/mul"),r=require("../ops/sqrt"),n=require("../ops/square"),u=require("../ops/sub"),l=require("../ops/zeros_like"),c=require("./optimizer");class m extends c.Optimizer{static get className(){return"RMSProp"}constructor(a,s=.9,t=0,i=null,r=!1){if(super(),this.learningRate=a,this.decay=s,this.momentum=t,this.epsilon=i,this.accumulatedMeanSquares=[],this.accumulatedMoments=[],this.accumulatedMeanGrads=[],this.centered=r,null==i&&(this.epsilon=e.ENGINE.backend.epsilon()),null==a)throw new Error("learningRate for RMSPropOptimizer must be defined.")}applyGradients(c){(Array.isArray(c)?c.map(e=>e.name):Object.keys(c)).forEach((m,d)=>{const o=e.ENGINE.registeredVariables[m];null==this.accumulatedMeanSquares[d]&&(this.accumulatedMeanSquares[d]={originalName:`${m}/rms`,variable:(0,a.tidy)(()=>(0,l.zerosLike)(o).variable(!1))}),null==this.accumulatedMoments[d]&&(this.accumulatedMoments[d]={originalName:`${m}/momentum`,variable:(0,a.tidy)(()=>(0,l.zerosLike)(o).variable(!1))}),null==this.accumulatedMeanGrads[d]&&this.centered&&(this.accumulatedMeanGrads[d]={originalName:`${m}/mg`,variable:(0,a.tidy)(()=>(0,l.zerosLike)(o).variable(!1))});const h=Array.isArray(c)?c[d].tensor:c[m];if(null==h)return;const p=this.accumulatedMeanSquares[d].variable,g=this.accumulatedMoments[d].variable;(0,a.tidy)(()=>{const e=(0,s.add)((0,i.mul)(p,this.decay),(0,i.mul)((0,n.square)(h),1-this.decay));if(this.centered){const a=this.accumulatedMeanGrads[d].variable,l=(0,s.add)((0,i.mul)(a,this.decay),(0,i.mul)(h,1-this.decay)),c=(0,t.div)((0,i.mul)(h,this.learningRate),(0,r.sqrt)((0,u.sub)(e,(0,s.add)((0,n.square)(l),this.epsilon)))),m=(0,s.add)((0,i.mul)(g,this.momentum),c);p.assign(e),a.assign(l),g.assign(m);const b=(0,u.sub)(o,m);o.assign(b)}else{const e=(0,s.add)((0,i.mul)(p,this.decay),(0,i.mul)((0,n.square)(h),1-this.decay)),a=(0,s.add)((0,i.mul)(g,this.momentum),(0,t.div)((0,i.mul)(h,this.learningRate),(0,r.sqrt)((0,s.add)(e,this.epsilon))));p.assign(e),g.assign(a);const l=(0,u.sub)(o,a);o.assign(l)}})}),this.incrementIterations()}dispose(){null!=this.accumulatedMeanSquares&&(0,a.dispose)(this.accumulatedMeanSquares.map(e=>e.variable)),null!=this.accumulatedMeanGrads&&this.centered&&(0,a.dispose)(this.accumulatedMeanGrads.map(e=>e.variable)),null!=this.accumulatedMoments&&(0,a.dispose)(this.accumulatedMoments.map(e=>e.variable))}async getWeights(){const e=[...this.accumulatedMeanSquares,...this.accumulatedMoments];return this.centered&&e.push(...this.accumulatedMeanGrads),[await this.saveIterations()].concat(e.map(e=>({name:e.originalName,tensor:e.variable})))}async setWeights(e){e=await this.extractIterations(e);const a=this.centered?e.length/3:e.length/2;this.accumulatedMeanSquares=e.slice(0,a).map(e=>({originalName:e.name,variable:e.tensor.variable(!1)})),this.accumulatedMoments=e.slice(a,2*a).map(e=>({originalName:e.name,variable:e.tensor.variable(!1)})),this.centered&&(this.accumulatedMeanGrads=e.slice(2*a,3*a).map(e=>({originalName:e.name,variable:e.tensor.variable(!1)})))}getConfig(){return{learningRate:this.learningRate,decay:this.decay,momentum:this.momentum,epsilon:this.epsilon,centered:this.centered}}static fromConfig(e,a){return new e(a.learningRate,a.decay,a.momentum,a.epsilon,a.centered)}}exports.RMSPropOptimizer=m;
},{"../engine":"phT7","../globals":"TsQp","../ops/add":"N73o","../ops/div":"S2L5","../ops/mul":"tBJ4","../ops/sqrt":"brr7","../ops/square":"KiGo","../ops/sub":"SgzI","../ops/zeros_like":"qY0o","./optimizer":"zxzS"}],"evGT":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.registerOptimizers=d;var e=require("./adadelta_optimizer"),r=require("./adagrad_optimizer"),i=require("./adam_optimizer"),t=require("./adamax_optimizer"),m=require("./momentum_optimizer"),a=require("./rmsprop_optimizer"),o=require("./sgd_optimizer"),p=require("../serialization");const z=[e.AdadeltaOptimizer,r.AdagradOptimizer,i.AdamOptimizer,t.AdamaxOptimizer,m.MomentumOptimizer,a.RMSPropOptimizer,o.SGDOptimizer];function d(){for(const e of z)(0,p.registerClass)(e)}
},{"./adadelta_optimizer":"WprY","./adagrad_optimizer":"zRFy","./adam_optimizer":"ZLBF","./adamax_optimizer":"eIt3","./momentum_optimizer":"M8Me","./rmsprop_optimizer":"dOmP","./sgd_optimizer":"GrUb","../serialization":"aVHA"}],"zFW7":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.BrowserDownloads=void 0,exports.browserDownloads=w,exports.browserDownloadsRouter=void 0,exports.browserFiles=c,require("../flags");var e=require("../environment"),t=require("./io_utils"),o=require("./router_registry"),r=require("./composite_array_buffer");const s="model",i=".json",n=".weights.bin";function a(e){return new Promise(e=>setTimeout(e)).then(e)}class l{constructor(t){if(!(0,e.env)().getBool("IS_BROWSER"))throw new Error("browserDownloads() cannot proceed because the current environment is not a browser.");t.startsWith(l.URL_SCHEME)&&(t=t.slice(l.URL_SCHEME.length)),null!=t&&0!==t.length||(t=s),this.modelJsonFileName=t+i,this.weightDataFileName=t+n}async save(e){if("undefined"==typeof document)throw new Error("Browser downloads are not supported in this environment since `document` is not present");const o=r.CompositeArrayBuffer.join(e.weightData),s=window.URL.createObjectURL(new Blob([o],{type:"application/octet-stream"}));if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserDownloads.save() does not support saving model topology in binary formats yet.");{const o=[{paths:["./"+this.weightDataFileName],weights:e.weightSpecs}],r=(0,t.getModelJSONForModelArtifacts)(e,o),i=window.URL.createObjectURL(new Blob([JSON.stringify(r)],{type:"application/json"})),n=null==this.modelJsonAnchor?document.createElement("a"):this.modelJsonAnchor;if(n.download=this.modelJsonFileName,n.href=i,await a(()=>n.dispatchEvent(new MouseEvent("click"))),null!=e.weightData){const e=null==this.weightDataAnchor?document.createElement("a"):this.weightDataAnchor;e.download=this.weightDataFileName,e.href=s,await a(()=>e.dispatchEvent(new MouseEvent("click")))}return{modelArtifactsInfo:(0,t.getModelArtifactsInfoForJSON)(e)}}}}exports.BrowserDownloads=l,l.URL_SCHEME="downloads://";class h{constructor(e){if(null==e||e.length<1)throw new Error("When calling browserFiles, at least 1 file is required, "+`but received ${e}`);this.jsonFile=e[0],this.weightsFiles=e.slice(1)}async load(){return new Promise((e,o)=>{const r=new FileReader;r.onload=(r=>{const s=JSON.parse(r.target.result),i=s.modelTopology;if(null==i)return void o(new Error(`modelTopology field is missing from file ${this.jsonFile.name}`));if(null==s.weightsManifest)return void o(new Error(`weightManifest field is missing from file ${this.jsonFile.name}`));if(0===this.weightsFiles.length)return void e({modelTopology:i});const n=(0,t.getModelArtifactsForJSON)(s,e=>this.loadWeights(e));e(n)}),r.onerror=(e=>o("Failed to read model topology and weights manifest JSON "+`from file '${this.jsonFile.name}'. BrowserFiles supports loading `+"Keras-style tf.Model artifacts only.")),r.readAsText(this.jsonFile)})}loadWeights(e){const t=[],o=[];for(const i of e)t.push(...i.weights),o.push(...i.paths);const r=this.checkManifestAndWeightFiles(e),s=o.map(e=>this.loadWeightsFile(e,r[e]));return Promise.all(s).then(e=>[t,e])}loadWeightsFile(e,t){return new Promise((o,r)=>{const s=new FileReader;s.onload=(e=>{const t=e.target.result;o(t)}),s.onerror=(t=>r(`Failed to weights data from file of path '${e}'.`)),s.readAsArrayBuffer(t)})}checkManifestAndWeightFiles(e){const o=[],r=this.weightsFiles.map(e=>(0,t.basename)(e.name)),s={};for(const i of e)i.paths.forEach(e=>{const i=(0,t.basename)(e);if(-1!==o.indexOf(i))throw new Error("Duplicate file basename found in weights manifest: "+`'${i}'`);if(o.push(i),-1===r.indexOf(i))throw new Error(`Weight file with basename '${i}' is not provided.`);s[e]=this.weightsFiles[r.indexOf(i)]});if(o.length!==this.weightsFiles.length)throw new Error("Mismatch in the number of files in weights manifest "+`(${o.length}) and the number of weight files provided `+`(${this.weightsFiles.length}).`);return s}}const d=t=>(0,e.env)().getBool("IS_BROWSER")&&!Array.isArray(t)&&t.startsWith(l.URL_SCHEME)?w(t.slice(l.URL_SCHEME.length)):null;function w(e="model"){return new l(e)}function c(e){return new h(e)}exports.browserDownloadsRouter=d,o.IORouterRegistry.registerSaveRouter(d);
},{"../flags":"lELk","../environment":"vpgN","./io_utils":"kOer","./router_registry":"XmHK","./composite_array_buffer":"THI4"}],"tiHi":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.monitorPromisesProgress=r;var t=require("../util");function r(r,e,n,s){!function(r){(0,t.assert)(null!=r&&Array.isArray(r)&&r.length>0,()=>"promises must be a none empty array")}(r),function(r,e){(0,t.assert)(r>=0&&r<=1,()=>"Progress fraction must be in range [0, 1], but "+`got startFraction ${r}`),(0,t.assert)(e>=0&&e<=1,()=>"Progress fraction must be in range [0, 1], but "+`got endFraction ${e}`),(0,t.assert)(e>=r,()=>"startFraction must be no more than endFraction, but "+`got startFraction ${r} and endFraction `+`${e}`)}(n=null==n?0:n,s=null==s?1:s);let o=0;return Promise.all(r.map(t=>(t.then(t=>{const a=n+ ++o/r.length*(s-n);return e(a),t}),t)))}
},{"../util":"XXxQ"}],"wDWD":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.loadWeights=f,exports.loadWeightsAsArrayBuffer=i,exports.streamWeights=u,exports.weightsLoaderFactory=l;var e=require("../environment"),t=a(require("../util")),r=require("./composite_array_buffer"),n=require("./io_utils"),o=require("./progress"),s=require("./types");function a(e,t){if("function"==typeof WeakMap)var r=new WeakMap,n=new WeakMap;return(a=function(e,t){if(!t&&e&&e.__esModule)return e;var o,s,a={__proto__:null,default:e};if(null===e||"object"!=typeof e&&"function"!=typeof e)return a;if(o=t?n:r){if(o.has(e))return o.get(e);o.set(e,a)}for(const r in e)"default"!==r&&{}.hasOwnProperty.call(e,r)&&((s=(o=Object.defineProperty)&&Object.getOwnPropertyDescriptor(e,r))&&(s.get||s.set)?o(a,r,s):a[r]=e[r]);return a})(e,t)}async function i(t,r){null==r&&(r={});const n=null==r.fetchFunc?(0,e.env)().platform.fetch:r.fetchFunc,s=t.map(e=>n(e,r.requestInit,{isBinary:!0})),a=(null==r.onProgress?await Promise.all(s):await(0,o.monitorPromisesProgress)(s,r.onProgress,0,.5)).map(e=>e.arrayBuffer());return null==r.onProgress?await Promise.all(a):await(0,o.monitorPromisesProgress)(a,r.onProgress,.5,1)}function u(t,r){var n;const o=null==r.fetchFunc?(0,e.env)().platform.fetch:r.fetchFunc;let s,a=0;return null===(n=r.onProgress)||void 0===n||n.call(r,0),new ReadableStream({pull:async e=>{for(var n;a<t.length;){if(!s){const e=(await o(t[a],r.requestInit,{isBinary:!0})).body;s=e.getReader()}const{done:i,value:u}=await s.read();if(!i)return void e.enqueue(u);a++,s=void 0,null===(n=r.onProgress)||void 0===n||n.call(r,a/t.length)}e.close()}})}async function f(e,t="",r,n){return l(e=>i(e,{requestInit:n}))(e,t,r)}function l(e){return async(o,a="",i)=>{const u=o.map(()=>!1),f={},l=null!=i?i.map(()=>!1):[],c=[];if(o.forEach((e,r)=>{let n=0;e.weights.forEach(e=>{const o="quantization"in e?e.quantization.dtype:e.dtype,a=s.DTYPE_VALUE_SIZE_MAP[o]*t.sizeFromShape(e.shape),p=()=>{u[r]=!0,null==f[r]&&(f[r]=[]),f[r].push({manifestEntry:e,groupOffset:n,sizeBytes:a})};null!=i?i.forEach((t,r)=>{t===e.name&&(p(),l[r]=!0)}):p(),c.push(e.name),n+=a})}),!l.every(e=>e)){const e=i.filter((e,t)=>!l[t]);throw new Error("Could not find weights in manifest with names: "+`${e.join(", ")}. \n`+"Manifest JSON has weights with names: "+`${c.join(", ")}.`)}const p=u.reduce((e,t,r)=>(t&&e.push(r),e),[]),h=[];p.forEach(e=>{o[e].paths.forEach(e=>{const t=a+(a.endsWith("/")?"":"/")+e;h.push(t)})});const g=await e(h),y={};let d=0;return p.forEach(e=>{const t=o[e].paths.length,s=new r.CompositeArrayBuffer(g.slice(d,d+t));f[e].forEach(e=>{const t=s.slice(e.groupOffset,e.groupOffset+e.sizeBytes),r=(0,n.decodeWeights)(t,[e.manifestEntry]);for(const n in r)y[n]=r[n]}),d+=t}),y}}
},{"../environment":"vpgN","../util":"XXxQ","./composite_array_buffer":"THI4","./io_utils":"kOer","./progress":"tiHi","./types":"tjMC"}],"GLCC":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.HTTPRequest=void 0,exports.browserHTTPRequest=f,exports.http=c,exports.httpRouter=void 0,exports.isHTTPScheme=u,exports.parseUrl=l;var t=require("../environment"),e=require("../util"),s=require("./io_utils"),r=require("./composite_array_buffer"),o=require("./router_registry"),i=require("./weights_loader");const n="application/octet-stream",a="application/json";class h{constructor(s,r){if(this.DEFAULT_METHOD="POST",null==r&&(r={}),this.weightPathPrefix=r.weightPathPrefix,this.weightUrlConverter=r.weightUrlConverter,null!=r.fetchFunc?((0,e.assert)("function"==typeof r.fetchFunc,()=>"Must pass a function that matches the signature of `fetch` (see https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API)"),this.fetch=r.fetchFunc):this.fetch=(0,t.env)().platform.fetch,(0,e.assert)(null!=s&&s.length>0,()=>"URL path for http must not be null, undefined or empty."),Array.isArray(s)&&(0,e.assert)(2===s.length,()=>"URL paths for http must have a length of 2, "+`(actual length is ${s.length}).`),this.path=s,null!=r.requestInit&&null!=r.requestInit.body)throw new Error("requestInit is expected to have no pre-existing body, but has one.");this.requestInit=r.requestInit||{},this.loadOptions=r}async save(t){if(t.modelTopology instanceof ArrayBuffer)throw new Error("BrowserHTTPRequest.save() does not support saving model topology in binary formats yet.");const e=Object.assign({method:this.DEFAULT_METHOD},this.requestInit);e.body=new FormData;const o=[{paths:["./model.weights.bin"],weights:t.weightSpecs}],i=(0,s.getModelJSONForModelArtifacts)(t,o);if(e.body.append("model.json",new Blob([JSON.stringify(i)],{type:a}),"model.json"),null!=t.weightData){const s=r.CompositeArrayBuffer.join(t.weightData);e.body.append("model.weights.bin",new Blob([s],{type:n}),"model.weights.bin")}const h=await this.fetch(this.path,e);if(h.ok)return{modelArtifactsInfo:(0,s.getModelArtifactsInfoForJSON)(t),responses:[h]};throw new Error("BrowserHTTPRequest.save() failed due to HTTP response status "+`${h.status}.`)}async loadModelJSON(){const t=await this.fetch(this.path,this.requestInit);if(!t.ok)throw new Error(`Request to ${this.path} failed with status code `+`${t.status}. Please verify this URL points to `+"the model JSON of the model to load.");let e;try{e=await t.json()}catch(o){let t=`Failed to parse model JSON of response from ${this.path}.`;throw this.path.endsWith(".pb")?t+=" Your path contains a .pb file extension. Support for .pb models have been removed in TensorFlow.js 1.0 in favor of .json models. You can re-convert your Python TensorFlow model using the TensorFlow.js 1.0 conversion scripts or you can convert your.pb models with the 'pb2json'NPM script in the tensorflow/tfjs-converter repository.":t+=" Please make sure the server is serving valid JSON for this request.",new Error(t)}const s=e.modelTopology,r=e.weightsManifest;if(null==s&&null==r)throw new Error(`The JSON from HTTP path ${this.path} contains neither model `+"topology or manifest for weights.");return e}async load(){if(this.loadOptions.streamWeights)return this.loadStream();const t=await this.loadModelJSON();return(0,s.getModelArtifactsForJSON)(t,t=>this.loadWeights(t))}async loadStream(){const t=await this.loadModelJSON(),e=await this.getWeightUrls(t.weightsManifest),r=(0,s.getWeightSpecs)(t.weightsManifest);return Object.assign(Object.assign({},t),{weightSpecs:r,getWeightStream:()=>(0,i.streamWeights)(e,this.loadOptions)})}async getWeightUrls(t){const e=Array.isArray(this.path)?this.path[1]:this.path,[s,r]=l(e),o=this.weightPathPrefix||s,i=[],n=[];for(const a of t)for(const t of a.paths)null!=this.weightUrlConverter?n.push(this.weightUrlConverter(t)):i.push(o+t+r);return this.weightUrlConverter&&i.push(...await Promise.all(n)),i}async loadWeights(t){const e=await this.getWeightUrls(t);return[(0,s.getWeightSpecs)(t),await(0,i.loadWeightsAsArrayBuffer)(e,this.loadOptions)]}}function l(t){const e=t.lastIndexOf("/"),s=t.lastIndexOf("?");return[t.substring(0,e)+"/",s>e?t.substring(s):""]}function u(t){return null!=t.match(h.URL_SCHEME_REGEX)}exports.HTTPRequest=h,h.URL_SCHEME_REGEX=/^https?:\/\//;const p=(t,e)=>{if("undefined"==typeof fetch&&(null==e||null==e.fetchFunc))return null;{let s=!0;if(s=Array.isArray(t)?t.every(t=>u(t)):u(t))return c(t,e)}return null};function c(t,e){return new h(t,e)}function f(t,e){return c(t,e)}exports.httpRouter=p,o.IORouterRegistry.registerSaveRouter(p),o.IORouterRegistry.registerLoadRouter(p);
},{"../environment":"vpgN","../util":"XXxQ","./io_utils":"kOer","./composite_array_buffer":"THI4","./router_registry":"XmHK","./weights_loader":"wDWD"}],"U2v3":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.fromMemory=t,exports.fromMemorySync=n,exports.withSaveHandler=a,exports.withSaveHandlerSync=s;class e{constructor(e){this.modelArtifacts=e}load(){return this.modelArtifacts}}class o{constructor(e){this.saveHandler=e}save(e){return this.saveHandler(e)}}class r{constructor(e){e.load&&(this.load=(()=>Promise.resolve(e.load()))),e.save&&(this.save=(o=>Promise.resolve(e.save(o))))}}function t(e,o,t,a){return new r(n(...arguments))}function n(o,r,t,n){if(1===arguments.length){return null!=o.modelTopology||null!=o.weightSpecs?new e(o):(console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new e({modelTopology:o}))}return console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new e({modelTopology:o,weightSpecs:r,weightData:t,trainingConfig:n})}function a(e){return new o(e)}function s(e){return new o(e)}
},{}],"wh56":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),Object.defineProperty(exports,"CompositeArrayBuffer",{enumerable:!0,get:function(){return i.CompositeArrayBuffer}}),Object.defineProperty(exports,"browserFiles",{enumerable:!0,get:function(){return e.browserFiles}}),Object.defineProperty(exports,"browserHTTPRequest",{enumerable:!0,get:function(){return r.browserHTTPRequest}}),Object.defineProperty(exports,"concatenateArrayBuffers",{enumerable:!0,get:function(){return t.concatenateArrayBuffers}}),Object.defineProperty(exports,"copyModel",{enumerable:!0,get:function(){return c.copyModel}}),Object.defineProperty(exports,"decodeWeights",{enumerable:!0,get:function(){return t.decodeWeights}}),Object.defineProperty(exports,"decodeWeightsStream",{enumerable:!0,get:function(){return t.decodeWeightsStream}}),Object.defineProperty(exports,"encodeWeights",{enumerable:!0,get:function(){return t.encodeWeights}}),Object.defineProperty(exports,"fromMemory",{enumerable:!0,get:function(){return n.fromMemory}}),Object.defineProperty(exports,"fromMemorySync",{enumerable:!0,get:function(){return n.fromMemorySync}}),Object.defineProperty(exports,"getLoadHandlers",{enumerable:!0,get:function(){return o.getLoadHandlers}}),Object.defineProperty(exports,"getModelArtifactsForJSON",{enumerable:!0,get:function(){return t.getModelArtifactsForJSON}}),Object.defineProperty(exports,"getModelArtifactsForJSONSync",{enumerable:!0,get:function(){return t.getModelArtifactsForJSONSync}}),Object.defineProperty(exports,"getModelArtifactsInfoForJSON",{enumerable:!0,get:function(){return t.getModelArtifactsInfoForJSON}}),Object.defineProperty(exports,"getSaveHandlers",{enumerable:!0,get:function(){return o.getSaveHandlers}}),Object.defineProperty(exports,"getWeightSpecs",{enumerable:!0,get:function(){return t.getWeightSpecs}}),Object.defineProperty(exports,"http",{enumerable:!0,get:function(){return r.http}}),Object.defineProperty(exports,"isHTTPScheme",{enumerable:!0,get:function(){return r.isHTTPScheme}}),Object.defineProperty(exports,"listModels",{enumerable:!0,get:function(){return c.listModels}}),Object.defineProperty(exports,"loadWeights",{enumerable:!0,get:function(){return u.loadWeights}}),Object.defineProperty(exports,"moveModel",{enumerable:!0,get:function(){return c.moveModel}}),Object.defineProperty(exports,"registerLoadRouter",{enumerable:!0,get:function(){return o.registerLoadRouter}}),Object.defineProperty(exports,"registerSaveRouter",{enumerable:!0,get:function(){return o.registerSaveRouter}}),Object.defineProperty(exports,"removeModel",{enumerable:!0,get:function(){return c.removeModel}}),Object.defineProperty(exports,"weightsLoaderFactory",{enumerable:!0,get:function(){return u.weightsLoaderFactory}}),Object.defineProperty(exports,"withSaveHandler",{enumerable:!0,get:function(){return n.withSaveHandler}}),Object.defineProperty(exports,"withSaveHandlerSync",{enumerable:!0,get:function(){return n.withSaveHandlerSync}}),require("./indexed_db"),require("./local_storage");var e=require("./browser_files"),r=require("./http"),t=require("./io_utils"),n=require("./passthrough"),o=require("./router_registry"),u=require("./weights_loader"),i=require("./composite_array_buffer"),c=require("./model_management");
},{"./indexed_db":"XHfa","./local_storage":"bqqF","./browser_files":"zFW7","./http":"GLCC","./io_utils":"kOer","./passthrough":"U2v3","./router_registry":"XmHK","./weights_loader":"wDWD","./composite_array_buffer":"THI4","./model_management":"xu20"}],"VdwK":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.confusionMatrix=void 0,exports.confusionMatrix_=u;var e=require("../tensor_util_env"),t=a(require("../util")),r=require("./cast"),n=require("./mat_mul"),o=require("./one_hot"),s=require("./operation"),i=require("./transpose");function a(e,t){if("function"==typeof WeakMap)var r=new WeakMap,n=new WeakMap;return(a=function(e,t){if(!t&&e&&e.__esModule)return e;var o,s,i={__proto__:null,default:e};if(null===e||"object"!=typeof e&&"function"!=typeof e)return i;if(o=t?n:r){if(o.has(e))return o.get(e);o.set(e,i)}for(const r in e)"default"!==r&&{}.hasOwnProperty.call(e,r)&&((s=(o=Object.defineProperty)&&Object.getOwnPropertyDescriptor(e,r))&&(s.get||s.set)?o(i,r,s):i[r]=e[r]);return i})(e,t)}function u(s,a,u){const c=(0,e.convertToTensor)(s,"labels","confusionMatrix"),p=(0,e.convertToTensor)(a,"predictions","confusionMatrix");t.assert(null==u||u>0&&Number.isInteger(u),()=>"If provided, numClasses must be a positive integer, "+`but got ${u}`),t.assert(1===c.rank,()=>`Expected the rank of labels to be 1, but got ${c.rank}`),t.assert(1===p.rank,()=>"Expected the rank of predictions to be 1, "+`but got ${p.rank}`),t.assert(c.shape[0]===p.shape[0],()=>"Mismatch in the number of examples: "+`${c.shape[0]} vs. ${p.shape[0]}. `+"Labels and predictions should have the same number of elements."),t.assert(u>0&&Number.isInteger(u),()=>"numClasses is required to be a positive integer, but got "+`${u}`);const f=(0,o.oneHot)((0,r.cast)(c,"int32"),u),l=(0,o.oneHot)((0,r.cast)(p,"int32"),u),b=(0,i.transpose)(f),d=(0,n.matMul)(b,l);return(0,r.cast)(d,"int32")}const c=exports.confusionMatrix=(0,s.op)({confusionMatrix_:u});
},{"../tensor_util_env":"y4X4","../util":"XXxQ","./cast":"qnzc","./mat_mul":"zVDr","./one_hot":"HpS0","./operation":"uE86","./transpose":"JmRY"}],"EwBN":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),Object.defineProperty(exports,"confusionMatrix",{enumerable:!0,get:function(){return e.confusionMatrix}});var e=require("./ops/confusion_matrix");
},{"./ops/confusion_matrix":"VdwK"}],"Wqnn":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.draw=E,exports.fromPixels=void 0,exports.fromPixelsAsync=h,exports.toPixels=x;var e=require("../engine"),n=require("../environment"),t=require("../kernel_names"),r=require("../kernel_registry"),o=require("../tensor"),a=require("../tensor_util_env"),i=require("./cast"),s=require("./operation"),l=require("./tensor3d");let f,u=!1;function d(n,o=3){if(o>4)throw new Error("Cannot construct Tensor with more than 4 channels from pixels.");if(null==n)throw new Error("pixels passed to tf.browser.fromPixels() can not be null");let a=!1,i=!1,s=!1,u=!1,d=!1,c=!1;if(n.data instanceof Uint8Array)a=!0;else if("undefined"!=typeof ImageData&&n instanceof ImageData)i=!0;else if("undefined"!=typeof HTMLVideoElement&&n instanceof HTMLVideoElement)s=!0;else if("undefined"!=typeof HTMLImageElement&&n instanceof HTMLImageElement)u=!0;else if(null!=n.getContext)d=!0;else{if(!("undefined"!=typeof ImageBitmap&&n instanceof ImageBitmap))throw new Error("pixels passed to tf.browser.fromPixels() must be either an HTMLVideoElement, HTMLImageElement, HTMLCanvasElement, ImageData in browser, or OffscreenCanvas, ImageData in webworker or {data: Uint32Array, width: number, height: number}, "+`but was ${n.constructor.name}`);c=!0}if(null!=(0,r.getKernel)(t.FromPixels,e.ENGINE.backendName)){const r={pixels:n},a={numChannels:o};return e.ENGINE.runKernel(t.FromPixels,r,a)}const[p,m]=s?[n.videoWidth,n.videoHeight]:[n.width,n.height];let w,h;if(d)w=n.getContext("2d").getImageData(0,0,p,m).data;else if(i||a)w=n.data;else if(u||s||c){if(null==f)if("undefined"==typeof document){if("undefined"==typeof OffscreenCanvas||"undefined"==typeof OffscreenCanvasRenderingContext2D)throw new Error("Cannot parse input in current context. Reason: OffscreenCanvas Context2D rendering is not supported.");f=new OffscreenCanvas(1,1).getContext("2d")}else f=document.createElement("canvas").getContext("2d",{willReadFrequently:!0});f.canvas.width=p,f.canvas.height=m,f.drawImage(n,0,0,p,m),w=f.getImageData(0,0,p,m).data}if(4===o)h=new Int32Array(w);else{const e=p*m;h=new Int32Array(e*o);for(let n=0;n<e;n++)for(let e=0;e<o;++e)h[n*o+e]=w[4*n+e]}const g=[m,p,o];return(0,l.tensor3d)(h,g,"int32")}function c(e){return null!=e&&e.data instanceof Uint8Array}function p(){return"undefined"!=typeof window&&"undefined"!=typeof ImageBitmap&&window.hasOwnProperty("createImageBitmap")}function m(e){return null!=e&&0!==e.width&&0!==e.height}function w(e){return p()&&!(e instanceof ImageBitmap)&&m(e)&&!c(e)}async function h(e,t=3){let r=null;if((0,n.env)().getBool("WRAP_TO_IMAGEBITMAP")&&w(e)){let n;try{n=await createImageBitmap(e,{premultiplyAlpha:"none"})}catch(o){n=null}r=null!=n&&n.width===e.width&&n.height===e.height?n:e}else r=e;return d(r,t)}function g(e){if(2!==e.rank&&3!==e.rank)throw new Error(`toPixels only supports rank 2 or 3 tensors, got rank ${e.rank}.`);const n=2===e.rank?1:e.shape[2];if(n>4||2===n)throw new Error("toPixels only supports depth of size "+`1, 3 or 4 but got ${n}`);if("float32"!==e.dtype&&"int32"!==e.dtype)throw new Error(`Unsupported type for toPixels: ${e.dtype}.`+" Please use float32 or int32 tensors.")}function y(e){const n=(null==e?void 0:e.alpha)||1;if(n>1||n<0)throw new Error(`Alpha value ${n} is suppoed to be in range [0 - 1].`)}async function x(n,s){let l=(0,a.convertToTensor)(n,"img","toPixels");if(!(n instanceof o.Tensor)){const e=l;l=(0,i.cast)(e,"int32"),e.dispose()}g(l);const[f,d]=l.shape.slice(0,2),c=2===l.rank?1:l.shape[2],p=await l.data(),m="float32"===l.dtype?255:1,w=new Uint8ClampedArray(d*f*4);for(let e=0;e<f*d;++e){const n=[0,0,0,255];for(let r=0;r<c;r++){const t=p[e*c+r];if("float32"===l.dtype){if(t<0||t>1)throw new Error("Tensor values for a float32 Tensor must be in the "+`range [0 - 1] but encountered ${t}.`)}else if("int32"===l.dtype&&(t<0||t>255))throw new Error("Tensor values for a int32 Tensor must be in the "+`range [0 - 255] but encountered ${t}.`);1===c?(n[0]=t*m,n[1]=t*m,n[2]=t*m):n[r]=t*m}const t=4*e;w[t+0]=Math.round(n[0]),w[t+1]=Math.round(n[1]),w[t+2]=Math.round(n[2]),w[t+3]=Math.round(n[3])}if(null!=s){if(!u){null!=(0,r.getKernel)(t.Draw,e.ENGINE.backendName)&&(console.warn("tf.browser.toPixels is not efficient to draw tensor on canvas. Please try tf.browser.draw instead."),u=!0)}s.width=d,s.height=f;const n=s.getContext("2d"),o=new ImageData(w,d,f);n.putImageData(o,0,0)}return l!==n&&l.dispose(),w}function E(n,r,s){let l=(0,a.convertToTensor)(n,"img","draw");if(!(n instanceof o.Tensor)){const e=l;l=(0,i.cast)(e,"int32"),e.dispose()}g(l),y(null==s?void 0:s.imageOptions);const f={image:l},u={canvas:r,options:s};e.ENGINE.runKernel(t.Draw,f,u)}const v=exports.fromPixels=(0,s.op)({fromPixels_:d});
},{"../engine":"phT7","../environment":"vpgN","../kernel_names":"rJl6","../kernel_registry":"PlaY","../tensor":"eFW4","../tensor_util_env":"y4X4","./cast":"qnzc","./operation":"uE86","./tensor3d":"gE0c"}],"JyCd":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.prepareAndValidate=t;var e=require("../util");function t(t,r){const s=t.shape.length,n=r.shape.length;if(s<1)throw new Error("tf.gatherND() expects the input to be rank 1 or higher,"+` but the rank was ${s}.`);if(n<1)throw new Error("tf.gatherND() expects the indices to be rank 1 or higher,"+` but the rank was ${n}.`);if("int32"!==r.dtype)throw new Error("tf.gatherND() expects the indices to be int32 type,"+` but the dtype was ${r.dtype}.`);if(r.shape[n-1]>s)throw new Error("index innermost dimension length must be <= tensor rank; saw: "+`${r.shape[n-1]} vs. ${s}`);if(0===(0,e.sizeFromShape)(t.shape))throw new Error("Requested more than 0 entries, but input is empty."+` Input shape: ${t.shape}.`);const h=r.shape,o=h[h.length-1];let p=1;for(let e=0;e<h.length-1;++e)p*=h[e];const i=t.shape,a=h.slice();a.pop();let u=1;for(let e=o;e<s;++e)u*=i[e],a.push(i[e]);const c=[...(0,e.computeStrides)(t.shape).map(e=>e/u),1].slice(0,o);return[a,p,u,c]}
},{"../util":"XXxQ"}],"PuAY":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.assertParamsValid=i,exports.computeFlatOffset=m,exports.computeOutShape=l,exports.getNormalizedAxes=u,exports.isSliceContinous=b,exports.maskToAxes=r,exports.parseSliceParams=A,exports.sliceInfo=M,exports.startForAxis=p,exports.startIndicesWithElidedDims=h,exports.stopForAxis=g,exports.stopIndicesWithElidedDims=f,exports.stridesForAxis=c,exports.stridesWithElidedDims=a;var e=n(require("../util"));function n(e,s){if("function"==typeof WeakMap)var t=new WeakMap,i=new WeakMap;return(n=function(e,n){if(!n&&e&&e.__esModule)return e;var s,r,l={__proto__:null,default:e};if(null===e||"object"!=typeof e&&"function"!=typeof e)return l;if(s=n?i:t){if(s.has(e))return s.get(e);s.set(e,l)}for(const t in e)"default"!==t&&{}.hasOwnProperty.call(e,t)&&((r=(s=Object.defineProperty)&&Object.getOwnPropertyDescriptor(e,t))&&(r.get||r.set)?s(l,t,r):l[t]=e[t]);return l})(e,s)}const s=-2,t=-1;function i(n,s,t){const i=n.shape.length;e.assert(i===s.length,()=>`Error in slice${i}D: Length of begin ${s} must `+`match the rank of the array (${i}).`),e.assert(i===t.length,()=>`Error in slice${i}D: Length of size ${t} must `+`match the rank of the array (${i}).`);for(let r=0;r<i;++r)e.assert(s[r]+t[r]<=n.shape[r],()=>`Error in slice${i}D: begin[${r}] + size[${r}] `+`(${s[r]+t[r]}) would overflow input.shape[${r}] (${n.shape[r]})`)}function r(e){const n=[];let s=0;for(;e>0;)1&e&&n.push(s),e/=2,s++;return n}function l(e,n,s){const t=[];for(let i=0;i<e.length;i++)t[i]=Math.ceil((n[i]-e[i])/s[i]);return t}function a(e,n,s,t){const i=[...e];for(let r=i.length;r<t.length;r++)i.push(1);for(let r=0;r<s;r++)0===r?i[n]=1:(i.splice(n,0,1),i.pop());return i}function o(e,n,s){return s<=e?s:s-(n-1)}function d(e,n){const s=[];for(let t=0;t<e;t++)s.push(n+t);return s}function u(e,n,s,t,i,r,l,o,d){const u=e.length;let b=new Array(u),m=new Array(u),A=new Array(u);if(n.length&&s>0){const d=n[0],u=s+1;b=h(l,d,u,t,e),m=f(o,d,u,i,e),A=a(r,d,u,e)}else for(let a=0;a<u;a++)b[a]=p(l,t,r,e,a,d),m[a]=g(o,i,r,e,a,d),A[a]=c(r,a,d);return{begin:b,end:m,strides:A}}function h(e,n,s,t,i){const r=[...i],l=d(s,n);for(let a=0;a<r.length;a++)if(l.indexOf(a)>-1)r[a]=0;else{const i=o(n,s,a);let l=t[i];e&1<<i&&(l=0),r[a]=l}return r}function f(n,s,t,i,r){const l=[...r],a=d(t,s);for(let e=0;e<l.length;e++)if(a.indexOf(e)>-1)l[e]=Number.MAX_SAFE_INTEGER;else{const r=o(s,t,e);let a=i[r];n&1<<r&&(a=Number.MAX_SAFE_INTEGER),l[e]=a}for(let o=0;o<l.length;o++){const n=r[o];l[o]<0&&(l[o]+=n),l[o]=e.clamp(0,l[o],r[o])}return l}function c(e,n,s){let t=e[n];return(s&1<<n||null==t)&&(t=1),t}function p(n,s,t,i,r,l){let a=s[r];const o=t[r]||1;(n&1<<r||l&1<<r||null==a)&&(a=o>0?Number.MIN_SAFE_INTEGER:Number.MAX_SAFE_INTEGER);const d=i[r];return a<0&&(a+=d),a=e.clamp(0,a,d-1)}function g(n,s,t,i,r,l){let a=s[r];const o=t[r]||1;(n&1<<r||l&1<<r||null==a)&&(a=o>0?Number.MAX_SAFE_INTEGER:Number.MIN_SAFE_INTEGER);const d=i[r];return a<0&&(a+=d),a=o>0?e.clamp(0,a,d):e.clamp(-1,a,d-1)}function b(e,n,s){let t=s.length;for(let i=0;i<s.length;i++)if(s[i]>1){t=i;break}for(let i=t+1;i<s.length;i++)if(n[i]>0||s[i]!==e[i])return!1;return!0}function m(e,n){let s=e.length>0?e[e.length-1]:1;for(let t=0;t<e.length-1;t++)s+=e[t]*n[t];return s}function A(n,s,t){let i;const r=n.shape.length;let l;return(i="number"==typeof s?[s,...new Array(r-1).fill(0)]:s.length<r?s.concat(new Array(r-s.length).fill(0)):s.slice()).forEach(n=>{e.assert(-1!==n,()=>"slice() does not support negative begin indexing.")}),l=(l=null==t?new Array(r).fill(-1):"number"==typeof t?[t,...new Array(r-1).fill(-1)]:t.length<r?t.concat(new Array(r-t.length).fill(-1)):t).map((s,t)=>s>=0?s:(e.assert(-1===s,()=>"Negative size values should be exactly -1 but got "+`${s} for the slice() size at index ${t}.`),n.shape[t]-i[t])),[i,l]}function M(e,n,t,i,r,l,a,o,d){let u;if(null==i?(u=new Array(n.length)).fill(1):u=i,null!=a&&0!=(a&a-1))throw new Error("Multiple ellipses in slice is not allowed.");let h=!1;const f={dims:u.length,numAddAxisAfterEllipsis:0,begin:n.slice(),end:t.slice(),strides:u.slice(),beginMask:r,endMask:l,ellipsisMask:a,newAxisMask:o,shrinkAxisMask:d};for(let s=0;s<f.dims;s++)h&&0!=(1<<s&o)&&f.numAddAxisAfterEllipsis++,1<<s&a&&(h=!0);h||(f.ellipsisMask|=1<<f.dims,f.dims++);const c={dims:e.length,beginMask:0,endMask:0,beginValid:!1,endValid:!1};k(f,c);let p=!0,g=!0,b=!0;const m=[],A=[];for(let s=0;s<e.length;++s){if(0===c.strides[s])throw Error(`strides[${s}] must be non-zero`);const n=!!(c.shrinkAxisMask&1<<s),t=e[s];if(-1===t){m.push(n?1:-1);continue}const i=[c.beginMask&1<<s,c.endMask&1<<s],r=[c.strides[s]>0?0:-1,c.strides[s]>0?t:t-1];if(n&&c.strides[s]<=0)throw Error("only stride 1 allowed on non-range indexing.");b=b&&1===c.strides[s];const l=!!(c.beginMask&1<<s&&c.endMask&1<<s);if(c.beginValid&&c.endValid){if(n){const e=c.begin[s]<0?t+c.begin[s]:c.begin[s];if(c.begin[s]=e,c.end[s]=c.begin[s]+1,e<0||e>=t)throw Error(`slice index ${c.begin[s]} of dimension ${s} out of bounds.`)}else c.begin[s]=x(c.begin[s],0,c.strides[s],t,i,r),c.end[s]=x(c.end[s],1,c.strides[s],t,i,r);const e=1===c.strides[s]&&0===c.begin[s]&&c.end[s]===t;p=p&&e,g=g&&(0===s&&1===c.strides[s]||e)}else p=p&&1===c.strides[s]&&l,g=g&&(0===s&&1===c.strides[s]||l);let a,o=!1;if(c.beginValid&&c.endValid?(a=c.end[s]-c.begin[s],o=!0):n?(a=1,o=!0):l&&t>=0&&(a=c.strides[s]<0?-t:t,o=!0),o){let e;e=0===a||a<0!=c.strides[s]<0?0:Math.trunc(a/c.strides[s])+(a%c.strides[s]!=0?1:0),m.push(e)}else m.push(-1)}for(let M=0;M<c.finalShapeGatherIndices.length;++M){const e=c.finalShapeGatherIndices[M];e>=0?A.push(m[e]):e===s&&A.push(1)}return{finalShapeSparse:A.filter((e,n)=>c.finalShapeGatherIndices[n]!==s),finalShape:A,isIdentity:p,sliceDim0:g,isSimpleSlice:b,begin:c.begin,end:c.end,strides:c.strides}}function k(e,n){n.beginMask=0,n.endMask=0,n.shrinkAxisMask=0;let i=0;n.beginValid=null!=e.begin,n.endValid=null!=e.end,n.begin=new Array(n.dims),n.end=new Array(n.dims),n.strides=new Array(n.dims),n.finalShapeGatherIndices=[],n.finalShapeGatherIndicesSparse=[],n.inputShapeGatherIndicesSparse=new Array(n.dims);for(let r=0;r<e.dims;r++)if(1<<r&e.ellipsisMask){const s=Math.min(n.dims-(e.dims-r)+1+e.numAddAxisAfterEllipsis,n.dims);for(;i<s;i++)n.begin[i]=0,n.end[i]=0,n.strides[i]=1,n.beginMask|=1<<i,n.endMask|=1<<i,n.finalShapeGatherIndices.push(i),n.finalShapeGatherIndicesSparse.push(-1),n.inputShapeGatherIndicesSparse[i]=r}else if(1<<r&e.newAxisMask)n.finalShapeGatherIndices.push(s),n.finalShapeGatherIndicesSparse.push(-1);else{if(i===n.begin.length)throw Error(`Index out of range using input dim ${i}; input `+`has only ${n.dims} dims, ${n.begin.length}.`);null!=e.begin&&(n.begin[i]=e.begin[r]),null!=e.end&&(n.end[i]=e.end[r]),n.strides[i]=e.strides[r],e.beginMask&1<<r&&(n.beginMask|=1<<i),e.endMask&1<<r&&(n.endMask|=1<<i),e.shrinkAxisMask&1<<r?(n.finalShapeGatherIndices.push(t),n.finalShapeGatherIndicesSparse.push(-1),n.shrinkAxisMask|=1<<i):(n.finalShapeGatherIndices.push(i),n.finalShapeGatherIndicesSparse.push(r)),n.inputShapeGatherIndicesSparse[i]=r,i++}}function x(e,n,s,t,i,r){if(i[n])return s>0?r[n]:r[n+1&1];{const n=e<0?t+e:e;return n<r[0]?r[0]:n>r[1]?r[1]:n}}
},{"../util":"XXxQ"}],"KPnh":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.version=void 0;const e=exports.version="4.22.0";
},{}],"efk8":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.OptimizerConstructors=void 0;var r=require("./adadelta_optimizer"),e=require("./adagrad_optimizer"),t=require("./adam_optimizer"),i=require("./adamax_optimizer"),a=require("./momentum_optimizer"),m=require("./rmsprop_optimizer"),u=require("./sgd_optimizer");class p{static sgd(r){return new u.SGDOptimizer(r)}static momentum(r,e,t=!1){return new a.MomentumOptimizer(r,e,t)}static rmsprop(r,e=.9,t=0,i=null,a=!1){return new m.RMSPropOptimizer(r,e,t,i,a)}static adam(r=.001,e=.9,i=.999,a=null){return new t.AdamOptimizer(r,e,i,a)}static adadelta(e=.001,t=.95,i=null){return new r.AdadeltaOptimizer(e,t,i)}static adamax(r=.002,e=.9,t=.999,a=null,m=0){return new i.AdamaxOptimizer(r,e,t,a,m)}static adagrad(r,t=.1){return new e.AdagradOptimizer(r,t)}}exports.OptimizerConstructors=p;
},{"./adadelta_optimizer":"WprY","./adagrad_optimizer":"zRFy","./adam_optimizer":"ZLBF","./adamax_optimizer":"eIt3","./momentum_optimizer":"M8Me","./rmsprop_optimizer":"dOmP","./sgd_optimizer":"GrUb"}],"MvXC":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.train=void 0;var r=require("./optimizers/optimizer_constructors");const t=exports.train=r.OptimizerConstructors;
},{"./optimizers/optimizer_constructors":"efk8"}],"kUit":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.nextFrame=t;const e=(()=>"undefined"!=typeof requestAnimationFrame?requestAnimationFrame:"undefined"!=typeof setImmediate?setImmediate:e=>e())();function t(){return new Promise(t=>e(()=>t()))}
},{}],"tzvg":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.assertParamsConsistent=r,exports.computeOutShape=n;var e=t(require("../util"));function t(e,r){if("function"==typeof WeakMap)var n=new WeakMap,o=new WeakMap;return(t=function(e,t){if(!t&&e&&e.__esModule)return e;var r,s,a={__proto__:null,default:e};if(null===e||"object"!=typeof e&&"function"!=typeof e)return a;if(r=t?o:n){if(r.has(e))return r.get(e);r.set(e,a)}for(const n in e)"default"!==n&&{}.hasOwnProperty.call(e,n)&&((s=(r=Object.defineProperty)&&Object.getOwnPropertyDescriptor(e,n))&&(s.get||s.set)?r(a,n,s):a[n]=e[n]);return a})(e,r)}function r(t,r){const n=t[0].length;t.forEach((t,r)=>{e.assert(t.length===n,()=>`Error in concat${n}D: rank of tensors[${r}] must be the same `+`as the rank of the rest (${n})`)}),e.assert(r>=0&&r<n,()=>`Error in concat${n}D: axis must be between 0 and ${n-1}.`);const o=t[0];t.forEach((t,s)=>{for(let a=0;a<n;a++)e.assert(a===r||t[a]===o[a],()=>`Error in concat${n}D: Shape of tensors[${s}] (${t}) `+`does not match the shape of the rest (${o}) `+`along the non-concatenated axis ${s}.`)})}function n(e,t){const r=e[0].slice();for(let n=1;n<e.length;n++)r[t]+=e[n][t];return r}
},{"../util":"XXxQ"}],"sp88":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0});
},{}],"w99j":[function(require,module,exports) {
"use strict";var e;function t(e,t,n){let r=new Array;if(null==n&&null==t)return r;if(null==t)for(;r.length<e+n.length;)r.push(-1);else r=t.slice();if(null==n)return r;if(e+n.length!==r.length)throw new Error(`rt input.shape and shape=${t} are incompatible: rt input.rank = ${e+n.length}, but shape.rank = ${r.length}`);for(let a=1;a<n.length;++a){const l=n[a],o=r[r.length-n.length+a],s=r[o];if(l>=0)if(s>=0){if(s!==l)throw new Error(`rt input.shape and shape=${t} are incompatible: rt input.shape[${a+e}] = ${l} but shape[${a+e}] = ${s}`)}else r[o]=l}return r}function n(t){const n={FIRST_DIM_SIZE:e.FIRST_DIM_SIZE,VALUE_ROWIDS:e.VALUE_ROWIDS,ROW_LENGTHS:e.ROW_LENGTHS,ROW_SPLITS:e.ROW_SPLITS,ROW_LIMITS:e.ROW_LIMITS,ROW_STARTS:e.ROW_STARTS},r=[];for(const e of t){if(!(e in n))break;r.push(n[e])}return r}function r(t){return 0===t.length?0:t[0]===e.FIRST_DIM_SIZE?t.length-1:t.length}function a(e,t){if(null==e||null==t)return;const n=e.length,r=t.length;if(n>=r)throw new Error(`defaultValue.shape=${e} and ragged tensor flatValues.shape=${t}, are incompatible: defaultValue.rank = ${n} must be less than ragged tensor input flatValues.rank = ${r})`);for(let a=0;a<Math.min(n,r-1);++a){const n=e[a],r=t[a+1];if(n>=0&&r>=0&&1!==n&&n!==r)throw new Error(`defaultValue.shape=${e}, and ragged tensor input flatValues.shape=${t} are incompatible: defaultValue.shape[${a-e.length}] = ${n} but ragged tensor input.flatValues.shape[${a-e.length}] = ${r}`)}}Object.defineProperty(exports,"__esModule",{value:!0}),exports.RowPartitionType=void 0,exports.combineRaggedTensorToTensorShapes=t,exports.getRaggedRank=r,exports.getRowPartitionTypesHelper=n,exports.validateDefaultValueShape=a,function(e){e[e.FIRST_DIM_SIZE=0]="FIRST_DIM_SIZE",e[e.VALUE_ROWIDS=1]="VALUE_ROWIDS",e[e.ROW_LENGTHS=2]="ROW_LENGTHS",e[e.ROW_SPLITS=3]="ROW_SPLITS",e[e.ROW_LIMITS=4]="ROW_LIMITS",e[e.ROW_STARTS=5]="ROW_STARTS"}(e||(exports.RowPartitionType=e={}));
},{}],"HQdi":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.PARALLELIZE_THRESHOLD=void 0,exports.computeOptimalWindowSize=r;var e=require("../util");const t=exports.PARALLELIZE_THRESHOLD=30;function r(r){return r<=t?r:(0,e.nearestDivisor)(r,Math.floor(Math.sqrt(r)))}
},{"../util":"XXxQ"}],"CFTd":[function(require,module,exports) {
"use strict";function e(e,t,r){return[r*("number"==typeof e?e:e[0]),t*("number"==typeof e?e:e[1])]}Object.defineProperty(exports,"__esModule",{value:!0}),exports.getImageCenter=e;
},{}],"XaxW":[function(require,module,exports) {
"use strict";function e(e,t,s,o=!0){let u=[];if(o)(u=u.concat(t.slice(0))).push(e[0]/s),u=u.concat(e.slice(1));else{u=u.concat(e[0]);const s=t.length;for(let o=0;o<s;++o)u=u.concat([e[o+1]/t[o],t[o]]);u=u.concat(e.slice(s+1))}return u}function t(e,t,s=!0){const o=[];if(s){o.push(t);for(let s=t+1;s<e;++s)s<=2*t?(o.push(s),o.push(s-(t+1))):o.push(s)}else{const s=[],u=[];for(let o=1;o<e;++o)o>=2*t+1||o%2==1?u.push(o):s.push(o);o.push(...s),o.push(0),o.push(...u)}return o}function s(e,t,s,o=!0){const u=[];o?u.push(e[0]/s):u.push(e[0]*s);for(let n=1;n<e.length;++n)n<=t.length?o?u.push(t[n-1]*e[n]):u.push(e[n]/t[n-1]):u.push(e[n]);return u}function o(e,t){const s=[0];for(let o=0;o<t;++o)s.push(e[o][0]);return s}function u(e,t,s){const o=e.slice(0,1);for(let u=0;u<s;++u)o.push(e[u+1]-t[u][0]-t[u][1]);return o}Object.defineProperty(exports,"__esModule",{value:!0}),exports.getPermuted=t,exports.getReshaped=e,exports.getReshapedPermuted=s,exports.getSliceBeginCoords=o,exports.getSliceSize=u;
},{}],"mEjB":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.SELU_SCALEALPHA=exports.SELU_SCALE=void 0;const e=exports.SELU_SCALEALPHA=1.7580993408473768,t=exports.SELU_SCALE=1.0507009873554805;
},{}],"uHuP":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.ERF_P=exports.ERF_A5=exports.ERF_A4=exports.ERF_A3=exports.ERF_A2=exports.ERF_A1=void 0;const e=exports.ERF_P=.3275911,t=exports.ERF_A1=.254829592,o=exports.ERF_A2=-.284496736,s=exports.ERF_A3=1.421413741,r=exports.ERF_A4=-1.453152027,p=exports.ERF_A5=1.061405429;
},{}],"C9bx":[function(require,module,exports) {
"use strict";function t(t,e){if(t.length!==e.length)throw new Error("Cannot merge real and imag arrays of different lengths. real:"+`${t.length}, imag: ${e.length}.`);const r=new Float32Array(2*t.length);for(let n=0;n<r.length;n+=2)r[n]=t[n/2],r[n+1]=e[n/2];return r}function e(t){const e=new Float32Array(t.length/2),r=new Float32Array(t.length/2);for(let n=0;n<t.length;n+=2)e[n/2]=t[n],r[n/2]=t[n+1];return{real:e,imag:r}}function r(t){const e=Math.ceil(t.length/4),r=new Float32Array(e),n=new Float32Array(e);for(let o=0;o<t.length;o+=4)r[Math.floor(o/4)]=t[o],n[Math.floor(o/4)]=t[o+1];return{real:r,imag:n}}function n(t){const e=Math.floor(t.length/4),r=new Float32Array(e),n=new Float32Array(e);for(let o=2;o<t.length;o+=4)r[Math.floor(o/4)]=t[o],n[Math.floor(o/4)]=t[o+1];return{real:r,imag:n}}function o(t,e){return{real:t[2*e],imag:t[2*e+1]}}function a(t,e,r,n){t[2*n]=e,t[2*n+1]=r}function l(t,e){const r=new Float32Array(t/2),n=new Float32Array(t/2);for(let o=0;o<Math.ceil(t/2);o++){const a=(e?2:-2)*Math.PI*(o/t);r[o]=Math.cos(a),n[o]=Math.sin(a)}return{real:r,imag:n}}function h(t,e,r){const n=(r?2:-2)*Math.PI*(t/e);return{real:Math.cos(n),imag:Math.sin(n)}}Object.defineProperty(exports,"__esModule",{value:!0}),exports.assignToTypedArray=a,exports.complexWithEvenIndex=r,exports.complexWithOddIndex=n,exports.exponent=h,exports.exponents=l,exports.getComplexWithIndex=o,exports.mergeRealAndImagArrays=t,exports.splitRealAndImagArrays=e;
},{}],"GBT3":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.checkEinsumDimSizes=u,exports.decodeEinsumEquation=s,exports.getEinsumComputePath=l,exports.getEinsumPermutation=i,exports.isIdentityPermutation=p;var t=require("../util_base");const e="->",n=/->/g,o=",",r="...";function s(s,i){const u=((s=s.replace(/\s/g,"")).length-s.replace(n,"").length)/e.length;if(u<1)throw new Error("Equations without an arrow are not supported.");if(u>1)throw new Error(`Equation must contain exactly one arrow ("${e}").`);const[l,p]=s.split(e);(0,t.assert)(-1===l.indexOf(r),()=>`The ellipsis notation ("${r}") is not supported yet.`);const h=l.split(o),c=h.length;if(i!==c)throw new Error(`Expected ${c} input tensors, received ${i}`);if(c>2)throw new Error("Support for more than 2 input tensors is not implemented yet.");const f=[];for(let t=0;t<p.length;++t){const e=p[t];if(!h.some(t=>-1!==t.indexOf(e)))throw new Error(`Output subscripts contain the label ${e} `+"not present in the input subscripts.");-1===f.indexOf(e)&&f.push(e)}for(let t=0;t<l.length;++t){const e=l[t];-1===f.indexOf(e)&&e!==o&&f.push(e)}const a=new Array(h.length);for(let t=0;t<c;++t){if(new Set(h[t].split("")).size!==h[t].length)throw new Error(`Found duplicate axes in input component ${h[t]}. `+"Support for duplicate axes in input is not implemented yet.");a[t]=[];for(let e=0;e<h[t].length;++e)a[t].push(f.indexOf(h[t][e]))}const d=f.length,g=[];for(let t=p.length;t<d;++t)g.push(t);return{allDims:f,summedDims:g,idDims:a}}function i(t,e){let n=new Array(t);n.fill(-1);for(let r=0;r<e.length;++r)n[e[r]]=r;const o=[];for(let r=0;r<t;++r)-1===n[r]&&o.push(r);return{permutationIndices:n=n.filter(t=>-1!==t),expandDims:o}}function u(e,n,o){const r=new Array(e);for(let s=0;s<o.length;++s){const e=o[s].shape;for(let o=0;o<n[s].length;++o)void 0===r[n[s][o]]?r[n[s][o]]=e[o]:(0,t.assert)(r[n[s][o]]===e[o],()=>`Expected dimension ${r[n[s][o]]} at axis ${o} `+`of input shaped ${JSON.stringify(e)}, `+`but got dimension ${e[o]}`)}}function l(t,e){const n=t,o=[];let r=0;0===t.length&&n.push(-1),r=t.length+1;for(let i=0;i<r;++i)o.push([]);const s=[];for(let i=0;i<n.length;++i){const t=h(e,n[i]);for(const e of t)-1===s.indexOf(e)&&(o[i].push(e),s.push(e))}return{path:n,steps:o}}function p(t){return t.every((t,e)=>t===e)}function h(t,e){const n=[];for(let o=0;o<t.length;++o)0!==t[o].length&&-1===t[o].indexOf(e)&&-1!==e||n.push(o);return n}
},{"../util_base":"uID4"}],"YeLn":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.prepareSplitSize=s;var e=require("../util");function s(s,t,r=0){let i=[];if("number"==typeof t)(0,e.assert)(s.shape[r]%t==0,()=>"Number of splits must evenly divide the axis."),i=new Array(t).fill(s.shape[r]/t);else{const a=t.reduce((e,s)=>(-1===s&&(e+=1),e),0);(0,e.assert)(a<=1,()=>"There should be only one negative value in split array.");const n=t.indexOf(-1);if(-1!==n){const e=t.reduce((e,s)=>s>0?e+s:e);t[n]=s.shape[r]-e}(0,e.assert)(s.shape[r]===t.reduce((e,s)=>e+s),()=>"The sum of sizes must match the size of the axis dimension."),i=t}return i}
},{"../util":"XXxQ"}],"xfqG":[function(require,module,exports) {
"use strict";function e(e){return`Received SparseTensor with denseShape[0] = 0 but\n  indices.shape[0] = ${e}`}function s(e,s){return`indices(${e}, 0) is invalid: ${s} < 0`}function i(e,s,i){return`indices(${e}, 0) is invalid: ${s} >= ${i}`}Object.defineProperty(exports,"__esModule",{value:!0}),exports.getSparseFillEmptyRowsIndicesDenseShapeMismatch=e,exports.getSparseFillEmptyRowsNegativeIndexErrorMessage=s,exports.getSparseFillEmptyRowsOutOfRangeIndexErrorMessage=i;
},{}],"H4zZ":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.getSparseReshapeEmptyTensorZeroOutputDimErrorMessage=r,exports.getSparseReshapeInputOutputMismatchErrorMessage=u,exports.getSparseReshapeInputOutputMultipleErrorMessage=p,exports.getSparseReshapeMultipleNegativeOneOutputDimErrorMessage=t,exports.getSparseReshapeNegativeOutputDimErrorMessage=s;var e=require("../../util");function t(e,t){return`only one output dimension may be -1, not both ${e} and ${t}`}function s(e,t){return`size ${e} must be non-negative, not ${t}`}function r(){return"reshape cannot infer the missing input size for an empty tensor unless all specified input sizes are non-zero"}function p(t,s){return`Input to reshape is a SparseTensor with ${(0,e.sizeFromShape)(t)}\n  dense values, but the requested shape requires a multiple of ${(0,e.sizeFromShape)(s)}. inputShape=${t} outputShape= ${s}`}function u(t,s){return`Input to reshape is a tensor with ${(0,e.sizeFromShape)(t)} dense values, but the requested shape has ${(0,e.sizeFromShape)(s)}. inputShape=${t} outputShape=${s}`}
},{"../../util":"XXxQ"}],"QqRG":[function(require,module,exports) {
"use strict";function e(){return"segment ids must be >= 0"}function t(){return"segment ids are not increasing"}function n(e,t){return`Segment id ${e} out of range [0, ${t}), possibly because segmentIds input is not sorted.`}function r(e,t,n){return`Bad: indices[${e}] == ${t} out of range [0, ${n})`}Object.defineProperty(exports,"__esModule",{value:!0}),exports.getSparseSegmentReductionIndicesOutOfRangeErrorMessage=r,exports.getSparseSegmentReductionNegativeSegmentIdsErrorMessage=e,exports.getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage=t,exports.getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage=n;
},{}],"MHAK":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.collectGatherOpShapeInfo=o,exports.computeOutShape=s,exports.segOpComputeOptimalWindowSize=r;var e=require("../util"),t=require("./reduce_util");function r(r,s){let o,h=!1;for(r<=t.PARALLELIZE_THRESHOLD?(o=r,h=!0):o=(0,e.nearestDivisor)(r,Math.floor(Math.sqrt(r)));!h;)o>s||o===r?h=!0:o=(0,e.nearestDivisor)(r,o+1);return o}function s(e,t,r){const s=[],o=e.length;for(let h=0;h<o;h++)h!==t?s.push(e[h]):s.push(r);return s}function o(e,t,r,s){const o=t.shape.length,h=e.shape.length;if(0!==s&&(s<-o||s>o))throw new Error(`Expect batchDims in the range of [-${o}, ${o}], but got ${s}`);if(s<0&&(s+=o),s>h)throw new Error(`batchDims (${s}) must be less than rank(x) (\n    ${h}).`);if(r<s)throw new Error(`batchDims (${s}) must be less than or equal to axis (${r}).`);for(let l=0;l<s;++l)if(e.shape[l]!==t.shape[l])throw new Error(`x.shape[${l}]: ${e.shape[l]} should be equal to indices.shape[${l}]: ${t.shape[l]}.`);const a=e.shape[r],p=[];let i=1,u=1,n=1;for(let l=0;l<s;++l)p.push(e.shape[l]),i*=e.shape[l];for(let l=s;l<r;l++)p.push(e.shape[l]),u*=e.shape[l];for(let l=s;l<o;l++)p.push(t.shape[l]);for(let l=r+1;l<h;l++)p.push(e.shape[l]),n*=e.shape[l];return{batchSize:i,sliceSize:n,outerSize:u,dimSize:a,outputShape:p}}
},{"../util":"XXxQ","./reduce_util":"HQdi"}],"rkoq":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0});var e={fromUint8ToStringArray:!0,fromStringArrayToUint8:!0,slice_util:!0,upcastType:!0,segment_util:!0};exports.fromStringArrayToUint8=q,exports.fromUint8ToStringArray=M,exports.slice_util=exports.segment_util=void 0,Object.defineProperty(exports,"upcastType",{enumerable:!0,get:function(){return l.upcastType}});var t=require("../util"),r=require("../ops/axis_util");Object.keys(r).forEach(function(t){"default"!==t&&"__esModule"!==t&&(Object.prototype.hasOwnProperty.call(e,t)||t in exports&&exports[t]===r[t]||Object.defineProperty(exports,t,{enumerable:!0,get:function(){return r[t]}}))});var o=require("../ops/broadcast_util");Object.keys(o).forEach(function(t){"default"!==t&&"__esModule"!==t&&(Object.prototype.hasOwnProperty.call(e,t)||t in exports&&exports[t]===o[t]||Object.defineProperty(exports,t,{enumerable:!0,get:function(){return o[t]}}))});var n=require("../ops/concat_util");Object.keys(n).forEach(function(t){"default"!==t&&"__esModule"!==t&&(Object.prototype.hasOwnProperty.call(e,t)||t in exports&&exports[t]===n[t]||Object.defineProperty(exports,t,{enumerable:!0,get:function(){return n[t]}}))});var u=require("../ops/conv_util");Object.keys(u).forEach(function(t){"default"!==t&&"__esModule"!==t&&(Object.prototype.hasOwnProperty.call(e,t)||t in exports&&exports[t]===u[t]||Object.defineProperty(exports,t,{enumerable:!0,get:function(){return u[t]}}))});var p=require("../ops/fused_util");Object.keys(p).forEach(function(t){"default"!==t&&"__esModule"!==t&&(Object.prototype.hasOwnProperty.call(e,t)||t in exports&&exports[t]===p[t]||Object.defineProperty(exports,t,{enumerable:!0,get:function(){return p[t]}}))});var s=require("../ops/fused_types");Object.keys(s).forEach(function(t){"default"!==t&&"__esModule"!==t&&(Object.prototype.hasOwnProperty.call(e,t)||t in exports&&exports[t]===s[t]||Object.defineProperty(exports,t,{enumerable:!0,get:function(){return s[t]}}))});var c=require("../ops/ragged_to_dense_util");Object.keys(c).forEach(function(t){"default"!==t&&"__esModule"!==t&&(Object.prototype.hasOwnProperty.call(e,t)||t in exports&&exports[t]===c[t]||Object.defineProperty(exports,t,{enumerable:!0,get:function(){return c[t]}}))});var i=require("../ops/reduce_util");Object.keys(i).forEach(function(t){"default"!==t&&"__esModule"!==t&&(Object.prototype.hasOwnProperty.call(e,t)||t in exports&&exports[t]===i[t]||Object.defineProperty(exports,t,{enumerable:!0,get:function(){return i[t]}}))});var a=k(require("../ops/slice_util"));exports.slice_util=a;var l=require("../types"),f=require("../ops/rotate_util");Object.keys(f).forEach(function(t){"default"!==t&&"__esModule"!==t&&(Object.prototype.hasOwnProperty.call(e,t)||t in exports&&exports[t]===f[t]||Object.defineProperty(exports,t,{enumerable:!0,get:function(){return f[t]}}))});var y=require("../ops/array_ops_util");Object.keys(y).forEach(function(t){"default"!==t&&"__esModule"!==t&&(Object.prototype.hasOwnProperty.call(e,t)||t in exports&&exports[t]===y[t]||Object.defineProperty(exports,t,{enumerable:!0,get:function(){return y[t]}}))});var b=require("../ops/gather_nd_util");Object.keys(b).forEach(function(t){"default"!==t&&"__esModule"!==t&&(Object.prototype.hasOwnProperty.call(e,t)||t in exports&&exports[t]===b[t]||Object.defineProperty(exports,t,{enumerable:!0,get:function(){return b[t]}}))});var d=require("../ops/scatter_nd_util");Object.keys(d).forEach(function(t){"default"!==t&&"__esModule"!==t&&(Object.prototype.hasOwnProperty.call(e,t)||t in exports&&exports[t]===d[t]||Object.defineProperty(exports,t,{enumerable:!0,get:function(){return d[t]}}))});var O=require("../ops/selu_util");Object.keys(O).forEach(function(t){"default"!==t&&"__esModule"!==t&&(Object.prototype.hasOwnProperty.call(e,t)||t in exports&&exports[t]===O[t]||Object.defineProperty(exports,t,{enumerable:!0,get:function(){return O[t]}}))});var _=require("../ops/erf_util");Object.keys(_).forEach(function(t){"default"!==t&&"__esModule"!==t&&(Object.prototype.hasOwnProperty.call(e,t)||t in exports&&exports[t]===_[t]||Object.defineProperty(exports,t,{enumerable:!0,get:function(){return _[t]}}))});var x=require("../log");Object.keys(x).forEach(function(t){"default"!==t&&"__esModule"!==t&&(Object.prototype.hasOwnProperty.call(e,t)||t in exports&&exports[t]===x[t]||Object.defineProperty(exports,t,{enumerable:!0,get:function(){return x[t]}}))});var j=require("../backends/complex_util");Object.keys(j).forEach(function(t){"default"!==t&&"__esModule"!==t&&(Object.prototype.hasOwnProperty.call(e,t)||t in exports&&exports[t]===j[t]||Object.defineProperty(exports,t,{enumerable:!0,get:function(){return j[t]}}))});var h=require("../backends/einsum_util");Object.keys(h).forEach(function(t){"default"!==t&&"__esModule"!==t&&(Object.prototype.hasOwnProperty.call(e,t)||t in exports&&exports[t]===h[t]||Object.defineProperty(exports,t,{enumerable:!0,get:function(){return h[t]}}))});var P=require("../ops/split_util");Object.keys(P).forEach(function(t){"default"!==t&&"__esModule"!==t&&(Object.prototype.hasOwnProperty.call(e,t)||t in exports&&exports[t]===P[t]||Object.defineProperty(exports,t,{enumerable:!0,get:function(){return P[t]}}))});var g=require("../ops/sparse/sparse_fill_empty_rows_util");Object.keys(g).forEach(function(t){"default"!==t&&"__esModule"!==t&&(Object.prototype.hasOwnProperty.call(e,t)||t in exports&&exports[t]===g[t]||Object.defineProperty(exports,t,{enumerable:!0,get:function(){return g[t]}}))});var m=require("../ops/sparse/sparse_reshape_util");Object.keys(m).forEach(function(t){"default"!==t&&"__esModule"!==t&&(Object.prototype.hasOwnProperty.call(e,t)||t in exports&&exports[t]===m[t]||Object.defineProperty(exports,t,{enumerable:!0,get:function(){return m[t]}}))});var v=require("../ops/sparse/sparse_segment_reduction_util");Object.keys(v).forEach(function(t){"default"!==t&&"__esModule"!==t&&(Object.prototype.hasOwnProperty.call(e,t)||t in exports&&exports[t]===v[t]||Object.defineProperty(exports,t,{enumerable:!0,get:function(){return v[t]}}))});var w=k(require("../ops/segment_util"));function k(e,t){if("function"==typeof WeakMap)var r=new WeakMap,o=new WeakMap;return(k=function(e,t){if(!t&&e&&e.__esModule)return e;var n,u,p={__proto__:null,default:e};if(null===e||"object"!=typeof e&&"function"!=typeof e)return p;if(n=t?o:r){if(n.has(e))return n.get(e);n.set(e,p)}for(const r in e)"default"!==r&&{}.hasOwnProperty.call(e,r)&&((u=(n=Object.defineProperty)&&Object.getOwnPropertyDescriptor(e,r))&&(u.get||u.set)?n(p,r,u):p[r]=e[r]);return p})(e,t)}function M(e){try{return e.map(e=>(0,t.decodeString)(e))}catch(r){throw new Error(`Failed to decode encoded string bytes into utf-8, error: ${r}`)}}function q(e){return e.map(e=>(0,t.encodeString)(e))}exports.segment_util=w;
},{"../util":"XXxQ","../ops/axis_util":"mPwf","../ops/broadcast_util":"fD2T","../ops/concat_util":"tzvg","../ops/conv_util":"PhWH","../ops/fused_util":"Pva5","../ops/fused_types":"sp88","../ops/ragged_to_dense_util":"w99j","../ops/reduce_util":"HQdi","../ops/slice_util":"PuAY","../types":"xhfJ","../ops/rotate_util":"CFTd","../ops/array_ops_util":"XaxW","../ops/gather_nd_util":"JyCd","../ops/scatter_nd_util":"keWG","../ops/selu_util":"mEjB","../ops/erf_util":"uHuP","../log":"kMIn","../backends/complex_util":"C9bx","../backends/einsum_util":"GBT3","../ops/split_util":"YeLn","../ops/sparse/sparse_fill_empty_rows_util":"xfqG","../ops/sparse/sparse_reshape_util":"H4zZ","../ops/sparse/sparse_segment_reduction_util":"QqRG","../ops/segment_util":"MHAK"}],"VTG5":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),Object.defineProperty(exports,"nonMaxSuppressionV3Impl",{enumerable:!0,get:function(){return e.nonMaxSuppressionV3Impl}}),Object.defineProperty(exports,"nonMaxSuppressionV4Impl",{enumerable:!0,get:function(){return e.nonMaxSuppressionV4Impl}}),Object.defineProperty(exports,"nonMaxSuppressionV5Impl",{enumerable:!0,get:function(){return e.nonMaxSuppressionV5Impl}}),Object.defineProperty(exports,"whereImpl",{enumerable:!0,get:function(){return r.whereImpl}});var e=require("./non_max_suppression_impl"),r=require("./where_impl");
},{"./non_max_suppression_impl":"awVp","./where_impl":"ebhY"}],"LYBT":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0});var e={io:!0,math:!0,broadcast_util:!0,browser:!0,gather_util:!0,scatter_util:!0,slice_util:!0,serialization:!0,tensor_util:!0,test_util:!0,util:!0,version_core:!0,AdadeltaOptimizer:!0,AdagradOptimizer:!0,AdamOptimizer:!0,AdamaxOptimizer:!0,MomentumOptimizer:!0,Optimizer:!0,OptimizerConstructors:!0,RMSPropOptimizer:!0,SGDOptimizer:!0,Tensor:!0,TensorBuffer:!0,Variable:!0,Rank:!0,sumOutType:!0,upcastType:!0,Reduction:!0,customGrad:!0,grad:!0,grads:!0,valueAndGrad:!0,valueAndGrads:!0,variableGrads:!0,Environment:!0,env:!0,ENV:!0,nextFrame:!0,backend_util:!0,device_util:!0,kernel_impls:!0,KernelBackend:!0,DataStorage:!0};Object.defineProperty(exports,"AdadeltaOptimizer",{enumerable:!0,get:function(){return m.AdadeltaOptimizer}}),Object.defineProperty(exports,"AdagradOptimizer",{enumerable:!0,get:function(){return b.AdagradOptimizer}}),Object.defineProperty(exports,"AdamOptimizer",{enumerable:!0,get:function(){return f.AdamOptimizer}}),Object.defineProperty(exports,"AdamaxOptimizer",{enumerable:!0,get:function(){return O.AdamaxOptimizer}}),Object.defineProperty(exports,"DataStorage",{enumerable:!0,get:function(){return S.DataStorage}}),Object.defineProperty(exports,"ENV",{enumerable:!0,get:function(){return G.ENV}}),Object.defineProperty(exports,"Environment",{enumerable:!0,get:function(){return G.Environment}}),Object.defineProperty(exports,"KernelBackend",{enumerable:!0,get:function(){return S.KernelBackend}}),Object.defineProperty(exports,"MomentumOptimizer",{enumerable:!0,get:function(){return x.MomentumOptimizer}}),Object.defineProperty(exports,"Optimizer",{enumerable:!0,get:function(){return _.Optimizer}}),Object.defineProperty(exports,"OptimizerConstructors",{enumerable:!0,get:function(){return y.OptimizerConstructors}}),Object.defineProperty(exports,"RMSPropOptimizer",{enumerable:!0,get:function(){return g.RMSPropOptimizer}}),Object.defineProperty(exports,"Rank",{enumerable:!0,get:function(){return j.Rank}}),Object.defineProperty(exports,"Reduction",{enumerable:!0,get:function(){return q.Reduction}}),Object.defineProperty(exports,"SGDOptimizer",{enumerable:!0,get:function(){return v.SGDOptimizer}}),Object.defineProperty(exports,"Tensor",{enumerable:!0,get:function(){return z.Tensor}}),Object.defineProperty(exports,"TensorBuffer",{enumerable:!0,get:function(){return z.TensorBuffer}}),Object.defineProperty(exports,"Variable",{enumerable:!0,get:function(){return z.Variable}}),exports.browser=exports.broadcast_util=exports.backend_util=void 0,Object.defineProperty(exports,"customGrad",{enumerable:!0,get:function(){return M.customGrad}}),exports.device_util=void 0,Object.defineProperty(exports,"env",{enumerable:!0,get:function(){return G.env}}),exports.gather_util=void 0,Object.defineProperty(exports,"grad",{enumerable:!0,get:function(){return M.grad}}),Object.defineProperty(exports,"grads",{enumerable:!0,get:function(){return M.grads}}),exports.math=exports.kernel_impls=exports.io=void 0,Object.defineProperty(exports,"nextFrame",{enumerable:!0,get:function(){return w.nextFrame}}),exports.slice_util=exports.serialization=exports.scatter_util=void 0,Object.defineProperty(exports,"sumOutType",{enumerable:!0,get:function(){return j.sumOutType}}),exports.test_util=exports.tensor_util=void 0,Object.defineProperty(exports,"upcastType",{enumerable:!0,get:function(){return j.upcastType}}),exports.util=void 0,Object.defineProperty(exports,"valueAndGrad",{enumerable:!0,get:function(){return M.valueAndGrad}}),Object.defineProperty(exports,"valueAndGrads",{enumerable:!0,get:function(){return M.valueAndGrads}}),Object.defineProperty(exports,"variableGrads",{enumerable:!0,get:function(){return M.variableGrads}}),Object.defineProperty(exports,"version_core",{enumerable:!0,get:function(){return d.version}});var r=B(require("./io/io"));exports.io=r;var t=B(require("./math"));exports.math=t;var i=B(require("./ops/broadcast_util"));exports.broadcast_util=i;var n=B(require("./ops/browser"));exports.browser=n;var o=B(require("./ops/gather_nd_util"));exports.gather_util=o;var u=B(require("./ops/scatter_nd_util"));exports.scatter_util=u;var a=B(require("./ops/slice_util"));exports.slice_util=a;var p=B(require("./serialization"));exports.serialization=p;var s=B(require("./tensor_util"));exports.tensor_util=s;var c=B(require("./test_util"));exports.test_util=c;var l=B(require("./util"));exports.util=l;var d=require("./version"),m=require("./optimizers/adadelta_optimizer"),b=require("./optimizers/adagrad_optimizer"),f=require("./optimizers/adam_optimizer"),O=require("./optimizers/adamax_optimizer"),x=require("./optimizers/momentum_optimizer"),_=require("./optimizers/optimizer"),y=require("./optimizers/optimizer_constructors"),g=require("./optimizers/rmsprop_optimizer"),v=require("./optimizers/sgd_optimizer"),z=require("./tensor"),j=require("./types"),P=require("./ops/ops");Object.keys(P).forEach(function(r){"default"!==r&&"__esModule"!==r&&(Object.prototype.hasOwnProperty.call(e,r)||r in exports&&exports[r]===P[r]||Object.defineProperty(exports,r,{enumerable:!0,get:function(){return P[r]}}))});var q=require("./ops/loss_ops_utils"),k=require("./train");Object.keys(k).forEach(function(r){"default"!==r&&"__esModule"!==r&&(Object.prototype.hasOwnProperty.call(e,r)||r in exports&&exports[r]===k[r]||Object.defineProperty(exports,r,{enumerable:!0,get:function(){return k[r]}}))});var h=require("./globals");Object.keys(h).forEach(function(r){"default"!==r&&"__esModule"!==r&&(Object.prototype.hasOwnProperty.call(e,r)||r in exports&&exports[r]===h[r]||Object.defineProperty(exports,r,{enumerable:!0,get:function(){return h[r]}}))});var A=require("./kernel_registry");Object.keys(A).forEach(function(r){"default"!==r&&"__esModule"!==r&&(Object.prototype.hasOwnProperty.call(e,r)||r in exports&&exports[r]===A[r]||Object.defineProperty(exports,r,{enumerable:!0,get:function(){return A[r]}}))});var M=require("./gradients"),G=require("./environment"),w=require("./browser_util"),T=B(require("./backends/backend_util"));exports.backend_util=T;var E=B(require("./device_util"));exports.device_util=E;var R=B(require("./backends/kernel_impls"));exports.kernel_impls=R;var S=require("./backends/backend"),D=require("./kernel_names");function B(e,r){if("function"==typeof WeakMap)var t=new WeakMap,i=new WeakMap;return(B=function(e,r){if(!r&&e&&e.__esModule)return e;var n,o,u={__proto__:null,default:e};if(null===e||"object"!=typeof e&&"function"!=typeof e)return u;if(n=r?i:t){if(n.has(e))return n.get(e);n.set(e,u)}for(const t in e)"default"!==t&&{}.hasOwnProperty.call(e,t)&&((o=(n=Object.defineProperty)&&Object.getOwnPropertyDescriptor(e,t))&&(o.get||o.set)?n(u,t,o):u[t]=e[t]);return u})(e,r)}Object.keys(D).forEach(function(r){"default"!==r&&"__esModule"!==r&&(Object.prototype.hasOwnProperty.call(e,r)||r in exports&&exports[r]===D[r]||Object.defineProperty(exports,r,{enumerable:!0,get:function(){return D[r]}}))});
},{"./io/io":"wh56","./math":"EwBN","./ops/broadcast_util":"fD2T","./ops/browser":"Wqnn","./ops/gather_nd_util":"JyCd","./ops/scatter_nd_util":"keWG","./ops/slice_util":"PuAY","./serialization":"aVHA","./tensor_util":"wtFc","./test_util":"cFdt","./util":"XXxQ","./version":"KPnh","./optimizers/adadelta_optimizer":"WprY","./optimizers/adagrad_optimizer":"zRFy","./optimizers/adam_optimizer":"ZLBF","./optimizers/adamax_optimizer":"eIt3","./optimizers/momentum_optimizer":"M8Me","./optimizers/optimizer":"zxzS","./optimizers/optimizer_constructors":"efk8","./optimizers/rmsprop_optimizer":"dOmP","./optimizers/sgd_optimizer":"GrUb","./tensor":"eFW4","./types":"xhfJ","./ops/ops":"hfXJ","./ops/loss_ops_utils":"IQtV","./train":"MvXC","./globals":"TsQp","./kernel_registry":"PlaY","./gradients":"VR5t","./environment":"vpgN","./browser_util":"kUit","./backends/backend_util":"rkoq","./device_util":"g3Z1","./backends/kernel_impls":"VTG5","./backends/backend":"Sk1f","./kernel_names":"rJl6"}],"kSBl":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),require("./base_side_effects");var e=require("./optimizers/register_optimizers"),r=require("./base");Object.keys(r).forEach(function(e){"default"!==e&&"__esModule"!==e&&(e in exports&&exports[e]===r[e]||Object.defineProperty(exports,e,{enumerable:!0,get:function(){return r[e]}}))}),(0,e.registerOptimizers)();
},{"./base_side_effects":"viUI","./optimizers/register_optimizers":"evGT","./base":"LYBT"}],"l60O":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.absGradConfig=void 0;var e=require("../kernel_names"),r=require("../ops/cast"),s=require("../ops/mul"),t=require("../ops/step");const o=exports.absGradConfig={kernelName:e.Abs,inputsToSave:["x"],gradFunc:(e,o)=>{const[a]=o;return{x:()=>(0,s.mul)(e,(0,t.step)((0,r.cast)(a,"float32"),-1))}}};
},{"../kernel_names":"rJl6","../ops/cast":"qnzc","../ops/mul":"tBJ4","../ops/step":"vRkD"}],"xXFB":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.acosGradConfig=void 0;var e=require("../kernel_names"),r=require("../ops/cast"),s=require("../ops/div"),o=require("../ops/neg"),a=require("../ops/scalar"),u=require("../ops/sqrt"),t=require("../ops/square"),i=require("../ops/sub");const n=exports.acosGradConfig={kernelName:e.Acos,inputsToSave:["x"],gradFunc:(e,n)=>{const[c]=n;return{x:()=>{const n=(0,t.square)((0,r.cast)(c,"float32")),p=(0,u.sqrt)((0,i.sub)((0,a.scalar)(1),n));return(0,o.neg)((0,s.div)(e,p))}}}};
},{"../kernel_names":"rJl6","../ops/cast":"qnzc","../ops/div":"S2L5","../ops/neg":"i2LN","../ops/scalar":"TiGU","../ops/sqrt":"brr7","../ops/square":"KiGo","../ops/sub":"SgzI"}],"Gnn5":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.acoshGradConfig=void 0;var e=require("../kernel_names"),r=require("../ops/cast"),s=require("../ops/div"),o=require("../ops/sqrt"),t=require("../ops/square"),u=require("../ops/sub");const a=exports.acoshGradConfig={kernelName:e.Acosh,inputsToSave:["x"],gradFunc:(e,a)=>{const[i]=a;return{x:()=>{const a=(0,o.sqrt)((0,u.sub)((0,t.square)((0,r.cast)(i,"float32")),1));return(0,s.div)(e,a)}}}};
},{"../kernel_names":"rJl6","../ops/cast":"qnzc","../ops/div":"S2L5","../ops/sqrt":"brr7","../ops/square":"KiGo","../ops/sub":"SgzI"}],"kVz5":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.addGradConfig=void 0;var e=require("../kernel_names"),t=a(require("../ops/broadcast_util")),r=require("../ops/reshape"),n=require("../ops/sum");function a(e,t){if("function"==typeof WeakMap)var r=new WeakMap,n=new WeakMap;return(a=function(e,t){if(!t&&e&&e.__esModule)return e;var a,s,o={__proto__:null,default:e};if(null===e||"object"!=typeof e&&"function"!=typeof e)return o;if(a=t?n:r){if(a.has(e))return a.get(e);a.set(e,o)}for(const r in e)"default"!==r&&{}.hasOwnProperty.call(e,r)&&((s=(a=Object.defineProperty)&&Object.getOwnPropertyDescriptor(e,r))&&(s.get||s.set)?a(o,r,s):o[r]=e[r]);return o})(e,t)}const s=exports.addGradConfig={kernelName:e.Add,inputsToSave:["a","b"],gradFunc:(e,a)=>{const[s,o]=a,u=t.assertAndGetBroadcastShape(s.shape,o.shape);return{a:()=>{let a=e;const o=t.getReductionAxes(s.shape,u);return o.length>0&&(a=(0,n.sum)(a,o)),(0,r.reshape)(a,s.shape)},b:()=>{let a=e;const s=t.getReductionAxes(o.shape,u);return s.length>0&&(a=(0,n.sum)(a,s)),(0,r.reshape)(a,o.shape)}}}};
},{"../kernel_names":"rJl6","../ops/broadcast_util":"fD2T","../ops/reshape":"F0cm","../ops/sum":"kc8w"}],"muMo":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.addNGradConfig=void 0;var e=require("../kernel_names");const r=exports.addNGradConfig={kernelName:e.AddN,saveAllInputs:!0,gradFunc:(e,r)=>{const d={};return r.forEach((r,n)=>{d[n]=(()=>e.clone())}),d}};
},{"../kernel_names":"rJl6"}],"pZ40":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.argMaxGradConfig=void 0;var e=require("../kernel_names"),r=require("../ops/zeros_like");const o=exports.argMaxGradConfig={kernelName:e.ArgMax,inputsToSave:["x"],gradFunc:(e,o)=>{const[a]=o;return{x:()=>(0,r.zerosLike)(a)}}};
},{"../kernel_names":"rJl6","../ops/zeros_like":"qY0o"}],"vNGj":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.argMinGradConfig=void 0;var e=require("../kernel_names"),r=require("../ops/zeros_like");const n=exports.argMinGradConfig={kernelName:e.ArgMin,inputsToSave:["x"],gradFunc:(e,n)=>{const[o]=n;return{x:()=>(0,r.zerosLike)(o)}}};
},{"../kernel_names":"rJl6","../ops/zeros_like":"qY0o"}],"WLmx":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.asinGradConfig=void 0;var e=require("../kernel_names"),r=require("../ops/cast"),s=require("../ops/div"),a=require("../ops/scalar"),i=require("../ops/sqrt"),o=require("../ops/square"),u=require("../ops/sub");const t=exports.asinGradConfig={kernelName:e.Asin,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>(0,s.div)(e,(0,i.sqrt)((0,u.sub)((0,a.scalar)(1),(0,o.square)((0,r.cast)(n,"float32")))))}}};
},{"../kernel_names":"rJl6","../ops/cast":"qnzc","../ops/div":"S2L5","../ops/scalar":"TiGU","../ops/sqrt":"brr7","../ops/square":"KiGo","../ops/sub":"SgzI"}],"vKHZ":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.asinhGradConfig=void 0;var e=require("../kernel_names"),r=require("../ops/add"),s=require("../ops/cast"),a=require("../ops/div"),o=require("../ops/scalar"),i=require("../ops/sqrt"),t=require("../ops/square");const n=exports.asinhGradConfig={kernelName:e.Asinh,inputsToSave:["x"],gradFunc:(e,n)=>{const[u]=n;return{x:()=>{const n=(0,i.sqrt)((0,r.add)((0,o.scalar)(1),(0,t.square)((0,s.cast)(u,"float32"))));return(0,a.div)(e,n)}}}};
},{"../kernel_names":"rJl6","../ops/add":"N73o","../ops/cast":"qnzc","../ops/div":"S2L5","../ops/scalar":"TiGU","../ops/sqrt":"brr7","../ops/square":"KiGo"}],"LZ38":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.atan2GradConfig=void 0;var e=require("../kernel_names"),r=require("../ops/add"),s=require("../ops/broadcast_util"),a=require("../ops/div"),t=require("../ops/mul"),u=require("../ops/neg"),n=require("../ops/reshape"),o=require("../ops/square"),p=require("../ops/sum");const i=exports.atan2GradConfig={kernelName:e.Atan2,inputsToSave:["a","b"],gradFunc:(e,i)=>{const[d,q]=i,c=(0,s.assertAndGetBroadcastShape)(d.shape,q.shape);return{a:()=>{const u=(0,r.add)((0,o.square)(d),(0,o.square)(q));let i=(0,t.mul)(e,(0,a.div)(q,u));const h=(0,s.getReductionAxes)(d.shape,c);return h.length>0&&(i=(0,p.sum)(i,h)),(0,n.reshape)(i,d.shape)},b:()=>{const i=(0,r.add)((0,o.square)(d),(0,o.square)(q));let h=(0,u.neg)((0,t.mul)(e,(0,a.div)(d,i)));const l=(0,s.getReductionAxes)(q.shape,c);return l.length>0&&(h=(0,p.sum)(h,l)),(0,n.reshape)(h,q.shape)}}}};
},{"../kernel_names":"rJl6","../ops/add":"N73o","../ops/broadcast_util":"fD2T","../ops/div":"S2L5","../ops/mul":"tBJ4","../ops/neg":"i2LN","../ops/reshape":"F0cm","../ops/square":"KiGo","../ops/sum":"kc8w"}],"inFl":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.atanGradConfig=void 0;var e=require("../kernel_names"),r=require("../ops/add"),a=require("../ops/cast"),s=require("../ops/div"),t=require("../ops/square");const o=exports.atanGradConfig={kernelName:e.Atan,inputsToSave:["x"],gradFunc:(e,o)=>{const[n]=o;return{x:()=>(0,s.div)(e,(0,r.add)((0,t.square)((0,a.cast)(n,"float32")),1))}}};
},{"../kernel_names":"rJl6","../ops/add":"N73o","../ops/cast":"qnzc","../ops/div":"S2L5","../ops/square":"KiGo"}],"aOO9":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.atanhGradConfig=void 0;var e=require("../kernel_names"),r=require("../ops/cast"),s=require("../ops/div"),a=require("../ops/square"),o=require("../ops/sub"),t=require("../ops/scalar");const u=exports.atanhGradConfig={kernelName:e.Atanh,inputsToSave:["x"],gradFunc:(e,u)=>{const[i]=u;return{x:()=>(0,s.div)(e,(0,o.sub)((0,t.scalar)(1),(0,a.square)((0,r.cast)(i,"float32"))))}}};
},{"../kernel_names":"rJl6","../ops/cast":"qnzc","../ops/div":"S2L5","../ops/square":"KiGo","../ops/sub":"SgzI","../ops/scalar":"TiGU"}],"cLvB":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.avgPool3dGrad=void 0;var e=require("../engine"),r=require("../kernel_names"),o=require("../tensor_util_env"),a=i(require("../util")),n=require("./conv_util"),t=require("./operation"),s=require("./reshape");function i(e,r){if("function"==typeof WeakMap)var o=new WeakMap,a=new WeakMap;return(i=function(e,r){if(!r&&e&&e.__esModule)return e;var n,t,s={__proto__:null,default:e};if(null===e||"object"!=typeof e&&"function"!=typeof e)return s;if(n=r?a:o){if(n.has(e))return n.get(e);n.set(e,s)}for(const o in e)"default"!==o&&{}.hasOwnProperty.call(e,o)&&((t=(n=Object.defineProperty)&&Object.getOwnPropertyDescriptor(e,o))&&(t.get||t.set)?n(s,o,t):s[o]=e[o]);return s})(e,r)}function u(t,i,u,p,d,l){const c=(0,o.convertToTensor)(t,"dy","avgPool3dGrad"),f=(0,o.convertToTensor)(i,"input","avgPool3dGrad");let h=c,v=f,g=!1;4===f.rank&&(g=!0,h=(0,s.reshape)(c,[1,c.shape[0],c.shape[1],c.shape[2],c.shape[3]]),v=(0,s.reshape)(f,[1,f.shape[0],f.shape[1],f.shape[2],f.shape[3]])),a.assert(5===h.rank,()=>"Error in avgPool3dGrad: dy must be rank 5 but got rank "+`${h.rank}.`),a.assert(5===v.rank,()=>"Error in avgPool3dGrad: input must be rank 5 but got rank "+`${v.rank}.`),(0,n.checkPadOnDimRoundingMode)("avgPool3dGrad",d,l);const k={dy:h,input:v},P={filterSize:u,strides:p,pad:d,dimRoundingMode:l},_=e.ENGINE.runKernel(r.AvgPool3DGrad,k,P);return g?(0,s.reshape)(_,[_.shape[1],_.shape[2],_.shape[3],_.shape[4]]):_}const p=exports.avgPool3dGrad=(0,t.op)({avgPool3dGrad_:u});
},{"../engine":"phT7","../kernel_names":"rJl6","../tensor_util_env":"y4X4","../util":"XXxQ","./conv_util":"PhWH","./operation":"uE86","./reshape":"F0cm"}],"ewFB":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.avgPool3DGradConfig=void 0;var e=require("../kernel_names"),o=require("../ops/avg_pool_3d_grad");const r=exports.avgPool3DGradConfig={kernelName:e.AvgPool3D,inputsToSave:["x"],gradFunc:(e,r,a)=>{const[d]=r,{filterSize:i,strides:n,pad:s,dimRoundingMode:t}=a;return{x:()=>(0,o.avgPool3dGrad)(e,d,i,n,s,t)}}};
},{"../kernel_names":"rJl6","../ops/avg_pool_3d_grad":"cLvB"}],"Hqn0":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.avgPoolGrad=void 0;var e=require("../engine"),r=require("../kernel_names"),a=require("../tensor_util_env"),n=s(require("../util")),t=require("./operation"),o=require("./reshape");function s(e,r){if("function"==typeof WeakMap)var a=new WeakMap,n=new WeakMap;return(s=function(e,r){if(!r&&e&&e.__esModule)return e;var t,o,s={__proto__:null,default:e};if(null===e||"object"!=typeof e&&"function"!=typeof e)return s;if(t=r?n:a){if(t.has(e))return t.get(e);t.set(e,s)}for(const a in e)"default"!==a&&{}.hasOwnProperty.call(e,a)&&((o=(t=Object.defineProperty)&&Object.getOwnPropertyDescriptor(e,a))&&(o.get||o.set)?t(s,a,o):s[a]=e[a]);return s})(e,r)}function u(t,s,u,i,p){const l=(0,a.convertToTensor)(t,"dy","avgPoolGrad"),d=(0,a.convertToTensor)(s,"input","avgPoolGrad");n.assert(d.rank===l.rank,()=>`Rank of input (${d.rank}) does not match rank of dy (${l.rank})`);let f=d,c=l,k=!1;3===d.rank&&(k=!0,f=(0,o.reshape)(d,[1,d.shape[0],d.shape[1],d.shape[2]]),c=(0,o.reshape)(l,[1,l.shape[0],l.shape[1],l.shape[2]])),n.assert(4===c.rank,()=>"Error in avgPoolGrad: dy must be rank 4 but got rank "+`${c.rank}.`),n.assert(4===f.rank,()=>"Error in avgPoolGrad: input must be rank 4 but got rank "+`${f.rank}.`);const h={dy:c,input:f},v={filterSize:u,strides:i,pad:p},g=e.ENGINE.runKernel(r.AvgPoolGrad,h,v);return k?(0,o.reshape)(g,[g.shape[1],g.shape[2],g.shape[3]]):g}const i=exports.avgPoolGrad=(0,t.op)({avgPoolGrad_:u});
},{"../engine":"phT7","../kernel_names":"rJl6","../tensor_util_env":"y4X4","../util":"XXxQ","./operation":"uE86","./reshape":"F0cm"}],"otiv":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.avgPoolGradConfig=void 0;var e=require("../kernel_names"),o=require("../ops/avg_pool_grad");const r=exports.avgPoolGradConfig={kernelName:e.AvgPool,inputsToSave:["x"],gradFunc:(e,r,a)=>{const[s]=r,{filterSize:t,strides:i,pad:n}=a;return{x:()=>(0,o.avgPoolGrad)(e,s,t,i,n)}}};
},{"../kernel_names":"rJl6","../ops/avg_pool_grad":"Hqn0"}],"YeGW":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.batchMatMulGradConfig=void 0;var a=require("../kernel_names"),t=require("../ops/mat_mul");const e=exports.batchMatMulGradConfig={kernelName:a.BatchMatMul,inputsToSave:["a","b"],gradFunc:(a,e,r)=>{const[u,l]=e,{transposeA:s,transposeB:M}=r;return s||M?!s&&M?{a:()=>(0,t.matMul)(a,l,!1,!1),b:()=>(0,t.matMul)(a,u,!0,!1)}:s&&!M?{a:()=>(0,t.matMul)(l,a,!1,!0),b:()=>(0,t.matMul)(u,a,!1,!1)}:{a:()=>(0,t.matMul)(l,a,!0,!0),b:()=>(0,t.matMul)(a,u,!0,!0)}:{a:()=>(0,t.matMul)(a,l,!1,!0),b:()=>(0,t.matMul)(u,a,!0,!1)}}};
},{"../kernel_names":"rJl6","../ops/mat_mul":"zVDr"}],"I5Ws":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.batchToSpaceNDGradConfig=void 0;var e=require("../kernel_names"),r=require("../ops/space_to_batch_nd");const a=exports.batchToSpaceNDGradConfig={kernelName:e.BatchToSpaceND,gradFunc:(e,a,o)=>{const{blockShape:c,crops:t}=o;return{x:()=>(0,r.spaceToBatchND)(e,c,t)}}};
},{"../kernel_names":"rJl6","../ops/space_to_batch_nd":"ERrS"}],"FMr1":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.broadcastToGradConfig=void 0;var e=require("../kernel_names"),r=require("../ops/sum");const o=exports.broadcastToGradConfig={kernelName:e.BroadcastTo,gradFunc:(e,o,t)=>{const a=t,s=a.inputShape,n=a.shape,c=Array.from(n);for(let r=s.length-1;r>=0;r--)if(s[r]===n[r])c[r]=1;else if(1!==s[r])throw new Error(`broadcastTo(): [${s}] cannot be broadcast to [${n}].`);const d=[];for(let r=0;r<c.length;r++)c[r]>1&&d.push(r);return{x:()=>(0,r.sum)(e,d,!0)}}};
},{"../kernel_names":"rJl6","../ops/sum":"kc8w"}],"PDcM":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.castGradConfig=void 0;var e=require("../kernel_names");const r=exports.castGradConfig={kernelName:e.Cast,gradFunc:e=>({x:()=>e.clone()})};
},{"../kernel_names":"rJl6"}],"sxhV":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.ceilGradConfig=void 0;var e=require("../kernel_names"),r=require("../ops/zeros_like");const i=exports.ceilGradConfig={kernelName:e.Ceil,gradFunc:e=>({x:()=>(0,r.zerosLike)(e)})};
},{"../kernel_names":"rJl6","../ops/zeros_like":"qY0o"}],"xMBC":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.clipByValueGradConfig=void 0;var e=require("../kernel_names"),r=require("../ops/greater_equal"),l=require("../ops/less_equal"),a=require("../ops/logical_and"),i=require("../ops/where"),s=require("../ops/zeros_like");const u=exports.clipByValueGradConfig={kernelName:e.ClipByValue,inputsToSave:["x"],gradFunc:(e,u,o)=>{const[p]=u,{clipValueMin:n,clipValueMax:t}=o;return{x:()=>(0,i.where)((0,a.logicalAnd)((0,r.greaterEqual)(p,n),(0,l.lessEqual)(p,t)),e,(0,s.zerosLike)(e))}}};
},{"../kernel_names":"rJl6","../ops/greater_equal":"a6nY","../ops/less_equal":"vnhI","../ops/logical_and":"sHir","../ops/where":"TsgC","../ops/zeros_like":"qY0o"}],"xaWd":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.complexAbsGradConfig=void 0;var e=require("../kernel_names"),r=require("./Abs_grad");const o=exports.complexAbsGradConfig={kernelName:e.ComplexAbs,inputsToSave:["x"],gradFunc:r.absGradConfig.gradFunc};
},{"../kernel_names":"rJl6","./Abs_grad":"l60O"}],"E50Q":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.concatGradConfig=void 0;var e=require("../kernel_names"),r=require("../ops/split"),a=require("../util");const s=exports.concatGradConfig={kernelName:e.Concat,saveAllInputs:!0,gradFunc:(e,s,t)=>{const n=s.map(e=>e.shape),{axis:o}=t,p=(0,a.parseAxisParam)(o,s[0].shape)[0],i=n.map(e=>e[p]);return(0,r.split)(e,i,p).map(e=>()=>e)}};
},{"../kernel_names":"rJl6","../ops/split":"lgPf","../util":"XXxQ"}],"l89e":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.conv2DGradConfig=void 0;var e=require("../kernel_names"),r=require("../ops/conv2d_backprop_filter"),t=require("../ops/conv2d_backprop_input"),n=a(require("../ops/conv_util")),o=a(require("../util"));function a(e,r){if("function"==typeof WeakMap)var t=new WeakMap,n=new WeakMap;return(a=function(e,r){if(!r&&e&&e.__esModule)return e;var o,a,i={__proto__:null,default:e};if(null===e||"object"!=typeof e&&"function"!=typeof e)return i;if(o=r?n:t){if(o.has(e))return o.get(e);o.set(e,i)}for(const t in e)"default"!==t&&{}.hasOwnProperty.call(e,t)&&((a=(o=Object.defineProperty)&&Object.getOwnPropertyDescriptor(e,t))&&(a.get||a.set)?o(i,t,a):i[t]=e[t]);return i})(e,r)}const i=exports.conv2DGradConfig={kernelName:e.Conv2D,inputsToSave:["x","filter"],gradFunc:(e,a,i)=>{const[p,s]=a,{dilations:u,strides:c,pad:l,dataFormat:f}=i;return o.assert(n.tupleValuesAreOne(u),()=>"Error in gradient of conv2D: dilation rates greater than 1 "+`are not yet supported in gradients. Got dilations '${u}'`),{x:()=>(0,t.conv2DBackpropInput)(p.shape,e,s,c,l,f),filter:()=>(0,r.conv2DBackpropFilter)(p,e,s.shape,c,l,f)}}};
},{"../kernel_names":"rJl6","../ops/conv2d_backprop_filter":"LPa2","../ops/conv2d_backprop_input":"sf3S","../ops/conv_util":"PhWH","../util":"XXxQ"}],"ZVOp":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.conv2DBackpropInputGradConfig=void 0;var e=require("../kernel_names"),r=require("../ops/conv2d"),o=require("../ops/conv2d_backprop_filter");const n=exports.conv2DBackpropInputGradConfig={kernelName:e.Conv2DBackpropInput,inputsToSave:["dy","filter"],gradFunc:(e,n,p)=>{const[t,a]=n,{strides:d,pad:c,dataFormat:i,dimRoundingMode:s}=p;return{dy:()=>(0,r.conv2d)(e,a,d,c,i,1,s),filter:()=>(0,o.conv2DBackpropFilter)(e,t,a.shape,d,c,i,s)}}};
},{"../kernel_names":"rJl6","../ops/conv2d":"CVMs","../ops/conv2d_backprop_filter":"LPa2"}],"E4dK":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.conv3DBackpropFilter=void 0;var e=require("../engine"),r=require("../kernel_names"),t=p(require("../util")),n=require("./operation"),a=require("./reshape");function p(e,r){if("function"==typeof WeakMap)var t=new WeakMap,n=new WeakMap;return(p=function(e,r){if(!r&&e&&e.__esModule)return e;var a,p,o={__proto__:null,default:e};if(null===e||"object"!=typeof e&&"function"!=typeof e)return o;if(a=r?n:t){if(a.has(e))return a.get(e);a.set(e,o)}for(const t in e)"default"!==t&&{}.hasOwnProperty.call(e,t)&&((p=(a=Object.defineProperty)&&Object.getOwnPropertyDescriptor(e,t))&&(p.get||p.set)?a(o,t,p):o[t]=e[t]);return o})(e,r)}function o(n,p,o,s,i){let u=n;4===n.rank&&(u=(0,a.reshape)(n,[1,n.shape[0],n.shape[1],n.shape[2],n.shape[3]]));let h=p;4===h.rank&&(h=(0,a.reshape)(p,[1,p.shape[0],p.shape[1],p.shape[2],p.shape[3]])),t.assert(5===u.rank,()=>"Error in conv3dDerFilter: input must be rank 5, but got shape "+`${u.shape}.`),t.assert(5===h.rank,()=>"Error in conv3dDerFilter: dy must be rank 5, but got shape "+`${h.shape}.`),t.assert(5===o.length,()=>"Error in conv3dDerFilter: filterShape must be length 5, but got "+`${o}.`),t.assert(u.shape[4]===o[3],()=>`Error in conv3dDerFilter: depth of input ${u.shape[4]}) must `+`match input depth in filter (${o[3]}.`),t.assert(h.shape[4]===o[4],()=>`Error in conv3dDerFilter: depth of dy (${h.shape[4]}) must `+`match output depth for filter (${o[4]}).`);const l={x:u,dy:h},c={strides:s,pad:i,filterShape:o};return e.ENGINE.runKernel(r.Conv3DBackpropFilterV2,l,c)}const s=exports.conv3DBackpropFilter=(0,n.op)({conv3DBackpropFilter_:o});
},{"../engine":"phT7","../kernel_names":"rJl6","../util":"XXxQ","./operation":"uE86","./reshape":"F0cm"}],"WnBm":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.conv3DGradConfig=void 0;var e=require("../kernel_names"),r=require("../ops/conv3d_backprop_filter"),t=require("../ops/conv3d_backprop_input"),n=require("../ops/conv_util"),o=i(require("../util"));function i(e,r){if("function"==typeof WeakMap)var t=new WeakMap,n=new WeakMap;return(i=function(e,r){if(!r&&e&&e.__esModule)return e;var o,i,a={__proto__:null,default:e};if(null===e||"object"!=typeof e&&"function"!=typeof e)return a;if(o=r?n:t){if(o.has(e))return o.get(e);o.set(e,a)}for(const t in e)"default"!==t&&{}.hasOwnProperty.call(e,t)&&((i=(o=Object.defineProperty)&&Object.getOwnPropertyDescriptor(e,t))&&(i.get||i.set)?o(a,t,i):a[t]=e[t]);return a})(e,r)}const a=exports.conv3DGradConfig={kernelName:e.Conv3D,inputsToSave:["x","filter"],gradFunc:(e,i,a)=>{const{dilations:p,strides:s,pad:u}=a;o.assert((0,n.tupleValuesAreOne)(p),()=>"Error in gradient of conv3D: dilation rates greater than 1 are "+`not yet supported in gradients. Got dilations '${p}'`);const[c,l]=i;return{x:()=>(0,t.conv3DBackpropInput)(c.shape,e,l,s,u),filter:()=>(0,r.conv3DBackpropFilter)(c,e,l.shape,s,u)}}};
},{"../kernel_names":"rJl6","../ops/conv3d_backprop_filter":"E4dK","../ops/conv3d_backprop_input":"uMVO","../ops/conv_util":"PhWH","../util":"XXxQ"}],"TBU6":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.cosGradConfig=void 0;var e=require("../kernel_names"),r=require("../ops/cast"),s=require("../ops/mul"),o=require("../ops/neg"),n=require("../ops/sin");const t=exports.cosGradConfig={kernelName:e.Cos,inputsToSave:["x"],gradFunc:(e,t)=>{const[i]=t;return{x:()=>(0,s.mul)((0,o.neg)((0,n.sin)((0,r.cast)(i,"float32"))),e)}}};
},{"../kernel_names":"rJl6","../ops/cast":"qnzc","../ops/mul":"tBJ4","../ops/neg":"i2LN","../ops/sin":"zDLt"}],"AsLZ":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.coshGradConfig=void 0;var e=require("../kernel_names"),r=require("../ops/cast"),s=require("../ops/mul"),o=require("../ops/sinh");const t=exports.coshGradConfig={kernelName:e.Cosh,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>(0,s.mul)((0,o.sinh)((0,r.cast)(n,"float32")),e)}}};
},{"../kernel_names":"rJl6","../ops/cast":"qnzc","../ops/mul":"tBJ4","../ops/sinh":"DmYY"}],"Pzif":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.cumsumGradConfig=void 0;var e=require("../kernel_names"),r=require("../ops/axis_util"),s=require("../ops/cumsum"),u=require("../ops/transpose");const t=exports.cumsumGradConfig={kernelName:e.Cumsum,inputsToSave:["x"],gradFunc:(e,t,n)=>{const[o]=t,{axis:i,exclusive:a,reverse:m}=n;return{x:()=>{const t=(0,r.getAxesPermutation)([i],o.rank);let n=(0,s.cumsum)(e,i,a,!m);return null!=t&&(n=(0,u.transpose)(n,t)),n}}}};
},{"../kernel_names":"rJl6","../ops/axis_util":"mPwf","../ops/cumsum":"s2nI","../ops/transpose":"JmRY"}],"elgP":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.depthwiseConv2dNativeGradConfig=void 0;var e=require("../kernel_names"),t=o(require("../ops/conv_util")),r=require("../ops/depthwise_conv2d_native_backprop_filter"),n=require("../ops/depthwise_conv2d_native_backprop_input"),i=o(require("../util"));function o(e,t){if("function"==typeof WeakMap)var r=new WeakMap,n=new WeakMap;return(o=function(e,t){if(!t&&e&&e.__esModule)return e;var i,o,a={__proto__:null,default:e};if(null===e||"object"!=typeof e&&"function"!=typeof e)return a;if(i=t?n:r){if(i.has(e))return i.get(e);i.set(e,a)}for(const r in e)"default"!==r&&{}.hasOwnProperty.call(e,r)&&((o=(i=Object.defineProperty)&&Object.getOwnPropertyDescriptor(e,r))&&(o.get||o.set)?i(a,r,o):a[r]=e[r]);return a})(e,t)}const a=exports.depthwiseConv2dNativeGradConfig={kernelName:e.DepthwiseConv2dNative,inputsToSave:["x","filter"],gradFunc:(e,o,a)=>{const{dilations:s,strides:d,pad:p,dimRoundingMode:u}=a,l=null==s?[1,1]:s;i.assert(t.tupleValuesAreOne(l),()=>"Error in gradient of depthwiseConv2dNative: dilation rates greater than 1 are not yet supported. Got dilations "+`'${l}'`);const[f,v]=o;return i.assert(4===f.rank,()=>"Error in gradient of depthwiseConv2dNative: input must be "+`rank 4, but got rank ${f.rank}.`),i.assert(4===v.rank,()=>"Error in gradient of depthwiseConv2dNative: filter must be "+`rank 4, but got rank ${v.rank}.`),i.assert(f.shape[3]===v.shape[2],()=>"Error in gradient of depthwiseConv2d: number of input "+`channels (${f.shape[3]}) must match the inChannels dimension `+`in filter ${v.shape[2]}.`),i.assert(t.eitherStridesOrDilationsAreOne(d,l),()=>"Error in gradient of depthwiseConv2d: Either strides or "+`dilations must be  1. Got strides ${d} and dilations `+`'${l}'.`),t.checkPadOnDimRoundingMode("depthwiseConv2d",p,u),{x:()=>(0,n.depthwiseConv2dNativeBackpropInput)(f.shape,e,v,d,p,l,u),filter:()=>(0,r.depthwiseConv2dNativeBackpropFilter)(f,e,v.shape,d,p,l,u)}}};
},{"../kernel_names":"rJl6","../ops/conv_util":"PhWH","../ops/depthwise_conv2d_native_backprop_filter":"QLaB","../ops/depthwise_conv2d_native_backprop_input":"vLIu","../util":"XXxQ"}],"lvne":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.dilation2dGradConfig=void 0;var e=require("../engine"),r=require("../kernel_names");const i=exports.dilation2dGradConfig={kernelName:r.Dilation2D,inputsToSave:["x","filter"],gradFunc:(i,n,t)=>{const[o,l]=n,a={x:o,filter:l,dy:i},d={x:o,filter:l,dy:i};return{x:()=>e.ENGINE.runKernel(r.Dilation2DBackpropInput,a,t),filter:()=>e.ENGINE.runKernel(r.Dilation2DBackpropFilter,d,t)}}};
},{"../engine":"phT7","../kernel_names":"rJl6"}],"Y3U7":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.eluGradConfig=void 0;var e=require("../engine"),r=require("../kernel_names");const n=exports.eluGradConfig={kernelName:r.Elu,outputsToSave:[!0],gradFunc:(n,u)=>{const[o]=u,t={dy:n,y:o};return{x:()=>e.ENGINE.runKernel(r.EluGrad,t)}}};
},{"../engine":"phT7","../kernel_names":"rJl6"}],"sItU":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.erfGradConfig=void 0;var e=require("../kernel_names"),r=require("../ops/exp"),s=require("../ops/mul"),u=require("../ops/neg"),o=require("../ops/square");const t=exports.erfGradConfig={kernelName:e.Erf,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t,a=(0,s.mul)((0,r.exp)((0,u.neg)((0,o.square)(n))),2/Math.sqrt(Math.PI));return{x:()=>(0,s.mul)(e,a)}}};
},{"../kernel_names":"rJl6","../ops/exp":"xcz4","../ops/mul":"tBJ4","../ops/neg":"i2LN","../ops/square":"KiGo"}],"ICdg":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.expGradConfig=void 0;var e=require("../kernel_names"),r=require("../ops/mul");const o=exports.expGradConfig={kernelName:e.Exp,outputsToSave:[!0],gradFunc:(e,o)=>{const[t]=o;return{x:()=>(0,r.mul)(e,t)}}};
},{"../kernel_names":"rJl6","../ops/mul":"tBJ4"}],"o9E0":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.expandDimsGradConfig=void 0;var e=require("../kernel_names"),r=require("../ops/reshape");const s=exports.expandDimsGradConfig={kernelName:e.ExpandDims,inputsToSave:["input"],gradFunc:(e,s)=>{const[n]=s;return{input:()=>(0,r.reshape)(e,n.shape)}}};
},{"../kernel_names":"rJl6","../ops/reshape":"F0cm"}],"IfK7":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.expm1GradConfig=void 0;var e=require("../kernel_names"),r=require("../ops/exp"),o=require("../ops/mul");const p=exports.expm1GradConfig={kernelName:e.Expm1,inputsToSave:["x"],gradFunc:(e,p)=>{const[s]=p;return{x:()=>(0,o.mul)(e,(0,r.exp)(s))}}};
},{"../kernel_names":"rJl6","../ops/exp":"xcz4","../ops/mul":"tBJ4"}],"Aayl":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.floorGradConfig=void 0;var e=require("../kernel_names"),r=require("../ops/zeros_like");const o=exports.floorGradConfig={kernelName:e.Floor,gradFunc:e=>({x:()=>(0,r.zerosLike)(e)})};
},{"../kernel_names":"rJl6","../ops/zeros_like":"qY0o"}],"VCsx":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.floorDivGradConfig=void 0;var e=require("../kernel_names"),r=require("../ops/broadcast_util"),s=require("../ops/cast"),o=require("../ops/div"),t=require("../ops/mul"),a=require("../ops/neg"),u=require("../ops/reshape"),i=require("../ops/square"),n=require("../ops/sum");const p=exports.floorDivGradConfig={kernelName:e.FloorDiv,inputsToSave:["a","b"],gradFunc:(e,p)=>{const[c,l]=p,d=(0,r.assertAndGetBroadcastShape)(c.shape,l.shape);return{a:()=>{const t=(0,o.div)(e,(0,s.cast)(l,"float32")),a=(0,r.getReductionAxes)(c.shape,d);return a.length>0?(0,u.reshape)((0,n.sum)(t,a),c.shape):t},b:()=>{let p=(0,t.mul)(e,(0,s.cast)(c,"float32"));const h=(0,r.getReductionAxes)(l.shape,d);h.length>0&&(p=(0,u.reshape)((0,n.sum)(p,h),l.shape));const q=(0,i.square)(l);return(0,a.neg)((0,o.div)(p,(0,s.cast)(q,"float32")))}}}};
},{"../kernel_names":"rJl6","../ops/broadcast_util":"fD2T","../ops/cast":"qnzc","../ops/div":"S2L5","../ops/mul":"tBJ4","../ops/neg":"i2LN","../ops/reshape":"F0cm","../ops/square":"KiGo","../ops/sum":"kc8w"}],"w8qP":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.fusedBatchNormGradConfig=void 0;var e=require("../kernel_names"),r=require("../ops/add"),s=require("../ops/broadcast_util"),a=require("../ops/mul"),u=require("../ops/reshape"),l=require("../ops/rsqrt"),p=require("../ops/scalar"),t=require("../ops/sub"),n=require("../ops/sum"),o=require("../ops/tile");const m=exports.fusedBatchNormGradConfig={kernelName:e.FusedBatchNorm,inputsToSave:["x","mean","variance","scale"],gradFunc:(e,m,h)=>{const{varianceEpsilon:i}=h,[c,d,q,f]=m,k=null==f?(0,p.scalar)(1):f,v=(0,s.getReductionAxes)(d.shape,c.shape),x=[];if(1===d.rank){for(let e=0;e<c.shape.length-1;++e)x.push(c.shape[e]);x.push(1)}const g=(0,t.sub)(c,d),b=(0,a.mul)(e,k),N=(0,l.rsqrt)((0,r.add)(q,(0,p.scalar)(i))),_=(0,a.mul)((0,a.mul)((0,a.mul)(N,N),N),(0,p.scalar)(-.5));return{x:()=>1===d.rank?(0,u.reshape)((0,a.mul)((0,a.mul)(e,(0,o.tile)((0,u.reshape)(N,[1,1,1,d.shape[0]]),x)),k),c.shape):(0,u.reshape)((0,a.mul)((0,a.mul)(e,N),k),c.shape),mean:()=>{let e=(0,a.mul)((0,a.mul)(N,(0,p.scalar)(-1)),b);return 1===d.rank&&(e=(0,n.sum)(e,v)),(0,u.reshape)(e,d.shape)},variance:()=>{let e=(0,a.mul)((0,a.mul)(_,g),b);return 1===d.rank&&(e=(0,n.sum)(e,v)),(0,u.reshape)(e,d.shape)},scale:()=>{const r=(0,a.mul)(g,N);let s=(0,a.mul)(e,r);return 1===d.rank&&(s=(0,n.sum)(s,v)),(0,u.reshape)(s,d.shape)},offset:()=>{let r=e;return 1===d.rank&&(r=(0,n.sum)(r,v)),(0,u.reshape)(r,d.shape)}}}};
},{"../kernel_names":"rJl6","../ops/add":"N73o","../ops/broadcast_util":"fD2T","../ops/mul":"tBJ4","../ops/reshape":"F0cm","../ops/rsqrt":"gHPL","../ops/scalar":"TiGU","../ops/sub":"SgzI","../ops/sum":"kc8w","../ops/tile":"DlNu"}],"QY40":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.gatherGradConfig=void 0;var e=require("../kernel_names"),s=require("../ops/axis_util"),r=require("../ops/reshape"),t=require("../ops/stack"),n=require("../ops/transpose"),i=require("../ops/unsorted_segment_sum"),a=require("../util");const o=exports.gatherGradConfig={kernelName:e.GatherV2,inputsToSave:["x","indices"],gradFunc:(e,o,c)=>{const[l,h]=o,{axis:g,batchDims:d}=c,m=(0,a.parseAxisParam)(g,l.shape)[0],x=(e,t,a)=>()=>{const o=e.shape,c=t.size,l=o.slice(0,m),h=l.length,d=o.slice(g,o.length).slice(1),x=d.length,f=u(0,h),q=u(h+1,h+1+x),_=p([l,[c],d]),k=(0,r.reshape)(a,_),v=(0,r.reshape)(t,[c]),G=p([[h],f,q]),P=(0,n.transpose)(k,G);let S=(0,i.unsortedSegmentSum)(P,v,e.shape[m]);const b=(0,s.getUndoAxesPermutation)(G);return S=(0,n.transpose)(S,b)};if(1===d){const s=l.shape[0],r=l.split(s,0);return{x:()=>{return(0,t.stack)(r.map((s,r)=>x(s,h.slice(r,1),e.slice(r,1))())).reshape(l.shape)},indices:()=>h}}return{x:x(l,h,e),indices:()=>h}}};function u(e,s){const r=[];for(let t=e;t<s;++t)r.push(t);return r}function p(e){const s=[];for(let r=0;r<e.length;++r)for(let t=0;t<e[r].length;++t)s.push(e[r][t]);return s}
},{"../kernel_names":"rJl6","../ops/axis_util":"mPwf","../ops/reshape":"F0cm","../ops/stack":"Wzzr","../ops/transpose":"JmRY","../ops/unsorted_segment_sum":"oY1I","../util":"XXxQ"}],"B6Z1":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.greaterEqualGradConfig=void 0;var e=require("../kernel_names"),r=require("../ops/zeros_like");const a=exports.greaterEqualGradConfig={kernelName:e.GreaterEqual,inputsToSave:["a","b"],gradFunc:(e,a)=>{const[o,s]=a;return{a:()=>(0,r.zerosLike)(o),b:()=>(0,r.zerosLike)(s)}}};
},{"../kernel_names":"rJl6","../ops/zeros_like":"qY0o"}],"TvOI":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.identityGradConfig=void 0;var e=require("../kernel_names"),t=require("../ops/cast");const r=exports.identityGradConfig={kernelName:e.Identity,gradFunc:e=>({x:()=>(0,t.cast)(e,"float32")})};
},{"../kernel_names":"rJl6","../ops/cast":"qnzc"}],"teh8":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.isFiniteGradConfig=void 0;var e=require("../kernel_names"),r=require("../ops/zeros_like");const i=exports.isFiniteGradConfig={kernelName:e.IsFinite,gradFunc:e=>({x:()=>(0,r.zerosLike)(e)})};
},{"../kernel_names":"rJl6","../ops/zeros_like":"qY0o"}],"HDmB":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.isInfGradConfig=void 0;var e=require("../kernel_names"),r=require("../ops/zeros_like");const s=exports.isInfGradConfig={kernelName:e.IsInf,gradFunc:e=>({x:()=>(0,r.zerosLike)(e)})};
},{"../kernel_names":"rJl6","../ops/zeros_like":"qY0o"}],"DbSF":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.isNanGradConfig=void 0;var e=require("../kernel_names"),r=require("../ops/zeros_like");const s=exports.isNanGradConfig={kernelName:e.IsNan,gradFunc:e=>({x:()=>(0,r.zerosLike)(e)})};
},{"../kernel_names":"rJl6","../ops/zeros_like":"qY0o"}],"ARg4":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.leakyReluGradConfig=void 0;var e=require("../kernel_names"),r=require("../ops/greater"),a=require("../ops/mul"),u=require("../ops/where");const o=exports.leakyReluGradConfig={kernelName:e.LeakyRelu,inputsToSave:["x"],gradFunc:(e,o,s)=>{const[t]=o,{alpha:l}=s,n=(0,r.greater)(t,0);return{x:()=>(0,u.where)(n,e,(0,a.mul)(e,l))}}};
},{"../kernel_names":"rJl6","../ops/greater":"WT29","../ops/mul":"tBJ4","../ops/where":"TsgC"}],"cTK8":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.log1pGradConfig=void 0;var e=require("../kernel_names"),r=require("../ops/add"),o=require("../ops/div");const d=exports.log1pGradConfig={kernelName:e.Log1p,inputsToSave:["x"],gradFunc:(e,d)=>{const[s]=d;return{x:()=>(0,o.div)(e,(0,r.add)(s,1))}}};
},{"../kernel_names":"rJl6","../ops/add":"N73o","../ops/div":"S2L5"}],"pIev":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.logGradConfig=void 0;var e=require("../kernel_names"),r=require("../ops/cast"),o=require("../ops/div");const s=exports.logGradConfig={kernelName:e.Log,inputsToSave:["x"],gradFunc:(e,s)=>{const[t]=s;return{x:()=>(0,o.div)(e,(0,r.cast)(t,"float32"))}}};
},{"../kernel_names":"rJl6","../ops/cast":"qnzc","../ops/div":"S2L5"}],"Rl4R":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.logSoftmaxGradConfig=void 0;var e=require("../kernel_names"),r=require("../ops/exp"),o=require("../ops/mul"),s=require("../ops/sub"),u=require("../ops/sum");const t=exports.logSoftmaxGradConfig={kernelName:e.LogSoftmax,inputsToSave:[],outputsToSave:[!0],gradFunc:(e,t,a)=>{const[i]=t,{axis:n}=a;return{logits:()=>{const t=(0,r.exp)(i);return(0,s.sub)(e,(0,o.mul)((0,u.sum)(e,n,!0),t))}}}};
},{"../kernel_names":"rJl6","../ops/exp":"xcz4","../ops/mul":"tBJ4","../ops/sub":"SgzI","../ops/sum":"kc8w"}],"aLyC":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.localResponseNormalizationBackprop=void 0;var e=require("../engine"),o=require("../kernel_names"),r=require("./operation");function a(r,a,n,i=5,p=1,s=1,t=.5){const l={x:r,y:a,dy:n},c={depthRadius:i,bias:p,alpha:s,beta:t};return e.ENGINE.runKernel(o.LRNGrad,l,c)}const n=exports.localResponseNormalizationBackprop=(0,r.op)({localResponseNormalizationBackprop_:a});
},{"../engine":"phT7","../kernel_names":"rJl6","./operation":"uE86"}],"A9bk":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.lrnGradConfig=void 0;var e=require("../kernel_names"),r=require("../ops/local_response_normalization_backprop");const o=exports.lrnGradConfig={kernelName:e.LRN,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(e,o,a)=>{const[n,s]=o,{depthRadius:t,bias:p,alpha:i,beta:l}=a;return{x:()=>(0,r.localResponseNormalizationBackprop)(n,s,e,t,p,i,l)}}};
},{"../kernel_names":"rJl6","../ops/local_response_normalization_backprop":"aLyC"}],"pfzo":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.gradForMinAndMax=o;var e=p(require("../ops/axis_util")),r=require("../ops/cast"),t=require("../ops/equal"),a=require("../ops/mul"),n=require("../ops/reshape");function p(e,r){if("function"==typeof WeakMap)var t=new WeakMap,a=new WeakMap;return(p=function(e,r){if(!r&&e&&e.__esModule)return e;var n,p,o={__proto__:null,default:e};if(null===e||"object"!=typeof e&&"function"!=typeof e)return o;if(n=r?a:t){if(n.has(e))return n.get(e);n.set(e,o)}for(const t in e)"default"!==t&&{}.hasOwnProperty.call(e,t)&&((p=(n=Object.defineProperty)&&Object.getOwnPropertyDescriptor(e,t))&&(p.get||p.set)?n(o,t,p):o[t]=e[t]);return o})(e,r)}function o(p,o,u,i){return o.rank<u.rank&&(o=(0,n.reshape)(o,e.expandShapeToKeepDim(o.shape,i))),p.rank<u.rank&&(p=(0,n.reshape)(p,e.expandShapeToKeepDim(p.shape,i))),{x:()=>{return(0,a.mul)(p,(0,r.cast)((0,t.equal)(u,o),p.dtype))}}}
},{"../ops/axis_util":"mPwf","../ops/cast":"qnzc","../ops/equal":"haNF","../ops/mul":"tBJ4","../ops/reshape":"F0cm"}],"zegh":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.maxGradConfig=void 0;var e=require("../kernel_names"),r=n(require("../util")),t=require("./min_max_grad_util");function n(e,r){if("function"==typeof WeakMap)var t=new WeakMap,a=new WeakMap;return(n=function(e,r){if(!r&&e&&e.__esModule)return e;var n,o,i={__proto__:null,default:e};if(null===e||"object"!=typeof e&&"function"!=typeof e)return i;if(n=r?a:t){if(n.has(e))return n.get(e);n.set(e,i)}for(const t in e)"default"!==t&&{}.hasOwnProperty.call(e,t)&&((o=(n=Object.defineProperty)&&Object.getOwnPropertyDescriptor(e,t))&&(o.get||o.set)?n(i,t,o):i[t]=e[t]);return i})(e,r)}const a=exports.maxGradConfig={kernelName:e.Max,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(e,n,a)=>{const o=a,{reductionIndices:i}=o,u=n[0],s=n[1],f=r.parseAxisParam(i,u.shape),p=(0,t.gradForMinAndMax)(e,s,u,f);return{x:()=>p.x()}}};
},{"../kernel_names":"rJl6","../util":"XXxQ","./min_max_grad_util":"pfzo"}],"PGKc":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.maximumGradConfig=void 0;var e=require("../kernel_names"),r=require("../ops/cast"),a=require("../ops/greater_equal"),s=require("../ops/less"),u=require("../ops/mul");const t=exports.maximumGradConfig={kernelName:e.Maximum,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[o,i]=t;return{a:()=>(0,u.mul)(e,(0,r.cast)((0,a.greaterEqual)(o,i),"float32")),b:()=>(0,u.mul)(e,(0,r.cast)((0,s.less)(o,i),"float32"))}}};
},{"../kernel_names":"rJl6","../ops/cast":"qnzc","../ops/greater_equal":"a6nY","../ops/less":"onA7","../ops/mul":"tBJ4"}],"TtY3":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.maxPool3dGrad=void 0;var e=require("../engine"),r=require("../kernel_names"),a=require("../tensor_util_env"),o=u(require("../util")),t=require("./conv_util"),n=require("./operation"),s=require("./reshape");function u(e,r){if("function"==typeof WeakMap)var a=new WeakMap,o=new WeakMap;return(u=function(e,r){if(!r&&e&&e.__esModule)return e;var t,n,s={__proto__:null,default:e};if(null===e||"object"!=typeof e&&"function"!=typeof e)return s;if(t=r?o:a){if(t.has(e))return t.get(e);t.set(e,s)}for(const a in e)"default"!==a&&{}.hasOwnProperty.call(e,a)&&((n=(t=Object.defineProperty)&&Object.getOwnPropertyDescriptor(e,a))&&(n.get||n.set)?t(s,a,n):s[a]=e[a]);return s})(e,r)}function p(n,u,p,i,d,l,h){const c=(0,a.convertToTensor)(n,"dy","maxPool3dGrad"),f=(0,a.convertToTensor)(u,"input","maxPool3dGrad"),k=(0,a.convertToTensor)(p,"output","maxPool3dGrad");let m=c,P=f,x=k,_=!1;4===f.rank&&(_=!0,m=(0,s.reshape)(c,[1,c.shape[0],c.shape[1],c.shape[2],c.shape[3]]),P=(0,s.reshape)(f,[1,f.shape[0],f.shape[1],f.shape[2],f.shape[3]]),x=(0,s.reshape)(k,[1,k.shape[0],k.shape[1],k.shape[2],k.shape[3]])),o.assert(5===m.rank,()=>"Error in maxPool3dGrad: dy must be rank 5 but got rank "+`${m.rank}.`),o.assert(5===P.rank,()=>"Error in maxPool3dGrad: input must be rank 5 but got rank "+`${P.rank}.`),o.assert(5===x.rank,()=>"Error in maxPool3dGrad: output must be rank 5 but got rank "+`${x.rank}.`),(0,t.checkPadOnDimRoundingMode)("maxPool3dGrad",l,h);const G={dy:m,input:P,output:x},b={filterSize:i,strides:d,pad:l,dimRoundingMode:h},v=e.ENGINE.runKernel(r.MaxPool3DGrad,G,b);return _?(0,s.reshape)(v,[v.shape[1],v.shape[2],v.shape[3],v.shape[4]]):v}const i=exports.maxPool3dGrad=(0,n.op)({maxPool3dGrad_:p});
},{"../engine":"phT7","../kernel_names":"rJl6","../tensor_util_env":"y4X4","../util":"XXxQ","./conv_util":"PhWH","./operation":"uE86","./reshape":"F0cm"}],"gj4V":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.maxPool3DGradConfig=void 0;var e=require("../kernel_names"),o=require("../ops/max_pool_3d_grad");const r=exports.maxPool3DGradConfig={kernelName:e.MaxPool3D,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(e,r,a)=>{const[d,t]=r,{filterSize:s,strides:i,pad:n,dimRoundingMode:u}=a;return{x:()=>(0,o.maxPool3dGrad)(e,d,t,s,i,n,u)}}};
},{"../kernel_names":"rJl6","../ops/max_pool_3d_grad":"TtY3"}],"tT1k":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.maxPoolGrad=void 0;var r=require("../engine"),e=require("../kernel_names"),o=require("../tensor_util_env"),n=u(require("../util")),t=u(require("./conv_util")),a=require("./operation");function u(r,e){if("function"==typeof WeakMap)var o=new WeakMap,n=new WeakMap;return(u=function(r,e){if(!e&&r&&r.__esModule)return r;var t,a,u={__proto__:null,default:r};if(null===r||"object"!=typeof r&&"function"!=typeof r)return u;if(t=e?n:o){if(t.has(r))return t.get(r);t.set(r,u)}for(const o in r)"default"!==o&&{}.hasOwnProperty.call(r,o)&&((a=(t=Object.defineProperty)&&Object.getOwnPropertyDescriptor(r,o))&&(a.get||a.set)?t(u,o,a):u[o]=r[o]);return u})(r,e)}function i(a,u,i,s,d,l,p){const c=(0,o.convertToTensor)(a,"dy","maxPoolGrad"),f=(0,o.convertToTensor)(u,"input","maxPoolGrad"),k=(0,o.convertToTensor)(i,"output","maxPoolGrad");n.assert(f.rank===c.rank,()=>`Rank of input (${f.rank}) does not match rank of dy `+`(${c.rank})`),n.assert(4===c.rank,()=>"Error in maxPoolGrad: dy must be rank 4 but got rank "+`${c.rank}.`),n.assert(4===f.rank,()=>"Error in maxPoolGrad: input must be rank 4 but got rank "+`${f.rank}.`),t.checkPadOnDimRoundingMode("maxPoolGrad",l,p);const m={dy:c,input:f,output:k},P={filterSize:s,strides:d,pad:l,dimRoundingMode:p};return r.ENGINE.runKernel(e.MaxPoolGrad,m,P)}const s=exports.maxPoolGrad=(0,a.op)({maxPoolGrad_:i});
},{"../engine":"phT7","../kernel_names":"rJl6","../tensor_util_env":"y4X4","../util":"XXxQ","./conv_util":"PhWH","./operation":"uE86"}],"tfaS":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.maxPoolGradConfig=void 0;var e=require("../kernel_names"),o=require("../ops/max_pool_grad");const r=exports.maxPoolGradConfig={kernelName:e.MaxPool,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(e,r,a)=>{const[t,s]=r,{filterSize:i,strides:n,pad:d}=a;return{x:()=>(0,o.maxPoolGrad)(e,t,s,i,n,d)}}};
},{"../kernel_names":"rJl6","../ops/max_pool_grad":"tT1k"}],"YKB4":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.meanGradConfig=void 0;var e=require("../kernel_names"),r=require("../ops/axis_util"),t=require("../ops/div"),n=require("../ops/mul"),o=require("../ops/ones"),a=require("../ops/reshape"),s=u(require("../util"));function u(e,r){if("function"==typeof WeakMap)var t=new WeakMap,n=new WeakMap;return(u=function(e,r){if(!r&&e&&e.__esModule)return e;var o,a,s={__proto__:null,default:e};if(null===e||"object"!=typeof e&&"function"!=typeof e)return s;if(o=r?n:t){if(o.has(e))return o.get(e);o.set(e,s)}for(const t in e)"default"!==t&&{}.hasOwnProperty.call(e,t)&&((a=(o=Object.defineProperty)&&Object.getOwnPropertyDescriptor(e,t))&&(a.get||a.set)?o(s,t,a):s[t]=e[t]);return s})(e,r)}const i=exports.meanGradConfig={kernelName:e.Mean,inputsToSave:["x"],gradFunc:(e,u,i)=>{const[p]=u,{axis:c}=i,f=s.parseAxisParam(c,p.shape),l=(0,r.computeOutAndReduceShapes)(p.shape,f)[1],d=s.sizeFromShape(l);return{x:()=>{const r=p.shape.slice();f.forEach(e=>{r[e]=1});const s=(0,a.reshape)(e,r);return(0,t.div)((0,n.mul)(s,(0,o.ones)(p.shape,"float32")),d)}}}};
},{"../kernel_names":"rJl6","../ops/axis_util":"mPwf","../ops/div":"S2L5","../ops/mul":"tBJ4","../ops/ones":"iY3A","../ops/reshape":"F0cm","../util":"XXxQ"}],"ek8n":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.minGradConfig=void 0;var e=require("../kernel_names"),r=n(require("../util")),t=require("./min_max_grad_util");function n(e,r){if("function"==typeof WeakMap)var t=new WeakMap,a=new WeakMap;return(n=function(e,r){if(!r&&e&&e.__esModule)return e;var n,o,i={__proto__:null,default:e};if(null===e||"object"!=typeof e&&"function"!=typeof e)return i;if(n=r?a:t){if(n.has(e))return n.get(e);n.set(e,i)}for(const t in e)"default"!==t&&{}.hasOwnProperty.call(e,t)&&((o=(n=Object.defineProperty)&&Object.getOwnPropertyDescriptor(e,t))&&(o.get||o.set)?n(i,t,o):i[t]=e[t]);return i})(e,r)}const a=exports.minGradConfig={kernelName:e.Min,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(e,n,a)=>{const o=a,{axis:i}=o,[u,s]=n,f=r.parseAxisParam(i,u.shape),p=(0,t.gradForMinAndMax)(e,s,u,f);return{x:()=>p.x()}}};
},{"../kernel_names":"rJl6","../util":"XXxQ","./min_max_grad_util":"pfzo"}],"w180":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.minimumGradConfig=void 0;var e=require("../kernel_names"),r=require("../ops/cast"),s=require("../ops/greater"),a=require("../ops/less_equal"),u=require("../ops/mul");const t=exports.minimumGradConfig={kernelName:e.Minimum,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[i,o]=t;return{a:()=>(0,u.mul)(e,(0,r.cast)((0,a.lessEqual)(i,o),"float32")),b:()=>(0,u.mul)(e,(0,r.cast)((0,s.greater)(i,o),"float32"))}}};
},{"../kernel_names":"rJl6","../ops/cast":"qnzc","../ops/greater":"WT29","../ops/less_equal":"vnhI","../ops/mul":"tBJ4"}],"DOfc":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.mirrorPadGradConfig=void 0;var r=require("../kernel_names"),e=require("../ops/slice");const o=exports.mirrorPadGradConfig={kernelName:r.MirrorPad,inputsToSave:["x"],gradFunc:(r,o,s)=>{const a=o[0],{paddings:i}=s,n=i.map(r=>r[0]);return{x:()=>(0,e.slice)(r,n,a.shape)}}};
},{"../kernel_names":"rJl6","../ops/slice":"wIos"}],"zPHU":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.modGradConfig=void 0;var e=require("../kernel_names"),r=require("../ops/broadcast_util"),s=require("../ops/div"),o=require("../ops/floor"),t=require("../ops/mul"),a=require("../ops/neg"),u=require("../ops/reshape"),n=require("../ops/sum");const p=exports.modGradConfig={kernelName:e.Mod,inputsToSave:["a","b"],gradFunc:(e,p)=>{const[i,d]=p,h=(0,r.assertAndGetBroadcastShape)(i.shape,d.shape);return{a:()=>{const s=(0,r.getReductionAxes)(i.shape,h);return s.length>0?(0,u.reshape)((0,n.sum)(e,s),i.shape):e},b:()=>{const p=(0,t.mul)(e,(0,a.neg)((0,o.floor)((0,s.div)(i,d)))),c=(0,r.getReductionAxes)(d.shape,h);return c.length>0?(0,u.reshape)((0,n.sum)(p,c),d.shape):p}}}};
},{"../kernel_names":"rJl6","../ops/broadcast_util":"fD2T","../ops/div":"S2L5","../ops/floor":"EeTS","../ops/mul":"tBJ4","../ops/neg":"i2LN","../ops/reshape":"F0cm","../ops/sum":"kc8w"}],"s8ip":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.multiplyGradConfig=void 0;var e=require("../kernel_names"),s=require("../ops/broadcast_util"),r=require("../ops/cast"),t=require("../ops/mul"),a=require("../ops/reshape"),u=require("../ops/sum");const o=exports.multiplyGradConfig={kernelName:e.Multiply,inputsToSave:["a","b"],gradFunc:(e,o)=>{const[p,n]=o,i=(0,s.assertAndGetBroadcastShape)(p.shape,n.shape);return{a:()=>{const o=(0,t.mul)(e,(0,r.cast)(n,"float32")),l=(0,s.getReductionAxes)(p.shape,i);return l.length>0?(0,a.reshape)((0,u.sum)(o,l),p.shape):o},b:()=>{const o=(0,t.mul)(e,(0,r.cast)(p,"float32")),l=(0,s.getReductionAxes)(n.shape,i);return l.length>0?(0,a.reshape)((0,u.sum)(o,l),n.shape):o}}}};
},{"../kernel_names":"rJl6","../ops/broadcast_util":"fD2T","../ops/cast":"qnzc","../ops/mul":"tBJ4","../ops/reshape":"F0cm","../ops/sum":"kc8w"}],"eOcq":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.negGradConfig=void 0;var e=require("../kernel_names"),r=require("../ops/neg");const n=exports.negGradConfig={kernelName:e.Neg,gradFunc:e=>({x:()=>(0,r.neg)(e)})};
},{"../kernel_names":"rJl6","../ops/neg":"i2LN"}],"tvM0":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.oneHotGradConfig=void 0;var e=require("../kernel_names"),o=require("../ops/zeros");const r=exports.oneHotGradConfig={kernelName:e.OneHot,inputsToSave:["indices"],gradFunc:(e,r)=>{const n=r[0];return{indices:()=>(0,o.zeros)(n.shape,"float32")}}};
},{"../kernel_names":"rJl6","../ops/zeros":"AsfN"}],"suTr":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.onesLikeGradConfig=void 0;var e=require("../kernel_names"),r=require("../ops/zeros_like");const o=exports.onesLikeGradConfig={kernelName:e.OnesLike,gradFunc:e=>({x:()=>(0,r.zerosLike)(e)})};
},{"../kernel_names":"rJl6","../ops/zeros_like":"qY0o"}],"Gc7m":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.packGradConfig=void 0;var e=require("../kernel_names"),r=require("../ops/unstack");const a=exports.packGradConfig={kernelName:e.Pack,saveAllInputs:!0,gradFunc:(e,a,s)=>{const{axis:n}=s;return(0,r.unstack)(e,n).map(e=>()=>e)}};
},{"../kernel_names":"rJl6","../ops/unstack":"Smo9"}],"iZYn":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.padV2GradConfig=void 0;var e=require("../kernel_names"),r=require("../ops/slice");const s=exports.padV2GradConfig={kernelName:e.PadV2,inputsToSave:["x"],gradFunc:(e,s,a)=>{const n=s[0],{paddings:o}=a,d=o.map(e=>e[0]);return{x:()=>(0,r.slice)(e,d,n.shape)}}};
},{"../kernel_names":"rJl6","../ops/slice":"wIos"}],"J9Vg":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.powGradConfig=void 0;var e=require("../kernel_names"),r=h(require("../ops/broadcast_util")),t=require("../ops/cast"),o=require("../ops/greater"),s=require("../ops/log"),u=require("../ops/mul"),a=require("../ops/pow"),n=require("../ops/reshape"),p=require("../ops/scalar"),i=require("../ops/sub"),l=require("../ops/sum"),c=require("../ops/where"),f=require("../ops/zeros_like");function h(e,r){if("function"==typeof WeakMap)var t=new WeakMap,o=new WeakMap;return(h=function(e,r){if(!r&&e&&e.__esModule)return e;var s,u,a={__proto__:null,default:e};if(null===e||"object"!=typeof e&&"function"!=typeof e)return a;if(s=r?o:t){if(s.has(e))return s.get(e);s.set(e,a)}for(const t in e)"default"!==t&&{}.hasOwnProperty.call(e,t)&&((u=(s=Object.defineProperty)&&Object.getOwnPropertyDescriptor(e,t))&&(u.get||u.set)?s(a,t,u):a[t]=e[t]);return a})(e,r)}const d=exports.powGradConfig={kernelName:e.Pow,inputsToSave:["a","b"],outputsToSave:[!0],gradFunc:(e,h)=>{const[d,g,q]=h,w=d,_=g,m=r.assertAndGetBroadcastShape(w.shape,_.shape);return{a:()=>{const o=(0,t.cast)(_,"float32");let s=(0,u.mul)(e,(0,u.mul)(o,(0,a.pow)(w,(0,i.sub)(o,(0,p.scalar)(1)))));const c=r.getReductionAxes(w.shape,m);return c.length>0&&(s=(0,l.sum)(s,c)),(0,n.reshape)(s,w.shape)},b:()=>{const t=(0,o.greater)(w,0),a=(0,c.where)(t,(0,s.log)(w),(0,f.zerosLike)(w));let p=(0,u.mul)(e,(0,u.mul)(q,a));const i=r.getReductionAxes(_.shape,m);return i.length>0&&(p=(0,l.sum)(p,i)),(0,n.reshape)(p,_.shape)}}}};
},{"../kernel_names":"rJl6","../ops/broadcast_util":"fD2T","../ops/cast":"qnzc","../ops/greater":"WT29","../ops/log":"f3PH","../ops/mul":"tBJ4","../ops/pow":"o2Kl","../ops/reshape":"F0cm","../ops/scalar":"TiGU","../ops/sub":"SgzI","../ops/sum":"kc8w","../ops/where":"TsgC","../ops/zeros_like":"qY0o"}],"lOIP":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.preluGradConfig=void 0;var e=require("../kernel_names"),r=require("../ops/broadcast_util"),s=require("../ops/greater"),u=require("../ops/mul"),o=require("../ops/reshape"),a=require("../ops/sum"),p=require("../ops/where"),t=require("../ops/zeros_like");const i=exports.preluGradConfig={kernelName:e.Prelu,inputsToSave:["x","alpha"],gradFunc:(e,i)=>{const[l,n]=i,h=(0,s.greater)(l,0);return{x:()=>(0,p.where)(h,e,(0,u.mul)(e,n)),alpha:()=>{let s=(0,p.where)(h,(0,t.zerosLike)(e),(0,u.mul)(e,l));const i=(0,r.getReductionAxes)(n.shape,e.shape);return i.length>0&&(s=(0,a.sum)(s,i)),(0,o.reshape)(s,n.shape)}}}};
},{"../kernel_names":"rJl6","../ops/broadcast_util":"fD2T","../ops/greater":"WT29","../ops/mul":"tBJ4","../ops/reshape":"F0cm","../ops/sum":"kc8w","../ops/where":"TsgC","../ops/zeros_like":"qY0o"}],"u4Ba":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.prodGradConfig=void 0;var e=require("../base"),r=require("../kernel_names"),s=require("../ops/cumprod"),t=require("../ops/mul"),n=require("../ops/reshape"),o=require("../ops/transpose");function u(e,r,o){const u=e.shape.slice();u[o]=1;const p=(0,n.reshape)(r,u),a=(0,s.cumprod)(e,o,!0,!1),l=(0,s.cumprod)(e,o,!0,!0),i=(0,t.mul)(a,l);return(0,t.mul)(p,i)}function p(r,s,t){const n=r.shape.length,p=n-t.length,a=e.backend_util.getAxesPermutation(t,n);let l=r;null!=a&&(l=(0,o.transpose)(r,a));const i=l.shape.slice(),c=i.splice(n-t.length,t.length).reduce((e,r)=>e*r,1);i.push(c);let d=u(l.reshape(i),s,p);if(d=d.reshape(l.shape),null!=a){const r=e.backend_util.getUndoAxesPermutation(a);d=(0,o.transpose)(d,r)}return d}const a=exports.prodGradConfig={kernelName:r.Prod,inputsToSave:["x"],gradFunc:(e,r,s)=>{const[t]=r,{axis:n}=s;let o=[];return o=null==n?t.shape.map((e,r)=>r):"number"==typeof n?[n]:n,{x:()=>p(t,e,o)}}};
},{"../base":"LYBT","../kernel_names":"rJl6","../ops/cumprod":"CZnL","../ops/mul":"tBJ4","../ops/reshape":"F0cm","../ops/transpose":"JmRY"}],"oyvb":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.divGradConfig=void 0;var e=require("../kernel_names"),r=p(require("../ops/broadcast_util")),t=require("../ops/cast"),s=require("../ops/div"),a=require("../ops/mul"),o=require("../ops/neg"),n=require("../ops/reshape"),u=require("../ops/square"),i=require("../ops/sum");function p(e,r){if("function"==typeof WeakMap)var t=new WeakMap,s=new WeakMap;return(p=function(e,r){if(!r&&e&&e.__esModule)return e;var a,o,n={__proto__:null,default:e};if(null===e||"object"!=typeof e&&"function"!=typeof e)return n;if(a=r?s:t){if(a.has(e))return a.get(e);a.set(e,n)}for(const t in e)"default"!==t&&{}.hasOwnProperty.call(e,t)&&((o=(a=Object.defineProperty)&&Object.getOwnPropertyDescriptor(e,t))&&(o.get||o.set)?a(n,t,o):n[t]=e[t]);return n})(e,r)}const c=exports.divGradConfig={kernelName:e.RealDiv,inputsToSave:["a","b"],gradFunc:(e,p)=>{const[c,l]=p,f=r.assertAndGetBroadcastShape(c.shape,l.shape);return{a:()=>{const a=(0,s.div)(e,(0,t.cast)(l,"float32")),o=r.getReductionAxes(c.shape,f);return o.length>0?(0,n.reshape)((0,i.sum)(a,o),c.shape):a},b:()=>{let p=(0,a.mul)(e,(0,t.cast)(c,"float32"));const d=r.getReductionAxes(l.shape,f);d.length>0&&(p=(0,n.reshape)((0,i.sum)(p,d),l.shape));const h=(0,u.square)(l);return(0,o.neg)((0,s.div)(p,(0,t.cast)(h,"float32")))}}}};
},{"../kernel_names":"rJl6","../ops/broadcast_util":"fD2T","../ops/cast":"qnzc","../ops/div":"S2L5","../ops/mul":"tBJ4","../ops/neg":"i2LN","../ops/reshape":"F0cm","../ops/square":"KiGo","../ops/sum":"kc8w"}],"mcH8":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.reciprocalGradConfig=void 0;var e=require("../kernel_names"),r=require("../ops/div"),o=require("../ops/neg"),i=require("../ops/square");const s=exports.reciprocalGradConfig={kernelName:e.Reciprocal,inputsToSave:["x"],gradFunc:(e,s)=>{const[a]=s;return{x:()=>(0,r.div)(e,(0,o.neg)((0,i.square)(a)))}}};
},{"../kernel_names":"rJl6","../ops/div":"S2L5","../ops/neg":"i2LN","../ops/square":"KiGo"}],"Ca6G":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.relu6GradConfig=void 0;var e=require("../kernel_names"),r=require("../ops/cast"),s=require("../ops/less_equal"),u=require("../ops/mul"),o=require("../ops/step");const t=exports.relu6GradConfig={kernelName:e.Relu6,inputsToSave:["x"],gradFunc:(e,t)=>{const[l]=t,a=(0,u.mul)((0,s.lessEqual)(l,6),(0,o.step)(l));return{x:()=>(0,u.mul)(e,(0,r.cast)(a,"float32"))}}};
},{"../kernel_names":"rJl6","../ops/cast":"qnzc","../ops/less_equal":"vnhI","../ops/mul":"tBJ4","../ops/step":"vRkD"}],"CkLH":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.reluGradConfig=void 0;var e=require("../kernel_names"),r=require("../ops/cast"),s=require("../ops/mul"),t=require("../ops/step");const o=exports.reluGradConfig={kernelName:e.Relu,inputsToSave:["x"],gradFunc:(e,o)=>{const[u]=o;return{x:()=>(0,s.mul)(e,(0,r.cast)((0,t.step)(u),"float32"))}}};
},{"../kernel_names":"rJl6","../ops/cast":"qnzc","../ops/mul":"tBJ4","../ops/step":"vRkD"}],"eApb":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.reshapeGradConfig=void 0;var e=require("../kernel_names"),r=require("../ops/reshape");const s=exports.reshapeGradConfig={kernelName:e.Reshape,inputsToSave:["x"],gradFunc:(e,s)=>{const[a]=s;return{x:()=>(0,r.reshape)(e,a.shape)}}};
},{"../kernel_names":"rJl6","../ops/reshape":"F0cm"}],"bpQe":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.resizeBilinearGradConfig=void 0;var e=require("../engine"),r=require("../kernel_names");const i=exports.resizeBilinearGradConfig={kernelName:r.ResizeBilinear,inputsToSave:["images"],gradFunc:(i,n,s)=>{const[a]=n,o={dy:i,images:a};return{images:()=>e.ENGINE.runKernel(r.ResizeBilinearGrad,o,s)}}};
},{"../engine":"phT7","../kernel_names":"rJl6"}],"HTpQ":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.resizeNearestNeighborGradConfig=void 0;var e=require("../engine"),r=require("../kernel_names");const s=exports.resizeNearestNeighborGradConfig={kernelName:r.ResizeNearestNeighbor,inputsToSave:["images"],gradFunc:(s,i,a)=>{const[n]=i,o={dy:s,images:n};return{images:()=>e.ENGINE.runKernel(r.ResizeNearestNeighborGrad,o,a)}}};
},{"../engine":"phT7","../kernel_names":"rJl6"}],"T6Tf":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.reverseGradConfig=void 0;var e=require("../kernel_names"),r=require("../ops/reverse"),s=require("../util");const a=exports.reverseGradConfig={kernelName:e.Reverse,gradFunc:(e,a,i)=>{const{dims:o}=i,t=(0,s.parseAxisParam)(o,e.shape);return{x:()=>(0,r.reverse)(e,t)}}};
},{"../kernel_names":"rJl6","../ops/reverse":"JJIO","../util":"XXxQ"}],"h5IW":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.roundGradConfig=void 0;var e=require("../kernel_names"),r=require("../ops/zeros_like");const o=exports.roundGradConfig={kernelName:e.Round,gradFunc:e=>({x:()=>(0,r.zerosLike)(e)})};
},{"../kernel_names":"rJl6","../ops/zeros_like":"qY0o"}],"wzV0":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.rsqrtGradConfig=void 0;var e=require("../kernel_names"),r=require("../ops/div"),o=require("../ops/mul"),s=require("../ops/neg"),t=require("../ops/pow");const i=exports.rsqrtGradConfig={kernelName:e.Rsqrt,inputsToSave:["x"],gradFunc:(e,i)=>{const[n]=i;return{x:()=>(0,s.neg)((0,r.div)(e,(0,o.mul)((0,t.pow)(n,1.5),2)))}}};
},{"../kernel_names":"rJl6","../ops/div":"S2L5","../ops/mul":"tBJ4","../ops/neg":"i2LN","../ops/pow":"o2Kl"}],"pxd3":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.selectGradConfig=void 0;var e=require("../kernel_names"),o=require("../ops/cast"),r=require("../ops/logical_not"),t=require("../ops/mul"),s=require("../ops/zeros_like");const i=exports.selectGradConfig={kernelName:e.Select,inputsToSave:["condition"],gradFunc:(e,i)=>{const[c]=i;return{condition:()=>(0,o.cast)((0,s.zerosLike)(c),"float32"),t:()=>(0,t.mul)(e,(0,o.cast)(c,e.dtype)),e:()=>(0,t.mul)(e,(0,o.cast)((0,r.logicalNot)(c),e.dtype))}}};
},{"../kernel_names":"rJl6","../ops/cast":"qnzc","../ops/logical_not":"jt3a","../ops/mul":"tBJ4","../ops/zeros_like":"qY0o"}],"mTb0":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.seluGradConfig=void 0;var e=require("../kernel_names"),r=require("../ops/cast"),s=require("../ops/exp"),u=require("../ops/greater"),a=require("../ops/mul"),o=require("../ops/scalar"),t=require("../ops/selu_util"),l=require("../ops/where");const i=exports.seluGradConfig={kernelName:e.Selu,inputsToSave:["x"],gradFunc:(e,i)=>{const[p]=i;return{x:()=>{const i=(0,u.greater)(p,(0,o.scalar)(0)),n=(0,o.scalar)(t.SELU_SCALEALPHA),c=(0,o.scalar)(t.SELU_SCALE),q=(0,a.mul)(e,c),x=(0,a.mul)((0,a.mul)(e,n),(0,s.exp)((0,r.cast)(p,"float32")));return(0,l.where)(i,q,x)}}}};
},{"../kernel_names":"rJl6","../ops/cast":"qnzc","../ops/exp":"xcz4","../ops/greater":"WT29","../ops/mul":"tBJ4","../ops/scalar":"TiGU","../ops/selu_util":"mEjB","../ops/where":"TsgC"}],"Sqlj":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.sigmoidGradConfig=void 0;var e=require("../kernel_names"),r=require("../ops/mul"),s=require("../ops/scalar"),o=require("../ops/sub");const u=exports.sigmoidGradConfig={kernelName:e.Sigmoid,outputsToSave:[!0],gradFunc:(e,u)=>{const[i]=u;return{x:()=>(0,r.mul)(e,(0,r.mul)(i,(0,o.sub)((0,s.scalar)(1),i)))}}};
},{"../kernel_names":"rJl6","../ops/mul":"tBJ4","../ops/scalar":"TiGU","../ops/sub":"SgzI"}],"vcgU":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.signGradConfig=void 0;var e=require("../kernel_names"),r=require("../ops/zeros_like");const s=exports.signGradConfig={kernelName:e.Sign,gradFunc:e=>({x:()=>(0,r.zerosLike)(e)})};
},{"../kernel_names":"rJl6","../ops/zeros_like":"qY0o"}],"RArE":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.sinGradConfig=void 0;var e=require("../kernel_names"),r=require("../ops/cast"),s=require("../ops/cos"),o=require("../ops/mul");const n=exports.sinGradConfig={kernelName:e.Sin,inputsToSave:["x"],gradFunc:(e,n)=>{const[t]=n;return{x:()=>(0,o.mul)((0,s.cos)((0,r.cast)(t,"float32")),e)}}};
},{"../kernel_names":"rJl6","../ops/cast":"qnzc","../ops/cos":"gHiU","../ops/mul":"tBJ4"}],"kzFM":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.sinhGradConfig=void 0;var e=require("../kernel_names"),r=require("../ops/cast"),s=require("../ops/cosh"),o=require("../ops/mul");const n=exports.sinhGradConfig={kernelName:e.Sinh,inputsToSave:["x"],gradFunc:(e,n)=>{const[t]=n;return{x:()=>(0,o.mul)((0,s.cosh)((0,r.cast)(t,"float32")),e)}}};
},{"../kernel_names":"rJl6","../ops/cast":"qnzc","../ops/cosh":"dWiz","../ops/mul":"tBJ4"}],"uUBY":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.sliceGradConfig=void 0;var e=require("../kernel_names"),r=require("../ops/pad"),s=require("../ops/slice_util");const i=exports.sliceGradConfig={kernelName:e.Slice,inputsToSave:["x"],gradFunc:(e,i,a)=>{const[o]=i,{begin:n,size:t}=a,p=o.shape,[l,u]=(0,s.parseSliceParams)(o,n,t),c=[];for(let r=0;r<e.rank;r++)c.push([l[r],p[r]-l[r]-u[r]]);return{x:()=>(0,r.pad)(e,c)}}};
},{"../kernel_names":"rJl6","../ops/pad":"y7nM","../ops/slice_util":"PuAY"}],"J9HO":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.softmaxGradConfig=void 0;var e=require("../kernel_names"),r=require("../ops/mul"),s=require("../ops/sub"),o=require("../ops/sum");const u=exports.softmaxGradConfig={kernelName:e.Softmax,outputsToSave:[!0],gradFunc:(e,u,t)=>{const[a]=u,{dim:i}=t,m=(0,r.mul)(e,a);return{logits:()=>(0,s.sub)(m,(0,r.mul)((0,o.sum)(m,[i],!0),a))}}};
},{"../kernel_names":"rJl6","../ops/mul":"tBJ4","../ops/sub":"SgzI","../ops/sum":"kc8w"}],"wyOO":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.softplusGradConfig=void 0;var e=require("../kernel_names"),r=require("../ops/mul"),s=require("../ops/sigmoid");const o=exports.softplusGradConfig={kernelName:e.Softplus,inputsToSave:["x"],gradFunc:(e,o)=>{const[t]=o;return{x:()=>(0,r.mul)(e,(0,s.sigmoid)(t))}}};
},{"../kernel_names":"rJl6","../ops/mul":"tBJ4","../ops/sigmoid":"DbGB"}],"Gm3N":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.spaceToBatchNDGradConfig=void 0;var e=require("../kernel_names"),a=require("../ops/batch_to_space_nd");const r=exports.spaceToBatchNDGradConfig={kernelName:e.SpaceToBatchND,gradFunc:(e,r,o)=>{const{blockShape:c,paddings:t}=o;return{x:()=>(0,a.batchToSpaceND)(e,c,t)}}};
},{"../kernel_names":"rJl6","../ops/batch_to_space_nd":"vEiD"}],"Zkqp":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.splitVGradConfig=void 0;var e=require("../kernel_names"),r=require("../ops/concat");const t=exports.splitVGradConfig={kernelName:e.SplitV,gradFunc:(e,t,o)=>{const{axis:s}=o;return{x:()=>(0,r.concat)(e,s)}}};
},{"../kernel_names":"rJl6","../ops/concat":"V5Ij"}],"wsln":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.sqrtGradConfig=void 0;var e=require("../kernel_names"),r=require("../ops/cast"),s=require("../ops/div"),t=require("../ops/mul"),o=require("../ops/sqrt");const i=exports.sqrtGradConfig={kernelName:e.Sqrt,inputsToSave:["x"],gradFunc:(e,i)=>{const[u]=i;return{x:()=>(0,s.div)(e,(0,t.mul)((0,o.sqrt)((0,r.cast)(u,"float32")),2))}}};
},{"../kernel_names":"rJl6","../ops/cast":"qnzc","../ops/div":"S2L5","../ops/mul":"tBJ4","../ops/sqrt":"brr7"}],"mD5J":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.squareGradConfig=void 0;var e=require("../kernel_names"),r=require("../ops/cast"),s=require("../ops/mul");const u=exports.squareGradConfig={kernelName:e.Square,inputsToSave:["x"],gradFunc:(e,u)=>{const[a]=u;return{x:()=>(0,s.mul)(e,(0,s.mul)((0,r.cast)(a,"float32"),2))}}};
},{"../kernel_names":"rJl6","../ops/cast":"qnzc","../ops/mul":"tBJ4"}],"pRLp":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.squaredDifferenceGradConfig=void 0;var e=require("../kernel_names"),r=require("../ops/mul"),u=require("../ops/scalar"),s=require("../ops/sub");const a=exports.squaredDifferenceGradConfig={kernelName:e.SquaredDifference,inputsToSave:["a","b"],gradFunc:(e,a)=>{const[n,o]=a,i=(0,u.scalar)(2);return{a:()=>(0,r.mul)(e,(0,r.mul)(i,(0,s.sub)(n,o))),b:()=>(0,r.mul)(e,(0,r.mul)(i,(0,s.sub)(o,n)))}}};
},{"../kernel_names":"rJl6","../ops/mul":"tBJ4","../ops/scalar":"TiGU","../ops/sub":"SgzI"}],"ssPQ":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.stepGradConfig=void 0;var e=require("../kernel_names"),r=require("../ops/zeros_like");const s=exports.stepGradConfig={kernelName:e.Step,gradFunc:e=>({x:()=>(0,r.zerosLike)(e)})};
},{"../kernel_names":"rJl6","../ops/zeros_like":"qY0o"}],"aGU5":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.subGradConfig=void 0;var e=require("../kernel_names"),r=a(require("../ops/broadcast_util")),t=require("../ops/neg"),n=require("../ops/reshape"),s=require("../ops/sum");function a(e,r){if("function"==typeof WeakMap)var t=new WeakMap,n=new WeakMap;return(a=function(e,r){if(!r&&e&&e.__esModule)return e;var s,a,o={__proto__:null,default:e};if(null===e||"object"!=typeof e&&"function"!=typeof e)return o;if(s=r?n:t){if(s.has(e))return s.get(e);s.set(e,o)}for(const t in e)"default"!==t&&{}.hasOwnProperty.call(e,t)&&((a=(s=Object.defineProperty)&&Object.getOwnPropertyDescriptor(e,t))&&(a.get||a.set)?s(o,t,a):o[t]=e[t]);return o})(e,r)}const o=exports.subGradConfig={kernelName:e.Sub,inputsToSave:["a","b"],gradFunc:(e,a)=>{const[o,u]=a,p=r.assertAndGetBroadcastShape(o.shape,u.shape);return{a:()=>{let t=e;const a=r.getReductionAxes(o.shape,p);return a.length>0&&(t=(0,s.sum)(t,a)),(0,n.reshape)(t,o.shape)},b:()=>{let a=e;const o=r.getReductionAxes(u.shape,p);return o.length>0&&(a=(0,s.sum)(a,o)),(0,n.reshape)((0,t.neg)(a),u.shape)}}}};
},{"../kernel_names":"rJl6","../ops/broadcast_util":"fD2T","../ops/neg":"i2LN","../ops/reshape":"F0cm","../ops/sum":"kc8w"}],"P0IO":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.sumGradConfig=void 0;var e=require("../kernel_names"),r=require("../ops/mul"),s=require("../ops/ones"),a=require("../ops/reshape"),o=require("../util");const u=exports.sumGradConfig={kernelName:e.Sum,inputsToSave:["x"],gradFunc:(e,u,i)=>{const[n]=u,p=n.shape.slice(),{axis:t}=i;(0,o.parseAxisParam)(t,n.shape).forEach(e=>{p[e]=1});const l=(0,a.reshape)(e,p),c=(0,r.mul)(l,(0,s.ones)(n.shape,"float32"));return{x:()=>c}}};
},{"../kernel_names":"rJl6","../ops/mul":"tBJ4","../ops/ones":"iY3A","../ops/reshape":"F0cm","../util":"XXxQ"}],"tWWN":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.tanGradConfig=void 0;var e=require("../kernel_names"),r=require("../ops/cos"),s=require("../ops/div"),o=require("../ops/square");const n=exports.tanGradConfig={kernelName:e.Tan,inputsToSave:["x"],gradFunc:(e,n)=>{const[a]=n;return{x:()=>(0,s.div)(e,(0,o.square)((0,r.cos)(a)))}}};
},{"../kernel_names":"rJl6","../ops/cos":"gHiU","../ops/div":"S2L5","../ops/square":"KiGo"}],"rwFp":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.tanhGradConfig=void 0;var e=require("../kernel_names"),r=require("../ops/mul"),s=require("../ops/scalar"),u=require("../ops/square"),a=require("../ops/sub");const o=exports.tanhGradConfig={kernelName:e.Tanh,outputsToSave:[!0],gradFunc:(e,o)=>{const[t]=o;return{x:()=>(0,r.mul)((0,a.sub)((0,s.scalar)(1),(0,u.square)(t)),e)}}};
},{"../kernel_names":"rJl6","../ops/mul":"tBJ4","../ops/scalar":"TiGU","../ops/square":"KiGo","../ops/sub":"SgzI"}],"ISjx":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.tileGradConfig=void 0;var e=require("../kernel_names"),r=require("../ops/add"),s=require("../ops/slice"),a=require("../ops/zeros_like");const o=exports.tileGradConfig={kernelName:e.Tile,inputsToSave:["x"],gradFunc:(e,o,t)=>{const[p]=o,{reps:i}=t;return{x:()=>{let o=(0,a.zerosLike)(p);if(1===p.rank)for(let a=0;a<i[0];++a)o=(0,r.add)(o,(0,s.slice)(e,[a*p.shape[0]],[p.shape[0]]));else if(2===p.rank)for(let a=0;a<i[0];++a)for(let t=0;t<i[1];++t)o=(0,r.add)(o,(0,s.slice)(e,[a*p.shape[0],t*p.shape[1]],[p.shape[0],p.shape[1]]));else if(3===p.rank)for(let a=0;a<i[0];++a)for(let t=0;t<i[1];++t)for(let l=0;l<i[2];++l)o=(0,r.add)(o,(0,s.slice)(e,[a*p.shape[0],t*p.shape[1],l*p.shape[2]],[p.shape[0],p.shape[1],p.shape[2]]));else{if(4!==p.rank)throw new Error("Gradient for tile operation is not implemented for rank-"+`${p.rank} tensors yet.`);for(let a=0;a<i[0];++a)for(let t=0;t<i[1];++t)for(let l=0;l<i[2];++l)for(let n=0;n<i[3];++n)o=(0,r.add)(o,(0,s.slice)(e,[a*p.shape[0],t*p.shape[1],l*p.shape[2],n*p.shape[3]],[p.shape[0],p.shape[1],p.shape[2],p.shape[3]]))}return o}}}};
},{"../kernel_names":"rJl6","../ops/add":"N73o","../ops/slice":"wIos","../ops/zeros_like":"qY0o"}],"CWwU":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.transposeGradConfig=void 0;var e=require("../kernel_names"),r=n(require("../ops/axis_util")),t=require("../ops/transpose");function n(e,r){if("function"==typeof WeakMap)var t=new WeakMap,o=new WeakMap;return(n=function(e,r){if(!r&&e&&e.__esModule)return e;var n,s,a={__proto__:null,default:e};if(null===e||"object"!=typeof e&&"function"!=typeof e)return a;if(n=r?o:t){if(n.has(e))return n.get(e);n.set(e,a)}for(const t in e)"default"!==t&&{}.hasOwnProperty.call(e,t)&&((s=(n=Object.defineProperty)&&Object.getOwnPropertyDescriptor(e,t))&&(s.get||s.set)?n(a,t,s):a[t]=e[t]);return a})(e,r)}const o=exports.transposeGradConfig={kernelName:e.Transpose,gradFunc:(e,n,o)=>{const s=o,{perm:a}=s,u=r.getUndoAxesPermutation(a);return{x:()=>(0,t.transpose)(e,u)}}};
},{"../kernel_names":"rJl6","../ops/axis_util":"mPwf","../ops/transpose":"JmRY"}],"gYaO":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.unpackGradConfig=void 0;var e=require("../kernel_names"),r=require("../ops/stack");const a=exports.unpackGradConfig={kernelName:e.Unpack,gradFunc:(e,a,n)=>{const s=n,{axis:t}=s;return{value:()=>(0,r.stack)(e,t)}}};
},{"../kernel_names":"rJl6","../ops/stack":"Wzzr"}],"MsJG":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.unsortedSegmentSumGradConfig=void 0;var e=require("../kernel_names"),r=require("../ops/expand_dims"),o=require("../ops/gather"),s=require("../ops/greater_equal"),n=require("../ops/logical_and"),t=require("../ops/maximum"),a=require("../ops/ones"),i=require("../ops/scalar"),u=require("../ops/where"),m=require("../ops/zeros_like");const p=exports.unsortedSegmentSumGradConfig={kernelName:e.UnsortedSegmentSum,inputsToSave:["segmentIds"],gradFunc:(e,r)=>{const[o]=r;return{x:()=>l(e,o)}}};function l(e,p){const l=(0,t.maximum)(p,(0,m.zerosLike)(p)),d=(0,o.gather)(e,l);let c=(0,s.greaterEqual)(p,(0,i.scalar)(0,"int32"));const g=d.rank-c.rank;for(let o=0;o<g;++o)c=(0,r.expandDims)(c,o+1);c=(0,n.logicalAnd)(c,(0,a.ones)(d.shape,"bool"));const q=(0,m.zerosLike)(d);return(0,u.where)(c,d,q)}
},{"../kernel_names":"rJl6","../ops/expand_dims":"WqhD","../ops/gather":"TfxI","../ops/greater_equal":"a6nY","../ops/logical_and":"sHir","../ops/maximum":"E33m","../ops/ones":"iY3A","../ops/scalar":"TiGU","../ops/where":"TsgC","../ops/zeros_like":"qY0o"}],"Ki6I":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.zerosLikeGradConfig=void 0;var e=require("../kernel_names"),r=require("../ops/zeros_like");const o=exports.zerosLikeGradConfig={kernelName:e.ZerosLike,gradFunc:e=>({x:()=>(0,r.zerosLike)(e)})};
},{"../kernel_names":"rJl6","../ops/zeros_like":"qY0o"}],"qJ5u":[function(require,module,exports) {
"use strict";var r=require("./gradients/Abs_grad"),e=require("./gradients/Acos_grad"),a=require("./gradients/Acosh_grad"),i=require("./gradients/Add_grad"),d=require("./gradients/AddN_grad"),g=require("./gradients/ArgMax_grad"),n=require("./gradients/ArgMin_grad"),o=require("./gradients/Asin_grad"),s=require("./gradients/Asinh_grad"),t=require("./gradients/Atan2_grad"),u=require("./gradients/Atan_grad"),f=require("./gradients/Atanh_grad"),C=require("./gradients/AvgPool3D_grad"),q=require("./gradients/AvgPool_grad"),G=require("./gradients/BatchMatMul_grad"),_=require("./gradients/BatchToSpaceND_grad"),l=require("./gradients/BroadcastTo_grad"),c=require("./gradients/Cast_grad"),p=require("./gradients/Ceil_grad"),m=require("./gradients/ClipByValue_grad"),h=require("./gradients/ComplexAbs_grad"),D=require("./gradients/Concat_grad"),S=require("./gradients/Conv2D_grad"),x=require("./gradients/Conv2DBackpropInput_grad"),v=require("./gradients/Conv3D_grad"),N=require("./gradients/Cos_grad"),M=require("./gradients/Cosh_grad"),A=require("./gradients/Cumsum_grad"),P=require("./gradients/DepthwiseConv2dNative_grad"),B=require("./gradients/Dilation2D_grad"),k=require("./gradients/Elu_grad"),R=require("./gradients/Erf_grad"),b=require("./gradients/Exp_grad"),T=require("./gradients/ExpandDims_grad"),y=require("./gradients/Expm1_grad"),L=require("./gradients/Floor_grad"),V=require("./gradients/FloorDiv_grad"),I=require("./gradients/FusedBatchNorm_grad"),E=require("./gradients/GatherV2_grad"),z=require("./gradients/GreaterEqual_grad"),F=require("./gradients/Identity_grad"),w=require("./gradients/IsFinite_grad"),H=require("./gradients/IsInf_grad"),O=require("./gradients/IsNan_grad"),U=require("./gradients/LeakyRelu_grad"),Z=require("./gradients/Log1p_grad"),j=require("./gradients/Log_grad"),J=require("./gradients/LogSoftmax_grad"),K=require("./gradients/LRN_grad"),Q=require("./gradients/Max_grad"),W=require("./gradients/Maximum_grad"),X=require("./gradients/MaxPool3D_grad"),Y=require("./gradients/MaxPool_grad"),$=require("./gradients/Mean_grad"),rr=require("./gradients/Min_grad"),er=require("./gradients/Minimum_grad"),ar=require("./gradients/MirrorPad_grad"),ir=require("./gradients/Mod_grad"),dr=require("./gradients/Multiply_grad"),gr=require("./gradients/Neg_grad"),nr=require("./gradients/OneHot_grad"),or=require("./gradients/OnesLike_grad"),sr=require("./gradients/Pack_grad"),tr=require("./gradients/PadV2_grad"),ur=require("./gradients/Pow_grad"),fr=require("./gradients/Prelu_grad"),Cr=require("./gradients/Prod_grad"),qr=require("./gradients/RealDiv_grad"),Gr=require("./gradients/Reciprocal_grad"),_r=require("./gradients/Relu6_grad"),lr=require("./gradients/Relu_grad"),cr=require("./gradients/Reshape_grad"),pr=require("./gradients/ResizeBilinear_grad"),mr=require("./gradients/ResizeNearestNeighbor_grad"),hr=require("./gradients/Reverse_grad"),Dr=require("./gradients/Round_grad"),Sr=require("./gradients/Rsqrt_grad"),xr=require("./gradients/Select_grad"),vr=require("./gradients/Selu_grad"),Nr=require("./gradients/Sigmoid_grad"),Mr=require("./gradients/Sign_grad"),Ar=require("./gradients/Sin_grad"),Pr=require("./gradients/Sinh_grad"),Br=require("./gradients/Slice_grad"),kr=require("./gradients/Softmax_grad"),Rr=require("./gradients/Softplus_grad"),br=require("./gradients/SpaceToBatchND_grad"),Tr=require("./gradients/SplitV_grad"),yr=require("./gradients/Sqrt_grad"),Lr=require("./gradients/Square_grad"),Vr=require("./gradients/SquaredDifference_grad"),Ir=require("./gradients/Step_grad"),Er=require("./gradients/Sub_grad"),zr=require("./gradients/Sum_grad"),Fr=require("./gradients/Tan_grad"),wr=require("./gradients/Tanh_grad"),Hr=require("./gradients/Tile_grad"),Or=require("./gradients/Transpose_grad"),Ur=require("./gradients/Unpack_grad"),Zr=require("./gradients/UnsortedSegmentSum_grad"),jr=require("./gradients/ZerosLike_grad"),Jr=require("./kernel_registry");const Kr=[r.absGradConfig,e.acosGradConfig,a.acoshGradConfig,i.addGradConfig,d.addNGradConfig,g.argMaxGradConfig,n.argMinGradConfig,o.asinGradConfig,s.asinhGradConfig,t.atan2GradConfig,u.atanGradConfig,f.atanhGradConfig,C.avgPool3DGradConfig,q.avgPoolGradConfig,G.batchMatMulGradConfig,_.batchToSpaceNDGradConfig,l.broadcastToGradConfig,c.castGradConfig,p.ceilGradConfig,m.clipByValueGradConfig,h.complexAbsGradConfig,D.concatGradConfig,x.conv2DBackpropInputGradConfig,S.conv2DGradConfig,v.conv3DGradConfig,N.cosGradConfig,M.coshGradConfig,A.cumsumGradConfig,P.depthwiseConv2dNativeGradConfig,B.dilation2dGradConfig,qr.divGradConfig,k.eluGradConfig,R.erfGradConfig,b.expGradConfig,T.expandDimsGradConfig,y.expm1GradConfig,V.floorDivGradConfig,L.floorGradConfig,I.fusedBatchNormGradConfig,E.gatherGradConfig,z.greaterEqualGradConfig,F.identityGradConfig,w.isFiniteGradConfig,H.isInfGradConfig,O.isNanGradConfig,U.leakyReluGradConfig,Z.log1pGradConfig,j.logGradConfig,J.logSoftmaxGradConfig,K.lrnGradConfig,Q.maxGradConfig,Q.maxGradConfig,W.maximumGradConfig,X.maxPool3DGradConfig,Y.maxPoolGradConfig,$.meanGradConfig,rr.minGradConfig,er.minimumGradConfig,ar.mirrorPadGradConfig,ir.modGradConfig,dr.multiplyGradConfig,gr.negGradConfig,nr.oneHotGradConfig,or.onesLikeGradConfig,sr.packGradConfig,tr.padV2GradConfig,tr.padV2GradConfig,ur.powGradConfig,fr.preluGradConfig,Cr.prodGradConfig,Gr.reciprocalGradConfig,_r.relu6GradConfig,lr.reluGradConfig,cr.reshapeGradConfig,pr.resizeBilinearGradConfig,mr.resizeNearestNeighborGradConfig,hr.reverseGradConfig,Dr.roundGradConfig,Sr.rsqrtGradConfig,xr.selectGradConfig,vr.seluGradConfig,Nr.sigmoidGradConfig,Mr.signGradConfig,Ar.sinGradConfig,Pr.sinhGradConfig,Br.sliceGradConfig,kr.softmaxGradConfig,Rr.softplusGradConfig,br.spaceToBatchNDGradConfig,br.spaceToBatchNDGradConfig,Tr.splitVGradConfig,Tr.splitVGradConfig,yr.sqrtGradConfig,Vr.squaredDifferenceGradConfig,Lr.squareGradConfig,Ir.stepGradConfig,Er.subGradConfig,zr.sumGradConfig,Fr.tanGradConfig,wr.tanhGradConfig,Hr.tileGradConfig,Or.transposeGradConfig,Ur.unpackGradConfig,Zr.unsortedSegmentSumGradConfig,jr.zerosLikeGradConfig];for(const Qr of Kr)(0,Jr.registerGradient)(Qr);
},{"./gradients/Abs_grad":"l60O","./gradients/Acos_grad":"xXFB","./gradients/Acosh_grad":"Gnn5","./gradients/Add_grad":"kVz5","./gradients/AddN_grad":"muMo","./gradients/ArgMax_grad":"pZ40","./gradients/ArgMin_grad":"vNGj","./gradients/Asin_grad":"WLmx","./gradients/Asinh_grad":"vKHZ","./gradients/Atan2_grad":"LZ38","./gradients/Atan_grad":"inFl","./gradients/Atanh_grad":"aOO9","./gradients/AvgPool3D_grad":"ewFB","./gradients/AvgPool_grad":"otiv","./gradients/BatchMatMul_grad":"YeGW","./gradients/BatchToSpaceND_grad":"I5Ws","./gradients/BroadcastTo_grad":"FMr1","./gradients/Cast_grad":"PDcM","./gradients/Ceil_grad":"sxhV","./gradients/ClipByValue_grad":"xMBC","./gradients/ComplexAbs_grad":"xaWd","./gradients/Concat_grad":"E50Q","./gradients/Conv2D_grad":"l89e","./gradients/Conv2DBackpropInput_grad":"ZVOp","./gradients/Conv3D_grad":"WnBm","./gradients/Cos_grad":"TBU6","./gradients/Cosh_grad":"AsLZ","./gradients/Cumsum_grad":"Pzif","./gradients/DepthwiseConv2dNative_grad":"elgP","./gradients/Dilation2D_grad":"lvne","./gradients/Elu_grad":"Y3U7","./gradients/Erf_grad":"sItU","./gradients/Exp_grad":"ICdg","./gradients/ExpandDims_grad":"o9E0","./gradients/Expm1_grad":"IfK7","./gradients/Floor_grad":"Aayl","./gradients/FloorDiv_grad":"VCsx","./gradients/FusedBatchNorm_grad":"w8qP","./gradients/GatherV2_grad":"QY40","./gradients/GreaterEqual_grad":"B6Z1","./gradients/Identity_grad":"TvOI","./gradients/IsFinite_grad":"teh8","./gradients/IsInf_grad":"HDmB","./gradients/IsNan_grad":"DbSF","./gradients/LeakyRelu_grad":"ARg4","./gradients/Log1p_grad":"cTK8","./gradients/Log_grad":"pIev","./gradients/LogSoftmax_grad":"Rl4R","./gradients/LRN_grad":"A9bk","./gradients/Max_grad":"zegh","./gradients/Maximum_grad":"PGKc","./gradients/MaxPool3D_grad":"gj4V","./gradients/MaxPool_grad":"tfaS","./gradients/Mean_grad":"YKB4","./gradients/Min_grad":"ek8n","./gradients/Minimum_grad":"w180","./gradients/MirrorPad_grad":"DOfc","./gradients/Mod_grad":"zPHU","./gradients/Multiply_grad":"s8ip","./gradients/Neg_grad":"eOcq","./gradients/OneHot_grad":"tvM0","./gradients/OnesLike_grad":"suTr","./gradients/Pack_grad":"Gc7m","./gradients/PadV2_grad":"iZYn","./gradients/Pow_grad":"J9Vg","./gradients/Prelu_grad":"lOIP","./gradients/Prod_grad":"u4Ba","./gradients/RealDiv_grad":"oyvb","./gradients/Reciprocal_grad":"mcH8","./gradients/Relu6_grad":"Ca6G","./gradients/Relu_grad":"CkLH","./gradients/Reshape_grad":"eApb","./gradients/ResizeBilinear_grad":"bpQe","./gradients/ResizeNearestNeighbor_grad":"HTpQ","./gradients/Reverse_grad":"T6Tf","./gradients/Round_grad":"h5IW","./gradients/Rsqrt_grad":"wzV0","./gradients/Select_grad":"pxd3","./gradients/Selu_grad":"mTb0","./gradients/Sigmoid_grad":"Sqlj","./gradients/Sign_grad":"vcgU","./gradients/Sin_grad":"RArE","./gradients/Sinh_grad":"kzFM","./gradients/Slice_grad":"uUBY","./gradients/Softmax_grad":"J9HO","./gradients/Softplus_grad":"wyOO","./gradients/SpaceToBatchND_grad":"Gm3N","./gradients/SplitV_grad":"Zkqp","./gradients/Sqrt_grad":"wsln","./gradients/Square_grad":"mD5J","./gradients/SquaredDifference_grad":"pRLp","./gradients/Step_grad":"ssPQ","./gradients/Sub_grad":"aGU5","./gradients/Sum_grad":"P0IO","./gradients/Tan_grad":"tWWN","./gradients/Tanh_grad":"rwFp","./gradients/Tile_grad":"ISjx","./gradients/Transpose_grad":"CWwU","./gradients/Unpack_grad":"gYaO","./gradients/UnsortedSegmentSum_grad":"MsJG","./gradients/ZerosLike_grad":"Ki6I","./kernel_registry":"PlaY"}],"AUNX":[function(require,module,exports) {
"use strict";var s=require("../../ops/ops"),r=require("../../tensor");(0,r.getGlobalTensorClass)().prototype.abs=function(){return this.throwIfDisposed(),(0,s.abs)(this)};
},{"../../ops/ops":"hfXJ","../../tensor":"eFW4"}],"DV3p":[function(require,module,exports) {
"use strict";var s=require("../../ops/ops"),o=require("../../tensor");(0,o.getGlobalTensorClass)().prototype.acos=function(){return this.throwIfDisposed(),(0,s.acos)(this)};
},{"../../ops/ops":"hfXJ","../../tensor":"eFW4"}],"hGyB":[function(require,module,exports) {
"use strict";var s=require("../../ops/ops"),o=require("../../tensor");(0,o.getGlobalTensorClass)().prototype.acosh=function(){return this.throwIfDisposed(),(0,s.acosh)(this)};
},{"../../ops/ops":"hfXJ","../../tensor":"eFW4"}],"WMvU":[function(require,module,exports) {
"use strict";var r=require("../../ops/add"),e=require("../../tensor");(0,e.getGlobalTensorClass)().prototype.add=function(e){return this.throwIfDisposed(),(0,r.add)(this,e)};
},{"../../ops/add":"N73o","../../tensor":"eFW4"}],"RcHq":[function(require,module,exports) {
"use strict";var r=require("../../ops/all"),e=require("../../tensor");(0,e.getGlobalTensorClass)().prototype.all=function(e,s){return this.throwIfDisposed(),(0,r.all)(this,e,s)};
},{"../../ops/all":"zHmK","../../tensor":"eFW4"}],"T9Ol":[function(require,module,exports) {
"use strict";var r=require("../../ops/any"),e=require("../../tensor");(0,e.getGlobalTensorClass)().prototype.any=function(e,s){return this.throwIfDisposed(),(0,r.any)(this,e,s)};
},{"../../ops/any":"XocL","../../tensor":"eFW4"}],"KCW7":[function(require,module,exports) {
"use strict";var r=require("../../ops/arg_max"),e=require("../../tensor");(0,e.getGlobalTensorClass)().prototype.argMax=function(e){return this.throwIfDisposed(),(0,r.argMax)(this,e)};
},{"../../ops/arg_max":"dv7u","../../tensor":"eFW4"}],"kfmH":[function(require,module,exports) {
"use strict";var r=require("../../ops/arg_min"),e=require("../../tensor");(0,e.getGlobalTensorClass)().prototype.argMin=function(e){return this.throwIfDisposed(),(0,r.argMin)(this,e)};
},{"../../ops/arg_min":"y2ST","../../tensor":"eFW4"}],"DCsN":[function(require,module,exports) {
"use strict";var e=require("../../ops/reshape"),r=require("../../tensor"),s=require("../../util");(0,r.getGlobalTensorClass)().prototype.asScalar=function(){return this.throwIfDisposed(),(0,s.assert)(1===this.size,()=>"The array must have only 1 element."),(0,e.reshape)(this,[])};
},{"../../ops/reshape":"F0cm","../../tensor":"eFW4","../../util":"XXxQ"}],"SqNb":[function(require,module,exports) {
"use strict";var s=require("../../ops/ops"),e=require("../../tensor");(0,e.getGlobalTensorClass)().prototype.asType=function(e){return this.throwIfDisposed(),(0,s.cast)(this,e)};
},{"../../ops/ops":"hfXJ","../../tensor":"eFW4"}],"cC4K":[function(require,module,exports) {
"use strict";var e=require("../../ops/reshape"),s=require("../../tensor");(0,s.getGlobalTensorClass)().prototype.as1D=function(){return this.throwIfDisposed(),(0,e.reshape)(this,[this.size])};
},{"../../ops/reshape":"F0cm","../../tensor":"eFW4"}],"ITbF":[function(require,module,exports) {
"use strict";var e=require("../../ops/reshape"),r=require("../../tensor");(0,r.getGlobalTensorClass)().prototype.as2D=function(r,s){return this.throwIfDisposed(),(0,e.reshape)(this,[r,s])};
},{"../../ops/reshape":"F0cm","../../tensor":"eFW4"}],"CtfD":[function(require,module,exports) {
"use strict";var e=require("../../ops/reshape"),r=require("../../tensor");(0,r.getGlobalTensorClass)().prototype.as3D=function(r,s,t){return this.throwIfDisposed(),(0,e.reshape)(this,[r,s,t])};
},{"../../ops/reshape":"F0cm","../../tensor":"eFW4"}],"pSwS":[function(require,module,exports) {
"use strict";var e=require("../../ops/reshape"),r=require("../../tensor");(0,r.getGlobalTensorClass)().prototype.as4D=function(r,s,t,o){return this.throwIfDisposed(),(0,e.reshape)(this,[r,s,t,o])};
},{"../../ops/reshape":"F0cm","../../tensor":"eFW4"}],"E3Tm":[function(require,module,exports) {
"use strict";var e=require("../../ops/reshape"),r=require("../../tensor");(0,r.getGlobalTensorClass)().prototype.as5D=function(r,s,t,o,i){return this.throwIfDisposed(),(0,e.reshape)(this,[r,s,t,o,i])};
},{"../../ops/reshape":"F0cm","../../tensor":"eFW4"}],"HBo0":[function(require,module,exports) {
"use strict";var s=require("../../ops/ops"),r=require("../../tensor");(0,r.getGlobalTensorClass)().prototype.asin=function(){return this.throwIfDisposed(),(0,s.asin)(this)};
},{"../../ops/ops":"hfXJ","../../tensor":"eFW4"}],"EahO":[function(require,module,exports) {
"use strict";var s=require("../../ops/ops"),r=require("../../tensor");(0,r.getGlobalTensorClass)().prototype.asinh=function(){return this.throwIfDisposed(),(0,s.asinh)(this)};
},{"../../ops/ops":"hfXJ","../../tensor":"eFW4"}],"JAxw":[function(require,module,exports) {
"use strict";var t=require("../../ops/ops"),r=require("../../tensor");(0,r.getGlobalTensorClass)().prototype.atan=function(){return this.throwIfDisposed(),(0,t.atan)(this)};
},{"../../ops/ops":"hfXJ","../../tensor":"eFW4"}],"pxNX":[function(require,module,exports) {
"use strict";var t=require("../../ops/atan2"),r=require("../../tensor");(0,r.getGlobalTensorClass)().prototype.atan2=function(r){return this.throwIfDisposed(),(0,t.atan2)(this,r)};
},{"../../ops/atan2":"lkDZ","../../tensor":"eFW4"}],"Ak1n":[function(require,module,exports) {
"use strict";var t=require("../../ops/ops"),r=require("../../tensor");(0,r.getGlobalTensorClass)().prototype.atanh=function(){return this.throwIfDisposed(),(0,t.atanh)(this)};
},{"../../ops/ops":"hfXJ","../../tensor":"eFW4"}],"HPUt":[function(require,module,exports) {
"use strict";var o=require("../../ops/avg_pool"),r=require("../../tensor");(0,r.getGlobalTensorClass)().prototype.avgPool=function(r,e,s,t){return this.throwIfDisposed(),(0,o.avgPool)(this,r,e,s,t)};
},{"../../ops/avg_pool":"LNDu","../../tensor":"eFW4"}],"TB8q":[function(require,module,exports) {
"use strict";var t=require("../../ops/batch_to_space_nd"),e=require("../../tensor");(0,e.getGlobalTensorClass)().prototype.batchToSpaceND=function(e,o){return this.throwIfDisposed(),(0,t.batchToSpaceND)(this,e,o)};
},{"../../ops/batch_to_space_nd":"vEiD","../../tensor":"eFW4"}],"QQ1Z":[function(require,module,exports) {
"use strict";var r=require("../../ops/batchnorm"),t=require("../../tensor");(0,t.getGlobalTensorClass)().prototype.batchNorm=function(t,o,e,s,i){return this.throwIfDisposed(),(0,r.batchNorm)(this,t,o,e,s,i)};
},{"../../ops/batchnorm":"gYII","../../tensor":"eFW4"}],"lBH2":[function(require,module,exports) {
"use strict";var o=require("../../ops/broadcast_to"),r=require("../../tensor");(0,r.getGlobalTensorClass)().prototype.broadcastTo=function(r){return this.throwIfDisposed(),(0,o.broadcastTo)(this,r)};
},{"../../ops/broadcast_to":"ZDfb","../../tensor":"eFW4"}],"xa9M":[function(require,module,exports) {
"use strict";var s=require("../../ops/ops"),t=require("../../tensor");(0,t.getGlobalTensorClass)().prototype.cast=function(t){return this.throwIfDisposed(),(0,s.cast)(this,t)};
},{"../../ops/ops":"hfXJ","../../tensor":"eFW4"}],"ba0E":[function(require,module,exports) {
"use strict";var e=require("../../ops/ops"),r=require("../../tensor");(0,r.getGlobalTensorClass)().prototype.ceil=function(){return this.throwIfDisposed(),(0,e.ceil)(this)};
},{"../../ops/ops":"hfXJ","../../tensor":"eFW4"}],"VXS2":[function(require,module,exports) {
"use strict";var e=require("../../ops/ops"),r=require("../../tensor");(0,r.getGlobalTensorClass)().prototype.clipByValue=function(r,s){return this.throwIfDisposed(),(0,e.clipByValue)(this,r,s)};
},{"../../ops/ops":"hfXJ","../../tensor":"eFW4"}],"kFde":[function(require,module,exports) {
"use strict";var t=require("../../ops/concat"),o=require("../../tensor");(0,o.getGlobalTensorClass)().prototype.concat=function(e,r){return this.throwIfDisposed(),e instanceof o.Tensor&&(e=[e]),(0,t.concat)([this,...e],r)};
},{"../../ops/concat":"V5Ij","../../tensor":"eFW4"}],"CFcA":[function(require,module,exports) {
"use strict";var o=require("../../ops/conv1d"),r=require("../../tensor");(0,r.getGlobalTensorClass)().prototype.conv1d=function(r,e,s,t,n,i){return this.throwIfDisposed(),(0,o.conv1d)(this,r,e,s,t,n,i)};
},{"../../ops/conv1d":"RZoo","../../tensor":"eFW4"}],"fWT8":[function(require,module,exports) {
"use strict";var s=require("../../ops/conv2d_transpose"),o=require("../../tensor");(0,o.getGlobalTensorClass)().prototype.conv2dTranspose=function(o,r,e,t,n){return this.throwIfDisposed(),(0,s.conv2dTranspose)(this,o,r,e,t,n)};
},{"../../ops/conv2d_transpose":"v80f","../../tensor":"eFW4"}],"a47A":[function(require,module,exports) {
"use strict";var o=require("../../ops/conv2d"),r=require("../../tensor");(0,r.getGlobalTensorClass)().prototype.conv2d=function(r,e,s,t,n,i){return this.throwIfDisposed(),(0,o.conv2d)(this,r,e,s,t,n,i)};
},{"../../ops/conv2d":"CVMs","../../tensor":"eFW4"}],"mvzD":[function(require,module,exports) {
"use strict";var s=require("../../ops/ops"),o=require("../../tensor");(0,o.getGlobalTensorClass)().prototype.cos=function(){return this.throwIfDisposed(),(0,s.cos)(this)};
},{"../../ops/ops":"hfXJ","../../tensor":"eFW4"}],"uhP2":[function(require,module,exports) {
"use strict";var s=require("../../ops/ops"),o=require("../../tensor");(0,o.getGlobalTensorClass)().prototype.cosh=function(){return this.throwIfDisposed(),(0,s.cosh)(this)};
},{"../../ops/ops":"hfXJ","../../tensor":"eFW4"}],"EPQ9":[function(require,module,exports) {
"use strict";var r=require("../../ops/cumprod"),o=require("../../tensor");(0,o.getGlobalTensorClass)().prototype.cumprod=function(o,e,s){return this.throwIfDisposed(),(0,r.cumprod)(this,o,e,s)};
},{"../../ops/cumprod":"CZnL","../../tensor":"eFW4"}],"Itdd":[function(require,module,exports) {
"use strict";var s=require("../../ops/cumsum"),r=require("../../tensor");(0,r.getGlobalTensorClass)().prototype.cumsum=function(r,e,t){return this.throwIfDisposed(),(0,s.cumsum)(this,r,e,t)};
},{"../../ops/cumsum":"s2nI","../../tensor":"eFW4"}],"b5Ls":[function(require,module,exports) {
"use strict";var e=require("../../ops/depth_to_space"),t=require("../../tensor");(0,t.getGlobalTensorClass)().prototype.depthToSpace=function(t,o){return this.throwIfDisposed(),(0,e.depthToSpace)(this,t,o)};
},{"../../ops/depth_to_space":"o3IO","../../tensor":"eFW4"}],"z4QP":[function(require,module,exports) {
"use strict";var e=require("../../ops/depthwise_conv2d"),s=require("../../tensor");(0,s.getGlobalTensorClass)().prototype.depthwiseConv2d=function(s,t,o,r,i,n){return this.throwIfDisposed(),(0,e.depthwiseConv2d)(this,s,t,o,r,i,n)};
},{"../../ops/depthwise_conv2d":"HEHz","../../tensor":"eFW4"}],"fqks":[function(require,module,exports) {
"use strict";var t=require("../../ops/dilation2d"),i=require("../../tensor");(0,i.getGlobalTensorClass)().prototype.dilation2d=function(i,o,r,e,s){return this.throwIfDisposed(),(0,t.dilation2d)(this,i,o,r,e,s)};
},{"../../ops/dilation2d":"XEeh","../../tensor":"eFW4"}],"OqXz":[function(require,module,exports) {
"use strict";var o=require("../../ops/div_no_nan"),r=require("../../tensor");(0,r.getGlobalTensorClass)().prototype.divNoNan=function(r){return this.throwIfDisposed(),(0,o.divNoNan)(this,r)};
},{"../../ops/div_no_nan":"VrTr","../../tensor":"eFW4"}],"CYEi":[function(require,module,exports) {
"use strict";var r=require("../../ops/div"),e=require("../../tensor");(0,e.getGlobalTensorClass)().prototype.div=function(e){return this.throwIfDisposed(),(0,r.div)(this,e)};
},{"../../ops/div":"S2L5","../../tensor":"eFW4"}],"VowQ":[function(require,module,exports) {
"use strict";var t=require("../../ops/dot"),o=require("../../tensor");(0,o.getGlobalTensorClass)().prototype.dot=function(o){return this.throwIfDisposed(),(0,t.dot)(this,o)};
},{"../../ops/dot":"M98r","../../tensor":"eFW4"}],"CQoI":[function(require,module,exports) {
"use strict";var e=require("../../ops/elu"),r=require("../../tensor");(0,r.getGlobalTensorClass)().prototype.elu=function(){return this.throwIfDisposed(),(0,e.elu)(this)};
},{"../../ops/elu":"qSof","../../tensor":"eFW4"}],"jVkX":[function(require,module,exports) {
"use strict";var e=require("../../ops/equal"),r=require("../../tensor");(0,r.getGlobalTensorClass)().prototype.equal=function(r){return this.throwIfDisposed(),(0,e.equal)(this,r)};
},{"../../ops/equal":"haNF","../../tensor":"eFW4"}],"kbSS":[function(require,module,exports) {
"use strict";var r=require("../../ops/ops"),e=require("../../tensor");(0,e.getGlobalTensorClass)().prototype.erf=function(){return this.throwIfDisposed(),(0,r.erf)(this)};
},{"../../ops/ops":"hfXJ","../../tensor":"eFW4"}],"N8xJ":[function(require,module,exports) {
"use strict";var e=require("../../ops/euclidean_norm"),r=require("../../tensor");(0,r.getGlobalTensorClass)().prototype.euclideanNorm=function(r,o){return this.throwIfDisposed(),(0,e.euclideanNorm)(this,r,o)};
},{"../../ops/euclidean_norm":"Qkob","../../tensor":"eFW4"}],"t9B7":[function(require,module,exports) {
"use strict";var e=require("../../ops/ops"),r=require("../../tensor");(0,r.getGlobalTensorClass)().prototype.exp=function(){return this.throwIfDisposed(),(0,e.exp)(this)};
},{"../../ops/ops":"hfXJ","../../tensor":"eFW4"}],"EXTx":[function(require,module,exports) {
"use strict";var e=require("../../ops/expand_dims"),s=require("../../tensor");(0,s.getGlobalTensorClass)().prototype.expandDims=function(s){return this.throwIfDisposed(),(0,e.expandDims)(this,s)};
},{"../../ops/expand_dims":"WqhD","../../tensor":"eFW4"}],"p0bR":[function(require,module,exports) {
"use strict";var e=require("../../ops/ops"),r=require("../../tensor");(0,r.getGlobalTensorClass)().prototype.expm1=function(){return this.throwIfDisposed(),(0,e.expm1)(this)};
},{"../../ops/ops":"hfXJ","../../tensor":"eFW4"}],"ocg5":[function(require,module,exports) {
"use strict";var t=require("../../ops/ops"),r=require("../../tensor");(0,r.getGlobalTensorClass)().prototype.fft=function(){return this.throwIfDisposed(),(0,t.fft)(this)};
},{"../../ops/ops":"hfXJ","../../tensor":"eFW4"}],"X5st":[function(require,module,exports) {
"use strict";var e=require("../../ops/reshape"),s=require("../../tensor");(0,s.getGlobalTensorClass)().prototype.flatten=function(){return this.throwIfDisposed(),(0,e.reshape)(this,[this.size])};
},{"../../ops/reshape":"F0cm","../../tensor":"eFW4"}],"jFXa":[function(require,module,exports) {
"use strict";var o=require("../../ops/ops"),r=require("../../tensor");(0,r.getGlobalTensorClass)().prototype.floor=function(){return this.throwIfDisposed(),(0,o.floor)(this)};
},{"../../ops/ops":"hfXJ","../../tensor":"eFW4"}],"MdKh":[function(require,module,exports) {
"use strict";var o=require("../../ops/floorDiv"),r=require("../../tensor");(0,r.getGlobalTensorClass)().prototype.floorDiv=function(r){return this.throwIfDisposed(),(0,o.floorDiv)(this,r)};
},{"../../ops/floorDiv":"OIz3","../../tensor":"eFW4"}],"CGsS":[function(require,module,exports) {
"use strict";var r=require("../../ops/gather"),e=require("../../tensor");(0,e.getGlobalTensorClass)().prototype.gather=function(e,t,s){return this.throwIfDisposed(),(0,r.gather)(this,e,t,s)};
},{"../../ops/gather":"TfxI","../../tensor":"eFW4"}],"fhpv":[function(require,module,exports) {
"use strict";var e=require("../../ops/greater_equal"),r=require("../../tensor");(0,r.getGlobalTensorClass)().prototype.greaterEqual=function(r){return this.throwIfDisposed(),(0,e.greaterEqual)(this,r)};
},{"../../ops/greater_equal":"a6nY","../../tensor":"eFW4"}],"u5aQ":[function(require,module,exports) {
"use strict";var r=require("../../ops/greater"),e=require("../../tensor");(0,e.getGlobalTensorClass)().prototype.greater=function(e){return this.throwIfDisposed(),(0,r.greater)(this,e)};
},{"../../ops/greater":"WT29","../../tensor":"eFW4"}],"SRMD":[function(require,module,exports) {
"use strict";var t=require("../../ops/ops"),r=require("../../tensor");(0,r.getGlobalTensorClass)().prototype.ifft=function(){return this.throwIfDisposed(),(0,t.ifft)(this)};
},{"../../ops/ops":"hfXJ","../../tensor":"eFW4"}],"STV0":[function(require,module,exports) {
"use strict";var r=require("../../ops/ops"),t=require("../../tensor");(0,t.getGlobalTensorClass)().prototype.irfft=function(){return this.throwIfDisposed(),(0,r.irfft)(this)};
},{"../../ops/ops":"hfXJ","../../tensor":"eFW4"}],"MYWd":[function(require,module,exports) {
"use strict";var s=require("../../ops/ops"),e=require("../../tensor");(0,e.getGlobalTensorClass)().prototype.isFinite=function(){return this.throwIfDisposed(),(0,s.isFinite)(this)};
},{"../../ops/ops":"hfXJ","../../tensor":"eFW4"}],"rbeL":[function(require,module,exports) {
"use strict";var s=require("../../ops/ops"),r=require("../../tensor");(0,r.getGlobalTensorClass)().prototype.isInf=function(){return this.throwIfDisposed(),(0,s.isInf)(this)};
},{"../../ops/ops":"hfXJ","../../tensor":"eFW4"}],"Jyfk":[function(require,module,exports) {
"use strict";var s=require("../../ops/ops"),r=require("../../tensor");(0,r.getGlobalTensorClass)().prototype.isNaN=function(){return this.throwIfDisposed(),(0,s.isNaN)(this)};
},{"../../ops/ops":"hfXJ","../../tensor":"eFW4"}],"NPvE":[function(require,module,exports) {
"use strict";var e=require("../../ops/leaky_relu"),r=require("../../tensor");(0,r.getGlobalTensorClass)().prototype.leakyRelu=function(r){return this.throwIfDisposed(),(0,e.leakyRelu)(this,r)};
},{"../../ops/leaky_relu":"RYa8","../../tensor":"eFW4"}],"RqP6":[function(require,module,exports) {
"use strict";var s=require("../../ops/less_equal"),e=require("../../tensor");(0,e.getGlobalTensorClass)().prototype.lessEqual=function(e){return this.throwIfDisposed(),(0,s.lessEqual)(this,e)};
},{"../../ops/less_equal":"vnhI","../../tensor":"eFW4"}],"xfxR":[function(require,module,exports) {
"use strict";var s=require("../../ops/less"),e=require("../../tensor");(0,e.getGlobalTensorClass)().prototype.less=function(e){return this.throwIfDisposed(),(0,s.less)(this,e)};
},{"../../ops/less":"onA7","../../tensor":"eFW4"}],"wWpR":[function(require,module,exports) {
"use strict";var o=require("../../ops/local_response_normalization"),e=require("../../tensor");(0,e.getGlobalTensorClass)().prototype.localResponseNormalization=function(e,s,r,t){return this.throwIfDisposed(),(0,o.localResponseNormalization)(this,e,s,r,t)};
},{"../../ops/local_response_normalization":"uT9U","../../tensor":"eFW4"}],"BwxK":[function(require,module,exports) {
"use strict";var o=require("../../ops/ops"),r=require("../../tensor");(0,r.getGlobalTensorClass)().prototype.logSigmoid=function(){return this.throwIfDisposed(),(0,o.logSigmoid)(this)};
},{"../../ops/ops":"hfXJ","../../tensor":"eFW4"}],"ynVN":[function(require,module,exports) {
"use strict";var o=require("../../ops/ops"),t=require("../../tensor");(0,t.getGlobalTensorClass)().prototype.logSoftmax=function(t){return this.throwIfDisposed(),(0,o.logSoftmax)(this,t)};
},{"../../ops/ops":"hfXJ","../../tensor":"eFW4"}],"wcnQ":[function(require,module,exports) {
"use strict";var e=require("../../ops/log_sum_exp"),o=require("../../tensor");(0,o.getGlobalTensorClass)().prototype.logSumExp=function(o,r){return this.throwIfDisposed(),(0,e.logSumExp)(this,o,r)};
},{"../../ops/log_sum_exp":"te98","../../tensor":"eFW4"}],"Nx3c":[function(require,module,exports) {
"use strict";var o=require("../../ops/ops"),r=require("../../tensor");(0,r.getGlobalTensorClass)().prototype.log=function(){return this.throwIfDisposed(),(0,o.log)(this)};
},{"../../ops/ops":"hfXJ","../../tensor":"eFW4"}],"AhKw":[function(require,module,exports) {
"use strict";var o=require("../../ops/ops"),r=require("../../tensor");(0,r.getGlobalTensorClass)().prototype.log1p=function(){return this.throwIfDisposed(),(0,o.log1p)(this)};
},{"../../ops/ops":"hfXJ","../../tensor":"eFW4"}],"YWjn":[function(require,module,exports) {
"use strict";var o=require("../../ops/logical_and"),r=require("../../tensor");(0,r.getGlobalTensorClass)().prototype.logicalAnd=function(r){return this.throwIfDisposed(),(0,o.logicalAnd)(this,r)};
},{"../../ops/logical_and":"sHir","../../tensor":"eFW4"}],"dCep":[function(require,module,exports) {
"use strict";var o=require("../../ops/logical_not"),t=require("../../tensor");(0,t.getGlobalTensorClass)().prototype.logicalNot=function(){return this.throwIfDisposed(),(0,o.logicalNot)(this)};
},{"../../ops/logical_not":"jt3a","../../tensor":"eFW4"}],"L5Ei":[function(require,module,exports) {
"use strict";var r=require("../../ops/logical_or"),o=require("../../tensor");(0,o.getGlobalTensorClass)().prototype.logicalOr=function(o){return this.throwIfDisposed(),(0,r.logicalOr)(this,o)};
},{"../../ops/logical_or":"cBH6","../../tensor":"eFW4"}],"ILDu":[function(require,module,exports) {
"use strict";var o=require("../../ops/logical_xor"),r=require("../../tensor");(0,r.getGlobalTensorClass)().prototype.logicalXor=function(r){return this.throwIfDisposed(),(0,o.logicalXor)(this,r)};
},{"../../ops/logical_xor":"RGME","../../tensor":"eFW4"}],"OqlU":[function(require,module,exports) {
"use strict";var t=require("../../ops/mat_mul"),r=require("../../tensor");(0,r.getGlobalTensorClass)().prototype.matMul=function(r,e,s){return this.throwIfDisposed(),(0,t.matMul)(this,r,e,s)};
},{"../../ops/mat_mul":"zVDr","../../tensor":"eFW4"}],"A0FP":[function(require,module,exports) {
"use strict";var o=require("../../ops/max_pool"),r=require("../../tensor");(0,r.getGlobalTensorClass)().prototype.maxPool=function(r,e,s,t){return this.throwIfDisposed(),(0,o.maxPool)(this,r,e,s,t)};
},{"../../ops/max_pool":"g3Dm","../../tensor":"eFW4"}],"r7kF":[function(require,module,exports) {
"use strict";var r=require("../../ops/max"),e=require("../../tensor");(0,e.getGlobalTensorClass)().prototype.max=function(e,s){return this.throwIfDisposed(),(0,r.max)(this,e,s)};
},{"../../ops/max":"KIVY","../../tensor":"eFW4"}],"YNXq":[function(require,module,exports) {
"use strict";var r=require("../../ops/maximum"),e=require("../../tensor");(0,e.getGlobalTensorClass)().prototype.maximum=function(e){return this.throwIfDisposed(),(0,r.maximum)(this,e)};
},{"../../ops/maximum":"E33m","../../tensor":"eFW4"}],"M8yh":[function(require,module,exports) {
"use strict";var e=require("../../ops/mean"),r=require("../../tensor");(0,r.getGlobalTensorClass)().prototype.mean=function(r,s){return this.throwIfDisposed(),(0,e.mean)(this,r,s)};
},{"../../ops/mean":"DIOh","../../tensor":"eFW4"}],"Dxnk":[function(require,module,exports) {
"use strict";var r=require("../../ops/min"),e=require("../../tensor");(0,e.getGlobalTensorClass)().prototype.min=function(e,s){return this.throwIfDisposed(),(0,r.min)(this,e,s)};
},{"../../ops/min":"pkmC","../../tensor":"eFW4"}],"vWeU":[function(require,module,exports) {
"use strict";var i=require("../../ops/minimum"),r=require("../../tensor");(0,r.getGlobalTensorClass)().prototype.minimum=function(r){return this.throwIfDisposed(),(0,i.minimum)(this,r)};
},{"../../ops/minimum":"TKku","../../tensor":"eFW4"}],"MlTX":[function(require,module,exports) {
"use strict";var r=require("../../ops/mirror_pad"),o=require("../../tensor");(0,o.getGlobalTensorClass)().prototype.mirrorPad=function(o,e){return this.throwIfDisposed(),(0,r.mirrorPad)(this,o,e)};
},{"../../ops/mirror_pad":"y7Tc","../../tensor":"eFW4"}],"csnH":[function(require,module,exports) {
"use strict";var o=require("../../ops/mod"),r=require("../../tensor");(0,r.getGlobalTensorClass)().prototype.mod=function(r){return this.throwIfDisposed(),(0,o.mod)(this,r)};
},{"../../ops/mod":"cyrT","../../tensor":"eFW4"}],"r0zp":[function(require,module,exports) {
"use strict";var r=require("../../ops/mul"),e=require("../../tensor");(0,e.getGlobalTensorClass)().prototype.mul=function(e){return this.throwIfDisposed(),(0,r.mul)(this,e)};
},{"../../ops/mul":"tBJ4","../../tensor":"eFW4"}],"fwt6":[function(require,module,exports) {
"use strict";var e=require("../../ops/ops"),r=require("../../tensor");(0,r.getGlobalTensorClass)().prototype.neg=function(){return this.throwIfDisposed(),(0,e.neg)(this)};
},{"../../ops/ops":"hfXJ","../../tensor":"eFW4"}],"Nydg":[function(require,module,exports) {
"use strict";var r=require("../../ops/ops"),o=require("../../tensor");(0,o.getGlobalTensorClass)().prototype.norm=function(o,s,e){return this.throwIfDisposed(),(0,r.norm)(this,o,s,e)};
},{"../../ops/ops":"hfXJ","../../tensor":"eFW4"}],"o23G":[function(require,module,exports) {
"use strict";var t=require("../../ops/not_equal"),e=require("../../tensor");(0,e.getGlobalTensorClass)().prototype.notEqual=function(e){return this.throwIfDisposed(),(0,t.notEqual)(this,e)};
},{"../../ops/not_equal":"TOzH","../../tensor":"eFW4"}],"CMoT":[function(require,module,exports) {
"use strict";var o=require("../../ops/one_hot"),e=require("../../tensor");(0,e.getGlobalTensorClass)().prototype.oneHot=function(e,t=1,r=0){return this.throwIfDisposed(),(0,o.oneHot)(this,e,t,r)};
},{"../../ops/one_hot":"HpS0","../../tensor":"eFW4"}],"DFVG":[function(require,module,exports) {
"use strict";var e=require("../../ops/ops"),s=require("../../tensor");(0,s.getGlobalTensorClass)().prototype.onesLike=function(){return this.throwIfDisposed(),(0,e.onesLike)(this)};
},{"../../ops/ops":"hfXJ","../../tensor":"eFW4"}],"lSix":[function(require,module,exports) {
"use strict";var r=require("../../ops/pad"),e=require("../../tensor");(0,e.getGlobalTensorClass)().prototype.pad=function(e,s){return this.throwIfDisposed(),(0,r.pad)(this,e,s)};
},{"../../ops/pad":"y7nM","../../tensor":"eFW4"}],"PpMu":[function(require,module,exports) {
"use strict";var o=require("../../ops/pool"),r=require("../../tensor");(0,r.getGlobalTensorClass)().prototype.pool=function(r,e,s,t,i,p){return this.throwIfDisposed(),(0,o.pool)(this,r,e,s,t,i,p)};
},{"../../ops/pool":"Zp2S","../../tensor":"eFW4"}],"udOC":[function(require,module,exports) {
"use strict";var o=require("../../ops/pow"),r=require("../../tensor");(0,r.getGlobalTensorClass)().prototype.pow=function(r){return this.throwIfDisposed(),(0,o.pow)(this,r)};
},{"../../ops/pow":"o2Kl","../../tensor":"eFW4"}],"mxpU":[function(require,module,exports) {
"use strict";var r=require("../../ops/prelu"),e=require("../../tensor");(0,e.getGlobalTensorClass)().prototype.prelu=function(e){return this.throwIfDisposed(),(0,r.prelu)(this,e)};
},{"../../ops/prelu":"Xs9q","../../tensor":"eFW4"}],"ca3x":[function(require,module,exports) {
"use strict";var r=require("../../ops/prod"),o=require("../../tensor");(0,o.getGlobalTensorClass)().prototype.prod=function(o,e){return this.throwIfDisposed(),(0,r.prod)(this,o,e)};
},{"../../ops/prod":"V8As","../../tensor":"eFW4"}],"TJVM":[function(require,module,exports) {
"use strict";var r=require("../../ops/ops"),e=require("../../tensor");(0,e.getGlobalTensorClass)().prototype.reciprocal=function(){return this.throwIfDisposed(),(0,r.reciprocal)(this)};
},{"../../ops/ops":"hfXJ","../../tensor":"eFW4"}],"Pddb":[function(require,module,exports) {
"use strict";var r=require("../../ops/relu"),e=require("../../tensor");(0,e.getGlobalTensorClass)().prototype.relu=function(){return this.throwIfDisposed(),(0,r.relu)(this)};
},{"../../ops/relu":"JbIg","../../tensor":"eFW4"}],"zmqc":[function(require,module,exports) {
"use strict";var r=require("../../ops/relu6"),e=require("../../tensor");(0,e.getGlobalTensorClass)().prototype.relu6=function(){return this.throwIfDisposed(),(0,r.relu6)(this)};
},{"../../ops/relu6":"urTr","../../tensor":"eFW4"}],"BxoW":[function(require,module,exports) {
"use strict";var e=require("../../ops/reshape"),s=require("../../tensor");(0,s.getGlobalTensorClass)().prototype.reshapeAs=function(s){return this.throwIfDisposed(),(0,e.reshape)(this,s.shape)};
},{"../../ops/reshape":"F0cm","../../tensor":"eFW4"}],"w0UW":[function(require,module,exports) {
"use strict";var e=require("../../ops/reshape"),r=require("../../tensor");(0,r.getGlobalTensorClass)().prototype.reshape=function(r){return this.throwIfDisposed(),(0,e.reshape)(this,r)};
},{"../../ops/reshape":"F0cm","../../tensor":"eFW4"}],"XeL8":[function(require,module,exports) {
"use strict";var e=require("../../ops/image/resize_bilinear"),r=require("../../tensor");(0,r.getGlobalTensorClass)().prototype.resizeBilinear=function(r,i,s){return this.throwIfDisposed(),(0,e.resizeBilinear)(this,r,i,s)};
},{"../../ops/image/resize_bilinear":"JODz","../../tensor":"eFW4"}],"j5Dy":[function(require,module,exports) {
"use strict";var e=require("../../ops/image/resize_nearest_neighbor"),r=require("../../tensor");(0,r.getGlobalTensorClass)().prototype.resizeNearestNeighbor=function(r,s,i){return this.throwIfDisposed(),(0,e.resizeNearestNeighbor)(this,r,s,i)};
},{"../../ops/image/resize_nearest_neighbor":"rQ9Q","../../tensor":"eFW4"}],"JUBd":[function(require,module,exports) {
"use strict";var e=require("../../ops/reverse"),r=require("../../tensor");(0,r.getGlobalTensorClass)().prototype.reverse=function(r){return this.throwIfDisposed(),(0,e.reverse)(this,r)};
},{"../../ops/reverse":"JJIO","../../tensor":"eFW4"}],"Vyh6":[function(require,module,exports) {
"use strict";var r=require("../../ops/ops"),t=require("../../tensor");(0,t.getGlobalTensorClass)().prototype.rfft=function(){return this.throwIfDisposed(),(0,r.rfft)(this)};
},{"../../ops/ops":"hfXJ","../../tensor":"eFW4"}],"YUlO":[function(require,module,exports) {
"use strict";var r=require("../../ops/ops"),o=require("../../tensor");(0,o.getGlobalTensorClass)().prototype.round=function(){return this.throwIfDisposed(),(0,r.round)(this)};
},{"../../ops/ops":"hfXJ","../../tensor":"eFW4"}],"HpOj":[function(require,module,exports) {
"use strict";var r=require("../../ops/ops"),s=require("../../tensor");(0,s.getGlobalTensorClass)().prototype.rsqrt=function(){return this.throwIfDisposed(),(0,r.rsqrt)(this)};
},{"../../ops/ops":"hfXJ","../../tensor":"eFW4"}],"oEYI":[function(require,module,exports) {
"use strict";var e=require("../../ops/selu"),s=require("../../tensor");(0,s.getGlobalTensorClass)().prototype.selu=function(){return this.throwIfDisposed(),(0,e.selu)(this)};
},{"../../ops/selu":"HaUr","../../tensor":"eFW4"}],"Jitb":[function(require,module,exports) {
"use strict";var e=require("../../ops/separable_conv2d"),r=require("../../tensor");(0,r.getGlobalTensorClass)().prototype.separableConv2d=function(r,s,o,t,a,n){return this.throwIfDisposed(),(0,e.separableConv2d)(this,r,s,o,t,a,n)};
},{"../../ops/separable_conv2d":"PKLM","../../tensor":"eFW4"}],"Grb4":[function(require,module,exports) {
"use strict";var s=require("../../ops/ops"),o=require("../../tensor");(0,o.getGlobalTensorClass)().prototype.sigmoid=function(){return this.throwIfDisposed(),(0,s.sigmoid)(this)};
},{"../../ops/ops":"hfXJ","../../tensor":"eFW4"}],"ZpkY":[function(require,module,exports) {
"use strict";var s=require("../../ops/ops"),r=require("../../tensor");(0,r.getGlobalTensorClass)().prototype.sign=function(){return this.throwIfDisposed(),(0,s.sign)(this)};
},{"../../ops/ops":"hfXJ","../../tensor":"eFW4"}],"tldY":[function(require,module,exports) {
"use strict";var s=require("../../ops/ops"),r=require("../../tensor");(0,r.getGlobalTensorClass)().prototype.sin=function(){return this.throwIfDisposed(),(0,s.sin)(this)};
},{"../../ops/ops":"hfXJ","../../tensor":"eFW4"}],"bZQs":[function(require,module,exports) {
"use strict";var s=require("../../ops/ops"),r=require("../../tensor");(0,r.getGlobalTensorClass)().prototype.sinh=function(){return this.throwIfDisposed(),(0,s.sinh)(this)};
},{"../../ops/ops":"hfXJ","../../tensor":"eFW4"}],"X48Y":[function(require,module,exports) {
"use strict";var s=require("../../ops/ops"),e=require("../../tensor");(0,e.getGlobalTensorClass)().prototype.slice=function(e,r){return this.throwIfDisposed(),(0,s.slice)(this,e,r)};
},{"../../ops/ops":"hfXJ","../../tensor":"eFW4"}],"aAfU":[function(require,module,exports) {
"use strict";var s=require("../../ops/ops"),t=require("../../tensor");(0,t.getGlobalTensorClass)().prototype.softmax=function(t){return this.throwIfDisposed(),(0,s.softmax)(this,t)};
},{"../../ops/ops":"hfXJ","../../tensor":"eFW4"}],"KpLM":[function(require,module,exports) {
"use strict";var s=require("../../ops/ops"),t=require("../../tensor");(0,t.getGlobalTensorClass)().prototype.softplus=function(){return this.throwIfDisposed(),(0,s.softplus)(this)};
},{"../../ops/ops":"hfXJ","../../tensor":"eFW4"}],"qbVH":[function(require,module,exports) {
"use strict";var t=require("../../ops/space_to_batch_nd"),e=require("../../tensor");(0,e.getGlobalTensorClass)().prototype.spaceToBatchND=function(e,s){return this.throwIfDisposed(),(0,t.spaceToBatchND)(this,e,s)};
},{"../../ops/space_to_batch_nd":"ERrS","../../tensor":"eFW4"}],"Tzks":[function(require,module,exports) {
"use strict";var s=require("../../ops/split"),t=require("../../tensor");(0,t.getGlobalTensorClass)().prototype.split=function(t,r){return this.throwIfDisposed(),(0,s.split)(this,t,r)};
},{"../../ops/split":"lgPf","../../tensor":"eFW4"}],"L8Lm":[function(require,module,exports) {
"use strict";var r=require("../../ops/ops"),s=require("../../tensor");(0,s.getGlobalTensorClass)().prototype.sqrt=function(){return this.throwIfDisposed(),(0,r.sqrt)(this)};
},{"../../ops/ops":"hfXJ","../../tensor":"eFW4"}],"m4Eg":[function(require,module,exports) {
"use strict";var r=require("../../ops/ops"),s=require("../../tensor");(0,s.getGlobalTensorClass)().prototype.square=function(){return this.throwIfDisposed(),(0,r.square)(this)};
},{"../../ops/ops":"hfXJ","../../tensor":"eFW4"}],"wdZg":[function(require,module,exports) {
"use strict";var e=require("../../ops/squared_difference"),r=require("../../tensor");(0,r.getGlobalTensorClass)().prototype.squaredDifference=function(r){return this.throwIfDisposed(),(0,e.squaredDifference)(this,r)};
},{"../../ops/squared_difference":"hbAV","../../tensor":"eFW4"}],"G3Wj":[function(require,module,exports) {
"use strict";var e=require("../../ops/squeeze"),s=require("../../tensor");(0,s.getGlobalTensorClass)().prototype.squeeze=function(s){return this.throwIfDisposed(),(0,e.squeeze)(this,s)};
},{"../../ops/squeeze":"pxYL","../../tensor":"eFW4"}],"n8bw":[function(require,module,exports) {
"use strict";var s=require("../../ops/stack"),t=require("../../tensor");(0,t.getGlobalTensorClass)().prototype.stack=function(e,r){this.throwIfDisposed();const o=e instanceof t.Tensor?[this,e]:[this,...e];return(0,s.stack)(o,r)};
},{"../../ops/stack":"Wzzr","../../tensor":"eFW4"}],"OAgb":[function(require,module,exports) {
"use strict";var s=require("../../ops/ops"),e=require("../../tensor");(0,e.getGlobalTensorClass)().prototype.step=function(e){return this.throwIfDisposed(),(0,s.step)(this,e)};
},{"../../ops/ops":"hfXJ","../../tensor":"eFW4"}],"p438":[function(require,module,exports) {
"use strict";var e=require("../../ops/ops"),r=require("../../tensor");(0,r.getGlobalTensorClass)().prototype.stridedSlice=function(r,s,t,i,o,d,l,n){return this.throwIfDisposed(),(0,e.stridedSlice)(this,r,s,t,i,o,d,l,n)};
},{"../../ops/ops":"hfXJ","../../tensor":"eFW4"}],"Pwmn":[function(require,module,exports) {
"use strict";var s=require("../../ops/sub"),r=require("../../tensor");(0,r.getGlobalTensorClass)().prototype.sub=function(r){return this.throwIfDisposed(),(0,s.sub)(this,r)};
},{"../../ops/sub":"SgzI","../../tensor":"eFW4"}],"E18A":[function(require,module,exports) {
"use strict";var s=require("../../ops/sum"),r=require("../../tensor");(0,r.getGlobalTensorClass)().prototype.sum=function(r,e){return this.throwIfDisposed(),(0,s.sum)(this,r,e)};
},{"../../ops/sum":"kc8w","../../tensor":"eFW4"}],"Ymc6":[function(require,module,exports) {
"use strict";var t=require("../../ops/ops"),r=require("../../tensor");(0,r.getGlobalTensorClass)().prototype.tan=function(){return this.throwIfDisposed(),(0,t.tan)(this)};
},{"../../ops/ops":"hfXJ","../../tensor":"eFW4"}],"o3uo":[function(require,module,exports) {
"use strict";var t=require("../../ops/ops"),r=require("../../tensor");(0,r.getGlobalTensorClass)().prototype.tanh=function(){return this.throwIfDisposed(),(0,t.tanh)(this)};
},{"../../ops/ops":"hfXJ","../../tensor":"eFW4"}],"C6QK":[function(require,module,exports) {
"use strict";var e=require("../../ops/tile"),t=require("../../tensor");(0,t.getGlobalTensorClass)().prototype.tile=function(t){return this.throwIfDisposed(),(0,e.tile)(this,t)};
},{"../../ops/tile":"DlNu","../../tensor":"eFW4"}],"Xw2i":[function(require,module,exports) {
"use strict";var o=require("../../ops/ops"),s=require("../../tensor");(0,s.getGlobalTensorClass)().prototype.toBool=function(){return this.throwIfDisposed(),(0,o.cast)(this,"bool")};
},{"../../ops/ops":"hfXJ","../../tensor":"eFW4"}],"EzPG":[function(require,module,exports) {
"use strict";var t=require("../../ops/ops"),o=require("../../tensor");(0,o.getGlobalTensorClass)().prototype.toFloat=function(){return this.throwIfDisposed(),(0,t.cast)(this,"float32")};
},{"../../ops/ops":"hfXJ","../../tensor":"eFW4"}],"o6EO":[function(require,module,exports) {
"use strict";var t=require("../../ops/ops"),s=require("../../tensor");(0,s.getGlobalTensorClass)().prototype.toInt=function(){return this.throwIfDisposed(),(0,t.cast)(this,"int32")};
},{"../../ops/ops":"hfXJ","../../tensor":"eFW4"}],"WFMh":[function(require,module,exports) {
"use strict";var t=require("../../ops/topk"),o=require("../../tensor");(0,o.getGlobalTensorClass)().prototype.topk=function(o,r){return this.throwIfDisposed(),(0,t.topk)(this,o,r)};
},{"../../ops/topk":"Hv3o","../../tensor":"eFW4"}],"cnzs":[function(require,module,exports) {
"use strict";var s=require("../../ops/transpose"),r=require("../../tensor");(0,r.getGlobalTensorClass)().prototype.transpose=function(r){return this.throwIfDisposed(),(0,s.transpose)(this,r)};
},{"../../ops/transpose":"JmRY","../../tensor":"eFW4"}],"PSxZ":[function(require,module,exports) {
"use strict";var e=require("../../ops/unique"),r=require("../../tensor");(0,r.getGlobalTensorClass)().prototype.unique=function(r){return this.throwIfDisposed(),(0,e.unique)(this,r)};
},{"../../ops/unique":"LuF4","../../tensor":"eFW4"}],"A9qd":[function(require,module,exports) {
"use strict";var e=require("../../ops/unsorted_segment_sum"),t=require("../../tensor");(0,t.getGlobalTensorClass)().prototype.unsortedSegmentSum=function(t,s){return this.throwIfDisposed(),(0,e.unsortedSegmentSum)(this,t,s)};
},{"../../ops/unsorted_segment_sum":"oY1I","../../tensor":"eFW4"}],"Gi7U":[function(require,module,exports) {
"use strict";var s=require("../../ops/unstack"),t=require("../../tensor");(0,t.getGlobalTensorClass)().prototype.unstack=function(t){return this.throwIfDisposed(),(0,s.unstack)(this,t)};
},{"../../ops/unstack":"Smo9","../../tensor":"eFW4"}],"XSIc":[function(require,module,exports) {
"use strict";var e=require("../../ops/where"),r=require("../../tensor");(0,r.getGlobalTensorClass)().prototype.where=function(r,s){return this.throwIfDisposed(),(0,e.where)(r,this,s)};
},{"../../ops/where":"TsgC","../../tensor":"eFW4"}],"tDUC":[function(require,module,exports) {
"use strict";var e=require("../../ops/ops"),r=require("../../tensor");(0,r.getGlobalTensorClass)().prototype.zerosLike=function(){return this.throwIfDisposed(),(0,e.zerosLike)(this)};
},{"../../ops/ops":"hfXJ","../../tensor":"eFW4"}],"BFpO":[function(require,module,exports) {
"use strict";require("./abs"),require("./acos"),require("./acosh"),require("./add"),require("./all"),require("./any"),require("./arg_max"),require("./arg_min"),require("./as_scalar"),require("./as_type"),require("./as1d"),require("./as2d"),require("./as3d"),require("./as4d"),require("./as5d"),require("./asin"),require("./asinh"),require("./atan"),require("./atan2"),require("./atanh"),require("./avg_pool"),require("./batch_to_space_nd"),require("./batchnorm"),require("./broadcast_to"),require("./cast"),require("./ceil"),require("./clip_by_value"),require("./concat"),require("./conv1d"),require("./conv2d_transpose"),require("./conv2d"),require("./cos"),require("./cosh"),require("./cumprod"),require("./cumsum"),require("./depth_to_space"),require("./depthwise_conv2d"),require("./dilation2d"),require("./div_no_nan"),require("./div"),require("./dot"),require("./elu"),require("./equal"),require("./erf"),require("./euclidean_norm"),require("./exp"),require("./expand_dims"),require("./expm1"),require("./fft"),require("./flatten"),require("./floor"),require("./floorDiv"),require("./gather"),require("./greater_equal"),require("./greater"),require("./ifft"),require("./irfft"),require("./is_finite"),require("./is_inf"),require("./is_nan"),require("./leaky_relu"),require("./less_equal"),require("./less"),require("./local_response_normalization"),require("./log_sigmoid"),require("./log_softmax"),require("./log_sum_exp"),require("./log"),require("./log1p"),require("./logical_and"),require("./logical_not"),require("./logical_or"),require("./logical_xor"),require("./mat_mul"),require("./max_pool"),require("./max"),require("./maximum"),require("./mean"),require("./min"),require("./minimum"),require("./mirror_pad"),require("./mod"),require("./mul"),require("./neg"),require("./norm"),require("./not_equal"),require("./one_hot"),require("./ones_like"),require("./pad"),require("./pool"),require("./pow"),require("./prelu"),require("./prod"),require("./reciprocal"),require("./relu"),require("./relu6"),require("./reshape_as"),require("./reshape"),require("./resize_bilinear"),require("./resize_nearest_neighbor"),require("./reverse"),require("./rfft"),require("./round"),require("./rsqrt"),require("./selu"),require("./separable_conv2d"),require("./sigmoid"),require("./sign"),require("./sin"),require("./sinh"),require("./slice"),require("./softmax"),require("./softplus"),require("./space_to_batch_nd"),require("./split"),require("./sqrt"),require("./square"),require("./squared_difference"),require("./squeeze"),require("./stack"),require("./step"),require("./strided_slice"),require("./sub"),require("./sum"),require("./tan"),require("./tanh"),require("./tile"),require("./to_bool"),require("./to_float"),require("./to_int"),require("./topk"),require("./transpose"),require("./unique"),require("./unsorted_segment_sum"),require("./unstack"),require("./where"),require("./zeros_like");
},{"./abs":"AUNX","./acos":"DV3p","./acosh":"hGyB","./add":"WMvU","./all":"RcHq","./any":"T9Ol","./arg_max":"KCW7","./arg_min":"kfmH","./as_scalar":"DCsN","./as_type":"SqNb","./as1d":"cC4K","./as2d":"ITbF","./as3d":"CtfD","./as4d":"pSwS","./as5d":"E3Tm","./asin":"HBo0","./asinh":"EahO","./atan":"JAxw","./atan2":"pxNX","./atanh":"Ak1n","./avg_pool":"HPUt","./batch_to_space_nd":"TB8q","./batchnorm":"QQ1Z","./broadcast_to":"lBH2","./cast":"xa9M","./ceil":"ba0E","./clip_by_value":"VXS2","./concat":"kFde","./conv1d":"CFcA","./conv2d_transpose":"fWT8","./conv2d":"a47A","./cos":"mvzD","./cosh":"uhP2","./cumprod":"EPQ9","./cumsum":"Itdd","./depth_to_space":"b5Ls","./depthwise_conv2d":"z4QP","./dilation2d":"fqks","./div_no_nan":"OqXz","./div":"CYEi","./dot":"VowQ","./elu":"CQoI","./equal":"jVkX","./erf":"kbSS","./euclidean_norm":"N8xJ","./exp":"t9B7","./expand_dims":"EXTx","./expm1":"p0bR","./fft":"ocg5","./flatten":"X5st","./floor":"jFXa","./floorDiv":"MdKh","./gather":"CGsS","./greater_equal":"fhpv","./greater":"u5aQ","./ifft":"SRMD","./irfft":"STV0","./is_finite":"MYWd","./is_inf":"rbeL","./is_nan":"Jyfk","./leaky_relu":"NPvE","./less_equal":"RqP6","./less":"xfxR","./local_response_normalization":"wWpR","./log_sigmoid":"BwxK","./log_softmax":"ynVN","./log_sum_exp":"wcnQ","./log":"Nx3c","./log1p":"AhKw","./logical_and":"YWjn","./logical_not":"dCep","./logical_or":"L5Ei","./logical_xor":"ILDu","./mat_mul":"OqlU","./max_pool":"A0FP","./max":"r7kF","./maximum":"YNXq","./mean":"M8yh","./min":"Dxnk","./minimum":"vWeU","./mirror_pad":"MlTX","./mod":"csnH","./mul":"r0zp","./neg":"fwt6","./norm":"Nydg","./not_equal":"o23G","./one_hot":"CMoT","./ones_like":"DFVG","./pad":"lSix","./pool":"PpMu","./pow":"udOC","./prelu":"mxpU","./prod":"ca3x","./reciprocal":"TJVM","./relu":"Pddb","./relu6":"zmqc","./reshape_as":"BxoW","./reshape":"w0UW","./resize_bilinear":"XeL8","./resize_nearest_neighbor":"j5Dy","./reverse":"JUBd","./rfft":"Vyh6","./round":"YUlO","./rsqrt":"HpOj","./selu":"oEYI","./separable_conv2d":"Jitb","./sigmoid":"Grb4","./sign":"ZpkY","./sin":"tldY","./sinh":"bZQs","./slice":"X48Y","./softmax":"aAfU","./softplus":"KpLM","./space_to_batch_nd":"qbVH","./split":"Tzks","./sqrt":"L8Lm","./square":"m4Eg","./squared_difference":"wdZg","./squeeze":"G3Wj","./stack":"n8bw","./step":"OAgb","./strided_slice":"p438","./sub":"Pwmn","./sum":"E18A","./tan":"Ymc6","./tanh":"o3uo","./tile":"C6QK","./to_bool":"Xw2i","./to_float":"EzPG","./to_int":"o6EO","./topk":"WFMh","./transpose":"cnzs","./unique":"PSxZ","./unsorted_segment_sum":"A9qd","./unstack":"Gi7U","./where":"XSIc","./zeros_like":"tDUC"}],"iJtr":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.ValueError=exports.RuntimeError=exports.NotImplementedError=exports.IndexError=exports.AttributeError=exports.AssertionError=void 0;class r extends Error{constructor(t){super(t),Object.setPrototypeOf(this,r.prototype)}}exports.AttributeError=r;class t extends Error{constructor(r){super(r),Object.setPrototypeOf(this,t.prototype)}}exports.RuntimeError=t;class e extends Error{constructor(r){super(r),Object.setPrototypeOf(this,e.prototype)}}exports.ValueError=e;class o extends Error{constructor(r){super(r),Object.setPrototypeOf(this,o.prototype)}}exports.NotImplementedError=o;class s extends Error{constructor(r){super(r),Object.setPrototypeOf(this,s.prototype)}}exports.AssertionError=s;class p extends Error{constructor(r){super(r),Object.setPrototypeOf(this,p.prototype)}}exports.IndexError=p;
},{}],"QLpZ":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.LruCache=void 0;class e{constructor(e){this.maxEntries=e||100,this.cache=new Map}get(e){let t;return this.cache.has(e)&&(t=this.cache.get(e),this.cache.delete(e),this.cache.set(e,t)),t}put(e,t){if(this.cache.has(e))this.cache.delete(e);else if(this.cache.size>=this.maxEntries){const e=this.cache.keys().next().value;this.cache.delete(e)}this.cache.set(e,t)}getMaxEntries(){return this.maxEntries}setMaxEntries(e){if(e<0)throw new Error(`The maxEntries of LRU caches must be at least 0, but got ${e}.`);if(this.maxEntries>e)for(let t=0;t<this.maxEntries-e;t++){const e=this.cache.keys().next().value;this.cache.delete(e)}this.maxEntries=e}}exports.LruCache=e;
},{}],"VKwv":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.assert=n,exports.assertPositiveInteger=j,exports.checkArrayTypeAndLength=x,exports.checkStringTypeUnionValue=$,exports.count=o,exports.debounce=O,exports.deserializeKerasObject=y,exports.formatAsFriendlyString=A,exports.getCartesianProductOfValues=E,exports.isObjectEmpty=m,exports.mapActivationToFusedKernel=v,exports.numberCompare=g,exports.objectListUid=a,exports.pyListRepeat=r,exports.reverseNumberCompare=d,exports.serializeKerasObject=f,exports.singletonOrArray=s,exports.stringToDType=h,exports.stringsEqual=w,exports.toCamelCase=u,exports.toList=i,exports.toSnakeCase=l,exports.unique=b;var e=require("@tensorflow/tfjs-core"),t=require("../errors");function r(e,t){if(Array.isArray(e)){let r=[];for(let n=0;n<t;n++)r=r.concat(e);return r}{const r=new Array(t);return r.fill(e),r}}function n(e,r){if(!e)throw new t.AssertionError(r)}function o(e,t){let r=0;for(const n of e)n===t&&r++;return r}function s(e){return 1===e.length?e[0]:e}function i(e){return Array.isArray(e)?e:[e]}function a(e){const r=i(e);let n="";for(const o of r){if(null==o.id)throw new t.ValueError(`Object ${o} passed to objectListUid without an id`);""!==n&&(n+=", "),n=`${n}${Math.abs(o.id)}`}return n}function l(e){const t=e.replace(/(.)([A-Z][a-z0-9]+)/g,"$1_$2").replace(/([a-z])([A-Z])/g,"$1_$2").toLowerCase();return"_"!==t[0]?t:"private"+t}function u(e){return e.length<=1?e:-1===e.indexOf("_")?e:e.replace(/[_]+(\w|$)/g,(e,t)=>t.toUpperCase())}let c={};function f(e){if(null==e)return null;const t={};return t.className=e.getClassName(),t.config=e.getConfig(),t}function p(e){if(null!=e&&"object"==typeof e)if(Array.isArray(e))e.forEach(e=>p(e));else{const t=Object.keys(e);for(const r of t){const t=e[r];null!=t&&"object"==typeof t&&(Array.isArray(t)||"ndarray"!==t.type||"number"!=typeof t.value?p(t):e[r]=t.value)}}}function y(e,r={},n={},o="object",s=!1){if("string"==typeof e){const s=e;let i;if(s in n)i=n[s];else if(s in c)i=c[s];else if(null==(i=r[s]))throw new t.ValueError(`Unknown ${o}: ${e}. `+"This may be due to one of the following reasons:\n"+`1. The ${o} is defined in Python, in which `+"case it needs to be ported to TensorFlow.js or your JavaScript code.\n"+`2. The custom ${o} is defined in JavaScript, `+"but is not registered properly with tf.serialization.registerClass().");return i}{const i=e;if(null==i.className||null==i.config)throw new t.ValueError(`${o}: Improper config format: `+`${JSON.stringify(i)}.\n`+"'className' and 'config' must set.");const a=i.className;let l,u;if(a in n?[l,u]=n[a]:a in c?[l,u]=c.className:a in r&&([l,u]=r[a]),null==l)throw new t.ValueError(`Unknown ${o}: ${a}. `+"This may be due to one of the following reasons:\n"+`1. The ${o} is defined in Python, in which `+"case it needs to be ported to TensorFlow.js or your JavaScript code.\n"+`2. The custom ${o} is defined in JavaScript, `+"but is not registered properly with tf.serialization.registerClass().");if(null!=u){const e={};for(const n of Object.keys(c))e[n]=c[n];for(const o of Object.keys(n))e[o]=n[o];i.config.customObjects=e;const t=Object.assign({},c);for(const o of Object.keys(n))c[o]=n[o];p(i.config);const r=u(l,i.config,n,s);return c=Object.assign({},t),r}{const e=Object.assign({},c);for(const r of Object.keys(n))c[r]=n[r];const t=new l(i.config);return c=Object.assign({},e),t}}}function g(e,t){return e<t?-1:e>t?1:0}function d(e,t){return-1*g(e,t)}function h(e){switch(e){case"float32":return"float32";default:throw new t.ValueError(`Invalid dtype: ${e}`)}}function w(e,t){if(null==e||null==t)return e===t;if(e.length!==t.length)return!1;for(let r=0;r<e.length;++r)if(e[r]!==t[r])return!1;return!0}function b(e){if(null==e)return e;const t=[];for(const r of e)-1===t.indexOf(r)&&t.push(r);return t}function m(e){if(null==e)throw new t.ValueError(`Invalid value in obj: ${JSON.stringify(e)}`);for(const t in e)if(e.hasOwnProperty(t))return!1;return!0}function $(e,r,n){if(null!=n&&e.indexOf(n)<0)throw new t.ValueError(`${n} is not a valid ${r}.  Valid values are ${e} or null/undefined.`)}function x(e,t,r=0,o=1/0){return n(r>=0),n(o>=r),Array.isArray(e)&&e.length>=r&&e.length<=o&&e.every(e=>typeof e===t)}function j(t,r){Array.isArray(t)?(e.util.assert(t.length>0,()=>`${r} is unexpectedly an empty array.`),t.forEach((e,t)=>j(e,`element ${t+1} of ${r}`))):e.util.assert(Number.isInteger(t)&&t>0,()=>`Expected ${r} to be a positive integer, but got `+`${A(t)}.`)}function A(e){return null===e?"null":Array.isArray(e)?"["+e.map(e=>A(e)).join(",")+"]":"string"==typeof e?`"${e}"`:`${e}`}function O(t,r,n){let o,s=null!=n?n():e.util.now();return(...i)=>{const a=null!=n?n():e.util.now();return a-s<r?o:(s=a,o=t(...i))}}function v(e){return"relu"===e?"relu":"linear"===e?"linear":"elu"===e?"elu":null}function E(...e){n(e.length>0,"arrayOfValues is empty");for(const t of e)n(Array.isArray(t),"one of the values is not an array"),n(t.length>0,"one of the values is empty");return e.reduce((e,t)=>0===e.length?t.map(e=>[e]):t.map(t=>e.map(e=>[...e,t])).reduce((e,t)=>e.concat(t),[]),[])}
},{"@tensorflow/tfjs-core":"kSBl","../errors":"iJtr"}],"R2ma":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.getNextUniqueTensorId=t,exports.getUid=r;let e=0;function t(){return e++}const n={};function r(e=""){return e in n||(n[e]=0),n[e]+=1,e+n[e].toString()}
},{}],"pmP2":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.VALID_SAMPLE_WEIGHT_MODES=exports.VALID_POOL_MODE_VALUES=exports.VALID_PADDING_MODE_VALUES=exports.VALID_INTERPOLATION_FORMAT_VALUES=exports.VALID_DATA_FORMAT_VALUES=exports.VALID_BIDIRECTIONAL_MERGE_MODES=void 0;const _=exports.VALID_DATA_FORMAT_VALUES=["channelsFirst","channelsLast"],A=exports.VALID_INTERPOLATION_FORMAT_VALUES=["nearest","bilinear"],e=exports.VALID_PADDING_MODE_VALUES=["valid","same","causal"],L=exports.VALID_POOL_MODE_VALUES=["max","avg"],D=exports.VALID_BIDIRECTIONAL_MERGE_MODES=["sum","mul","concat","ave"],E=exports.VALID_SAMPLE_WEIGHT_MODES=["temporal"];
},{}],"sR6u":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.checkDataFormat=o,exports.checkInterpolationFormat=r,exports.checkPaddingMode=c,exports.checkPoolMode=a,exports.getScopedTensorName=_,exports.getUniqueTensorName=h,exports.isValidTensorName=A,exports.nameScope=u;var e=require("./keras_format/common"),t=require("./utils/generic_utils");const n=new Map;function o(n){(0,t.checkStringTypeUnionValue)(e.VALID_DATA_FORMAT_VALUES,"DataFormat",n)}function r(n){(0,t.checkStringTypeUnionValue)(e.VALID_INTERPOLATION_FORMAT_VALUES,"InterpolationFormat",n)}function c(n){(0,t.checkStringTypeUnionValue)(e.VALID_PADDING_MODE_VALUES,"PaddingMode",n)}function a(n){(0,t.checkStringTypeUnionValue)(e.VALID_POOL_MODE_VALUES,"PoolMode",n)}const i=[],s="/";function u(e,t){i.push(e);try{const e=t();return i.pop(),e}catch(n){throw i.pop(),n}}function p(){return 0===i.length?"":i.join(s)+s}function _(e){if(!A(e))throw new Error("Not a valid tensor name: '"+e+"'");return p()+e}function h(e){if(!A(e))throw new Error("Not a valid tensor name: '"+e+"'");n.has(e)||n.set(e,0);const t=n.get(e);if(n.set(e,n.get(e)+1),t>0){const o=`${e}_${t}`;return n.set(o,1),o}return e}const l=new RegExp(/^[A-Za-z0-9][-A-Za-z0-9\._\/]*$/);function A(e){return!!e.match(l)}
},{"./keras_format/common":"pmP2","./utils/generic_utils":"VKwv"}],"eQAy":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.arrayProd=r,exports.isInteger=t,exports.max=o,exports.mean=l,exports.median=i,exports.min=n,exports.range=f,exports.sum=u,exports.variance=s;var e=require("../errors");function t(e){return e===parseInt(e.toString(),10)}function r(e,t,r){null==t&&(t=0),null==r&&(r=e.length);let n=1;for(let o=t;o<r;++o)n*=e[o];return n}function n(e){if(0===e.length)return Number.NaN;let t=Number.POSITIVE_INFINITY;for(let r=0;r<e.length;r++){const n=e[r];n<t&&(t=n)}return t}function o(e){if(0===e.length)return Number.NaN;let t=Number.NEGATIVE_INFINITY;for(let r=0;r<e.length;r++){const n=e[r];n>t&&(t=n)}return t}function u(e){let t=0;for(let r=0;r<e.length;r++){t+=e[r]}return t}function l(e){return u(e)/e.length}function s(e){const t=l(e),r=e.map(e=>e-t);let n=0;for(let o=0;o<r.length;o++){const e=r[o];n+=e*e}return n/e.length}function i(e){const t=e.slice().sort((e,t)=>e-t),r=Math.floor((t.length-1)/2),n=Math.ceil((t.length-1)/2);return r===n?t[r]:(t[r]+t[n])/2}function f(t,r){if(r<t)throw new e.ValueError(`end (${r}) < begin (${t}) is forbidden.`);const n=[];for(let e=t;e<r;++e)n.push(e);return n}
},{"../errors":"iJtr"}],"VOlA":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.epsilon=n,exports.imageDataFormat=o,exports.setEpsilon=r;var e=require("@tensorflow/tfjs-core");let t;function n(){return null==t&&(t=(0,e.backend)().epsilon()),t}function r(e){t=e}function o(){return"channelsLast"}
},{"@tensorflow/tfjs-core":"kSBl"}],"Ftmo":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.batchFlatten=w,exports.biasAdd=M,exports.cast=l,exports.concatAlongFirstAxis=b,exports.concatenate=g,exports.countParams=h,exports.dot=E,exports.dropout=D,exports.elu=P,exports.expandDims=d,exports.flatten=k,exports.gather=V,exports.getBackend=c,exports.hardSigmoid=N,exports.inTrainPhase=O,exports.isBackendSymbolic=p,exports.oneHot=F,exports.pow=L,exports.randomNormal=$,exports.repeat=f,exports.setBackend=u,exports.sign=v,exports.sliceAlongAxis=y,exports.sliceAlongFirstAxis=x,exports.sliceAlongLastAxis=m,exports.softsign=B,exports.square=q,exports.tile=A;var e=o(require("@tensorflow/tfjs-core")),r=e,t=require("../common"),n=require("../errors"),a=o(require("../utils/math_utils")),s=require("./common");function o(e,r){if("function"==typeof WeakMap)var t=new WeakMap,n=new WeakMap;return(o=function(e,r){if(!r&&e&&e.__esModule)return e;var a,s,o={__proto__:null,default:e};if(null===e||"object"!=typeof e&&"function"!=typeof e)return o;if(a=r?n:t){if(a.has(e))return a.get(e);a.set(e,o)}for(const t in e)"default"!==t&&{}.hasOwnProperty.call(e,t)&&((s=(a=Object.defineProperty)&&Object.getOwnPropertyDescriptor(e,t))&&(s.get||s.set)?a(o,t,s):o[t]=e[t]);return o})(e,r)}let i="webgl";function u(e){r.setBackend(e),i=e}function c(){return i}function p(){return!1}function h(e){const r=e.shape;return r.length>0?r.reduce((e,r)=>e*r):1}function l(e,t){return r.cast(e,t)}function d(e,t=-1){const n=e.shape.slice();return t<0&&(t=n.length+t+1),n.splice(t,0,1),r.reshape(e,n)}function f(r,t){return(0,e.tidy)(()=>{if(2!==r.shape.length)throw new n.ValueError("repeat() expects a rank-2 tensor, but received a "+`rank-${r.shape.length} tensor.`);return A(d(r,1),[1,t,1])})}function k(e){const t=[a.arrayProd(e.shape)];return r.reshape(e,t)}function w(e){if(e.rank<=1)throw new n.ValueError(`batchFlatten requires a minimum rank of 2. Got rank: ${e.rank}.`);const t=[e.shape[0],a.arrayProd(e.shape,1)];return r.reshape(e,t)}function x(t,a,s){return(0,e.tidy)(()=>{switch(t.rank){case 1:return r.slice1d(t,a,s);case 2:return r.slice2d(t,[a,0],[s,t.shape[1]]);case 3:return r.slice3d(t,[a,0,0],[s,t.shape[1],t.shape[2]]);case 4:return r.slice4d(t,[a,0,0,0],[s,t.shape[1],t.shape[2],t.shape[3]]);case 5:return r.slice(t,[a,0,0,0,0],[s,t.shape[1],t.shape[2],t.shape[3],t.shape[4]]);case 6:return r.slice(t,[a,0,0,0,0,0],[s,t.shape[1],t.shape[2],t.shape[3],t.shape[4],t.shape[5]]);default:throw new n.ValueError("sliceAlongFirstAxis() received an unsupported tensor rank: "+`${t.rank}`)}})}function m(t,a,s){return(0,e.tidy)(()=>{switch(t.rank){case 1:return r.slice1d(t,a,s);case 2:return r.slice2d(t,[0,a],[t.shape[0],s]);case 3:return r.slice3d(t,[0,0,a],[t.shape[0],t.shape[1],s]);case 4:return r.slice4d(t,[0,0,0,a],[t.shape[0],t.shape[1],t.shape[2],s]);default:throw new n.ValueError("sliceAlongLastAxis() received an unsupported tensor rank: "+`${t.rank}`)}})}function y(t,a,s,o){return(0,e.tidy)(()=>{switch(t.rank){case 1:return r.slice1d(t,a,s);case 2:switch(o){case 1:return x(t,a,s);case 2:return m(t,a,s);default:throw new n.ValueError("The axis is not within the rank of the tensor "+`${o}`)}case 3:switch(o){case 1:return x(t,a,s);case 2:return r.slice3d(t,[0,a,0],[t.shape[0],s,t.shape[2]]);case 3:return m(t,a,s);default:throw new n.ValueError("The axis is not within the rank of the tensor "+`${o}`)}case 4:switch(o){case 1:return x(t,a,s);case 2:return r.slice4d(t,[0,a,0,0],[t.shape[0],s,t.shape[2],t.shape[3]]);case 3:return r.slice4d(t,[0,0,a,0],[t.shape[0],t.shape[1],s,t.shape[3]]);case 4:return m(t,a,s);default:throw new n.ValueError("The axis is not within the rank of the tensor "+`${o}`)}default:throw new n.ValueError("sliceAlongLastAxis() received an unsupported tensor rank: "+`${t.rank}`)}})}function g(e,t=-1){let n;return t<0&&(t=0!==(n=e[0].rank)?n:0),t===e[0].rank&&(t=-1),r.concat(e,t)}function b(e,t){switch(e.rank){case 1:return r.concat1d([e,t]);case 2:return r.concat2d([e,t],0);case 3:return r.concat3d([e,t],0);case 4:return r.concat4d([e,t],0);default:throw new n.ValueError("concatAlongFirstAxis() received an unsupported "+`tensor rank: ${e.rank}`)}}function A(e,t){if(Array.isArray(t)||(t=[t]),e.rank!==t.length)throw new n.ValueError(`The length of input n (${t.length}) does not match `+`the number of dimensions in input x (${e.rank})`);return r.tile(e,t)}function $(e,t=0,n=1,a,s){return r.randomNormal(e,t,n,a,s)}function E(e,t,a,o){if(e.rank<2||t.rank<2)throw new n.NotImplementedError("dot requires both inputs to be rank >= 2"+` but got x shape = ${e.shape} and y shape = ${t.shape}`);if(t.rank>=3){if(e.shape.slice(-1)[0]!==t.shape.slice(-2)[0])throw new n.NotImplementedError("If rank y >= 3, then the second last dim"+` of y must equal the last dim of x but got x shape = ${e.shape} and `+` y shape = ${t.shape}`)}if(2===e.rank&&2===t.rank){const n=!1,i=!1;return r.fused.matMul({a:e,b:t,transposeA:n,transposeB:i,bias:o?_(e.rank,o,(0,s.imageDataFormat)()):null,activation:a})}{const n=e.shape.slice(),i=n.pop();e=r.reshape(e,[-1,i]);const u=t.shape.slice(),c=u.pop(),p=u.pop(),h=[...u,c],l=Array.from({length:t.rank},(e,r)=>0===r?t.rank-2:r<=t.rank-2?r-1:r);t=r.reshape(r.transpose(t,l),[p,-1]);const d=[...n,...h],f=!1,k=!1;return r.reshape(r.fused.matMul({a:e,b:t,transposeA:f,transposeB:k,bias:o?_(e.rank,o,(0,s.imageDataFormat)()):null,activation:a}),d)}}function v(t){return(0,e.tidy)(()=>{const n=(0,e.zerosLike)(t),a=(0,e.onesLike)(t);return(0,e.where)(r.equal(t,n),n,(0,e.where)(r.greater(t,(0,e.zerosLike)(t)),a,r.mul(-1,a)))})}function F(t,n){return(0,e.tidy)(()=>{if(1!==t.rank)throw new Error("Only 1D one-hot tensors are supported in the deeplearn backend, at present.");return t=r.cast(t,"int32"),r.cast(r.oneHot(t,n),"float32")})}function V(t,n,a){return(0,e.tidy)(()=>(n=Array.isArray(n)?(0,e.tensor1d)(n,"int32"):r.cast(n,"int32"),r.gather(t,n,a)))}function q(e){return r.mul(e,e)}function L(t,a){return(0,e.tidy)(()=>{if("number"==typeof a&&(a=(0,e.scalar)(Math.round(a),"int32")),"int32"!==a.dtype)throw new n.NotImplementedError(`Non-int32 dtype (${a.dtype}) is not supported by pow() yet`);return r.pow(t,a)})}function _(e,t,a){const s=t.shape;if(1!==t.rank&&t.rank!==e)throw new n.ValueError(`Unexpected bias dimensions: ${t.rank}`+`; expected it to be 1 or ${e}`);if(5===e){if("channelsFirst"===a)return 1===s.length?r.reshape(t,[1,s[0],1,1,1]):r.reshape(t,[1,s[3],s[0],s[1],s[2]]);if("channelsLast"===a)return 1===s.length?r.reshape(t,[1,1,1,1,s[0]]):r.reshape(t,[1].concat(s))}else if(4===e){if("channelsFirst"===a)return 1===s.length?r.reshape(t,[1,s[0],1,1]):r.reshape(t,[1,s[2],s[0],s[1]]);if("channelsLast"===a)return 1===s.length?r.reshape(t,[1,1,1,s[0]]):r.reshape(t,[1].concat(s))}else if(3===e){if("channelsFirst"===a)return 1===s.length?r.reshape(t,[1,s[0],1]):r.reshape(t,[1,s[1],s[0]]);if("channelsLast"===a)return 1===s.length?r.reshape(t,[1,1,s[0]]):r.reshape(t,[1].concat(s))}else if(e<3)return t;throw new n.ValueError(`Unsupported input rank by biasAdd: ${t.rank}`)}function M(n,a,o){return(0,e.tidy)(()=>(null==o&&(o=(0,s.imageDataFormat)()),(0,t.checkDataFormat)(o),r.add(n,_(n.rank,a,o))))}function P(e,t=1){if(1!==t)throw new n.NotImplementedError(`Support for alpha values other than 1 (${t}) is not implemented `+"yet.");return r.elu(e)}function B(t){return(0,e.tidy)(()=>r.div(t,r.add(r.abs(t),1)))}function D(t,n,a,s){return(0,e.tidy)(()=>r.dropout(t,n,a,s))}function N(t){return(0,e.tidy)(()=>{const e=r.add(.5,r.mul(.2,t));return r.clipByValue(e,0,1)})}function O(e,r,t=!1){return t?e():r()}
},{"@tensorflow/tfjs-core":"kSBl","../common":"sR6u","../errors":"iJtr","../utils/math_utils":"eQAy","./common":"VOlA"}],"Ys0Z":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.initializerClassNames=exports.VALID_FAN_MODE_VALUES=exports.VALID_DISTRIBUTION_VALUES=void 0;const e=exports.VALID_FAN_MODE_VALUES=["fanIn","fanOut","fanAvg"],a=exports.VALID_DISTRIBUTION_VALUES=["normal","uniform","truncatedNormal"],o=exports.initializerClassNames=["Zeros","Ones","Constant","RandomNormal","RandomUniform","TruncatedNormal","VarianceScaling","Orthogonal","Identity"];
},{}],"Ltyq":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.Zeros=exports.VarianceScaling=exports.TruncatedNormal=exports.RandomUniform=exports.RandomNormal=exports.Orthogonal=exports.Ones=exports.LeCunUniform=exports.LeCunNormal=exports.Initializer=exports.Identity=exports.INITIALIZER_IDENTIFIER_REGISTRY_SYMBOL_MAP=exports.HeUniform=exports.HeNormal=exports.GlorotUniform=exports.GlorotNormal=exports.Constant=void 0,exports.checkDistribution=u,exports.checkFanMode=l,exports.getInitializer=D,exports.serializeInitializer=M;var e=require("@tensorflow/tfjs-core"),t=o(require("./backend/tfjs_backend")),s=require("./common"),r=require("./errors"),n=require("./keras_format/initializer_config"),a=require("./utils/generic_utils"),i=require("./utils/math_utils");function o(e,t){if("function"==typeof WeakMap)var s=new WeakMap,r=new WeakMap;return(o=function(e,t){if(!t&&e&&e.__esModule)return e;var n,a,i={__proto__:null,default:e};if(null===e||"object"!=typeof e&&"function"!=typeof e)return i;if(n=t?r:s){if(n.has(e))return n.get(e);n.set(e,i)}for(const s in e)"default"!==s&&{}.hasOwnProperty.call(e,s)&&((a=(n=Object.defineProperty)&&Object.getOwnPropertyDescriptor(e,s))&&(a.get||a.set)?n(i,s,a):i[s]=e[s]);return i})(e,t)}function l(e){(0,a.checkStringTypeUnionValue)(n.VALID_FAN_MODE_VALUES,"FanMode",e)}function u(e){(0,a.checkStringTypeUnionValue)(n.VALID_DISTRIBUTION_VALUES,"Distribution",e)}class m extends e.serialization.Serializable{fromConfigUsesCustomObjects(){return!1}getConfig(){return{}}}exports.Initializer=m;class d extends m{apply(t,s){return(0,e.zeros)(t,s)}}exports.Zeros=d,d.className="Zeros",e.serialization.registerClass(d);class c extends m{apply(t,s){return(0,e.ones)(t,s)}}exports.Ones=c,c.className="Ones",e.serialization.registerClass(c);class h extends m{constructor(e){if(super(),"object"!=typeof e)throw new r.ValueError(`Expected argument of type ConstantConfig but got ${e}`);if(void 0===e.value)throw new r.ValueError(`config must have value set but got ${e}`);this.value=e.value}apply(t,s){return(0,e.tidy)(()=>(0,e.mul)((0,e.scalar)(this.value),(0,e.ones)(t,s)))}getConfig(){return{value:this.value}}}exports.Constant=h,h.className="Constant",e.serialization.registerClass(h);class f extends m{constructor(e){super(),this.DEFAULT_MINVAL=-.05,this.DEFAULT_MAXVAL=.05,this.minval=e.minval||this.DEFAULT_MINVAL,this.maxval=e.maxval||this.DEFAULT_MAXVAL,this.seed=e.seed}apply(t,s){return(0,e.randomUniform)(t,this.minval,this.maxval,s,this.seed)}getConfig(){return{minval:this.minval,maxval:this.maxval,seed:this.seed}}}exports.RandomUniform=f,f.className="RandomUniform",e.serialization.registerClass(f);class p extends m{constructor(e){super(),this.DEFAULT_MEAN=0,this.DEFAULT_STDDEV=.05,this.mean=e.mean||this.DEFAULT_MEAN,this.stddev=e.stddev||this.DEFAULT_STDDEV,this.seed=e.seed}apply(e,s){if("float32"!==(s=s||"float32")&&"int32"!==s)throw new r.NotImplementedError(`randomNormal does not support dType ${s}.`);return t.randomNormal(e,this.mean,this.stddev,s,this.seed)}getConfig(){return{mean:this.mean,stddev:this.stddev,seed:this.seed}}}exports.RandomNormal=p,p.className="RandomNormal",e.serialization.registerClass(p);class g extends m{constructor(e){super(),this.DEFAULT_MEAN=0,this.DEFAULT_STDDEV=.05,this.mean=e.mean||this.DEFAULT_MEAN,this.stddev=e.stddev||this.DEFAULT_STDDEV,this.seed=e.seed}apply(t,s){if("float32"!==(s=s||"float32")&&"int32"!==s)throw new r.NotImplementedError(`truncatedNormal does not support dType ${s}.`);return(0,e.truncatedNormal)(t,this.mean,this.stddev,s,this.seed)}getConfig(){return{mean:this.mean,stddev:this.stddev,seed:this.seed}}}exports.TruncatedNormal=g,g.className="TruncatedNormal",e.serialization.registerClass(g);class N extends m{constructor(e){super(),this.gain=null!=e.gain?e.gain:1}apply(t,s){return(0,e.tidy)(()=>{if(2!==t.length||t[0]!==t[1])throw new r.ValueError("Identity matrix initializer can only be used for 2D square matrices.");return(0,e.mul)(this.gain,(0,e.eye)(t[0]))})}getConfig(){return{gain:this.gain}}}function x(e,t="channelsLast"){let r,n;if((0,s.checkDataFormat)(t),2===e.length)r=e[0],n=e[1];else if(-1!==[3,4,5].indexOf(e.length)){if("channelsFirst"===t){const t=(0,i.arrayProd)(e,2);r=e[1]*t,n=e[0]*t}else if("channelsLast"===t){const t=(0,i.arrayProd)(e,0,e.length-2);r=e[e.length-2]*t,n=e[e.length-1]*t}}else{const t=(0,i.arrayProd)(e);r=Math.sqrt(t),n=Math.sqrt(t)}return[r,n]}exports.Identity=N,N.className="Identity",e.serialization.registerClass(N);class E extends m{constructor(e){if(super(),e.scale<0)throw new r.ValueError(`scale must be a positive float. Got: ${e.scale}`);this.scale=null==e.scale?1:e.scale,this.mode=null==e.mode?"fanIn":e.mode,l(this.mode),this.distribution=null==e.distribution?"normal":e.distribution,u(this.distribution),this.seed=e.seed}apply(t,s){const n=x(t),a=n[0],i=n[1];let o=this.scale;if("fanIn"===this.mode?o/=Math.max(1,a):"fanOut"===this.mode?o/=Math.max(1,i):o/=Math.max(1,(a+i)/2),"normal"===this.distribution){const n=Math.sqrt(o);if("float32"!==(s=s||"float32")&&"int32"!==s)throw new r.NotImplementedError(`${this.getClassName()} does not support dType ${s}.`);return(0,e.truncatedNormal)(t,0,n,s,this.seed)}{const r=Math.sqrt(3*o);return(0,e.randomUniform)(t,-r,r,s,this.seed)}}getConfig(){return{scale:this.scale,mode:this.mode,distribution:this.distribution,seed:this.seed}}}exports.VarianceScaling=E,E.className="VarianceScaling",e.serialization.registerClass(E);class C extends E{constructor(e){super({scale:1,mode:"fanAvg",distribution:"uniform",seed:null==e?null:e.seed})}getClassName(){return E.className}}exports.GlorotUniform=C,C.className="GlorotUniform",e.serialization.registerClass(C);class U extends E{constructor(e){super({scale:1,mode:"fanAvg",distribution:"normal",seed:null==e?null:e.seed})}getClassName(){return E.className}}exports.GlorotNormal=U,U.className="GlorotNormal",e.serialization.registerClass(U);class _ extends E{constructor(e){super({scale:2,mode:"fanIn",distribution:"normal",seed:null==e?null:e.seed})}getClassName(){return E.className}}exports.HeNormal=_,_.className="HeNormal",e.serialization.registerClass(_);class I extends E{constructor(e){super({scale:2,mode:"fanIn",distribution:"uniform",seed:null==e?null:e.seed})}getClassName(){return E.className}}exports.HeUniform=I,I.className="HeUniform",e.serialization.registerClass(I);class L extends E{constructor(e){super({scale:1,mode:"fanIn",distribution:"normal",seed:null==e?null:e.seed})}getClassName(){return E.className}}exports.LeCunNormal=L,L.className="LeCunNormal",e.serialization.registerClass(L);class y extends E{constructor(e){super({scale:1,mode:"fanIn",distribution:"uniform",seed:null==e?null:e.seed})}getClassName(){return E.className}}exports.LeCunUniform=y,y.className="LeCunUniform",e.serialization.registerClass(y);class A extends m{constructor(e){super(),this.DEFAULT_GAIN=1,this.ELEMENTS_WARN_SLOW=2e3,this.gain=null==e.gain?this.DEFAULT_GAIN:e.gain,this.seed=e.seed}apply(s,n){return(0,e.tidy)(()=>{if(s.length<2)throw new r.NotImplementedError("Shape must be at least 2D.");if("int32"!==n&&"float32"!==n&&void 0!==n)throw new TypeError(`Unsupported data type ${n}.`);n=n;const a=e.util.sizeFromShape(s.slice(0,-1)),i=s[s.length-1],o=a*i;o>this.ELEMENTS_WARN_SLOW&&console.warn("Orthogonal initializer is being called on a matrix with more "+`than ${this.ELEMENTS_WARN_SLOW} (${o}) elements: `+"Slowness may result.");const l=[Math.max(i,a),Math.min(i,a)],u=t.randomNormal(l,0,1,n,this.seed),m=e.linalg.qr(u,!1);let d=m[0];const c=m[1].flatten().stridedSlice([0],[Math.min(i,a)*Math.min(i,a)],[Math.min(i,a)+1]);return d=(0,e.mul)(d,c.sign()),a<i&&(d=d.transpose()),(0,e.mul)((0,e.scalar)(this.gain),d.reshape(s))})}getConfig(){return{gain:this.gain,seed:this.seed}}}exports.Orthogonal=A,A.className="Orthogonal",e.serialization.registerClass(A);const v=exports.INITIALIZER_IDENTIFIER_REGISTRY_SYMBOL_MAP={constant:"Constant",glorotNormal:"GlorotNormal",glorotUniform:"GlorotUniform",heNormal:"HeNormal",heUniform:"HeUniform",identity:"Identity",leCunNormal:"LeCunNormal",leCunUniform:"LeCunUniform",ones:"Ones",orthogonal:"Orthogonal",randomNormal:"RandomNormal",randomUniform:"RandomUniform",truncatedNormal:"TruncatedNormal",varianceScaling:"VarianceScaling",zeros:"Zeros"};function T(t,s={}){return(0,a.deserializeKerasObject)(t,e.serialization.SerializationMap.getMap().classNameMap,s,"initializer")}function M(e){return(0,a.serializeKerasObject)(e)}function D(e){if("string"==typeof e){const t=e in v?v[e]:e;if("GlorotNormal"===t)return new U;if("GlorotUniform"===t)return new C;if("HeNormal"===t)return new _;if("HeUniform"===t)return new I;if("LeCunNormal"===t)return new L;if("LeCunUniform"===t)return new y;{const e={};return e.className=t,e.config={},T(e)}}return e instanceof m?e:T(e)}
},{"@tensorflow/tfjs-core":"kSBl","./backend/tfjs_backend":"Ftmo","./common":"sR6u","./errors":"iJtr","./keras_format/initializer_config":"Ys0Z","./utils/generic_utils":"VKwv","./utils/math_utils":"eQAy"}],"mOET":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.getExactlyOneShape=a,exports.getExactlyOneTensor=n,exports.isArrayOfShapes=e,exports.normalizeShapeList=t;var r=require("../errors");function e(r){return Array.isArray(r)&&Array.isArray(r[0])}function t(r){return 0===r.length?[]:Array.isArray(r[0])?r:[r]}function n(e){let t;if(Array.isArray(e)){if(1!==e.length)throw new r.ValueError(`Expected Tensor length to be 1; got ${e.length}`);t=e[0]}else t=e;return t}function a(e){if(Array.isArray(e)&&Array.isArray(e[0])){if(1===e.length)return(e=e)[0];throw new r.ValueError(`Expected exactly 1 Shape; got ${e.length}`)}return e}
},{"../errors":"iJtr"}],"NSdo":[function(require,module,exports) {
"use strict";function e(e){let t=0;for(const r of e)0===r.shape.length?t+=1:t+=r.shape.reduce((e,t)=>e*t);return t}Object.defineProperty(exports,"__esModule",{value:!0}),exports.countParamsInWeights=e;
},{}],"mwlr":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.LayerVariable=void 0,exports.batchGetValue=x,exports.batchSetValue=g,exports.eyeVariable=h,exports.gradients=V,exports.onesLike=c,exports.onesVariable=f,exports.randomNormalVariable=w,exports.randomUniformVariable=m,exports.truncatedNormalVariable=b,exports.update=N,exports.updateAdd=y,exports.updateSub=v,exports.variable=u,exports.zerosLike=d,exports.zerosVariable=p;var e=o(require("@tensorflow/tfjs-core")),t=e,r=require("./backend/state"),n=require("./common"),a=require("./errors");function o(e,t){if("function"==typeof WeakMap)var r=new WeakMap,n=new WeakMap;return(o=function(e,t){if(!t&&e&&e.__esModule)return e;var a,o,i={__proto__:null,default:e};if(null===e||"object"!=typeof e&&"function"!=typeof e)return i;if(a=t?n:r){if(a.has(e))return a.get(e);a.set(e,i)}for(const r in e)"default"!==r&&{}.hasOwnProperty.call(e,r)&&((o=(a=Object.defineProperty)&&Object.getOwnPropertyDescriptor(e,r))&&(o.get||o.set)?a(i,r,o):i[r]=e[r]);return i})(e,t)}const i="Variable";class s{constructor(e,a="float32",o=i,s=!0,l=null){this.dtype=null==a?"float32":a,this.shape=e.shape,this.id=(0,r.getNextUniqueTensorId)(),o=null==o?i:o,this.originalName=(0,n.getScopedTensorName)(o),this.name=(0,n.getUniqueTensorName)(this.originalName),this.trainable_=s,this.constraint=l,this.val=t.variable(e,this.trainable_,this.name,this.dtype)}read(){return this.assertNotDisposed(),this.val}write(e){return this.assertNotDisposed(),l(this.val,e),this.val.id!==e.id&&(this.val.assign(e),null!=this.constraint&&this.val.assign(this.constraint.apply(this.val))),this}dispose(){this.assertNotDisposed(),this.val.dispose()}assertNotDisposed(){if(this.val.isDisposed)throw new Error(`LayersVariable ${this.name} is already disposed.`)}get trainable(){return this.trainable_}set trainable(e){this.trainable_=e,this.val.trainable=e}}function l(e,t){if(e.shape.toString()!==t.shape.toString())throw new Error("Shape mismatch: "+JSON.stringify(e.shape)+" vs. "+JSON.stringify(t.shape))}function u(e,t,r,n){return new s(e,t,r,!0,n)}function p(e,r,n){return new s(t.zeros(e),r,n)}function d(e,r,n){return new s(t.zerosLike(e),r,n)}function f(e,r,n){const a=t.ones(e);return new s(a,r,n)}function c(e,r,n){const a=t.onesLike(e);return new s(a,r,n)}function h(e,r,n){return new s(t.eye(e),r,n)}function m(e,r,n,a,o,i="randomUniform"){return new s(t.randomUniform(e,r,n,a),a,i)}function b(e,r=0,n=1,o,i,l="truncatedNormal"){if("float32"!==(o=o||"float32")&&"int32"!==o)throw new a.NotImplementedError(`randomNormal does not support dType ${o}.`);return new s(t.truncatedNormal(e,r,n,o,i),o,l)}function w(e,r=0,n=1,o,i,l="randomNormal"){if("float32"!==(o=o||"float32")&&"int32"!==o)throw new a.NotImplementedError(`randomNormalVariable does not support dType ${o}.`);return new s(t.randomNormal(e,r,n,o,i),o,l)}function N(e,t){return e.write(t)}function y(e,r){return e.write(t.add(e.read(),r))}function v(e,r){return e.write(t.sub(e.read(),r))}function x(e){return e.map(e=>e.read())}function g(e){e.forEach(e=>{e[0].write(e[1])})}function V(t,r){const n=r.map(e=>e.read()),a=(0,e.variableGrads)(t,n);return r.map(e=>a.grads[e.name])}exports.LayerVariable=s;
},{"@tensorflow/tfjs-core":"kSBl","./backend/state":"R2ma","./common":"sR6u","./errors":"iJtr"}],"wHpB":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.SymbolicTensor=exports.Node=exports.Layer=exports.InputSpec=void 0,exports.getSourceInputs=m;var t=require("@tensorflow/tfjs-core"),e=require("../backend/state"),n=require("../common"),i=require("../errors"),s=require("../initializers"),r=u(require("../utils/generic_utils")),o=u(require("../utils/types_utils")),a=u(require("../utils/variable_utils")),h=require("../variables");function u(t,e){if("function"==typeof WeakMap)var n=new WeakMap,i=new WeakMap;return(u=function(t,e){if(!e&&t&&t.__esModule)return t;var s,r,o={__proto__:null,default:t};if(null===t||"object"!=typeof t&&"function"!=typeof t)return o;if(s=e?i:n){if(s.has(t))return s.get(t);s.set(t,o)}for(const n in t)"default"!==n&&{}.hasOwnProperty.call(t,n)&&((r=(s=Object.defineProperty)&&Object.getOwnPropertyDescriptor(t,n))&&(r.get||r.set)?s(o,n,r):o[n]=t[n]);return o})(t,e)}class l{constructor(t){this.dtype=t.dtype,this.shape=t.shape,null!=t.shape?this.ndim=t.shape.length:this.ndim=t.ndim,this.maxNDim=t.maxNDim,this.minNDim=t.minNDim,this.axes=t.axes||{}}}exports.InputSpec=l;class p{constructor(t,i,s,r,o,a,h){this.dtype=t,this.shape=i,this.sourceLayer=s,this.inputs=r,this.callArgs=o,this.outputTensorIndex=h,this.id=(0,e.getNextUniqueTensorId)(),null!=a&&(this.originalName=(0,n.getScopedTensorName)(a),this.name=(0,n.getUniqueTensorName)(this.originalName)),this.rank=i.length}}exports.SymbolicTensor=p;let d=0;class c{constructor(t,e){this.callArgs=e,this.id=d++,this.outboundLayer=t.outboundLayer,this.inboundLayers=t.inboundLayers,this.nodeIndices=t.nodeIndices,this.tensorIndices=t.tensorIndices,this.inputTensors=t.inputTensors,this.outputTensors=t.outputTensors,this.inputMasks=t.inputMasks,this.outputMasks=t.outputMasks,this.inputShapes=t.inputShapes,this.outputShapes=t.outputShapes;for(const n of t.inboundLayers)null!=n&&n.outboundNodes.push(this);t.outboundLayer.inboundNodes.push(this)}getConfig(){const t=[];for(const e of this.inboundLayers)null!=e?t.push(e.name):t.push(null);return{outboundLayer:this.outboundLayer?this.outboundLayer.name:null,inboundLayers:t,nodeIndices:this.nodeIndices,tensorIndices:this.tensorIndices}}}exports.Node=c;let f=0;class g extends t.serialization.Serializable{constructor(t={}){super(),this._callHook=null,this._addedWeightNames=[],this._stateful=!1,this.id=f++,this.activityRegularizer=null,this.inputSpec=null,this.supportsMasking=!1,this._trainableWeights=[],this._nonTrainableWeights=[],this._losses=[],this._updates=[],this._built=!1,this.inboundNodes=[],this.outboundNodes=[];let n=t.name;if(!n){const t=this.getClassName();n=r.toSnakeCase(t)+"_"+(0,e.getUid)(t)}if(this.name=n,this.trainable_=null==t.trainable||t.trainable,null!=t.inputShape||null!=t.batchInputShape){let e;if(null!=t.batchInputShape)e=t.batchInputShape;else if(null!=t.inputShape){let n=null;null!=t.batchSize&&(n=t.batchSize),e=[n].concat(t.inputShape)}this.batchInputShape=e;let n=t.dtype;null==n&&(n=t.inputDType),null==n&&(n="float32"),this.dtype=n}null!=t.weights?this.initialWeights=t.weights:this.initialWeights=null,this._refCount=null,this.fastWeightInitDuringBuild=!1}static nodeKey(t,e){return t.name+"_ib-"+e.toString()}getNodeAtIndex(t,e){if(0===this.inboundNodes.length)throw new i.RuntimeError("The layer has never been called "+`and thus has no defined ${e}.`);if(this.inboundNodes.length<=t)throw new i.ValueError(`Asked to get ${e} at node ${t}, `+`but the layer has only ${this.inboundNodes.length} inbound nodes.`);return this.inboundNodes[t]}getInputAt(t){return r.singletonOrArray(this.getNodeAtIndex(t,"input").inputTensors)}getOutputAt(t){return r.singletonOrArray(this.getNodeAtIndex(t,"output").outputTensors)}get input(){if(this.inboundNodes.length>1)throw new i.AttributeError(`Layer ${this.name}`+' has multiple inbound nodes, hence the notion of "layer input" is ill-defined. Use `getInputAt(nodeIndex)` instead.');if(0===this.inboundNodes.length)throw new i.AttributeError(`Layer ${this.name}`+" is not connected, no input to return.");return r.singletonOrArray(this.getNodeAtIndex(0,"input").inputTensors)}get output(){if(0===this.inboundNodes.length)throw new i.AttributeError(`Layer ${this.name}`+" has no inbound nodes.");if(this.inboundNodes.length>1)throw new i.AttributeError(`Layer ${this.name}`+' has multiple inbound nodes, hence the notion of "layer output" is ill-defined. Use `getOutputAt(nodeIndex)` instead.');return r.singletonOrArray(this.getNodeAtIndex(0,"output").outputTensors)}get losses(){return this._losses}calculateLosses(){return this.losses.map(t=>t())}get updates(){return this._updates}get built(){return this._built}set built(t){this._built=t}get trainable(){return this.trainable_}set trainable(t){this._trainableWeights.forEach(e=>e.trainable=t),this.trainable_=t}get trainableWeights(){return this.trainable_?this._trainableWeights.filter(t=>t.trainable):[]}set trainableWeights(t){this._trainableWeights=t}get nonTrainableWeights(){return this.trainable?this._trainableWeights.filter(t=>!t.trainable).concat(this._nonTrainableWeights):this._trainableWeights.concat(this._nonTrainableWeights)}set nonTrainableWeights(t){this._nonTrainableWeights=t}get weights(){return this.trainableWeights.concat(this.nonTrainableWeights)}get stateful(){return this._stateful}resetStates(){if(!this.stateful)throw new Error("Cannot call the resetStates() method of a non-stateful Layer object.")}assertInputCompatibility(t){const e=r.toList(t);if(null==this.inputSpec||0===this.inputSpec.length)return;const n=r.toList(this.inputSpec);if(e.length!==n.length)throw new i.ValueError(`Layer ${this.name} expects ${n.length} inputs, `+`but it received ${e.length} input tensors. `+`Input received: ${t}`);for(let s=0;s<e.length;s++){const t=e[s],r=n[s];if(null==r)continue;const o=t.rank;if(null!=r.ndim&&o!==r.ndim)throw new i.ValueError(`Input ${s} is incompatible with layer ${this.name}: `+`expected ndim=${r.ndim}, found ndim=${o}`);if(null!=r.maxNDim&&o>r.maxNDim)throw new i.ValueError(`Input ${s} is incompatible with layer ${this.name}`+`: expected max_ndim=${r.maxNDim}, found ndim=${o}`);if(null!=r.minNDim&&o<r.minNDim)throw new i.ValueError(`Input ${s} is incompatible with layer ${this.name}`+`: expected min_ndim=${r.minNDim}, found ndim=${o}.`);if(null!=r.dtype&&t.dtype!==r.dtype)throw new i.ValueError(`Input ${s} is incompatible with layer ${this.name} `+`: expected dtype=${r.dtype}, found dtype=${t.dtype}.`);if(r.axes){const e=t.shape;for(const t in r.axes){const n=Number(t),o=r.axes[t],a=n>=0?e[n]:e[e.length+n];if(null!=o&&-1===[o,null].indexOf(a))throw new i.ValueError(`Input ${s} is incompatible with layer `+`${this.name}: expected axis ${n} of input shape to `+`have value ${o} but got shape ${e}.`)}}if(null!=r.shape)for(let e=0;e<r.shape.length;++e){const n=r.shape[e],o=t.shape[e];if(null!=n&&null!=o&&n!==o)throw new i.ValueError(`Input ${s} is incompatible with layer `+`${this.name}: expected shape=${r.shape}, `+`found shape=${t.shape}.`)}}}call(t,e){return t}invokeCallHook(t,e){null!=this._callHook&&this._callHook(t,e)}setCallHook(t){this._callHook=t}clearCallHook(){this._callHook=null}apply(t,e){e=e||{},this.assertNotDisposed();const s=r.toList(t),o=w(t),a=I(t);if(o===a)throw new i.ValueError("Arguments to apply() must be all SymbolicTensors or all Tensors");return(0,n.nameScope)(this.name,()=>{if(!this.built){this.assertInputCompatibility(t);const e=[];for(const n of r.toList(t))e.push(n.shape);this.build(r.singletonOrArray(e)),this.built=!0,this.initialWeights&&this.setWeights(this.initialWeights),null===this._refCount&&a&&(this._refCount=1)}if(this.assertInputCompatibility(t),a){let n=this.call(t,e);this.supportsMasking&&this.setMaskMetadata(t,n);const o=r.toList(n),a=[];for(let t of o)-1!==s.indexOf(t)&&(t=t.clone()),a.push(t);if(n=r.singletonOrArray(a),null!=this.activityRegularizer)throw new i.NotImplementedError("Layer invocation in the presence of activity regularizer(s) is not supported yet.");return n}{const n=b(t),s=this.computeOutputShape(n);let o;const a=y(t);if(this.warnOnIncompatibleInputShape(Array.isArray(t)?n[0]:n),o=null!=s&&s.length>0&&Array.isArray(s[0])?s.map((n,i)=>new p(a,n,this,r.toList(t),e,this.name,i)):new p(a,s,this,r.toList(t),e,this.name),this.addInboundNode(t,o,null,null,n,s,e),this._refCount++,null!=this.activityRegularizer)throw new i.NotImplementedError("Layer invocation in the presence of activity regularizer(s) is not supported yet.");return o}})}warnOnIncompatibleInputShape(t){if(null!=this.batchInputShape)if(t.length!==this.batchInputShape.length)console.warn("The rank of the input tensor provided (shape: "+`${JSON.stringify(t)}) does not match that of the `+`batchInputShape (${JSON.stringify(this.batchInputShape)}) `+`of the layer ${this.name}`);else{let e=!1;this.batchInputShape.forEach((n,i)=>{null!=n&&null!=t[i]&&t[i]!==n&&(e=!0)}),e&&console.warn("The shape of the input tensor "+`(${JSON.stringify(t)}) does not `+`match the expectation of layer ${this.name}: `+`${JSON.stringify(this.batchInputShape)}`)}}get outputShape(){if(null==this.inboundNodes||0===this.inboundNodes.length)throw new i.AttributeError(`The layer ${this.name} has never been called and thus has no `+"defined output shape.");const t=[];for(const e of this.inboundNodes){const n=JSON.stringify(e.outputShapes);-1===t.indexOf(n)&&t.push(n)}if(1===t.length){const t=this.inboundNodes[0].outputShapes;return Array.isArray(t)&&Array.isArray(t[0])&&1===t.length?t[0]:t}throw new i.AttributeError(`The layer ${this.name} has multiple inbound nodes with different `+'output shapes. Hence the notion of "output shape" is ill-defined for the layer.')}countParams(){if(!this.built)throw new i.RuntimeError(`You tried to call countParams() on ${this.name}, `+"but the layer is not built yet. Build it first by calling build(batchInputShape).");return a.countParamsInWeights(this.weights)}build(t){this.built=!0}getWeights(t=!1){return(0,h.batchGetValue)(t?this.trainableWeights:this.weights)}setWeights(e){(0,t.tidy)(()=>{const n=this.weights;if(n.length!==e.length)throw new i.ValueError(`You called setWeights(weights) on layer "${this.name}" `+`with a weight list of length ${e.length}, `+`but the layer was expecting ${n.length} weights. `+`Provided weights: ${e}...`);if(0===n.length)return;const s=[],r=(0,h.batchGetValue)(n);for(let o=0;o<r.length;++o){const a=r[o],h=n[o],u=e[o];if(!t.util.arraysEqual(a.shape,u.shape))throw new i.ValueError(`Layer weight shape ${a.shape} `+`not compatible with provided weight shape ${u.shape}`);s.push([h,u])}(0,h.batchSetValue)(s)})}addWeight(t,e,n,r,o,a,u,l){if(-1!==this._addedWeightNames.indexOf(t))throw new i.ValueError(`Duplicate weight name ${t} for layer ${this.name}`);this._addedWeightNames.push(t),null==n&&(n="float32"),this.fastWeightInitDuringBuild&&(r=null!=l?l():(0,s.getInitializer)("zeros"));const p=r.apply(e,n),d=new h.LayerVariable(p,n,t,a,u);return p.dispose(),null!=o&&this.addLoss(()=>o.apply(d.read())),null==a&&(a=!0),a?this._trainableWeights.push(d):this._nonTrainableWeights.push(d),d}setFastWeightInitDuringBuild(t){this.fastWeightInitDuringBuild=t}addLoss(t){null==t||Array.isArray(t)&&0===t.length||(t=r.toList(t),void 0!==this._losses&&null!==this._losses&&this.losses.push(...t))}computeOutputShape(t){return t}computeMask(t,e){if(!this.supportsMasking){if(null!=e){if(!Array.isArray(e))throw new TypeError(`Layer ${this.name} does not support masking, `+"but was passed an inputMask.");e.forEach(t=>{if(null!=t)throw new TypeError(`Layer ${this.name} does not support masking, `+"but was passed an inputMask.")})}return null}return e}setMaskMetadata(t,e,n){if(!this.supportsMasking)return;const i=this.computeMask(t,n),s=r.toList(e),o=r.toList(i);if(s.length!==o.length)throw new Error(`${this.name} outputs ${s.length} tensors `+`but ${s.length} masks for those tensors`);for(let r=0;r<s.length;r++)s[r].kerasMask=o[r]}addInboundNode(t,e,n,i,s,a,h=null){const u=r.toList(t);e=r.toList(e),n=r.toList(n),i=r.toList(i),s=o.normalizeShapeList(s),a=o.normalizeShapeList(a);const l=[],p=[],d=[];for(const r of u)l.push(r.sourceLayer),p.push(r.nodeIndex),d.push(r.tensorIndex);new c({outboundLayer:this,inboundLayers:l,nodeIndices:p,tensorIndices:d,inputTensors:u,outputTensors:e,inputMasks:n,outputMasks:i,inputShapes:s,outputShapes:a},h);for(let r=0;r<e.length;r++)e[r].sourceLayer=this,e[r].nodeIndex=this.inboundNodes.length-1,e[r].tensorIndex=r}getConfig(){const t={name:this.name,trainable:this.trainable};return null!=this.batchInputShape&&(t.batchInputShape=this.batchInputShape),null!=this.dtype&&(t.dtype=this.dtype),t}disposeWeights(){return this.weights.forEach(t=>t.dispose()),this.weights.length}assertNotDisposed(){if(0===this._refCount)throw new Error(`Layer '${this.name}' is already disposed.`)}dispose(){if(!this.built)throw new Error(`Cannot dispose Layer ${this.name} because it has not been `+"built yet.");if(null===this._refCount)throw new Error(`Cannot dispose Layer ${this.name} because it has not been used `+"yet.");this.assertNotDisposed();let t=0;return 0==--this._refCount&&(t=this.disposeWeights()),{refCountAfterDispose:this._refCount,numDisposedVariables:t}}}function b(t){t=r.toList(t);const e=[];for(const n of t)e.push(n.shape);return r.singletonOrArray(e)}function y(t){return"float32"}function m(t,e,n){if((null==e||null!=n&&n>0)&&(e=t.sourceLayer,n=t.nodeIndex),0===e.inboundNodes.length)return[t];{const t=e.inboundNodes[n];if(0===t.inboundLayers.length)return t.inputTensors;{const e=[];for(let n=0;n<t.inboundLayers.length;n++){const i=m(t.inputTensors[n],t.inboundLayers[n],t.nodeIndices[n]);for(const t of i)-1===e.indexOf(t)&&e.push(t)}return e}}}function w(t){let e=!0;for(const n of r.toList(t))if(!(n instanceof p)){e=!1;break}return e}function I(t){let e=!0;for(const n of r.toList(t))if(n instanceof p){e=!1;break}return e}exports.Layer=g;
},{"@tensorflow/tfjs-core":"kSBl","../backend/state":"R2ma","../common":"sR6u","../errors":"iJtr","../initializers":"Ltyq","../utils/generic_utils":"VKwv","../utils/types_utils":"mOET","../utils/variable_utils":"NSdo","../variables":"mwlr"}],"xdtw":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.Input=p,exports.InputLayer=void 0;var e=require("@tensorflow/tfjs-core"),t=require("../backend/state"),n=require("../errors"),a=require("./topology");class s extends a.Layer{constructor(e){if(super({dtype:e.dtype,name:null!=e.name?e.name:(0,t.getUid)("input").toString()}),null==e.batchSize&&(e.batchSize=null),null==e.sparse&&(e.sparse=!1),this.trainable=!1,this.built=!0,this.sparse=e.sparse,null!=e.inputShape&&null!=e.batchInputShape)throw new n.ValueError("Only provide the inputShape OR batchInputShape argument to inputLayer, not both at the same time.");let s=e.batchInputShape;if(null==s){if(null==e.inputShape)throw new n.ValueError("An InputLayer should be passed either a `batchInputShape` or an `inputShape`.");s=[e.batchSize].concat(e.inputShape)}else if(null!=e.batchSize)throw new n.ValueError("Cannot specify batchSize if batchInputShape is specified when creating an InputLayer.");const p=e.dtype||"float32";this.batchInputShape=s,this.dtype=p,this.inputSpec=[{shape:s}];const r=new a.SymbolicTensor(this.dtype,this.batchInputShape,this,[],{},this.name);r.nodeIndex=0,r.tensorIndex=0,new a.Node({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:[r],outputTensors:[r],inputMasks:[null],outputMasks:[null],inputShapes:[s],outputShapes:[s]})}apply(e,t){throw new n.ValueError("Cannot pass any input to an "+`InputLayer's apply() method. InputLayer name: ${this.name}`)}dispose(){return{refCountAfterDispose:this._refCount,numDisposedVariables:0}}getConfig(){return{batchInputShape:this.batchInputShape,dtype:this.dtype,sparse:this.sparse,name:this.name}}}function p(e){if(null==e.batchShape&&null==e.shape)throw new Error("Please provide to Input either a `shape` or a `batchShape` argument. Note that `shape` does not include the batch dimension.");if(null!=e.batchShape&&null!=e.shape)throw new n.ValueError("Please provide either a `shape` or `batchShape` argument to Input, but not both.");let t=e.batchShape;null!=e.shape&&null==t&&(t=[null].concat(e.shape));let a=e.dtype;return null==a&&(a="float32"),new s({batchInputShape:t,name:e.name,dtype:a,sparse:e.sparse}).inboundNodes[0].outputTensors[0]}exports.InputLayer=s,s.className="InputLayer",e.serialization.registerClass(s);
},{"@tensorflow/tfjs-core":"kSBl","../backend/state":"R2ma","../errors":"iJtr","./topology":"wHpB"}],"w9qS":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.cachedSorted=exports.cachedRecipientCounts=exports.FeedDict=void 0,exports.execute=c,exports.getTopologicalSortAndRecipientCountsForOneFetch=f,exports.updateCacheMaxEntries=d;var e=require("@tensorflow/tfjs-core"),t=require("../errors"),n=require("../utils/executor_utils"),s=require("../utils/generic_utils"),o=require("./input_layer"),r=require("./topology");function i(n,s){if(null==n.dtype||n.dtype===s.dtype)return s;try{return(0,e.cast)(s,n.dtype)}catch(o){throw new t.ValueError(`The dtype of the feed (${s.dtype}) can not be cast to the dtype `+`of the key '${n.name}' (${n.dtype}).`)}}class a{constructor(e){if(this.id2Value={},this.id2Mask={},this.name2Id={},e instanceof a)for(const t in e.id2Value)this.id2Value[t]=e.id2Value[t],t in e.id2Mask&&(this.id2Mask[t]=e.id2Mask[t]);else{if(null==e)return;for(const t of e)this.add(t.key,t.value)}}add(e,n,s){if(null!=this.id2Value[e.id])throw new t.ValueError(`Duplicate key: name=${e.name}, id=${e.id}`);return this.id2Value[e.id]=i(e,n),this.name2Id[e.name]=e.id,null!=s&&(this.id2Mask[e.id]=s),this}addFeed(e){this.add(e.key,e.value)}hasKey(e){return null!=this.id2Value[e.id]}names(){return Object.keys(this.name2Id)}getValue(e){if(e instanceof r.SymbolicTensor){if(null==this.id2Value[e.id])throw new t.ValueError(`Nonexistent key: ${e.name}`);return this.id2Value[e.id]}{const n=this.name2Id[e];if(null==n)throw new t.ValueError(`Feed dict has no SymbolicTensor name: ${e}`);return this.id2Value[n]}}getMask(e){if(e instanceof r.SymbolicTensor){if(null==this.id2Value[e.id])throw new t.ValueError(`Nonexistent key: ${e.name}`);return this.id2Mask[e.id]}{const n=this.name2Id[e];if(null==n)throw new t.ValueError(`Feed dict has no SymbolicTensor name: ${e}`);return this.id2Mask[n]}}disposeMasks(){null!=this.id2Mask&&(0,e.dispose)(this.id2Mask)}}exports.FeedDict=a;const u=exports.cachedSorted=new n.LruCache,l=exports.cachedRecipientCounts=new n.LruCache;function d(e){null!=u&&u.setMaxEntries(e),null!=l&&l.setMaxEntries(e)}function c(t,n,r,i){const d=null!=r&&r.training,c=Array.isArray(t),p=c?t:[t],f=p.map(e=>e.name),y=[],g=n.names();for(const e of f)-1!==g.indexOf(e)?y.push(n.getValue(e)):y.push(null);null!=i&&(i.maxNumTensors=-1/0,i.minNumTensors=1/0);const k=f.join(",")+"|"+n.names().sort().join(",");let x,M=u.get(k);if(null==M){const e=h(p,n);M=e.sorted,x=e.recipientCounts,u.put(k,M),l.put(k,x)}x={},d||Object.assign(x,l.get(k));const w=new a(n);for(let a=0;a<M.length;++a){if(null!=i){const t=(0,e.memory)().numTensors;t>i.maxNumTensors&&(i.maxNumTensors=t),t<i.minNumTensors&&(i.minNumTensors=t)}const t=M[a],u=t.sourceLayer;if(u instanceof o.InputLayer)continue;const l=[],c=[],h=[];let p=!1;for(const e of t.inputs){const t=w.getValue(e),s=w.getMask(e);l.push(t),c.push(s),null!=s&&(p=!0),d||(x[e.name]--,0!==x[e.name]||n.hasKey(e)||-1!==f.indexOf(e.name)||t.isDisposed||!0===e.sourceLayer.stateful||h.push(t))}p&&((r=r||{}).mask=c[0]);const g=(0,s.toList)(u.apply(l,r));let k=null;u.supportsMasking&&(k=u.computeMask(l,c));const V=m(t),T=Array.isArray(V)?V:[V];for(let e=0;e<T.length;++e){w.hasKey(T[e])||w.add(T[e],g[e],Array.isArray(k)?k[0]:k);const t=f.indexOf(T[e].name);-1!==t&&(y[t]=g[e])}d||(0,e.dispose)(h)}return w.disposeMasks(),c?y:y[0]}function h(t,n){e.util.assert(null!=t&&t.length>0,()=>"Expected at least one fetch, got none");let s=[],o={};if(1===t.length){const e=f(t[0],n);s=e.sorted,o=e.recipientMap}else{const e=new Set;for(const r of t){const{sorted:t,recipientMap:i}=f(r,n);for(const n of t)e.has(n.name)||(s.push(n),e.add(n.name));for(const e in i)null==o[e]&&(o[e]=new Set),i[e].forEach(t=>o[e].add(t))}}return{sorted:s,recipientCounts:p(o)}}function p(e){const t={};for(const n in e)t[n]=e[n].size;return t}function f(e,t){const n=new Set,s=[],o={};for(const a of t.names())n.add(a);const r=[],i=[];for(r.push(e);r.length>0;){const e=r[r.length-1];if(n.has(e.name)){r.pop();continue}const t=i[i.length-1]===r.length-1;if(0===e.inputs.length||t)r.pop(),s.push(e),n.add(e.name),t&&i.pop();else{i.push(r.length-1);for(const t of e.inputs)null==o[t.name]&&(o[t.name]=new Set),o[t.name].add(e.name),n.has(t.name)||r.push(t)}}return{sorted:s,recipientMap:o}}function m(e){let t;if(1===e.sourceLayer.inboundNodes.length)t=e.sourceLayer.output;else{let n=null;for(let t=0;t<e.sourceLayer.inboundNodes.length;++t)for(const s of e.sourceLayer.inboundNodes[t].outputTensors)if(s.id===e.id){n=t;break}t=e.sourceLayer.getOutputAt(n)}return t}
},{"@tensorflow/tfjs-core":"kSBl","../errors":"iJtr","../utils/executor_utils":"QLpZ","../utils/generic_utils":"VKwv","./input_layer":"xdtw","./topology":"wHpB"}],"FSKJ":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.ENV=void 0;var e=require("@tensorflow/tfjs-core"),r=require("./engine/executor");const t=exports.ENV=(0,e.env)();t.registerFlag("TOPOLOGICAL_SORT_CACHE_MAX_ENTRIES",()=>100,r.updateCacheMaxEntries);
},{"@tensorflow/tfjs-core":"kSBl","./engine/executor":"w9qS"}],"zJV2":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.UnitNorm=exports.NonNeg=exports.MinMaxNorm=exports.MaxNorm=exports.Constraint=exports.CONSTRAINT_IDENTIFIER_REGISTRY_SYMBOL_MAP=void 0,exports.deserializeConstraint=c,exports.getConstraint=f,exports.serializeConstraint=p;var e=s(require("@tensorflow/tfjs-core")),t=e,a=require("./backend/common"),i=require("./utils/generic_utils");function s(e,t){if("function"==typeof WeakMap)var a=new WeakMap,i=new WeakMap;return(s=function(e,t){if(!t&&e&&e.__esModule)return e;var s,r,n={__proto__:null,default:e};if(null===e||"object"!=typeof e&&"function"!=typeof e)return n;if(s=t?i:a){if(s.has(e))return s.get(e);s.set(e,n)}for(const a in e)"default"!==a&&{}.hasOwnProperty.call(e,a)&&((r=(s=Object.defineProperty)&&Object.getOwnPropertyDescriptor(e,a))&&(r.get||r.set)?s(n,a,r):n[a]=e[a]);return n})(e,t)}function r(a,i){return(0,e.tidy)(()=>t.sqrt(t.sum(t.mul(a,a),i,!0)))}class n extends e.serialization.Serializable{getConfig(){return{}}}exports.Constraint=n;class l extends n{constructor(e){super(),this.defaultMaxValue=2,this.defaultAxis=0,this.maxValue=null!=e.maxValue?e.maxValue:this.defaultMaxValue,this.axis=null!=e.axis?e.axis:this.defaultAxis}apply(i){return(0,e.tidy)(()=>{const e=r(i,this.axis),s=t.clipByValue(e,0,this.maxValue);return t.mul(i,t.div(s,t.add((0,a.epsilon)(),e)))})}getConfig(){return{maxValue:this.maxValue,axis:this.axis}}}exports.MaxNorm=l,l.className="MaxNorm",e.serialization.registerClass(l);class u extends n{constructor(e){super(),this.defaultAxis=0,this.axis=null!=e.axis?e.axis:this.defaultAxis}apply(i){return(0,e.tidy)(()=>t.div(i,t.add((0,a.epsilon)(),r(i,this.axis))))}getConfig(){return{axis:this.axis}}}exports.UnitNorm=u,u.className="UnitNorm",e.serialization.registerClass(u);class o extends n{apply(e){return t.relu(e)}}exports.NonNeg=o,o.className="NonNeg",e.serialization.registerClass(o);class x extends n{constructor(e){super(),this.defaultMinValue=0,this.defaultMaxValue=1,this.defaultRate=1,this.defaultAxis=0,this.minValue=null!=e.minValue?e.minValue:this.defaultMinValue,this.maxValue=null!=e.maxValue?e.maxValue:this.defaultMaxValue,this.rate=null!=e.rate?e.rate:this.defaultRate,this.axis=null!=e.axis?e.axis:this.defaultAxis}apply(i){return(0,e.tidy)(()=>{const e=r(i,this.axis),s=t.add(t.mul(this.rate,t.clipByValue(e,this.minValue,this.maxValue)),t.mul(1-this.rate,e));return t.mul(i,t.div(s,t.add((0,a.epsilon)(),e)))})}getConfig(){return{minValue:this.minValue,maxValue:this.maxValue,rate:this.rate,axis:this.axis}}}exports.MinMaxNorm=x,x.className="MinMaxNorm",e.serialization.registerClass(x);const m=exports.CONSTRAINT_IDENTIFIER_REGISTRY_SYMBOL_MAP={maxNorm:"MaxNorm",minMaxNorm:"MinMaxNorm",nonNeg:"NonNeg",unitNorm:"UnitNorm"};function p(e){return(0,i.serializeKerasObject)(e)}function c(t,a={}){return(0,i.deserializeKerasObject)(t,e.serialization.SerializationMap.getMap().classNameMap,a,"constraint")}function f(e){if(null==e)return null;if("string"==typeof e){return c({className:e in m?m[e]:e,config:{}})}return e instanceof n?e:c(e)}
},{"@tensorflow/tfjs-core":"kSBl","./backend/common":"VOlA","./utils/generic_utils":"VKwv"}],"E5bG":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.maxNorm=r,exports.minMaxNorm=o,exports.nonNeg=t,exports.unitNorm=e;var n=require("./constraints");function r(r){return new n.MaxNorm(r)}function e(r){return new n.UnitNorm(r)}function t(){return new n.NonNeg}function o(r){return new n.MinMaxNorm(r)}
},{"./constraints":"zJV2"}],"hrGI":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.constant=o,exports.glorotNormal=f,exports.glorotUniform=c,exports.heNormal=l,exports.heUniform=m,exports.identity=a,exports.leCunNormal=p,exports.leCunUniform=x,exports.ones=e,exports.orthogonal=w,exports.randomNormal=u,exports.randomUniform=t,exports.truncatedNormal=i,exports.varianceScaling=s,exports.zeros=r;var n=require("./initializers");function r(){return new n.Zeros}function e(){return new n.Ones}function o(r){return new n.Constant(r)}function t(r){return new n.RandomUniform(r)}function u(r){return new n.RandomNormal(r)}function i(r){return new n.TruncatedNormal(r)}function a(r){return new n.Identity(r)}function s(r){return new n.VarianceScaling(r)}function c(r){return new n.GlorotUniform(r)}function f(r){return new n.GlorotNormal(r)}function l(r){return new n.HeNormal(r)}function m(r){return new n.HeUniform(r)}function p(r){return new n.LeCunNormal(r)}function x(r){return new n.LeCunUniform(r)}function w(r){return new n.Orthogonal(r)}
},{"./initializers":"Ltyq"}],"gooH":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.disposeTensorsInLogs=o,exports.resolveScalarsInLogs=e;var s=require("@tensorflow/tfjs-core");async function e(e){if(null==e)return;const o=[],n=[],t=[];for(const s in e){const r=e[s];if("number"!=typeof r){const e=r;o.push(e.data()),n.push(s),t.push(e)}}if(o.length>0){const r=await Promise.all(o);for(let s=0;s<r.length;++s)e[n[s]]=r[s][0];(0,s.dispose)(t)}}function o(s){if(null!=s)for(const e in s){const o=s[e];"number"!=typeof o&&o.dispose()}}
},{"@tensorflow/tfjs-core":"kSBl"}],"GDiE":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.ModelLoggingVerbosity=exports.History=exports.DEFAULT_YIELD_EVERY_MS=exports.CustomCallback=exports.CallbackList=exports.CallbackConstructorRegistry=exports.BaseLogger=exports.BaseCallback=void 0,exports.configureCallbacks=d,exports.standardizeCallbacks=p;var t,s=require("@tensorflow/tfjs-core"),n=require("./errors"),e=require("./logs"),o=a(require("./utils/generic_utils"));function a(t,s){if("function"==typeof WeakMap)var n=new WeakMap,e=new WeakMap;return(a=function(t,s){if(!s&&t&&t.__esModule)return t;var o,a,i={__proto__:null,default:t};if(null===t||"object"!=typeof t&&"function"!=typeof t)return i;if(o=s?e:n){if(o.has(t))return o.get(t);o.set(t,i)}for(const n in t)"default"!==n&&{}.hasOwnProperty.call(t,n)&&((a=(o=Object.defineProperty)&&Object.getOwnPropertyDescriptor(t,n))&&(a.get||a.set)?o(i,n,a):i[n]=t[n]);return i})(t,s)}!function(t){t[t.SILENT=0]="SILENT",t[t.VERBOSE=1]="VERBOSE"}(t||(exports.ModelLoggingVerbosity=t={}));const i=exports.DEFAULT_YIELD_EVERY_MS=125;class r{constructor(){this.validationData=null}setParams(t){this.params=t}async onEpochBegin(t,s){}async onEpochEnd(t,s){}async onBatchBegin(t,s){}async onBatchEnd(t,s){}async onTrainBegin(t){}async onTrainEnd(t){}setModel(t){}}exports.BaseCallback=r;class c{constructor(t,s=10){null==t&&(t=[]),this.callbacks=t,this.queueLength=s}append(t){this.callbacks.push(t)}setParams(t){for(const s of this.callbacks)s.setParams(t)}setModel(t){for(const s of this.callbacks)s.setModel(t)}async onEpochBegin(t,s){null==s&&(s={});for(const n of this.callbacks)await n.onEpochBegin(t,s)}async onEpochEnd(t,s){null==s&&(s={});for(const n of this.callbacks)await n.onEpochEnd(t,s)}async onBatchBegin(t,s){null==s&&(s={});for(const n of this.callbacks)await n.onBatchBegin(t,s)}async onBatchEnd(t,s){null==s&&(s={});for(const n of this.callbacks)await n.onBatchEnd(t,s)}async onTrainBegin(t){null==t&&(t={});for(const s of this.callbacks)await s.onTrainBegin(t)}async onTrainEnd(t){null==t&&(t={});for(const s of this.callbacks)await s.onTrainEnd(t)}}exports.CallbackList=c;class l extends r{constructor(){super()}async onEpochBegin(t){this.seen=0,this.totals={}}async onBatchEnd(t,n){null==n&&(n={});const e=null==n.size?0:n.size;this.seen+=e;for(const o in n){const t=n[o];if("number"==typeof t)this.totals.hasOwnProperty(o)||(this.totals[o]=0),this.totals[o]=this.totals[o]+t*e;else{let n;o in this.totals?n=this.totals[o]:this.totals[o]=0;const a=(0,s.tidy)(()=>(0,s.add)(this.totals[o],(0,s.mul)(t,e)));this.totals[o]=a,null!=n&&n.dispose()}}}async onEpochEnd(t,n){if(null!=n)for(const e of this.params.metrics)null!=this.totals[e]&&("number"==typeof this.totals[e]?n[e]=this.totals[e]/this.seen:(0,s.tidy)(()=>{const t=(0,s.mul)((0,s.div)(1,this.seen),this.totals[e]);n[e]=t,this.totals[e].dispose(),(0,s.keep)(n[e])}))}}exports.BaseLogger=l;class h extends r{async onTrainBegin(t){this.epoch=[],this.history={}}async onEpochEnd(t,s){null==s&&(s={}),this.epoch.push(t);for(const n in s)null==this.history[n]&&(this.history[n]=[]),this.history[n].push(s[n])}async syncData(){const t=[],s=[],n=[];for(const o in this.history){const e=this.history[o];for(let a=0;a<e.length;++a)if("number"!=typeof e[a]){const i=e[a];t.push(i.data()),s.push(o),n.push(a)}}const e=await Promise.all(t);for(let o=0;o<e.length;++o){this.history[s[o]][n[o]].dispose(),this.history[s[o]][n[o]]=e[o][0]}}}exports.History=h;class u extends r{constructor(t,n){if(super(),this.currentEpoch=0,this.nowFunc=t.nowFunc,this.nextFrameFunc=t.nextFrameFunc||s.nextFrame,this.yieldEvery=n||"auto","auto"===this.yieldEvery&&(this.yieldEvery=i),"never"===this.yieldEvery&&null!=t.onYield)throw new Error("yieldEvery is `never` but you provided an `onYield` callback. Either change `yieldEvery` or remove the callback");s.util.isNumber(this.yieldEvery)&&(this.maybeWait=o.debounce(this.maybeWait.bind(this),this.yieldEvery,this.nowFunc)),this.trainBegin=t.onTrainBegin,this.trainEnd=t.onTrainEnd,this.epochBegin=t.onEpochBegin,this.epochEnd=t.onEpochEnd,this.batchBegin=t.onBatchBegin,this.batchEnd=t.onBatchEnd,this.yield=t.onYield}async maybeWait(t,s,n){const o=[];null!=this.yield&&(await(0,e.resolveScalarsInLogs)(n),o.push(this.yield(t,s,n))),o.push(this.nextFrameFunc()),await Promise.all(o)}async onEpochBegin(t,s){this.currentEpoch=t,null!=this.epochBegin&&(await(0,e.resolveScalarsInLogs)(s),await this.epochBegin(t,s))}async onEpochEnd(t,s){const n=[];null!=this.epochEnd&&(await(0,e.resolveScalarsInLogs)(s),n.push(this.epochEnd(t,s))),"epoch"===this.yieldEvery&&n.push(this.nextFrameFunc()),await Promise.all(n)}async onBatchBegin(t,s){null!=this.batchBegin&&(await(0,e.resolveScalarsInLogs)(s),await this.batchBegin(t,s))}async onBatchEnd(t,n){const o=[];null!=this.batchEnd&&(await(0,e.resolveScalarsInLogs)(n),o.push(this.batchEnd(t,n))),"batch"===this.yieldEvery?o.push(this.nextFrameFunc()):s.util.isNumber(this.yieldEvery)&&o.push(this.maybeWait(this.currentEpoch,t,n)),await Promise.all(o)}async onTrainBegin(t){null!=this.trainBegin&&(await(0,e.resolveScalarsInLogs)(t),await this.trainBegin(t))}async onTrainEnd(t){null!=this.trainEnd&&(await(0,e.resolveScalarsInLogs)(t),await this.trainEnd(t))}}function p(t,s){if(null==t&&(t={}),t instanceof r)return[t];if(Array.isArray(t)&&t[0]instanceof r)return t;return o.toList(t).map(t=>new u(t,s))}exports.CustomCallback=u;class y{constructor(){}static registerCallbackConstructor(t,n){s.util.assert(t>=0&&Number.isInteger(t),()=>"Verbosity level is expected to be an integer >= 0, "+`but got ${t}`),y.checkForDuplicate(n),null==y.constructors[t]&&(y.constructors[t]=[]),y.constructors[t].push(n)}static checkForDuplicate(t){for(const s in y.constructors){y.constructors[+s].forEach(s=>{if(s===t)throw new n.ValueError("Duplicate callback constructor.")})}}static clear(){y.constructors={}}static createCallbacks(t){const s=[];for(const n in y.constructors){const e=+n;t>=e&&s.push(...y.constructors[e])}return s.map(t=>new t)}}function d(t,s,n,e,o,a,i,r,u){const p=new h,d=[new l,...y.createCallbacks(s)];null!=t&&d.push(...t),d.push(p);const E=new c(d);return E.setParams({epochs:n,initialEpoch:e,samples:o,steps:a,batchSize:i,verbose:s,doValidation:r,metrics:u}),{callbackList:E,history:p}}exports.CallbackConstructorRegistry=y,y.constructors={};
},{"@tensorflow/tfjs-core":"kSBl","./errors":"iJtr","./logs":"gooH","./utils/generic_utils":"VKwv"}],"bKFn":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.deserialize=i;var e=require("@tensorflow/tfjs-core"),r=require("../utils/generic_utils");function i(i,t={},a=!1){return(0,r.deserializeKerasObject)(i,e.serialization.SerializationMap.getMap().classNameMap,t,"layer",a)}
},{"@tensorflow/tfjs-core":"kSBl","../utils/generic_utils":"VKwv"}],"EG90":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.MSLE=exports.MSE=exports.MAPE=exports.MAE=exports.KLD=void 0,exports.binaryCrossentropy=b,exports.categoricalCrossentropy=x,exports.categoricalHinge=d,exports.cosine=void 0,exports.cosineProximity=M,exports.get=O,exports.hinge=m,exports.kld=void 0,exports.kullbackLeiblerDivergence=h,exports.l2Normalize=i,exports.logcosh=f,exports.mape=exports.mae=exports.lossesMap=void 0,exports.meanAbsoluteError=a,exports.meanAbsolutePercentageError=l,exports.meanSquaredError=u,exports.meanSquaredLogarithmicError=p,exports.msle=exports.mse=void 0,exports.poisson=E,exports.sigmoidCrossEntropyWithLogits=g,exports.sparseCategoricalCrossentropy=y,exports.squaredHinge=c;var e=n(require("@tensorflow/tfjs-core")),r=e,t=require("./backend/common"),o=n(require("./backend/tfjs_backend")),s=require("./errors");function n(e,r){if("function"==typeof WeakMap)var t=new WeakMap,o=new WeakMap;return(n=function(e,r){if(!r&&e&&e.__esModule)return e;var s,n,i={__proto__:null,default:e};if(null===e||"object"!=typeof e&&"function"!=typeof e)return i;if(s=r?o:t){if(s.has(e))return s.get(e);s.set(e,i)}for(const t in e)"default"!==t&&{}.hasOwnProperty.call(e,t)&&((n=(s=Object.defineProperty)&&Object.getOwnPropertyDescriptor(e,t))&&(n.get||n.set)?s(i,t,n):i[t]=e[t]);return i})(e,r)}function i(s,n){return(0,e.tidy)(()=>{"float32"!==s.dtype&&(s=r.cast(s,"float32"));const e=r.sum(o.square(s),n,!0),i=r.fill(e.shape,(0,t.epsilon)()),u=r.sqrt(r.maximum(e,i));return r.div(s,u)})}function u(t,s){return(0,e.tidy)(()=>r.mean(o.square(r.sub(s,t)),-1))}function a(t,o){return(0,e.tidy)(()=>r.mean(r.abs(r.sub(o,t)),-1))}function l(o,s){return(0,e.tidy)(()=>{const e=r.sub(o,s),n=r.clipByValue(r.abs(o),(0,t.epsilon)(),Number.MAX_VALUE),i=r.abs(r.div(e,n));return r.mul(100,r.mean(i,-1))})}function p(s,n){return(0,e.tidy)(()=>{const e=r.clipByValue(n,(0,t.epsilon)(),Number.MAX_VALUE),i=r.log(r.add(1,e)),u=r.clipByValue(s,(0,t.epsilon)(),Number.MAX_VALUE),a=r.log(r.add(1,u));return r.mean(o.square(r.sub(i,a)),-1)})}function c(t,s){return(0,e.tidy)(()=>{const e=r.maximum(0,r.sub(1,r.mul(t,s)));return r.mean(o.square(e),-1)})}function m(t,o){return(0,e.tidy)(()=>{const e=r.maximum(0,r.sub(1,r.mul(t,o)));return r.mean(e,-1)})}function d(t,o){return(0,e.tidy)(()=>{const e=r.sum(r.mul(t,o),-1),s=r.max(r.mul(r.sub(1,t),o),-1);return r.maximum(0,r.add(1,r.sub(s,e)))})}function f(t,o){return(0,e.tidy)(()=>{const e=Math.log(2),s=r.sub(o,t),n=r.sub(r.add(s,r.softplus(r.mul(-2,s))),e);return r.mean(n,-1)})}function x(o,s,n=!1){return(0,e.tidy)(()=>{if(n)s=r.softmax(s);else{const e=r.sum(s,s.shape.length-1,!0);s=r.div(s,e)}return s=r.clipByValue(s,(0,t.epsilon)(),1-(0,t.epsilon)()),r.neg(r.sum(r.mul(r.cast(o,"float32"),r.log(s)),s.shape.length-1))})}function y(s,n,i=!1){return(0,e.tidy)(()=>{const e=r.cast(r.floor(o.flatten(s)),"int32"),u=(n=r.clipByValue(n,(0,t.epsilon)(),1-(0,t.epsilon)())).shape;return x(r.reshape(r.oneHot(e,u[u.length-1]),u),n,i)})}function g(t,o){if(!e.util.arraysEqual(t.shape,o.shape))throw new s.ValueError("logits and labels must have the same shape, but got shapes "+`${JSON.stringify(t.shape)} and ${JSON.stringify(o.shape)}`);return(0,e.tidy)(()=>{const e=r.relu(o),s=r.neg(r.abs(o));return r.add(r.sub(e,r.mul(o,t)),r.log1p(r.exp(s)))})}function b(o,s){return(0,e.tidy)(()=>{let e;return e=r.clipByValue(s,(0,t.epsilon)(),1-(0,t.epsilon)()),e=r.log(r.div(e,r.sub(1,e))),r.mean(g(o,e),-1)})}function h(o,s){return(0,e.tidy)(()=>{const e=r.clipByValue(o,(0,t.epsilon)(),1),n=r.clipByValue(s,(0,t.epsilon)(),1);return r.sum(r.mul(o,r.log(r.div(e,n))),-1)})}function E(o,s){return(0,e.tidy)(()=>{const e=r.log(r.add((0,t.epsilon)(),s));return r.mean(r.sub(s,r.mul(o,e)),-1)})}function M(t,o){return(0,e.tidy)(()=>{const e=i(t,-1),s=i(o,-1),n=r.mul(e,s);return r.neg(r.sum(n,-1))})}const v=exports.mse=u,q=exports.MSE=u,k=exports.mae=a,A=exports.MAE=a,L=exports.mape=l,V=exports.MAPE=l,w=exports.msle=p,C=exports.MSLE=p,_=exports.kld=h,P=exports.KLD=h,S=exports.cosine=M,B=exports.lossesMap={meanSquaredError:u,meanAbsoluteError:a,meanAbsolutePercentageError:l,meanSquaredLogarithmicError:p,squaredHinge:c,hinge:m,categoricalHinge:d,logcosh:f,categoricalCrossentropy:x,sparseCategoricalCrossentropy:y,binaryCrossentropy:b,kullbackLeiblerDivergence:h,poisson:E,cosineProximity:M};function O(e){if("string"==typeof e){if(e in B)return B[e];let r=`Unknown loss ${e}`;throw e.toLowerCase().includes("softmaxcrossentropy")&&(r=`Unknown loss ${e}. `+'Use "categoricalCrossentropy" as the string name for tf.losses.softmaxCrossEntropy'),new s.ValueError(r)}return e}
},{"@tensorflow/tfjs-core":"kSBl","./backend/common":"VOlA","./backend/tfjs_backend":"Ftmo","./errors":"iJtr"}],"kNCu":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.MSE=exports.MAPE=exports.MAE=void 0,exports.binaryAccuracy=c,exports.binaryCrossentropy=d,exports.categoricalAccuracy=i,exports.cosine=exports.categoricalCrossentropy=void 0,exports.get=O,exports.getLossOrMetricName=j,exports.mse=exports.metricsMap=exports.mape=exports.mae=void 0,exports.precision=f,exports.r2Score=M,exports.recall=y,exports.sparseCategoricalAccuracy=x,exports.sparseCategoricalCrossentropy=void 0,exports.sparseTopKCategoricalAccuracy=m,exports.topKCategoricalAccuracy=g;var e=a(require("@tensorflow/tfjs-core")),r=e,t=a(require("./backend/tfjs_backend")),o=require("./errors"),s=require("./losses"),n=a(require("./utils/generic_utils"));function a(e,r){if("function"==typeof WeakMap)var t=new WeakMap,o=new WeakMap;return(a=function(e,r){if(!r&&e&&e.__esModule)return e;var s,n,a={__proto__:null,default:e};if(null===e||"object"!=typeof e&&"function"!=typeof e)return a;if(s=r?o:t){if(s.has(e))return s.get(e);s.set(e,a)}for(const t in e)"default"!==t&&{}.hasOwnProperty.call(e,t)&&((n=(s=Object.defineProperty)&&Object.getOwnPropertyDescriptor(e,t))&&(n.get||n.set)?s(a,t,n):a[t]=e[t]);return a})(e,r)}function c(o,s){return(0,e.tidy)(()=>{const e=r.mul(.5,r.onesLike(s)),n=t.cast(r.greater(s,e),o.dtype);return r.mean(r.equal(o,n),-1)})}function i(o,s){return(0,e.tidy)(()=>t.cast(r.equal(r.argMax(o,-1),r.argMax(s,-1)),"float32"))}function u(t,o){return(0,e.tidy)(()=>r.cast(r.sum(r.logicalAnd(r.equal(t,1),r.equal(o,1))),"float32"))}function p(t,o){return(0,e.tidy)(()=>r.cast(r.sum(r.logicalAnd(r.equal(t,1),r.equal(o,0))),"float32"))}function l(t,o){return(0,e.tidy)(()=>r.cast(r.sum(r.logicalAnd(r.equal(t,0),r.equal(o,1))),"float32"))}function f(t,o){return(0,e.tidy)(()=>{const e=u(t,o),s=l(t,o),n=r.add(e,s);return r.cast(r.where(r.greater(n,0),r.div(e,n),0),"float32")})}function y(t,o){return(0,e.tidy)(()=>{const e=u(t,o),s=p(t,o),n=r.add(e,s);return r.cast(r.where(r.greater(n,0),r.div(e,n),0),"float32")})}function d(e,r){return(0,s.binaryCrossentropy)(e,r)}function x(e,t){return e.rank===t.rank&&(e=r.squeeze(e,[e.rank-1])),(t=r.argMax(t,-1)).dtype!==e.dtype&&(t=r.cast(t,e.dtype)),r.cast(r.equal(e,t),"float32")}function g(e,r){throw new o.NotImplementedError}function m(e,r){throw new o.NotImplementedError}function M(t,o){return(0,e.tidy)(()=>{const e=t.sub(o).square().sum(),s=t.sub(t.mean()).square().sum();return r.scalar(1).sub(e.div(s))})}const b=exports.mse=s.meanSquaredError,A=exports.MSE=s.meanSquaredError,q=exports.mae=s.meanAbsoluteError,E=exports.MAE=s.meanAbsoluteError,C=exports.mape=s.meanAbsolutePercentageError,k=exports.MAPE=s.meanAbsolutePercentageError,w=exports.categoricalCrossentropy=s.categoricalCrossentropy,v=exports.cosine=s.cosineProximity,P=exports.sparseCategoricalCrossentropy=s.sparseCategoricalCrossentropy,_=exports.metricsMap={binaryAccuracy:c,categoricalAccuracy:i,precision:f,categoricalCrossentropy:w,sparseCategoricalCrossentropy:P,mse:b,MSE:A,mae:q,MAE:E,mape:C,MAPE:k,cosine:v};function O(e){if("string"==typeof e&&e in _)return _[e];if("string"!=typeof e&&null!=e)return e;throw new o.ValueError(`Unknown metric ${e}`)}function j(e){if(n.assert(null!==e,`Unknown LossOrMetricFn ${e}`),"string"==typeof e)return e;{let r;for(const t of Object.keys(s.lossesMap))if(s.lossesMap[t]===e){r=t;break}if(void 0!==r)return r;for(const t of Object.keys(_))if(_[t]===e){r=t;break}return void 0!==r?r:e.name}}
},{"@tensorflow/tfjs-core":"kSBl","./backend/tfjs_backend":"Ftmo","./errors":"iJtr","./losses":"EG90","./utils/generic_utils":"VKwv"}],"FwoH":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.getOptimizer=d;var a=require("@tensorflow/tfjs-core"),r=require("./backend/common"),e=require("./errors");function d(d){const t={Adagrad:()=>a.train.adagrad(.01),Adadelta:()=>a.train.adadelta(1,.95,(0,r.epsilon)()),Adam:()=>a.train.adam(.001,.9,.999,(0,r.epsilon)()),Adamax:()=>a.train.adamax(.002,.9,.999,(0,r.epsilon)(),0),RMSProp:()=>a.train.rmsprop(.001,.9,0,(0,r.epsilon)()),SGD:()=>a.train.sgd(.01)};if(t.adagrad=t.Adagrad,t.adadelta=t.Adadelta,t.adam=t.Adam,t.adamax=t.Adamax,t.rmsprop=t.RMSProp,t.sgd=t.SGD,d in t)return t[d]();throw new e.ValueError(`Unknown Optimizer ${d}`)}
},{"@tensorflow/tfjs-core":"kSBl","./backend/common":"VOlA","./errors":"iJtr"}],"hhZn":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.MAX_USER_DEFINED_METADATA_SERIALIZED_LENGTH=void 0,exports.checkUserDefinedMetadata=t,exports.plainObjectCheck=r;const e=exports.MAX_USER_DEFINED_METADATA_SERIALIZED_LENGTH=1048576;function t(t,o,n=!1){if(null==t||"object"!=typeof t||Object.getPrototypeOf(t)!==Object.prototype||!r(t))throw new Error("User-defined metadata is expected to be a JSON object, but is not.");if(n){const r=JSON.stringify(t);r.length>e&&console.warn(`User-defined metadata of model "${o}" is too large in `+`size (length=${r.length} when serialized). It is not `+"recommended to store such large objects in user-defined metadata. Please make sure its serialized length is <= "+`${e}.`)}}function r(e){if(null===e)return!0;if("object"==typeof e){if(Object.getPrototypeOf(e)===Object.prototype){const t=Object.keys(e);for(const o of t){if("string"!=typeof o)return!1;if(!r(e[o]))return!1}return!0}if(Array.isArray(e)){for(const t of e)if(!r(t))return!1;return!0}return!1}{const t=typeof e;return"string"===t||"number"===t||"boolean"===t}}
},{}],"uvqr":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.printSummary=t;var e=require("./variable_utils");function t(t,r,l,c=console.log){const u=o(t),h=["Layer (type)","Input Shape","Output shape","Param #"];let p;if(u?(r=r||90,l=l||[.32,.61,.89,1]):(r=r||115,l=l||[.24,.48,.7,.8,1]),l[l.length-1]<=1&&(l=l.map(e=>Math.floor(r*e))),!u){h.push("Receives inputs"),p=[];for(const e in t.nodesByDepth)p.push(...t.nodesByDepth[e])}c("_".repeat(r)),s(h,l,c),c("=".repeat(r));const f=t.layers;for(let e=0;e<f.length;++e)u?a(f[e],l,c):i(f[e],l,p,c),c((e===f.length-1?"=":"_").repeat(r));t.checkTrainableWeightsConsistency();const g=n(t),d=(0,e.countParamsInWeights)(t.nonTrainableWeights);c(`Total params: ${g+d}`),c(`Trainable params: ${g}`),c(`Non-trainable params: ${d}`),c("_".repeat(r))}function n(t){let n;return n=null!=t.collectedTrainableWeights?(0,e.countParamsInWeights)(t.collectedTrainableWeights):(0,e.countParamsInWeights)(t.trainableWeights)}function o(e){let t=!0;const n=[],o=[];for(const s in e.nodesByDepth)n.push(e.nodesByDepth[s]);for(const s of n){if(s.length>1||1===s.length&&s[0].inboundLayers.length>1){t=!1;break}o.push(...s)}if(t)for(const s of e.layers){let e=!1;for(const n of s.inboundNodes)if(-1!==o.indexOf(n)){if(e){t=!1;break}e=!0}if(!t)break}return t}function s(e,t,n=console.log){let o="";for(let s=0;s<e.length;++s)s>0&&(o=o.slice(0,o.length-1)+" "),o=(o+=e[s]).slice(0,t[s]),o+=" ".repeat(t[s]-o.length);n(o)}function a(e,t,n){let o,a;try{a=e.inboundNodes.map(e=>JSON.stringify(e.inputShapes)).join(",")}catch(i){a="multiple"}try{o=JSON.stringify(e.outputShape)}catch(i){o="multiple"}s([`${e.name} (${e.getClassName()})`,a,o,e.countParams().toString()],t,n)}function i(e,t,n,o){let a,i;try{i=e.inboundNodes.map(e=>JSON.stringify(e.inputShapes)).join(",")}catch(h){i="multiple"}try{a=JSON.stringify(e.outputShape)}catch(h){a="multiple"}const r=[];for(const s of e.inboundNodes)if(!(null!=n&&n.length>0&&-1===n.indexOf(s)))for(let e=0;e<s.inboundLayers.length;++e){const t=s.inboundLayers[e].name,n=s.nodeIndices[e],o=s.tensorIndices[e];r.push(`${t}[${n}][${o}]`)}const l=e.name,c=e.getClassName(),u=0===r.length?"":r[0];s([`${l} (${c})`,i,a,e.countParams().toString(),u],t,o);for(let p=1;p<r.length;++p)s(["","","","",r[p]],t,o)}
},{"./variable_utils":"NSdo"}],"eha7":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.convertPythonicToTs=r,exports.convertTsToPythonic=o;var e=t(require("../utils/generic_utils"));function t(e,n){if("function"==typeof WeakMap)var r=new WeakMap,o=new WeakMap;return(t=function(e,t){if(!t&&e&&e.__esModule)return e;var n,s,u={__proto__:null,default:e};if(null===e||"object"!=typeof e&&"function"!=typeof e)return u;if(n=t?o:r){if(n.has(e))return n.get(e);n.set(e,u)}for(const r in e)"default"!==r&&{}.hasOwnProperty.call(e,r)&&((s=(n=Object.defineProperty)&&Object.getOwnPropertyDescriptor(e,r))&&(s.get||s.set)?n(u,r,s):u[r]=e[r]);return u})(e,n)}function n(e,t,n){return("inboundNodes"===e||"outputLayers"===e||"inputLayers"===e)&&0===t&&"string"==typeof n}function r(t,o){if(null===t)return null;if("string"==typeof t)return e.toCamelCase(t);if("number"==typeof t||"boolean"==typeof t)return t;if(t instanceof Array){const e=[],s=t.length;for(let u=0;u<s;++u){const s=t[u];n(o,u,s)?e.push(s):e.push(r(s,o))}return e}{const n={};for(const o of Object.keys(t)){const s=t[o];if("name"===o&&"string"==typeof s)n[o]=s;else{const t=e.toCamelCase(o);n[t]=r(s,t)}}return n}}function o(t,r){if(null==t)return null;if("string"==typeof t)return e.toSnakeCase(t);if("number"==typeof t||"boolean"==typeof t)return t;if(t instanceof Array){const e=[],s=t.length;for(let u=0;u<s;++u){const s=t[u];n(r,u,s)?e.push(s):e.push(o(s,r))}return e}{const n={};for(const r of Object.keys(t)){const s=t[r],u=e.toSnakeCase(r);n[u]="name"!==r&&"className"!==r||"string"!=typeof s?o(s,r):s}return n}}
},{"../utils/generic_utils":"VKwv"}],"QFjJ":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.Container=void 0;var t=require("@tensorflow/tfjs-core"),e=require("../backend/state"),s=require("../errors"),n=require("../layers/serialization"),o=p(require("../utils/generic_utils")),i=require("../utils/serialization_utils"),r=p(require("../utils/types_utils")),a=require("../variables"),u=require("../version"),l=require("./executor"),h=require("./input_layer"),c=require("./topology");function p(t,e){if("function"==typeof WeakMap)var s=new WeakMap,n=new WeakMap;return(p=function(t,e){if(!e&&t&&t.__esModule)return t;var o,i,r={__proto__:null,default:t};if(null===t||"object"!=typeof t&&"function"!=typeof t)return r;if(o=e?n:s){if(o.has(t))return o.get(t);o.set(t,r)}for(const s in t)"default"!==s&&{}.hasOwnProperty.call(t,s)&&((i=(o=Object.defineProperty)&&Object.getOwnPropertyDescriptor(t,s))&&(i.get||i.set)?o(r,s,i):r[s]=t[s]);return r})(t,e)}const d=t=>{const e=Object.keys(t);if(0===e.length)return!1;const s=e[0].split("/");return!isNaN(parseInt(s[s.length-1],10))};class f extends c.Layer{constructor(t){if(super({}),this.containerNodes=new Set,this.name=t.name,null==this.name){const t=this.getClassName().toLowerCase();this.name=(0,e.getUid)(t)}if(this.supportsMasking=!1,this.trainable_=!0,Array.isArray(t.inputs)?this.inputs=t.inputs.slice():this.inputs=[t.inputs],Array.isArray(t.outputs)?this.outputs=t.outputs.slice():this.outputs=[t.outputs],o.unique(this.inputs).length!==this.inputs.length)throw new s.ValueError("The list of inputs passed to the model is redundant. All inputs should only appear once. Found: "+`${this.inputs.map(t=>t.name)}`);o.unique(this.outputs).length!==this.outputs.length&&console.warn("The list of outputs passed to the model is redundant. All outputs should only appear once. Found: "+`${this.outputs.map(t=>t.name)}`),this.inputLayers=[],this.inputLayersNodeIndices=[],this.inputLayersTensorIndices=[],this.outputLayers=[],this.outputLayersNodeIndices=[],this.outputLayersTensorIndices=[],this.layers=[],this.internalContainerRefs=[];for(const e of this.outputs){const t=e.sourceLayer,s=e.nodeIndex,n=e.tensorIndex;this.outputLayers.push(t),this.outputLayersNodeIndices.push(s),this.outputLayersTensorIndices.push(n)}for(const e of this.inputs){const t=e.sourceLayer,s=e.nodeIndex,n=e.tensorIndex;o.assert(0===s,"input layer has >1 nodes"),o.assert(0===n,"input layer has >1 tensors"),this.inputLayers.push(t),this.inputLayersNodeIndices.push(s),this.inputLayersTensorIndices.push(n)}this.inputNames=[],this.outputNames=[],this.feedInputShapes=[],this.feedInputNames=[],this.feedOutputNames=[];for(let e=0;e<this.inputLayers.length;e++){const s=this.inputLayers[e];if(!(s instanceof h.InputLayer))throw new TypeError("Input layers to a LayersModel must be InputLayer objects. "+`Received inputs: ${t.inputs}. `+`Input ${e} (0-based) originates `+`from layer type ${s.getClassName()}.`);this.inputNames.push(s.name),this.feedInputShapes.push(s.batchInputShape),this.feedInputNames.push(s.name)}for(const e of this.outputLayers)this.outputNames.push(e.name);this.internalInputShapes=this.inputs.map(t=>t.shape),this.internalOutputShapes=this.outputs.map(t=>t.shape);const n={},i={},r={},a={},u={},l=[],p=(t,e,n,o,i,r)=>{null!=o&&null!=i&&null!=r||(o=t.sourceLayer,i=t.nodeIndex,r=t.tensorIndex);const a=o.inboundNodes[i];if(-1!==n.indexOf(a))throw new s.RuntimeError(`The tensor ${t.name} at layer "${o.name}" `+"is part of a cycle.");if(-1!==e.indexOf(a))return;this.containerNodes.add(f.nodeKey(o,i)),o.id in u||(u[o.id]=Object.keys(u).length),-1===n.indexOf(a)&&n.push(a);const h=a.inboundLayers.length;for(let s=0;s<h;s++){const t=a.inputTensors[s],o=a.inboundLayers[s],i=a.nodeIndices[s],r=a.tensorIndices[s];p(t,e,n,o,i,r)}for(e.push(a);n.indexOf(a)>=0;)n.splice(n.indexOf(a),1);l.push(a)},d=[],y=[];for(const e of this.outputs)p(e,d,y);const m=l.slice().reverse();for(const e of m){i[e.id]=e,e.id in n||(n[e.id]=0);let t=n[e.id];const s=null==r[e.outboundLayer.id]?0:r[e.outboundLayer.id];t=Math.max(t,s),r[e.outboundLayer.id]=t,a[e.outboundLayer.id]=e.outboundLayer,n[e.id]=t;for(let o=0;o<e.inboundLayers.length;o++){const s=e.inboundLayers[o],r=e.nodeIndices[o],a=s.inboundNodes[r],u=null==n[a.id]?0:n[a.id];n[a.id]=Math.max(t+1,u),i[a.id]=a}}const g={};for(const e in n){const t=n[e];t in g||(g[t]=[]),g[t].push(i[e])}const b={};for(const e in r){const t=r[e];t in b||(b[t]=[]),b[t].push(a[e])}let L=Object.keys(b).map(t=>parseInt(t,10)).sort(o.reverseNumberCompare);this.layers=[];for(const e of L){const t=b[e];t.sort((t,e)=>{const s=u[t.id],n=u[e.id];return s<n?-1:s>n?1:0});for(const e of t)e instanceof f&&this.internalContainerRefs.push(e),this.layers.push(e)}this.layersByDepth=b,L=Object.keys(g).map(t=>parseInt(t,10)).sort(o.reverseNumberCompare);const w=this.inputs.slice(),N=[];for(const e of L)for(const t of g[e]){const e=t.outboundLayer;if(null!=e){for(const n of t.inputTensors)if(-1===w.indexOf(n))throw new s.RuntimeError(`Graph disconnected: cannot obtain value for tensor ${n}`+` at layer "${e.name}". `+"The following previous layers were accessed without "+`issue: ${N}`);for(const e of t.outputTensors)w.push(e);N.push(e.name)}}this.nodesByDepth=g;const I=this.layers.map(t=>t.name);for(const e of I){const t=I.filter(t=>t===e).length;if(1!==t)throw new s.RuntimeError(`The name "${e}" is used ${t} times `+"in the model. All layer names should be unique. Layer names: "+JSON.stringify(I))}this.outboundNodes=[],this.inboundNodes=[],new c.Node({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:this.inputs,outputTensors:this.outputs,inputMasks:this.inputs.map(t=>null),outputMasks:this.outputs.map(t=>null),inputShapes:this.inputs.map(t=>t.shape),outputShapes:this.outputs.map(t=>t.shape)}),this.built=!0,this._refCount=1}assertNotDisposed(){if(0===this._refCount)throw new Error(`Container '${this.name}' is already disposed.`)}dispose(){this.assertNotDisposed();const t={refCountAfterDispose:null,numDisposedVariables:0};if(0==--this._refCount){for(const e of this.layers)t.numDisposedVariables+=e.dispose().numDisposedVariables;for(const e of this.internalContainerRefs)t.numDisposedVariables+=e.dispose().numDisposedVariables}return t.refCountAfterDispose=this._refCount,t}get trainable(){return this.trainable_}set trainable(t){this.layers.forEach(e=>{e._trainableWeights.forEach(e=>e.trainable=t)}),this.trainable_=t}get trainableWeights(){if(this._trainableWeights.length>0)throw new s.ValueError("Container instance unexpectedly contains _trainableWeights.The trainable weights of a Container are a union of the trainable weights of its consituent Layers. Its own _trainableWeights must remain an empty Array.");if(!this.trainable)return[];let t=[];for(const e of this.layers)t=t.concat(e.trainableWeights);return t}get nonTrainableWeights(){const t=[];for(const e of this.layers)t.push(...e.nonTrainableWeights);if(!this.trainable){const e=[];for(const t of this.layers)e.push(...t.trainableWeights);return e.concat(t)}return t}get weights(){return this.trainableWeights.concat(this.nonTrainableWeights)}loadWeights(t,e=!0){const n={};let o=0;const i=d(t);i&&this.parseWeights(t);for(const a of this.layers)for(const[t,e]of a.weights.entries()){const r=i?`${e.name.split("/").slice(0,-1).join("/")+"/"}${t}`:e.originalName;if(null!=n[r])throw new s.ValueError(`Duplicate weight name: ${r}`);n[r]=e,o++}const r=[];for(const a in t){let o=a;if(null==n[a]){const t=a.split("/");o=t.slice(0,-2).concat([t[t.length-1]]).join("/")}if(null!=n[o])r.push([n[o],t[a]]);else if(e)throw new s.ValueError(`Provided weight data has no target variable: ${a}`);delete n[o]}if(e){const t=[];for(const e in n)t.push(e);if(t.length>0)throw new s.ValueError(`${t.length} of ${o} weights are not set: `+`${t}`)}(0,a.batchSetValue)(r)}parseWeights(t){for(const e in Object.keys(t)){const s=e.split("/"),n=["vars","layer_checkpoint_dependencies"],o=s.map(t=>t.startsWith("_")?t.slice(1):t).filter(t=>!n.includes(t)).join("/");o!==e&&(t[o]=t[e],delete t[e])}}updatedConfig(){const t=this.getConfig(),e={};return e.className=this.getClassName(),e.config=t,e.kerasVersion=`tfjs-layers ${u.version}`,e.backend="TensorFlow.js",e}toJSON(t,e=!0){const s=(0,i.convertTsToPythonic)(this.updatedConfig());return e?JSON.stringify(s):s}call(e,s){return(0,t.tidy)(()=>{e=o.toList(e);const t=new l.FeedDict;for(let s=0;s<this.inputs.length;++s)t.add(this.inputs[s],e[s]);return(0,l.execute)(this.outputs,t,s)})}computeMask(e,s){return(0,t.tidy)(()=>{let t;return e=o.toList(e),t=null==s?o.pyListRepeat(null,e.length):o.toList(s),this.runInternalGraph(e,t)[1]})}computeOutputShape(t){const e=r.normalizeShapeList(t);if(e.length!==this.inputLayers.length)throw new s.ValueError(`Invalid inputShape argument ${t}: `+`model has ${this.inputLayers.length} tensor inputs.`);const n={};for(let s=0;s<e.length;s++){const t=this.inputLayers[s],o=e[s];n[t.name+"_0_0"]=o}const i=Object.keys(this.nodesByDepth).map(t=>parseInt(t,10)).sort(o.reverseNumberCompare);if(i.length>1)for(const s of i){const t=this.nodesByDepth[s];for(const e of t){const t=e.outboundLayer;if(-1!==this.inputLayers.map(t=>t.id).indexOf(t.id))continue;const s=[];for(let o=0;o<e.inboundLayers.length;o++){const t=e.inboundLayers[o],i=e.nodeIndices[o],r=e.tensorIndices[o],a=n[`${t.name}_${i}_${r}`];s.push(a)}const i=t.computeOutputShape(o.singletonOrArray(s)),a=r.normalizeShapeList(i),u=t.inboundNodes.indexOf(e);for(let e=0;e<a.length;e++){n[`${t.name}_${u}_${e}`]=a[e]}}}const a=[],u=[];for(let s=0;s<this.outputLayers.length;s++){const t=this.outputLayers[s],e=this.outputLayersNodeIndices[s],n=this.outputLayersTensorIndices[s],o=`${t.name}_${e}_${n}`;u.push(o)}for(let s=0;s<u.length;s++){const t=u[s];o.assert(t in n),a.push(n[t])}return o.singletonOrArray(a)}runInternalGraph(t,e){null==e&&(e=o.pyListRepeat(null,t.length));const n={};for(let s=0;s<this.inputs.length;++s){const o=this.inputs[s],i=t[s],r=e[s];n[o.id]=[i,r]}const i=Object.keys(this.nodesByDepth).map(t=>parseInt(t,10)).sort(o.reverseNumberCompare);for(const l of i){const t=this.nodesByDepth[l];for(const e of t){const t=e.outboundLayer,i=e.inputTensors,r=e.outputTensors,a=new Array;for(const e of i)e.id in n&&a.push(n[e.id]);if(a.length===i.length){let i,u,l,h,c={};if(null!=e.callArgs&&(c=e.callArgs),1===a.length){const[e,s]=a[0];null==c.mask&&(c.mask=s),l=o.toList(t.call(e,c)),h=o.toList(t.computeMask(e,s)),i=[e],u=[s]}else i=a.map(t=>t[0]),u=a.map(t=>t[1]),null==c.mask&&(c.mask=u),l=o.toList(t.call(i,c)),h=o.toList(t.computeMask(i,u));if(t.activityRegularizer)throw new s.NotImplementedError("LayersModel invocation with concrete Tensor value(s) in the presence of activity regularizer(s) is not supported yet.");for(let t=0;t<r.length;++t){const e=r[t],s=l[t],o=h[t];n[e.id]=[s,o]}}}}const r=[],a=[],u=[];for(const s of this.outputs){o.assert(s.id in n,`Could not compute output ${s.name} : ${s.id}`);const[t,e]=n[s.id];u.push(t.shape),r.push(t),a.push(e)}return[r,a,u]}buildNodeConversionMap(t){const e={};let s;for(const n of this.layers){s=n instanceof f?1:0;for(let t=0;t<n.inboundNodes.length;t++){const o=f.nodeKey(n,t);this.containerNodes.has(o)&&(e[o]=s,s+=1)}}return e}getLayer(t,e){if(null!=e)return this.findLayer(e);if(null==t)throw new s.ValueError("Provide either a layer name or layer index");if("number"==typeof t)return this.findLayer(t);for(const s of this.layers)if(s.name===t)return s;throw new s.ValueError(`No such layer: ${t}`)}findLayer(t){if(this.layers.length<=t)throw new s.ValueError(`Was asked to retrieve layer at index ${t}, but model only `+`has ${this.layers.length} layer(s).`);return this.layers[t]}calculateLosses(){return(0,t.tidy)(()=>{const t=[];for(const e of this.layers)for(let s=0;s<e.inboundNodes.length;++s){const n=f.nodeKey(e,s);this.containerNodes.has(n)&&t.push(...e.calculateLosses())}return t})}getConfig(){const t={name:this.name},e=this.buildNodeConversionMap(this.layers),s=[];for(const r of this.layers){const t=r.getClassName(),n=r.getConfig(),o=[];for(let s=0;s<r.inboundNodes.length;s++){const t=r.inboundNodes[s],n=f.nodeKey(r,s);let a={};if(this.containerNodes.has(n)){if(t.callArgs)try{JSON.stringify(t.callArgs),a=t.callArgs}catch(i){console.warn(`Layer ${r.name} was passed `+"non-serializable keyword arguments: "+`${t.callArgs}. They will not be included `+"in the serialized model (and thus will be missing at deserialization time)."),a={}}if(t.inboundLayers.length>0){const s=[];for(let n=0;n<t.inboundLayers.length;n++){const o=t.inboundLayers[n],i=t.nodeIndices[n],r=t.tensorIndices[n];let u=e[f.nodeKey(o,i)];null==u&&(u=0),s.push([o.name,u,r,a])}o.push(s)}}}const a={};a.name=r.name,a.className=t,a.config=n,a.inboundNodes=o,s.push(a)}t.layers=s;const n=[];for(let r=0;r<this.inputLayers.length;r++){const t=this.inputLayers[r],s=this.inputLayersNodeIndices[r],o=f.nodeKey(t,s);if(!this.containerNodes.has(o))continue;let i=e[o];null==i&&(i=0);const a=this.inputLayersTensorIndices[r];n.push([t.name,i,a])}t.inputLayers=n;const o=[];for(let r=0;r<this.outputLayers.length;r++){const t=this.outputLayers[r],s=this.outputLayersNodeIndices[r],n=f.nodeKey(t,s);if(!this.containerNodes.has(n))continue;let i=e[n];null==i&&(i=0);const a=this.outputLayersTensorIndices[r];o.push([t.name,i,a])}return t.outputLayers=o,t}static fromConfig(t,e,i={},r=!1){const a={},u={};function l(t,e){t.name in u?u[t.name].push(e):u[t.name]=[e]}function h(t,e){const s=[];let n;for(const o of e){const i=o[0],r=o[1],u=o[2];if(n=null==o[3]?{}:o[3],!(i in a))return void l(t,e);const h=a[i];if(h.inboundNodes.length<=r)return void l(t,e);const c=h.inboundNodes[r];s.push(c.outputTensors[u])}s.length>0&&t.apply(o.singletonOrArray(s),n)}function c(t){const o=t.name,i=(0,n.deserialize)(t,null!=e.customObjects?e.customObjects:{});i.setFastWeightInitDuringBuild(r),a[o]=i,t.inboundNodes.forEach(t=>{if(!(t instanceof Array))throw new s.ValueError(`Corrupted configuration, expected array for nodeData: ${t}`);l(i,t)})}const p=e.name,d=e.layers;for(const s of d)c(s);for(;!o.isObjectEmpty(u);)for(const t of d){const e=a[t.name];if(e.name in u){const t=u[e.name];delete u[e.name];for(const s of t)h(e,s)}}const f=[],y=[],m=e.inputLayers;for(const s of m){const t=s[0],e=s[1],n=s[2];o.assert(t in a);const i=a[t].inboundNodes[e].outputTensors;f.push(i[n])}const g=e.outputLayers;for(const s of g){const t=s[0],e=s[1],n=s[2];o.assert(t in a);const i=a[t].inboundNodes[e].outputTensors;y.push(i[n])}return new t({inputs:f,outputs:y,name:p})}get stateful(){if(this._stateful)throw new s.ValueError("Container instance unexpectedly has _stateful = true. The statefulness of a Container is determined by the Layers it contains. Its _stateful property must remain the default false.");for(const t of this.layers)if(t.stateful)return!0;return!1}resetStates(){(0,t.tidy)(()=>{this.layers.forEach(t=>{t.stateful&&t.resetStates()})})}}exports.Container=f;
},{"@tensorflow/tfjs-core":"kSBl","../backend/state":"R2ma","../errors":"iJtr","../layers/serialization":"bKFn","../utils/generic_utils":"VKwv","../utils/serialization_utils":"eha7","../utils/types_utils":"mOET","../variables":"mwlr","../version":"KPnh","./executor":"w9qS","./input_layer":"xdtw","./topology":"wHpB"}],"DnBX":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.computeWeightedLoss=o,exports.standardizeClassWeights=r,exports.standardizeSampleWeights=n,exports.standardizeWeights=s;var e=require("@tensorflow/tfjs-core");function t(e,t,r){const n=t.length;if(null==e||Array.isArray(e)&&0===e.length)return t.map(e=>null);if(1===n)return Array.isArray(e)&&1===e.length?e:"object"==typeof e&&t[0]in e?[e[t[0]]]:[e];if(Array.isArray(e)){if(e.length!==n)throw new Error(`Provided ${r} is an array of ${e.length} `+`element(s), but the model has ${n} outputs. `+"Make sure a set of weights is provided for each model output.");return e}if("object"==typeof e&&Object.keys(e).length>0&&"object"==typeof e[Object.keys(e)[0]]){const r=[];return t.forEach(t=>{t in e?r.push(e[t]):r.push(null)}),r}throw new Error(`The model has multiple (${n}) outputs, `+`so ${r} must be either an array with `+`${n} elements or an object with ${t} keys. `+`Provided ${r} not understood: ${JSON.stringify(e)}`)}function r(e,r){return t(e,r,"classWeight")}function n(e,r){return t(e,r,"sampleWeight")}async function s(t,r,n,s){if(null!=r||null!=s)throw new Error("Support sampleWeight is not implemented yet");if(null!=n){const r=(0,e.tidy)(()=>{if(1===t.shape.length)return(0,e.clone)(t);if(2===t.shape.length){if(t.shape[1]>1){const r=1;return(0,e.argMax)(t,r)}if(1===t.shape[1])return(0,e.reshape)(t,[t.shape[0]]);throw new Error(`Encountered unexpected last-dimension size (${t.shape[1]}) `+"during handling of class weights. The size is expected to be >= 1.")}throw new Error(`Unexpected rank of target (y) tensor (${t.rank}) during `+"handling of class weights. The rank is expected to be 1 or 2.")}),s=Array.from(await r.data());(0,e.dispose)(r);const o=[];return s.forEach(e=>{if(null==n[e])throw new Error("classWeight must contain all classes in the training data. "+`The class ${e} exists in the data but not in `+"classWeight");o.push(n[e])}),(0,e.tensor1d)(o,"float32")}return null}function o(t,r){return(0,e.mul)(t,r)}
},{"@tensorflow/tfjs-core":"kSBl"}],"WFf5":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.evaluateDataset=b,exports.fitDataset=p;var t=r(require("@tensorflow/tfjs-core")),e=t,a=require("../base_callbacks"),s=require("../errors"),i=require("../logs"),n=require("../utils/generic_utils"),o=require("./training_utils");function r(t,e){if("function"==typeof WeakMap)var a=new WeakMap,s=new WeakMap;return(r=function(t,e){if(!e&&t&&t.__esModule)return t;var i,n,o={__proto__:null,default:t};if(null===t||"object"!=typeof t&&"function"!=typeof t)return o;if(i=e?s:a){if(i.has(t))return i.get(t);i.set(t,o)}for(const a in t)"default"!==a&&{}.hasOwnProperty.call(t,a)&&((n=(i=Object.defineProperty)&&Object.getOwnPropertyDescriptor(t,a))&&(n.get||n.set)?i(o,a,n):o[a]=t[a]);return o})(t,e)}const l=32;function c(t,a){let s,i;const n=a;s=n.xs,i=n.ys,e.util.assert(null!=s&&null!=i,()=>"A Dataset iterator for fitDataset() is expected to generate objects of the form `{xs: xVal, ys: yVal}`, where the two values may be `tf.Tensor`, an array of Tensors, or a map of string to Tensor.  The provided Dataset instead generates "+`${a}`);const o=u("input",t.inputNames,s),r=u("output",t.outputNames,i),l=o[0].shape[0];e.util.assert(o.length===t.inputs.length,()=>`LayersModel has ${t.inputs.length} inputs, but the dataset `+`provides ${o.length} inputs.  (Expected input keys: `+`${JSON.stringify(t.inputNames)})`),e.util.assert(r.length===t.outputs.length,()=>`LayersModel has ${t.outputs.length} outputs, but the dataset `+`provides ${r.length} outputs.  (Expected output keys: `+`${JSON.stringify(t.outputNames)})`);for(let c=0;c<o.length;c++)e.util.assert(o[c].shape[0]===l,()=>"Batch size mismatch: input "+`${t.inputNames[c]} has ${o[c].shape[0]}; `+`expected  ${l} based on input ${t.inputNames[0]}.`);for(let c=0;c<r.length;c++)e.util.assert(r[c].shape[0]===l,()=>"Batch size mismatch: output "+`${t.outputNames[c]} has ${r[c].shape[0]}; `+`expected  ${l} based on input ${t.inputNames[0]}.`);return{xs:o,ys:r}}function u(t,a,i){if(i instanceof e.Tensor)return[i];if(Array.isArray(i))return e.util.assert(i.length===a.length,()=>`Received an array of ${i.length} Tensors, but expected ${a.length} to match the ${t} keys ${a}.`),i;{const e=[];for(const n of a){if(null==i[n])throw new s.ValueError("The feature data generated by the dataset lacks the required "+`${t} key '${n}'.`);e.push(i[n])}return e}}function h(t){if(3===t.length)throw new s.NotImplementedError("Validation with sample weights is not implemented yet.");return{xs:t[0],ys:t[1]}}async function p(t,s,r){const u=null!=r.batchesPerEpoch;if(e.util.assert(null!=t.optimizer,()=>"You must compile a model before training/testing. Use LayersModel.compile(modelCompileConfig)."),e.util.assert(null!=r,()=>"For fitDataset(), the 2nd argument (config) is required, but it is not provided in this call."),e.util.assert(null!=r.epochs&&r.epochs>0&&Number.isInteger(r.epochs),()=>"For fitDataset(), config.epochs is expected to be a positive "+`integer, but got ${r.epochs}`),e.util.assert(!u||r.batchesPerEpoch>0&&Number.isInteger(r.batchesPerEpoch),()=>"For fitDataset(), config.batchesPerEpoch is expected to be a "+`positive integer if specified, but got ${r.batchesPerEpoch}`),e.util.assert(null==r.validationSplit,()=>"`validationSplit` is not supported by `fitDataset()`. Use validationData instead."),t.isTraining)throw new Error("Cannot start training because another fit() call is ongoing.");t.isTraining=!0;try{const p=null!=r.validationData;let g,b;if(p)if(f(r.validationData))e.util.assert(null==r.validationBatches||r.validationBatches>0&&Number.isInteger(r.validationBatches),()=>"For fitDataset() with dataset-based validation, config.validationBatches is expected not to be provided, or to be a positive integer, "+`but got ${r.validationBatches}`);else{const t=h(r.validationData);g=t.xs,b=t.ys}const y=t.makeTrainFunction(),v=t.getDedupedMetricsNames();let m;m=p?v.slice().concat(v.map(t=>"val_"+t)):v.slice();const w=(0,a.standardizeCallbacks)(r.callbacks,r.yieldEvery),$=null==r.verbose?1:r.verbose,{callbackList:E,history:x}=(0,a.configureCallbacks)(w,$,r.epochs,null,null,d(s,r),null,p,m);E.setModel(t),t.history=x,await E.onTrainBegin(),t.stopTraining_=!1;let k=null==r.initialEpoch?0:r.initialEpoch,N=await s.iterator();for(;k<r.epochs;){const a={};await E.onEpochBegin(k);let h=0,d=0;for(u||(N=await s.iterator());!u||h<r.batchesPerEpoch;){const s=await N.next();if(u&&s.done){console.warn("You provided `batchesPerEpoch` as "+`${r.batchesPerEpoch}, `+"but your dataset iterator ran out of data after "+`${h} batches; `+"interrupting training. Make sure that your dataset can generate at least `batchesPerEpoch * epochs` batches (in this case, "+`${r.batchesPerEpoch*r.epochs} batches). `+"You may need to use the repeat() function when building your dataset.");break}if(null!=s.value){const{xs:a,ys:n}=c(t,s.value),l={};l.batch=d,l.size=a[0].shape[0],await E.onBatchBegin(d,l);const u=[];if(null!=r.classWeight){const e=(0,o.standardizeClassWeights)(r.classWeight,t.outputNames);for(let t=0;t<e.length;++t)u.push(await(0,o.standardizeWeights)(n[t],null,e[t]))}const p=a.concat(n).concat(u),f=y(p);e.dispose(p);for(let t=0;t<v.length;++t){const a=v[t],s=f[t];l[a]=s,e.keep(s)}await E.onBatchEnd(d,l),(0,i.disposeTensorsInLogs)(l),d++,h++}if(u?h>=r.batchesPerEpoch:s.done){if(p){let e;e=f(r.validationData)?(0,n.toList)(await t.evaluateDataset(r.validationData,{batches:r.validationBatches})):(0,n.toList)(t.evaluate(g,b,{batchSize:null==r.validationBatchSize?l:r.validationBatchSize,verbose:0}));for(let s=0;s<t.metricsNames.length;++s)a[`val_${t.metricsNames[s]}`]=e[s]}break}if(t.stopTraining_)break}if(await E.onEpochEnd(k,a),k++,t.stopTraining_)break}return await E.onTrainEnd(),await t.history.syncData(),t.history}finally{t.isTraining=!1}}function d(t,e){let a=null;return null!=e.batchesPerEpoch?a=e.batchesPerEpoch:Number.isFinite(t.size)&&(a=t.size),a}function f(t){return"function"==typeof t.iterator}function g(t){return"function"==typeof t.next}async function b(a,i,o){const r=null!=(o=o||{}).batches,l=a.testFunction;let u=[];if(o.verbose>0)throw new s.NotImplementedError("Verbose mode is not implemented yet.");e.util.assert(!r||o.batches>0&&Number.isInteger(o.batches),()=>"Test loop expects `batches` to be a positive integer, but "+`received ${JSON.stringify(o.batches)}`);const h=g(i)?i:await i.iterator();let p=0,d=0;for(;!r||d<o.batches;){const s=await h.next();if(u=e.tidy(()=>{if(s.value){const{xs:i,ys:n}=c(a,s.value),o=i.concat(n),r=e.tidy(()=>l(o));if(e.dispose(o),0===d)for(let e=0;e<r.length;++e)u.push((0,t.scalar)(0));const h=o[0].shape[0];for(let t=0;t<r.length;++t){const a=r[t],s=u[t];u[t]=e.tidy(()=>e.add(u[t],e.mul(h,a))),d>0&&e.dispose(s)}e.dispose(r),p+=h,++d}return u}),s.done){r&&console.warn("Your dataset iterator ran out of data during evaluateDataset(). Interrupting evalution. Make sure that your dataset can generate at least `batches` "+`batches (in this case, ${o.batches} batches). `+"You may need to use the repeat() function when building your dataset.");break}}for(let t=0;t<u.length;++t){const a=u[t];u[t]=e.div(u[t],p),e.dispose(a)}return(0,n.singletonOrArray)(u)}
},{"@tensorflow/tfjs-core":"kSBl","../base_callbacks":"GDiE","../errors":"iJtr","../logs":"gooH","../utils/generic_utils":"VKwv","./training_utils":"DnBX"}],"sRwx":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.checkBatchSize=s,exports.disposeNewTensors=c,exports.ensureTensorsRank2OrHigher=a,exports.makeBatches=u,exports.sliceArrays=i,exports.sliceArraysByIndices=o;var e=n(require("@tensorflow/tfjs-core")),r=e,t=require("../backend/tfjs_backend");function n(e,r){if("function"==typeof WeakMap)var t=new WeakMap,s=new WeakMap;return(n=function(e,r){if(!r&&e&&e.__esModule)return e;var n,i,o={__proto__:null,default:e};if(null===e||"object"!=typeof e&&"function"!=typeof e)return o;if(n=r?s:t){if(n.has(e))return n.get(e);n.set(e,o)}for(const t in e)"default"!==t&&{}.hasOwnProperty.call(e,t)&&((i=(n=Object.defineProperty)&&Object.getOwnPropertyDescriptor(e,t))&&(i.get||i.set)?n(o,t,i):o[t]=e[t]);return o})(e,r)}function s(e){r.util.assert(e>0&&Number.isInteger(e),()=>`batchSize is required to be a positive integer, but got ${e}`)}function i(e,r,n){return null==e?[null]:Array.isArray(e)?e.map(e=>(0,t.sliceAlongFirstAxis)(e,r,n-r)):(0,t.sliceAlongFirstAxis)(e,r,n-r)}function o(e,n){return r.tidy(()=>null==e?null:Array.isArray(e)?e.map(e=>o(e,n)):(0,t.gather)(e,"int32"===n.dtype?n:r.cast(n,"int32")))}function u(e,r){const t=[];let n=0,s=null;for(;n<e;)(s=n+r)>=e&&(s=e),t.push([n,s]),n=s;return t}function a(r){const n=[];r instanceof e.Tensor&&(r=[r]);for(let e=0;e<r.length;++e){const s=r[e];if(1===s.rank)n.push((0,t.expandDims)(s,1));else{if(0===s.rank)throw new Error("Expected tensor to be at least 1D, but received a 0D tensor (scalar).");n.push(s)}}return n}function c(r,t){if(null==r)return;const n=[];if(t instanceof e.Tensor)n.push(t.id);else if(Array.isArray(t))t.forEach(e=>n.push(e.id));else if(null!=t)for(const e in t){const r=t[e];n.push(r.id)}const s=[];if(r instanceof e.Tensor)-1===n.indexOf(r.id)&&s.push(r);else if(Array.isArray(r))r.forEach(e=>{-1===n.indexOf(e.id)&&s.push(e)});else if(null!=r)for(const e in r){const t=r[e];-1===n.indexOf(t.id)&&s.push(t)}s.forEach(e=>{e.isDisposed||e.dispose()})}
},{"@tensorflow/tfjs-core":"kSBl","../backend/tfjs_backend":"Ftmo"}],"BP0g":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.LayersModel=exports.Functional=void 0,exports.checkArrayLengths=k,exports.collectMetrics=x,exports.isDataArray=O,exports.isDataDict=z,exports.isDataTensor=A,exports.standardizeInputData=$;var e=E(require("@tensorflow/tfjs-core")),t=e,s=E(require("../backend/tfjs_backend")),i=require("../base_callbacks"),n=require("../common"),r=require("../errors"),o=require("../layers/serialization"),a=require("../logs"),l=E(require("../losses")),h=E(require("../metrics")),c=E(require("../optimizers")),u=require("../user_defined_metadata"),p=require("../utils/generic_utils"),d=require("../utils/layer_utils"),f=require("../utils/math_utils"),g=require("../utils/serialization_utils"),m=require("../version"),y=require("./container"),w=require("./executor"),b=require("./training_dataset"),T=require("./training_tensors"),v=require("./training_utils");function E(e,t){if("function"==typeof WeakMap)var s=new WeakMap,i=new WeakMap;return(E=function(e,t){if(!t&&e&&e.__esModule)return e;var n,r,o={__proto__:null,default:e};if(null===e||"object"!=typeof e&&"function"!=typeof e)return o;if(n=t?i:s){if(n.has(e))return n.get(e);n.set(e,o)}for(const s in e)"default"!==s&&{}.hasOwnProperty.call(e,s)&&((r=(n=Object.defineProperty)&&Object.getOwnPropertyDescriptor(e,s))&&(r.get||r.set)?n(o,s,r):o[s]=e[s]);return o})(e,t)}function A(t){return t instanceof e.Tensor}function O(e){return Array.isArray(e)}function z(e){return!A(e)&&!O(e)}function $(e,t,s,i=!0,n=""){if(null==t||0===t.length){if(null!=e){let t=!1;if(O(e)&&e.length>0)t=!0;else if(z(e)){for(const s in e)if(e.hasOwnProperty(s)){t=!0;break}}else t=!0;if(t)throw new r.ValueError(`Error when checking model ${n} expected no data, `+`but got ${e}`)}return[]}if(null==e)return t.map(e=>null);let o;if(z(e)){e=e,o=[];for(const s of t){if(null==e[s])throw new r.ValueError(`No data provided for "${s}". Need data for each key in: `+`${t}`);o.push(e[s])}}else if(O(e)){if((e=e).length!==t.length)throw new r.ValueError(`Error when checking model ${n}: the Array of `+"Tensors that you are passing to your model is not the size the "+`model expected. Expected to see ${t.length} Tensor(s), but `+`instead got the following list of Tensor(s): ${e}`);o=e}else{if(e=e,t.length>1)throw new r.ValueError(`The model ${n} expects ${t.length} Tensor(s), `+`but only received one Tensor. Found: Tensor with shape ${e.shape}`);o=[e]}if(o=(0,T.ensureTensorsRank2OrHigher)(o),null!=s)for(let a=0;a<t.length;++a){if(null==s[a])continue;const e=o[a];if(e.shape.length!==s[a].length)throw new r.ValueError(`Error when checking ${n}: expected ${t[a]} `+`to have ${s[a].length} dimension(s). but got array with `+`shape ${e.shape}`);for(let t=0;t<s[a].length;++t){if(0===t&&!i)continue;const o=e.shape[t],l=s[a][t];if(null!=l&&l>=0&&o!==l)throw new r.ValueError(`${n} expected a batch of elements where each `+`example has shape [${s[a].slice(1,s[a].length)}] `+`(i.e.,tensor shape [*,${s[a].slice(1,s[a].length)}])`+` but the ${n} received an input with ${e.shape[0]}`+` examples, each with shape [${e.shape.slice(1,e.shape.length)}]`+` (tensor shape [${e.shape}])`)}}return o}function k(t,s,i){const n=(0,p.unique)(t.map(e=>e.shape[0]));n.sort();const o=(0,p.unique)(s.map(e=>e.shape[0]));if(o.sort(),n.length>1)throw new r.ValueError("All input Tensors (x) should have the same number of samples. Got array shapes: "+`${JSON.stringify(t.map(e=>e.shape))}`);if(o.length>1)throw new r.ValueError("All target Tensors (y) should have the same number of samples. Got array shapes: "+`${JSON.stringify(s.map(e=>e.shape))}`);if(n.length>0&&o.length>0&&!e.util.arraysEqual(n,o))throw new r.ValueError("Input Tensors should have the same number of samples as target "+`Tensors. Found ${n[0]} input sample(s) and ${o[0]} target `+"sample(s).")}function N(e,t,s){const i=[l.meanSquaredError,l.binaryCrossentropy,l.categoricalCrossentropy];for(let n=0;n<e.length;++n){const o=e[n],a=t[n],h=s[n];if(null!=a){if(a===l.categoricalCrossentropy&&1===o.shape[o.shape.length-1])throw new r.ValueError(`You are passing a target array of shape ${o.shape} while using `+"a loss 'categorical_crossentropy'. 'categorical_crossentropy'expects targets to be binary matrices (1s and 0s) of shape [samples, classes].");if(-1!==i.indexOf(a)){const e=o.shape.slice(1),t=h.slice(1);for(let s=0;s<e.length;++s){const i=e[s],n=t[s];if(null!=n&&i!==n)throw new r.ValueError(`A target Tensor with shape ${o.shape} was passed for an `+`output of shape ${h}, while using a loss function that `+"expects targets to have the same shape as the output.")}}}}}function S(e,t,s,i=!0,n=""){let o;if(Array.isArray(e)){if(e.length!==t.length)throw new r.ValueError(`Error when checking model ${n}: the Array of `+"Tensors that you are passing to your model is not the size the "+`the model expected. Expected to see ${t.length} Tensor(s),`+` but instead got ${e.length} Tensors(s).`);o=e}else{if(t.length>1)throw new r.ValueError(`The model expects ${t.length} ${n} Tensors, `+"but only received one Tensor. Found: array with shape "+`${JSON.stringify(e.shape)}.`);o=[e]}if(null!=s)for(let a=0;a<t.length;++a){if(null==s[a])continue;const e=o[a];if(e.shape.length!==s[a].length)throw new r.ValueError(`Error when checking ${n}: expected ${t[a]} `+`to have ${s[a].length} dimension(s), but got array with `+`shape ${JSON.stringify(e.shape)}`);for(let o=0;o<s[a].length;++o){if(0===o&&!i)continue;const l=e.shape[o],h=s[a][o];if(null!=h&&h!==l)throw new r.ValueError(`Error when checking ${n}: expected `+`${t[a]} to have shape ${JSON.stringify(s[a])} but `+`got array with shape ${JSON.stringify(e.shape)}.`)}}}function x(e,t){if(null==e||Array.isArray(e)&&0===e.length)return t.map(e=>[]);let s;if("string"==typeof e||"function"==typeof e)s=[e];else{if(!Array.isArray(e)&&"object"!=typeof e)throw new TypeError("Type of metrics argument not understood. Expected an string,"+`function, Array, or Object, found: ${e}`);s=e}if(Array.isArray(s))return t.map(e=>s);{const e=[];for(const i of t){let t=s.hasOwnProperty(i)?s[i]:[];Array.isArray(t)||(t=[t]),e.push(t)}return e}}const _="layers-model";class C extends y.Container{constructor(e){super(e),this.isTraining=!1}summary(e,t,s=console.log){if(!this.built)throw new r.ValueError("This model has never been called, thus its weights have not been created yet. So no summary can be displayed. Build the model first (e.g., by calling it on some test data).");(0,d.printSummary)(this,e,t,s)}compile(t){if(null==t.loss&&(t.loss=[]),this.loss=t.loss,"string"==typeof t.optimizer)this.optimizer_=c.getOptimizer(t.optimizer),this.isOptimizerOwned=!0;else{if(!(t.optimizer instanceof e.Optimizer))throw new r.ValueError("User-defined optimizer must be an instance of tf.Optimizer.");this.optimizer_=t.optimizer,this.isOptimizerOwned=!1}let s=[];if(Array.isArray(t.loss)||"string"==typeof t.loss||"function"==typeof t.loss)if(Array.isArray(t.loss)){if(t.loss.length!==this.outputs.length)throw new r.ValueError("When passing an Array as loss, it should have one entry per "+`model output. The model has ${this.outputs.length} output(s), `+`but you passed loss=${t.loss}.`);const e=t.loss;s=e.map(e=>l.get(e))}else{const e=l.get(t.loss);this.outputs.forEach(t=>{s.push(e)})}else{t.loss=t.loss;for(const e in t.loss)if(-1===this.outputNames.indexOf(e))throw new r.ValueError(`Unknown entry in loss dictionary: "${e}". `+`Only expected the following keys: ${this.outputNames}`);for(const e of this.outputNames)null==t.loss[e]&&console.warn(`Output "${e}" is missing from loss dictionary. We assume `+"this was done on purpose, and we will not be expecting data "+`to be passed to ${e} during training`),s.push(l.get(t.loss[e]))}this.lossFunctions=s,this.feedOutputNames=[],this.feedOutputShapes=[],this.feedLossFns=[];for(let e=0;e<this.outputs.length;++e){const t=this.internalOutputShapes[e],s=this.outputNames[e];this.feedOutputNames.push(s),this.feedOutputShapes.push(t),this.feedLossFns.push(this.lossFunctions[e])}const i=[];this.metrics=t.metrics,this.metricsNames=["loss"],this.metricsTensors=[],(0,n.nameScope)("loss",()=>{for(let e=0;e<this.outputs.length;++e){if(-1!==i.indexOf(e))continue;const t=this.lossFunctions[e];this.outputs.length>1&&(this.metricsTensors.push([t,e]),this.metricsNames.push(this.outputNames[e]+"_loss"))}});const o=x(t.metrics,this.outputNames),a=(e,t,s)=>{this.outputNames.length>1&&(t=this.outputNames[e]+"_"+t),this.metricsNames.push(t),this.metricsTensors.push([s,e])};(0,n.nameScope)("metric",()=>{for(let e=0;e<this.outputs.length;++e){if(-1!==i.indexOf(e))continue;(t=>{let s,i,r;for(const o of t){if("string"==typeof o&&-1!==["accuracy","acc","crossentropy","ce"].indexOf(o)){const t=this.internalOutputShapes[e];let n;1===t[t.length-1]||this.lossFunctions[e]===l.binaryCrossentropy?-1!==["accuracy","acc"].indexOf(o)?i=h.binaryAccuracy:-1!==["crossentropy","ce"].indexOf(o)&&(i=h.binaryCrossentropy):this.lossFunctions[e]===l.sparseCategoricalCrossentropy?-1!==["accuracy","acc"].indexOf(o)?i=h.sparseCategoricalAccuracy:-1!==["crossentropy","ce"].indexOf(o)&&(i=h.sparseCategoricalCrossentropy):-1!==["accuracy","acc"].indexOf(o)?i=h.categoricalAccuracy:-1!==["crossentropy","ce"].indexOf(o)&&(i=h.categoricalCrossentropy),-1!==["accuracy","acc"].indexOf(o)?n="acc":-1!==["crossentropy","ce"].indexOf(o)&&(n="ce"),r=i,s=""+n}else{const e=h.get(o);r=e,s=""+h.getLossOrMetricName(o)}let t;(0,n.nameScope)(s,()=>{t=r}),a(e,s,t)}})(o[e])}}),this.collectedTrainableWeights=this.trainableWeights}checkTrainableWeightsConsistency(){null!=this.collectedTrainableWeights&&this.trainableWeights.length!==this.collectedTrainableWeights.length&&console.warn("Discrepancy between trainableweights and collected trainable weights. Did you set `model.trainable` without calling `model.compile()` afterwards?")}evaluate(e,t,s={}){const i=null==s.batchSize?32:s.batchSize;(0,T.checkBatchSize)(i);const n=this.standardizeUserDataXY(e,t,!0,i);try{const r=n[0].concat(n[1]);this.makeTestFunction();const o=this.testFunction,a=this.testLoop(o,r,i,s.verbose,s.steps);return(0,p.singletonOrArray)(a)}finally{(0,T.disposeNewTensors)(n[0],e),(0,T.disposeNewTensors)(n[1],t)}}async evaluateDataset(e,t){return this.makeTestFunction(),(0,b.evaluateDataset)(this,e,t)}checkNumSamples(e,t,s,i="steps"){let n;if(null!=s){if(n=null,null!=t)throw new r.ValueError(`If ${i} is set, batchSize must be null or undefined.`+`Got batchSize = ${t}`)}else{if(null==e)throw new r.ValueError("Either the input data should have a defined shape, or "+`${i} shoud be specified.`);n=Array.isArray(e)?e[0].shape[0]:e.shape[0]}return n}execute(t,s){if(Array.isArray(s)&&0===s.length)throw new r.ValueError("`outputs` is an empty Array, which is not allowed.");const i=Array.isArray(s),n=i?s:[s],o=this.retrieveSymbolicTensors(n),a=new w.FeedDict;if(t instanceof e.Tensor&&(t=[t]),Array.isArray(t)){if(t.length!==this.inputs.length)throw new r.ValueError(`The number of inputs provided (${t.length}) `+"does not match the number of inputs of this model "+`(${this.inputs.length}).`);for(let e=0;e<this.inputs.length;++e)a.add(this.inputs[e],t[e])}else for(const e of this.inputs){const s=t[e.name];if(null==s)throw new r.ValueError(`No value is provided for the model's input ${e.name}`);a.add(e,s)}const l=(0,w.execute)(o,a);return i?l:l[0]}retrieveSymbolicTensors(e){const t=(0,p.pyListRepeat)(null,e.length);let s=e.length;for(const i of this.layers){const n=Array.isArray(i.output)?i.output:[i.output],r=n.map(e=>e.name);for(let i=0;i<e.length;++i){const o=r.indexOf(e[i]);if(-1!==o&&(t[i]=n[o],s--),0===s)break}if(0===s)break}if(s>0){const s=[];throw t.forEach((t,i)=>{null==t&&s.push(e[i])}),new r.ValueError("Cannot find SymbolicTensors for output name(s): "+`${JSON.stringify(s)}`)}return t}predictLoop(e,s=32,i=!1){return t.tidy(()=>{const n=this.checkNumSamples(e);if(i)throw new r.NotImplementedError("Verbose predictLoop() is not implemented yet.");const o=(0,T.makeBatches)(n,s),a=this.outputs.map(e=>[]);for(let s=0;s<o.length;++s){t.tidy(()=>{const t=o[s][0],i=o[s][1],n=(0,T.sliceArrays)(e,t,i),r=[];if(Array.isArray(n))for(let e=0;e<n.length;++e)r.push({key:this.inputs[e],value:n[e]});else r.push({key:this.inputs[0],value:n});const a=new w.FeedDict(r);return(0,w.execute)(this.outputs,a)}).forEach((e,t)=>a[t].push(e))}return(0,p.singletonOrArray)(a.map(e=>t.concat(e,0)))})}predict(e,t={}){const s=(0,T.ensureTensorsRank2OrHigher)(e);S(s,this.inputNames,this.feedInputShapes,!1);try{const i=null==t.batchSize?32:t.batchSize;return(0,T.checkBatchSize)(i),this.predictLoop(s,i)}finally{(0,T.disposeNewTensors)(s,e)}}predictOnBatch(e){S(e,this.inputNames,this.feedInputShapes,!0);const t=(Array.isArray(e)?e[0]:e).shape[0];return this.predictLoop(e,t)}standardizeUserDataXY(e,t,s=!0,i){if(null==this.optimizer_)throw new r.RuntimeError("You must compile a model before training/testing. Use LayersModel.compile(modelCompileArgs).");const n=[];for(let r=0;r<this.feedOutputShapes.length;++r){const e=this.feedOutputShapes[r];this.feedLossFns[r]===l.sparseCategoricalCrossentropy?n.push(e.slice(0,e.length-1).concat([1])):n.push(e)}if(k(e=$(e,this.feedInputNames,this.feedInputShapes,!1,"input"),t=$(t,this.feedOutputNames,n,!1,"target"),null),N(t,this.feedLossFns,this.feedOutputShapes),this.stateful&&null!=i&&i>0&&e[0].shape[0]%i!=0)throw new r.ValueError("In a stateful network, you should only pass inputs with a number of samples that is divisible by the batch size "+`${i}. Found: ${e[0].shape[0]} sample(s).`);return[e,t]}async standardizeUserData(e,t,s,i,n=!0,r){const[o,a]=this.standardizeUserDataXY(e,t,n,r);if(null!=s)throw new Error("sample weight is not supported yet.");let l=null;if(null!=i){const e=(0,v.standardizeClassWeights)(i,this.outputNames);l=[];for(let t=0;t<e.length;++t)l.push(await(0,v.standardizeWeights)(a[t],null,e[t]))}return[o,a,l]}testLoop(i,n,o,a=0,l){return t.tidy(()=>{const h=this.checkNumSamples(n,o,l,"steps"),c=[];if(a>0)throw new r.NotImplementedError("Verbose mode is not implemented yet.");if(null!=l)throw new r.NotImplementedError("steps mode in testLoop() is not implemented yet");{const r=(0,T.makeBatches)(h,o),a=(0,e.tensor1d)((0,f.range)(0,h));for(let o=0;o<r.length;++o){const l=r[o][0],h=r[o][1],u=s.sliceAlongFirstAxis(a,l,h-l),p=(0,T.sliceArraysByIndices)(n,u),d=i(p);if(0===o)for(let t=0;t<d.length;++t)c.push((0,e.scalar)(0));for(let e=0;e<d.length;++e){const s=d[e];c[e]=t.add(c[e],t.mul(h-l,s))}}for(let e=0;e<c.length;++e)c[e]=t.div(c[e],h)}return c})}getDedupedMetricsNames(){const e=this.metricsNames,t=[];for(let s=0;s<e.length;++s){const i=e[s];let n=i;if((0,p.count)(e,i)>1){n+=`_${(0,p.count)(e.slice(0,s),i)}`}t.push(n)}return t}makeTrainFunction(){return e=>{const s=[],i=e.slice(0,this.inputs.length),n=e.slice(this.inputs.length,this.inputs.length+this.outputs.length),r=e.slice(this.inputs.length+this.outputs.length,this.inputs.length+2*this.outputs.length),o=[],a=this.collectedTrainableWeights.map(e=>e.read());return[this.optimizer_.minimize(()=>{const e=[];for(let t=0;t<this.inputs.length;++t)e.push({key:this.inputs[t],value:i[t]});const a=new w.FeedDict(e),l=(0,w.execute)(this.outputs,a,{training:!0});let h;for(let i=0;i<this.lossFunctions.length;++i){let e=(0,this.lossFunctions[i])(n[i],l[i]);null!=r[i]&&(e=(0,v.computeWeightedLoss)(e,r[i]));const o=t.mean(e);s.push(o),h=0===i?e:t.add(h,e)}for(let i=0;i<this.metricsTensors.length;++i){let e;if(this.outputs.length>1&&i<this.outputs.length)e=s[i];else{const s=this.metricsTensors[i][0],r=this.metricsTensors[i][1];e=t.mean(s(n[r],l[r]))}t.keep(e),o.push(e)}return h=t.mean(h),this.calculateLosses().forEach(e=>{h=t.add(h,e)}),h},!0,a)].concat(o)}}makeTestFunction(){this.testFunction=(e=>t.tidy(()=>{const s=[];let i;const n=e.slice(0,this.inputs.length),r=e.slice(this.inputs.length,this.inputs.length+this.outputs.length),o=[];for(let e=0;e<this.inputs.length;++e)o.push({key:this.inputs[e],value:n[e]});const a=new w.FeedDict(o),l=(0,w.execute)(this.outputs,a);for(let e=0;e<this.lossFunctions.length;++e){const n=this.lossFunctions[e],o=t.mean(n(r[e],l[e]));i=0===e?o:t.add(i,o),s.push(i)}for(let e=0;e<this.metricsTensors.length;++e){const i=this.metricsTensors[e][0],n=this.metricsTensors[e][1],o=t.mean(i(r[n],l[n]));s.push(o)}return s}))}async fit(e,s,n={}){if(this.isTraining)throw new Error("Cannot start training because another fit() call is ongoing.");let o,a,l,h,c,u,p,d,f;this.isTraining=!0;try{const g=null==n.batchSize?32:n.batchSize;(0,T.checkBatchSize)(g);const m=!1,y=await this.standardizeUserData(e,s,n.sampleWeight,n.classWeight,m,g);o=y[0],a=y[1],f=y[2];let w,b=!1;if(null!=n.validationData&&n.validationData.length>0){if(b=!0,2!==n.validationData.length)throw 3===n.validationData.length?new r.NotImplementedError("validationData including sample weights is not supported yet."):new r.ValueError("When passing validation data, it must contain 2 (valX, valY) or 3 (valX, valY, valSampleWeight) items; "+`${n.validationData} is invalid.`);c=n.validationData[0],u=n.validationData[1];const e=!0,t=await this.standardizeUserData(c,u,null,null,e,g);p=t[0],d=t[1],w=p.concat(d)}else if(null!=n.validationSplit&&n.validationSplit>0&&n.validationSplit<1){b=!0;const e=Math.floor(o[0].shape[0]*(1-n.validationSplit)),t=o[0].shape[0];p=(0,T.sliceArrays)(o,e,t),l=o,o=(0,T.sliceArrays)(o,0,e),d=(0,T.sliceArrays)(a,e,t),h=a,a=(0,T.sliceArrays)(a,0,e),w=p.concat(d)}else null!=n.validationSteps&&(b=!0);const v=o.concat(a).concat(f);this.checkTrainableWeightsConsistency();const E=this.makeTrainFunction(),A=this.getDedupedMetricsNames();let O,z;b?(this.makeTestFunction(),O=this.testFunction,z=A.slice().concat(A.map(e=>"val_"+e))):(O=null,w=[],z=A.slice());const $=(0,i.standardizeCallbacks)(n.callbacks,n.yieldEvery);return await this.fitLoop(E,v,A,g,n.epochs,n.verbose,$,O,w,n.shuffle,z,n.initialEpoch,null,null)}finally{this.isTraining=!1,(0,T.disposeNewTensors)(o,e),(0,T.disposeNewTensors)(a,s),(0,T.disposeNewTensors)(l,e),(0,T.disposeNewTensors)(h,s),(0,T.disposeNewTensors)(p,c),(0,T.disposeNewTensors)(d,u),null!=f&&t.dispose(f)}}async fitLoop(n,o,l,h,c,u,p,d,g,m,y,w,b,v){null==h&&(h=32),null==c&&(c=1),null==m&&(m=!0),null==w&&(w=0);let E=!1;if(null!=d&&null!=g&&(E=!0),null!=v&&(E=!0,null==b))throw new r.ValueError("Can only use `validationSteps` when doing step-wise training, i.e., `stepsPerEpoch` must be set.");const A=this.checkNumSamples(o,h,b,"steps_per_epoch");let O;null!=A&&(O=(0,f.range)(0,A)),null==u&&(u=1);const{callbackList:z,history:$}=(0,i.configureCallbacks)(p,u,c,w,A,b,h,E,y);z.setModel(this),this.history=$,await z.onTrainBegin(),this.stopTraining_=!1;for(let i=w;i<c;++i){await z.onEpochBegin(i);const c={};if(null!=b)throw new r.NotImplementedError("stepsPerEpoch mode is not implemented yet.");{if("batch"===m)throw new r.NotImplementedError("batch shuffling is not implemneted yet");m&&e.util.shuffle(O);const i=(0,e.tensor1d)(O),u=(0,T.makeBatches)(A,h);for(let e=0;e<u.length;++e){const r={};if(await z.onBatchBegin(e,r),t.tidy(()=>{const a=u[e][0],p=u[e][1],f=s.sliceAlongFirstAxis(i,a,p-a);r.batch=e,r.size=p-a;const m=(0,T.sliceArraysByIndices)(o,f),y=n(m);for(let e=0;e<l.length;++e){const s=l[e],i=y[e];r[s]=i,t.keep(i)}if(e===u.length-1&&E){const e=this.testLoop(d,g,h);for(let s=0;s<l.length;++s){const i=l[s],n=e[s];t.keep(n),c["val_"+i]=n}}}),await z.onBatchEnd(e,r),(0,a.disposeTensorsInLogs)(r),this.stopTraining_)break}i.dispose()}if(await z.onEpochEnd(i,c),this.stopTraining_)break}return await z.onTrainEnd(),await this.history.syncData(),this.history}async fitDataset(e,t){return(0,b.fitDataset)(this,e,t)}async trainOnBatch(e,s){const i=await this.standardizeUserData(e,s),n=i[0],r=i[1],o=this.makeTrainFunction()(n.concat(r)),a=[];for(const t of o){const e=await t.data();a.push(e[0])}return t.dispose(o),(0,T.disposeNewTensors)(i[0],e),(0,T.disposeNewTensors)(i[1],s),(0,p.singletonOrArray)(a)}getNamedWeights(e){const t=[],s=null!=e&&e.trainableOnly,i=s?this.trainableWeights:this.weights,n=this.getWeights(s);for(let r=0;r<i.length;++r)s&&!i[r].trainable||t.push({name:i[r].originalName,tensor:n[r]});return t}set stopTraining(e){this.stopTraining_=e}get stopTraining(){return this.stopTraining_}get optimizer(){return this.optimizer_}set optimizer(e){this.optimizer_!==e&&(this.optimizer_=e,this.isOptimizerOwned=!1)}dispose(){const e=super.dispose();if(0===e.refCountAfterDispose&&null!=this.optimizer&&this.isOptimizerOwned){const s=t.memory().numTensors;this.optimizer_.dispose(),e.numDisposedVariables+=s-t.memory().numTensors}return e}getLossIdentifiers(){let e;if("string"==typeof this.loss)e=(0,p.toSnakeCase)(this.loss);else if(Array.isArray(this.loss)){for(const e of this.loss)if("string"!=typeof e)throw new Error("Serialization of non-string loss is not supported.");e=this.loss.map(e=>(0,p.toSnakeCase)(e))}else{const t=Object.keys(this.loss);e={};const s=this.loss;for(const i of t){if("string"!=typeof s[i])throw new Error("Serialization of non-string loss is not supported.");e[i]=(0,p.toSnakeCase)(s[i])}}return e}getMetricIdentifiers(){if("string"==typeof this.metrics||"function"==typeof this.metrics)return[(0,p.toSnakeCase)(h.getLossOrMetricName(this.metrics))];if(Array.isArray(this.metrics))return this.metrics.map(e=>(0,p.toSnakeCase)(h.getLossOrMetricName(e)));{const e={};for(const t in this.metrics)e[t]=(0,p.toSnakeCase)(h.getLossOrMetricName(this.metrics[t]));return e}}getTrainingConfig(){return{loss:this.getLossIdentifiers(),metrics:this.getMetricIdentifiers(),optimizer_config:{class_name:this.optimizer.getClassName(),config:this.optimizer.getConfig()}}}loadTrainingConfig(e){if(null!=e.weighted_metrics)throw new Error("Loading weight_metrics is not supported yet.");if(null!=e.loss_weights)throw new Error("Loading loss_weights is not supported yet.");if(null!=e.sample_weight_mode)throw new Error("Loading sample_weight_mode is not supported yet.");const t=(0,g.convertPythonicToTs)(e.optimizer_config),s=(0,o.deserialize)(t);let i,n;if("string"==typeof e.loss)i=(0,p.toCamelCase)(e.loss);else if(Array.isArray(e.loss))i=e.loss.map(e=>(0,p.toCamelCase)(e));else if(null!=e.loss){i={};for(const t in e.loss)i[t]=(0,p.toCamelCase)(e.loss[t])}if(Array.isArray(e.metrics))n=e.metrics.map(e=>(0,p.toCamelCase)(e));else if(null!=e.metrics){n={};for(const t in e.metrics)n[t]=(0,p.toCamelCase)(e.metrics[t])}this.compile({loss:i,metrics:n,optimizer:s})}async save(t,s){if("string"==typeof t){const s=e.io.getSaveHandlers(t);if(0===s.length)throw new r.ValueError(`Cannot find any save handlers for URL '${t}'`);if(s.length>1)throw new r.ValueError(`Found more than one (${s.length}) save handlers for `+`URL '${t}'`);t=s[0]}if(null==t.save)throw new r.ValueError("LayersModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");const i=await e.io.encodeWeights(this.getNamedWeights(s)),n={modelTopology:this.toJSON(null,!1),format:_,generatedBy:`TensorFlow.js tfjs-layers v${m.version}`,convertedBy:null};if(null!=s&&s.includeOptimizer&&null!=this.optimizer){n.trainingConfig=this.getTrainingConfig();const t="optimizer",{data:s,specs:r}=await e.io.encodeWeights(await this.optimizer.getWeights(),t);i.specs.push(...r),i.data=e.io.concatenateArrayBuffers([i.data,s])}if(null!=this.userDefinedMetadata){const e=!0;(0,u.checkUserDefinedMetadata)(this.userDefinedMetadata,this.name,e),n.userDefinedMetadata=this.userDefinedMetadata}return n.weightData=i.data,n.weightSpecs=i.specs,t.save(n)}setUserDefinedMetadata(e){(0,u.checkUserDefinedMetadata)(e,this.name),this.userDefinedMetadata=e}getUserDefinedMetadata(){return this.userDefinedMetadata}}exports.LayersModel=C,C.className="Model",e.serialization.registerClass(C);class D extends C{}exports.Functional=D,D.className="Functional",e.serialization.registerClass(D);
},{"@tensorflow/tfjs-core":"kSBl","../backend/tfjs_backend":"Ftmo","../base_callbacks":"GDiE","../common":"sR6u","../errors":"iJtr","../layers/serialization":"bKFn","../logs":"gooH","../losses":"EG90","../metrics":"kNCu","../optimizers":"FwoH","../user_defined_metadata":"hhZn","../utils/generic_utils":"VKwv","../utils/layer_utils":"uvqr","../utils/math_utils":"eQAy","../utils/serialization_utils":"eha7","../version":"KPnh","./container":"QFjJ","./executor":"w9qS","./training_dataset":"WFf5","./training_tensors":"sRwx","./training_utils":"DnBX"}],"GBM9":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.Sequential=void 0,exports.loadLayersModel=p,exports.loadLayersModelFromIOHandler=m,exports.modelFromJSON=d;var e=require("@tensorflow/tfjs-core"),t=require("./backend/state"),i=require("./engine/input_layer"),s=require("./engine/topology"),o=require("./engine/training"),n=require("./errors"),r=require("./layers/serialization"),l=h(require("./utils/generic_utils")),a=require("./utils/serialization_utils"),u=require("./utils/types_utils");function h(e,t){if("function"==typeof WeakMap)var i=new WeakMap,s=new WeakMap;return(h=function(e,t){if(!t&&e&&e.__esModule)return e;var o,n,r={__proto__:null,default:e};if(null===e||"object"!=typeof e&&"function"!=typeof e)return r;if(o=t?s:i){if(o.has(e))return o.get(e);o.set(e,r)}for(const i in e)"default"!==i&&{}.hasOwnProperty.call(e,i)&&((n=(o=Object.defineProperty)&&Object.getOwnPropertyDescriptor(e,i))&&(n.get||n.set)?o(r,i,n):r[i]=e[i]);return r})(e,t)}async function d(t,i){"modelTopology"in t||(t={modelTopology:t});let s=(t=t).modelTopology;null!=s.model_config&&(s=s.model_config);const o=(0,a.convertPythonicToTs)(s),n=(0,r.deserialize)(o,i);if(null!=t.weightsManifest){const i=await e.io.loadWeights(t.weightsManifest,t.pathPrefix,n.weights.map(e=>e.originalName)),s={};for(const e of n.weights)s[e.originalName]=i[e.originalName];n.loadWeights(s),(0,e.dispose)(i)}return n}async function p(t,i){if(null==i&&(i={}),"string"==typeof t){const s=e.io.getLoadHandlers(t,i);if(0===s.length)s.push(e.io.browserHTTPRequest(t,i));else if(s.length>1)throw new n.ValueError(`Found more than one (${s.length}) load handlers for `+`URL '${t}'`);t=s[0]}return m(t,void 0,i)}async function m(t,i,s){if(null==s&&(s={}),null==t.load)throw new n.ValueError("Cannot proceed with model loading because the IOHandler provided does not have the `load` method implemented.");const o=await t.load();let l=o.modelTopology;null!=l.model_config&&(l=l.model_config);const u=null==s.strict||s.strict,h=null!=o.weightData&&null!=o.weightSpecs&&u,d=(0,r.deserialize)((0,a.convertPythonicToTs)(l),i,h),p=o.trainingConfig;if(null!=p&&d.loadTrainingConfig(p),null!=o.userDefinedMetadata&&d.setUserDefinedMetadata(o.userDefinedMetadata),null!=o.weightData){if(null==o.weightSpecs)throw new n.ValueError("LayersModel artifacts contains weight data, but not weight specs. Therefore loading of weights cannot proceed.");const{modelWeights:t,optimizerWeights:i}=c(o.weightData,o.weightSpecs);d.loadWeights(t,u),null!=d.optimizer&&i.length>0&&await d.optimizer.setWeights(i),(0,e.dispose)(t),(0,e.dispose)(i.map(e=>e.tensor))}return d}function c(t,i){const s=e.io.decodeWeights(t,i),o={},n=[];return i.forEach(e=>{"optimizer"===e.group?n.push({name:e.name,tensor:s[e.name]}):o[e.name]=s[e.name]}),{modelWeights:o,optimizerWeights:n}}class f extends o.LayersModel{constructor(e){if(super({inputs:[],outputs:[]}),e=e||{},this.trainable=!0,this.built=!1,this.name=null!=e.name?e.name:(0,t.getUid)("sequential_"),null!=e.layers)for(const t of e.layers)this.add(t)}checkShape(e){if(e.inboundNodes[0].outputTensors[0].shape.some(e=>e<0))throw new n.ValueError("Negative dimension size caused by adding layer "+`${e.name} with input shape [`+`${e.inboundNodes[0].inputTensors[0].shape}]`)}add(e){const t=e instanceof f||e instanceof o.LayersModel;let r;if(t){if(1!==(r=e).outputs.length)throw new n.ValueError("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");if(1!==r.inputs.length)throw new n.ValueError("All layers in a Sequential model should have a single input tensor. For multi-input layers, use the functional API.")}if(0===this.outputs.length){if(0===e.inboundNodes.length){if(null==e.batchInputShape)throw new n.ValueError("The first layer in a Sequential model must get an `inputShape` or `batchInputShape` argument.");const t=(0,i.Input)({batchShape:e.batchInputShape,dtype:e.dtype,name:e.name+"_input"});e.apply(t)}if(t)this.outputs=r.outputs,this.inputs=r.inputs;else{if(1!==e.inboundNodes.length)throw new n.ValueError("A layer added to a Sequential model must not already be "+`connected somewhere else. LayersModel received layer ${e.name} `+`which has ${e.inboundNodes.length} pre-existing inbound `+"connections.");if(1!==e.inboundNodes[0].outputTensors.length)throw new n.ValueError("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");this.checkShape(e),this.outputs=[e.inboundNodes[0].outputTensors[0]],this.inputs=(0,s.getSourceInputs)(this.outputs[0])}this.inboundNodes=[],new s.Node({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:this.inputs,outputTensors:this.outputs,inputMasks:l.pyListRepeat(null,this.inputs.length),outputMasks:[null],inputShapes:this.inputs.map(e=>e.shape),outputShapes:this.outputs[0].shape})}else{const t=e.apply(this.outputs[0]);if(Array.isArray(t))throw new TypeError("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");this.checkShape(e),this.outputs=[t],this.inboundNodes[0].outputTensors=this.outputs,this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}this.layers.push(e),this.built=!1}pop(){if(0===this.layers.length)throw new TypeError("There are no layers in the model.");if(this.layers.pop(),0===this.layers.length)this.outputs=[],this.inboundNodes=[],this.outboundNodes=[];else{const e=this.layers.length-1;this.layers[e].outboundNodes=[],this.outputs=[this.layers[e].output],this.inboundNodes[0].outputTensors=this.outputs,this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}}call(e,t){return null==this.model&&this.build(),this.model.call(e,t)}build(e){if((0,u.getExactlyOneShape)(e),0===this.inputs.length||0===this.outputs.length)throw new TypeError("Sequential model cannot be built: model is empty. Add some layers first.");this.model=new o.LayersModel({inputs:this.inputs,outputs:this.outputs[0],name:this.name+"_model"}),this.model.trainable=this.trainable,this.supportsMasking=this.model.supportsMasking,this.inputLayers=this.model.inputLayers,this.inputLayersNodeIndices=this.model.inputLayersNodeIndices,this.inputLayersTensorIndices=this.model.inputLayersTensorIndices,this.outputLayers=this.model.outputLayers,this.outputLayersNodeIndices=this.model.outputLayersNodeIndices,this.outputLayersTensorIndices=this.model.outputLayersTensorIndices,this.nodesByDepth=this.model.nodesByDepth,this.containerNodes=this.model.containerNodes,this.outputNames=this.model.outputNames,this.inputNames=this.model.inputNames,this.built=!0}countParams(){return this.built||this.build(),super.countParams()}summary(e,t,i=console.log){this.built||this.build(),super.summary(e,t,i)}setWeights(e){null==this.model&&this.build(),this.model.setWeights(e)}evaluate(e,t,i={}){if(!this.built)throw new n.RuntimeError("The model needs to be compiled before being used.");return this.model.evaluate(e,t,i)}async evaluateDataset(e,t){if(!this.built)throw new n.RuntimeError("The model needs to be compiled before being used.");return this.model.evaluateDataset(e,t)}predict(e,t={}){return null==this.model&&this.build(),this.model.predict(e,t)}predictOnBatch(e){return null==this.model&&this.build(),this.model.predictOnBatch(e)}compile(e){this.build(),this.model.compile(e),this.optimizer_=this.model.optimizer,this.isOptimizerOwned=this.model.isOptimizerOwned,this.loss=this.model.loss,this.metrics=this.model.metrics,this.metricsTensors=this.model.metricsTensors,this.metricsNames=this.model.metricsNames}get optimizer(){return null==this.model?void 0:this.model.optimizer}set optimizer(e){this.model.optimizer=e}async fit(e,t,i={}){if(!this.built)throw new n.RuntimeError("The model needs to be compiled before being used.");return this.model.fit(e,t,i)}async fitDataset(e,t){if(!this.built)throw new n.RuntimeError("The model needs to be compiled before being used.");return this.model.fitDataset(e,t)}async trainOnBatch(e,t){return this.model.trainOnBatch(e,t)}static fromConfig(t,i,s={},o=!1){let l,a={};if(i instanceof Array){if(null==i[0].className||"Merge"===i[0].className)throw new n.ValueError("Legacy serialization format not supported yet.");l=i}else e.util.assert(null!=i.layers,()=>"When the config data for a Sequential model is not an Array, it must be an Object that contains the 'layers' field."),l=i.layers,delete i.layers,a=i;const u=new t(a);if(!(u instanceof f))throw new n.NotImplementedError(`Sequential.fromConfig called on non-Sequential input: ${u}`);for(const e of l){const t=void 0,i=(0,r.deserialize)(e,t,o);o&&i.setFastWeightInitDuringBuild(!0),u.add(i)}return u}set stopTraining(e){if(null==this.model)throw new n.ValueError("Cannot set the stopTraining property of a sequential model before it is compiled.");this.model.stopTraining=e}get stopTraining(){if(null==this.model)throw new n.ValueError("Cannot get the stopTraining property of a sequential model before it is compiled.");return this.model.stopTraining}getConfig(){const e=[];for(const t of this.layers){const i={};i.className=t.getClassName(),i.config=t.getConfig(),e.push(i)}return{name:this.name,layers:e}}}exports.Sequential=f,f.className="Sequential",e.serialization.registerClass(f);
},{"@tensorflow/tfjs-core":"kSBl","./backend/state":"R2ma","./engine/input_layer":"xdtw","./engine/topology":"wHpB","./engine/training":"BP0g","./errors":"iJtr","./layers/serialization":"bKFn","./utils/generic_utils":"VKwv","./utils/serialization_utils":"eha7","./utils/types_utils":"mOET"}],"FxJ6":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.input=i,Object.defineProperty(exports,"loadLayersModel",{enumerable:!0,get:function(){return n.loadLayersModel}}),exports.model=o,exports.registerCallbackConstructor=s,exports.sequential=u;var e=require("./base_callbacks"),r=require("./engine/input_layer"),t=require("./engine/training"),n=require("./models");function o(e){return new t.LayersModel(e)}function u(e){return new n.Sequential(e)}function i(e){return(0,r.Input)(e)}function s(r,t){e.CallbackConstructorRegistry.registerCallbackConstructor(r,t)}
},{"./base_callbacks":"GDiE","./engine/input_layer":"xdtw","./engine/training":"BP0g","./models":"GBM9"}],"NY2V":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.Tanh=exports.Swish=exports.Softsign=exports.Softplus=exports.Softmax=exports.Sigmoid=exports.Selu=exports.Relu6=exports.Relu=exports.Mish=exports.LogSoftmax=exports.Linear=exports.HardSigmoid=exports.GeluNew=exports.Gelu=exports.Elu=exports.Activation=void 0,exports.deserializeActivation=v,exports.getActivation=w,exports.serializeActivation=C;var e=a(require("@tensorflow/tfjs-core")),s=e,t=a(require("./backend/tfjs_backend")),r=require("./utils/generic_utils");function a(e,s){if("function"==typeof WeakMap)var t=new WeakMap,r=new WeakMap;return(a=function(e,s){if(!s&&e&&e.__esModule)return e;var a,i,l={__proto__:null,default:e};if(null===e||"object"!=typeof e&&"function"!=typeof e)return l;if(a=s?r:t){if(a.has(e))return a.get(e);a.set(e,l)}for(const t in e)"default"!==t&&{}.hasOwnProperty.call(e,t)&&((i=(a=Object.defineProperty)&&Object.getOwnPropertyDescriptor(e,t))&&(i.get||i.set)?a(l,t,i):l[t]=e[t]);return l})(e,s)}class i extends e.serialization.Serializable{getConfig(){return{}}}exports.Activation=i;class l extends i{apply(e,s=1){return t.elu(e,s)}}exports.Elu=l,l.className="elu",e.serialization.registerClass(l);class o extends i{apply(e){return s.selu(e)}}exports.Selu=o,o.className="selu",e.serialization.registerClass(o);class n extends i{apply(e){return s.relu(e)}}exports.Relu=n,n.className="relu",e.serialization.registerClass(n);class p extends i{apply(t){return(0,e.tidy)(()=>s.minimum(6,s.relu(t)))}}exports.Relu6=p,p.className="relu6",e.serialization.registerClass(p);class u extends i{apply(e){return e}}exports.Linear=u,u.className="linear",e.serialization.registerClass(u);class c extends i{apply(e){return s.sigmoid(e)}}exports.Sigmoid=c,c.className="sigmoid",e.serialization.registerClass(c);class x extends i{apply(e){return t.hardSigmoid(e)}}exports.HardSigmoid=x,x.className="hardSigmoid",e.serialization.registerClass(x);class d extends i{apply(e){return s.softplus(e)}}exports.Softplus=d,d.className="softplus",e.serialization.registerClass(d);class m extends i{apply(e){return t.softsign(e)}}exports.Softsign=m,m.className="softsign",e.serialization.registerClass(m);class f extends i{apply(e){return s.tanh(e)}}exports.Tanh=f,f.className="tanh",e.serialization.registerClass(f);class g extends i{apply(e,t=-1){return s.softmax(e,t)}}exports.Softmax=g,g.className="softmax",e.serialization.registerClass(g);class y extends i{apply(e,t=-1){return s.logSoftmax(e,t)}}exports.LogSoftmax=y,y.className="logSoftmax",e.serialization.registerClass(y);class z extends i{apply(t){return(0,e.tidy)(()=>s.tidy(()=>{const e=Math.sqrt(2),r=s.mul(.5,s.add(1,s.erf(s.div(t,e))));return s.mul(t,r)}))}}exports.Gelu=z,z.className="gelu",e.serialization.registerClass(z);class N extends i{apply(t){return(0,e.tidy)(()=>s.mul(.5,s.mul(t,s.add(1,s.tanh(s.mul(s.sqrt(s.div(2,Math.PI)),s.add(t,s.mul(.044715,s.pow(t,3)))))))))}}exports.GeluNew=N,N.className="gelu_new",e.serialization.registerClass(N);class S extends i{apply(t){return(0,e.tidy)(()=>s.mul(t,s.tanh(s.softplus(t))))}}exports.Mish=S,S.className="mish",e.serialization.registerClass(S);class h extends i{apply(t,r=1){return(0,e.tidy)(()=>s.mul(s.sigmoid(s.mul(t,r)),t))}}function C(e){return e.getClassName()}function v(s,t={}){return(0,r.deserializeKerasObject)(s,e.serialization.SerializationMap.getMap().classNameMap,t,"activation")}function w(e){if(null==e){const e={className:"linear",config:{}};return v(e)}if("string"==typeof e){const s={};return s.className=e,s.config={},v(s)}return e instanceof i?e:v(e)}exports.Swish=h,h.className="swish",e.serialization.registerClass(h);
},{"@tensorflow/tfjs-core":"kSBl","./backend/tfjs_backend":"Ftmo","./utils/generic_utils":"VKwv"}],"TEkX":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.Regularizer=exports.REGULARIZER_IDENTIFIER_REGISTRY_SYMBOL_MAP=exports.L1L2=void 0,exports.deserializeRegularizer=p,exports.getRegularizer=d,exports.l1=a,exports.l2=o,exports.serializeRegularizer=f;var e=n(require("@tensorflow/tfjs-core")),r=e,t=n(require("./backend/tfjs_backend")),l=require("./utils/generic_utils");function n(e,r){if("function"==typeof WeakMap)var t=new WeakMap,l=new WeakMap;return(n=function(e,r){if(!r&&e&&e.__esModule)return e;var n,i,s={__proto__:null,default:e};if(null===e||"object"!=typeof e&&"function"!=typeof e)return s;if(n=r?l:t){if(n.has(e))return n.get(e);n.set(e,s)}for(const t in e)"default"!==t&&{}.hasOwnProperty.call(e,t)&&((i=(n=Object.defineProperty)&&Object.getOwnPropertyDescriptor(e,t))&&(i.get||i.set)?n(s,t,i):s[t]=e[t]);return s})(e,r)}function i(e){if(null!=e&&"object"!=typeof e)throw new Error("Argument to L1L2 regularizer's constructor is expected to be an "+`object, but received: ${e}`)}class s extends e.serialization.Serializable{}exports.Regularizer=s;class u extends s{constructor(e){super(),i(e),this.l1=null==e||null==e.l1?.01:e.l1,this.l2=null==e||null==e.l2?.01:e.l2,this.hasL1=0!==this.l1,this.hasL2=0!==this.l2}apply(l){return(0,e.tidy)(()=>{let n=(0,e.zeros)([1]);return this.hasL1&&(n=(0,e.add)(n,(0,e.sum)(r.mul(this.l1,(0,e.abs)(l))))),this.hasL2&&(n=(0,e.add)(n,(0,e.sum)(r.mul(this.l2,t.square(l))))),r.reshape(n,[])})}getConfig(){return{l1:this.l1,l2:this.l2}}static fromConfig(e,r){return new e({l1:r.l1,l2:r.l2})}}function a(e){return i(e),new u({l1:null!=e?e.l1:null,l2:0})}function o(e){return i(e),new u({l2:null!=e?e.l2:null,l1:0})}exports.L1L2=u,u.className="L1L2",e.serialization.registerClass(u);const c=exports.REGULARIZER_IDENTIFIER_REGISTRY_SYMBOL_MAP={l1l2:"L1L2"};function f(e){return(0,l.serializeKerasObject)(e)}function p(r,t={}){return(0,l.deserializeKerasObject)(r,e.serialization.SerializationMap.getMap().classNameMap,t,"regularizer")}function d(e){if(null==e)return null;if("string"==typeof e){return p({className:e in c?c[e]:e,config:{}})}return e instanceof s?e:p(e)}
},{"@tensorflow/tfjs-core":"kSBl","./backend/tfjs_backend":"Ftmo","./utils/generic_utils":"VKwv"}],"S626":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.ThresholdedReLU=exports.Softmax=exports.ReLU=exports.PReLU=exports.LeakyReLU=exports.ELU=void 0;var e=require("@tensorflow/tfjs-core"),t=require("../activations"),s=require("../constraints"),a=require("../engine/topology"),r=require("../errors"),i=require("../initializers"),l=require("../regularizers"),n=require("../utils/types_utils");class h extends a.Layer{constructor(e){super(null==e?{}:e),this.supportsMasking=!0,null!=e&&(this.maxValue=e.maxValue)}call(t,s){t=(0,n.getExactlyOneTensor)(t);let a=(0,e.relu)(t);return null!=this.maxValue&&(a=(0,e.clipByValue)(a,0,this.maxValue)),a}computeOutputShape(e){return e}getConfig(){const e={maxValue:this.maxValue},t=super.getConfig();return Object.assign(e,t),e}}exports.ReLU=h,h.className="ReLU",e.serialization.registerClass(h);class u extends a.Layer{constructor(e){super(null==e?{}:e),this.DEFAULT_ALPHA=.3,null==e&&(e={}),this.alpha=null==e.alpha?this.DEFAULT_ALPHA:e.alpha}call(t,s){const a=(0,n.getExactlyOneTensor)(t);return(0,e.leakyRelu)(a,this.alpha)}computeOutputShape(e){return e}getConfig(){const e={alpha:this.alpha},t=super.getConfig();return Object.assign(e,t),e}}exports.LeakyReLU=u,u.className="LeakyReLU",e.serialization.registerClass(u);class o extends a.Layer{constructor(e){if(super(null==e?{}:e),this.DEFAULT_ALPHA_INITIALIZER="zeros",null==e&&(e={}),this.supportsMasking=!0,this.alphaInitializer=(0,i.getInitializer)(e.alphaInitializer||this.DEFAULT_ALPHA_INITIALIZER),this.alphaRegularizer=(0,l.getRegularizer)(e.alphaRegularizer),this.alphaConstraint=(0,s.getConstraint)(e.alphaConstraint),null==e.sharedAxes)this.sharedAxes=null;else if(Array.isArray(e.sharedAxes))this.sharedAxes=e.sharedAxes;else{if("number"!=typeof e.sharedAxes)throw new r.ValueError("Expected sharedAxes to be a number or an array of numbers, "+`but got ${e.sharedAxes}`);this.sharedAxes=[e.sharedAxes]}}build(e){const t=(e=(0,n.getExactlyOneShape)(e)).slice(1);if(null!=this.sharedAxes)for(const a of this.sharedAxes)t[a-1]=1;this.alpha=this.addWeight("alpha",t,"float32",this.alphaInitializer,this.alphaRegularizer,!0,this.alphaConstraint);const s={};if(null!=this.sharedAxes)for(let a=1;a<e.length;++a)s[a]=e[a];this.inputSpec=[new a.InputSpec({ndim:e.length,axes:s})],this.built=!0}call(t,s){return t=(0,n.getExactlyOneTensor)(t),(0,e.prelu)(t,this.alpha.read())}getConfig(){const e={alphaInitializer:(0,i.serializeInitializer)(this.alphaInitializer),alphaRegularizer:(0,l.serializeRegularizer)(this.alphaRegularizer),alphaConstraint:(0,s.serializeConstraint)(this.alphaConstraint),sharedAxes:this.sharedAxes},t=super.getConfig();return Object.assign(e,t),e}}exports.PReLU=o,o.className="PReLU",e.serialization.registerClass(o);class p extends a.Layer{constructor(e){if(super(null==e?{}:e),this.DEFAULT_ALPHA=1,null==e&&(e={}),null!=e.alpha&&e.alpha!==this.DEFAULT_ALPHA)throw new r.NotImplementedError(`Non-default alpha value (${e.alpha}) is not supported by the `+"ELU layer yet.");this.alpha=null==e.alpha?this.DEFAULT_ALPHA:e.alpha}call(t,s){const a=(0,n.getExactlyOneTensor)(t);return(0,e.elu)(a)}computeOutputShape(e){return e}getConfig(){const e={alpha:this.alpha},t=super.getConfig();return Object.assign(e,t),e}}exports.ELU=p,p.className="ELU",e.serialization.registerClass(p);class c extends a.Layer{constructor(e){super(null==e?{}:e),this.DEFAULT_THETA=1,null==e&&(e={}),this.theta=null==e.theta?this.DEFAULT_THETA:e.theta}call(t,s){const a=(0,n.getExactlyOneTensor)(t);return(0,e.mul)(a,(0,e.cast)((0,e.greater)(a,this.theta),"float32"))}computeOutputShape(e){return e}getConfig(){const e={theta:this.theta},t=super.getConfig();return Object.assign(e,t),e}}exports.ThresholdedReLU=c,c.className="ThresholdedReLU",e.serialization.registerClass(c);class x extends a.Layer{constructor(e){super(null==e?{}:e),this.DEFAULT_AXIS=1,null==e&&(e={}),this.softmax=(new t.Softmax).apply,this.axis=null==e.axis?this.DEFAULT_AXIS:e.axis}call(t,s){return(0,e.tidy)(()=>{let a=(0,n.getExactlyOneTensor)(t);const r=s.mask;if(null!=r){const t=(0,e.mul)((0,e.sub)((0,e.ones)(a.shape),(0,e.cast)(r,a.dtype)),(0,e.scalar)(-1e9));a=(0,e.add)(a,t)}return this.axis instanceof Array?this.axis.length>1?(0,e.exp)((0,e.sub)(a,(0,e.logSumExp)(a,this.axis,!0))):this.softmax(a,this.axis[0]):this.softmax(a,this.axis)})}computeOutputShape(e){return e}getConfig(){const e={axis:this.axis},t=super.getConfig();return Object.assign(e,t),e}}exports.Softmax=x,x.className="Softmax",e.serialization.registerClass(x);
},{"@tensorflow/tfjs-core":"kSBl","../activations":"NY2V","../constraints":"zJV2","../engine/topology":"wHpB","../errors":"iJtr","../initializers":"Ltyq","../regularizers":"TEkX","../utils/types_utils":"mOET"}],"cPzX":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.convOutputLength=u,exports.deconvLength=i,exports.normalizeArray=n;var e=require("../errors"),r=require("./generic_utils"),t=require("./math_utils");function n(n,u,i){if("number"==typeof n)return(0,r.pyListRepeat)(n,u);if(n.length!==u)throw new e.ValueError(`The ${i} argument must be an integer or tuple of ${u} integers.`+` Received: ${n.length} elements.`);for(let r=0;r<u;++r){const o=n[r];if(!(0,t.isInteger)(o))throw new e.ValueError(`The ${i} argument must be an integer or tuple of ${u}`+` integers. Received: ${JSON.stringify(n)} including a`+` non-integer number ${o}`)}return n}function u(e,r,t,n,u=1){if(null==e)return e;let i;return i="same"===t?e:e-(r+(r-1)*(u-1))+1,Math.floor((i+n-1)/n)}function i(r,n,u,i){if(null==r)return null;if("valid"===i)r=r*n+(0,t.max)([u-n,0]);else{if("same"!==i)throw new e.ValueError(`Unsupport padding mode: ${i}.`);r*=n}return r}
},{"../errors":"iJtr","./generic_utils":"VKwv","./math_utils":"eQAy"}],"sbhA":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.UpSampling2D=exports.SeparableConv2D=exports.SeparableConv=exports.Cropping2D=exports.Conv3DTranspose=exports.Conv3D=exports.Conv2DTranspose=exports.Conv2D=exports.Conv1D=exports.Conv=exports.BaseConv=void 0,exports.conv1d=v,exports.conv1dWithBias=z,exports.conv2d=k,exports.conv2dWithBiasActivation=b,exports.conv3d=w,exports.conv3dWithBias=C,exports.preprocessConv2DInput=f,exports.preprocessConv3DInput=m;var e=g(require("@tensorflow/tfjs-core")),t=e,i=require("../activations"),r=require("../backend/common"),n=g(require("../backend/tfjs_backend")),s=require("../common"),a=require("../constraints"),o=require("../engine/topology"),l=require("../errors"),h=require("../initializers"),d=require("../regularizers"),p=require("../utils/conv_utils"),u=g(require("../utils/generic_utils")),c=require("../utils/types_utils");function g(e,t){if("function"==typeof WeakMap)var i=new WeakMap,r=new WeakMap;return(g=function(e,t){if(!t&&e&&e.__esModule)return e;var n,s,a={__proto__:null,default:e};if(null===e||"object"!=typeof e&&"function"!=typeof e)return a;if(n=t?r:i){if(n.has(e))return n.get(e);n.set(e,a)}for(const i in e)"default"!==i&&{}.hasOwnProperty.call(e,i)&&((s=(n=Object.defineProperty)&&Object.getOwnPropertyDescriptor(e,i))&&(s.get||s.set)?n(a,i,s):a[i]=e[i]);return a})(e,t)}function f(i,r){return(0,e.tidy)(()=>((0,s.checkDataFormat)(r),"channelsFirst"===r?t.transpose(i,[0,2,3,1]):i))}function m(i,r){return(0,e.tidy)(()=>((0,s.checkDataFormat)(r),"channelsFirst"===r?t.transpose(i,[0,2,3,4,1]):i))}function z(i,a,o,h=1,d="valid",p,u=1){return(0,e.tidy)(()=>{if(null==p&&(p=(0,r.imageDataFormat)()),(0,s.checkDataFormat)(p),3!==i.shape.length)throw new l.ValueError("The input of a conv1dWithBias operation should be 3, but is "+`${i.shape.length} instead.`);if(3!==a.shape.length)throw new l.ValueError("The kernel for a conv1dWithBias operation should be 3, but is "+`${a.shape.length} instead`);if(null!=o&&1!==o.shape.length)throw new l.ValueError("The bias for a conv1dWithBias operation should be 1, but is "+`${o.shape.length} instead`);if("channelsFirst"===p&&(i=t.transpose(i,[0,2,1])),"causal"===d)throw new l.NotImplementedError("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");let e=t.conv1d(i,a,h,"same"===d?"same":"valid","NWC",u);return null!=o&&(e=n.biasAdd(e,o)),e})}function v(t,i,r=1,n="valid",a,o=1){return(0,e.tidy)(()=>((0,s.checkDataFormat)(a),z(t,i,null,r,n,a,o)))}function k(t,i,r=[1,1],n="valid",a,o){return(0,e.tidy)(()=>((0,s.checkDataFormat)(a),b(t,i,null,r,n,a,o)))}function b(i,n,a,o=[1,1],h="valid",d,p,u=null){return(0,e.tidy)(()=>{if(null==d&&(d=(0,r.imageDataFormat)()),(0,s.checkDataFormat)(d),3!==i.rank&&4!==i.rank)throw new l.ValueError("conv2dWithBiasActivation expects input to be of rank 3 or 4, "+`but received ${i.rank}.`);if(3!==n.rank&&4!==n.rank)throw new l.ValueError("conv2dWithBiasActivation expects kernel to be of rank 3 or 4, "+`but received ${i.rank}.`);let e=f(i,d);if("causal"===h)throw new l.NotImplementedError("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");return e=t.fused.conv2d({x:e,filter:n,strides:o,pad:"same"===h?"same":"valid",dilations:p,dataFormat:"NHWC",bias:a,activation:u}),"channelsFirst"===d&&(e=t.transpose(e,[0,3,1,2])),e})}function w(t,i,r=[1,1,1],n="valid",a,o){return(0,e.tidy)(()=>((0,s.checkDataFormat)(a),C(t,i,null,r,n,a,o)))}function C(i,a,o,h=[1,1,1],d="valid",p,u){return(0,e.tidy)(()=>{if(null==p&&(p=(0,r.imageDataFormat)()),(0,s.checkDataFormat)(p),4!==i.rank&&5!==i.rank)throw new l.ValueError("conv3dWithBias expects input to be of rank 4 or 5, but received "+`${i.rank}.`);if(4!==a.rank&&5!==a.rank)throw new l.ValueError("conv3dWithBias expects kernel to be of rank 4 or 5, but received "+`${i.rank}.`);let e=m(i,p);if("causal"===d)throw new l.NotImplementedError("The support for CAUSAL padding mode in conv3dWithBias is not implemented yet.");return e=t.conv3d(e,a,h,"same"===d?"same":"valid","NDHWC",u),null!=o&&(e=n.biasAdd(e,o)),"channelsFirst"===p&&(e=t.transpose(e,[0,4,1,2,3])),e})}class y extends o.Layer{constructor(e,t){if(super(t),this.bias=null,this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_BIAS_INITIALIZER="zeros",y.verifyArgs(t),this.rank=e,u.assertPositiveInteger(this.rank,"rank"),1!==this.rank&&2!==this.rank&&3!==this.rank)throw new l.NotImplementedError(`Convolution layer for rank other than 1, 2, or 3 (${this.rank}) is `+"not implemented yet.");if(this.kernelSize=(0,p.normalizeArray)(t.kernelSize,e,"kernelSize"),this.strides=(0,p.normalizeArray)(null==t.strides?1:t.strides,e,"strides"),this.padding=null==t.padding?"valid":t.padding,(0,s.checkPaddingMode)(this.padding),this.dataFormat=null==t.dataFormat?"channelsLast":t.dataFormat,(0,s.checkDataFormat)(this.dataFormat),this.activation=(0,i.getActivation)(t.activation),this.useBias=null==t.useBias||t.useBias,this.biasInitializer=(0,h.getInitializer)(t.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.biasConstraint=(0,a.getConstraint)(t.biasConstraint),this.biasRegularizer=(0,d.getRegularizer)(t.biasRegularizer),this.activityRegularizer=(0,d.getRegularizer)(t.activityRegularizer),this.dilationRate=(0,p.normalizeArray)(null==t.dilationRate?1:t.dilationRate,e,"dilationRate"),1===this.rank&&Array.isArray(this.dilationRate)&&1!==this.dilationRate.length)throw new l.ValueError("dilationRate must be a number or an array of a single number for 1D convolution, but received "+`${JSON.stringify(this.dilationRate)}`);if(2===this.rank){if("number"==typeof this.dilationRate)this.dilationRate=[this.dilationRate,this.dilationRate];else if(2!==this.dilationRate.length)throw new l.ValueError("dilationRate must be a number or array of two numbers for 2D "+`convolution, but received ${JSON.stringify(this.dilationRate)}`)}else if(3===this.rank)if("number"==typeof this.dilationRate)this.dilationRate=[this.dilationRate,this.dilationRate,this.dilationRate];else if(3!==this.dilationRate.length)throw new l.ValueError("dilationRate must be a number or array of three numbers for 3D "+`convolution, but received ${JSON.stringify(this.dilationRate)}`)}static verifyArgs(e){if(u.assert("kernelSize"in e,"required key 'kernelSize' not in config"),"number"!=typeof e.kernelSize&&!u.checkArrayTypeAndLength(e.kernelSize,"number",1,3))throw new l.ValueError("BaseConv expects config.kernelSize to be number or number[] with "+`length 1, 2, or 3, but received ${JSON.stringify(e.kernelSize)}.`)}getConfig(){const e={kernelSize:this.kernelSize,strides:this.strides,padding:this.padding,dataFormat:this.dataFormat,dilationRate:this.dilationRate,activation:(0,i.serializeActivation)(this.activation),useBias:this.useBias,biasInitializer:(0,h.serializeInitializer)(this.biasInitializer),biasRegularizer:(0,d.serializeRegularizer)(this.biasRegularizer),activityRegularizer:(0,d.serializeRegularizer)(this.activityRegularizer),biasConstraint:(0,a.serializeConstraint)(this.biasConstraint)},t=super.getConfig();return Object.assign(e,t),e}}exports.BaseConv=y;class S extends y{constructor(e,t){super(e,t),this.kernel=null,S.verifyArgs(t),this.filters=t.filters,u.assertPositiveInteger(this.filters,"filters"),this.kernelInitializer=(0,h.getInitializer)(t.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.kernelConstraint=(0,a.getConstraint)(t.kernelConstraint),this.kernelRegularizer=(0,d.getRegularizer)(t.kernelRegularizer)}build(e){e=(0,c.getExactlyOneShape)(e);const t="channelsFirst"===this.dataFormat?1:e.length-1;if(null==e[t])throw new l.ValueError("The channel dimension of the input should be defined. "+`Found ${e[t]}`);const i=e[t],r=this.kernelSize.concat([i,this.filters]);this.kernel=this.addWeight("kernel",r,null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[{ndim:this.rank+2,axes:{[t]:i}}],this.built=!0}call(t,i){return(0,e.tidy)(()=>{let e;t=(0,c.getExactlyOneTensor)(t);const i=null==this.bias?null:this.bias.read(),r=u.mapActivationToFusedKernel(this.activation.getClassName());if(null!=r&&2===this.rank)e=b(t,this.kernel.read(),i,this.strides,this.padding,this.dataFormat,this.dilationRate,r);else{if(1===this.rank)e=z(t,this.kernel.read(),i,this.strides[0],this.padding,this.dataFormat,this.dilationRate[0]);else if(2===this.rank)e=b(t,this.kernel.read(),i,this.strides,this.padding,this.dataFormat,this.dilationRate);else{if(3!==this.rank)throw new l.NotImplementedError("convolutions greater than 3D are not implemented yet.");e=C(t,this.kernel.read(),i,this.strides,this.padding,this.dataFormat,this.dilationRate)}null!=this.activation&&(e=this.activation.apply(e))}return e})}computeOutputShape(e){e=(0,c.getExactlyOneShape)(e);const t=[],i="channelsLast"===this.dataFormat?e.slice(1,e.length-1):e.slice(2);for(let n=0;n<i.length;++n){const e=(0,p.convOutputLength)(i[n],this.kernelSize[n],this.padding,this.strides[n],"number"==typeof this.dilationRate?this.dilationRate:this.dilationRate[n]);t.push(e)}let r=[e[0]];return"channelsLast"===this.dataFormat?(r=r.concat(t)).push(this.filters):(r.push(this.filters),r=r.concat(t)),r}getConfig(){const e={filters:this.filters,kernelInitializer:(0,h.serializeInitializer)(this.kernelInitializer),kernelRegularizer:(0,d.serializeRegularizer)(this.kernelRegularizer),kernelConstraint:(0,a.serializeConstraint)(this.kernelConstraint)},t=super.getConfig();return Object.assign(e,t),e}static verifyArgs(e){if(!("filters"in e)||"number"!=typeof e.filters||e.filters<1)throw new l.ValueError("Convolution layer expected config.filters to be a 'number' > 0 "+`but got ${JSON.stringify(e.filters)}`)}}exports.Conv=S;class I extends S{constructor(e){super(2,e),I.verifyArgs(e)}getConfig(){const e=super.getConfig();return delete e.rank,e}static verifyArgs(e){if("number"!=typeof e.kernelSize&&!u.checkArrayTypeAndLength(e.kernelSize,"number",1,2))throw new l.ValueError("Conv2D expects config.kernelSize to be number or number[] with "+`length 1 or 2, but received ${JSON.stringify(e.kernelSize)}.`)}}exports.Conv2D=I,I.className="Conv2D",e.serialization.registerClass(I);class F extends S{constructor(e){super(3,e),F.verifyArgs(e)}getConfig(){const e=super.getConfig();return delete e.rank,e}static verifyArgs(e){if("number"!=typeof e.kernelSize&&(!Array.isArray(e.kernelSize)||1!==e.kernelSize.length&&3!==e.kernelSize.length))throw new l.ValueError("Conv3D expects config.kernelSize to be number or"+` [number, number, number], but received ${JSON.stringify(e.kernelSize)}.`)}}exports.Conv3D=F,F.className="Conv3D",e.serialization.registerClass(F);class R extends I{constructor(e){if(super(e),this.inputSpec=[new o.InputSpec({ndim:4})],"same"!==this.padding&&"valid"!==this.padding)throw new l.ValueError("Conv2DTranspose currently supports only padding modes 'same' "+`and 'valid', but received padding mode ${this.padding}`)}build(e){if(4!==(e=(0,c.getExactlyOneShape)(e)).length)throw new l.ValueError("Input should have rank 4; Received input shape: "+JSON.stringify(e));const t="channelsFirst"===this.dataFormat?1:e.length-1;if(null==e[t])throw new l.ValueError("The channel dimension of the inputs should be defined. Found `None`.");const i=e[t],r=this.kernelSize.concat([this.filters,i]);this.kernel=this.addWeight("kernel",r,"float32",this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[new o.InputSpec({ndim:4,axes:{[t]:i}})],this.built=!0}call(e,i){return t.tidy(()=>{let i=(0,c.getExactlyOneTensor)(e);if(4!==i.shape.length)throw new l.ValueError("Conv2DTranspose.call() expects input tensor to be rank-4, but "+`received a tensor of rank-${i.shape.length}`);const r=i.shape,s=r[0];let a,o;"channelsFirst"===this.dataFormat?(a=2,o=3):(a=1,o=2);const h=r[a],d=r[o],u=this.kernelSize[0],g=this.kernelSize[1],f=this.strides[0],m=this.strides[1],z=[s,(0,p.deconvLength)(h,f,u,this.padding),(0,p.deconvLength)(d,m,g,this.padding),this.filters];"channelsLast"!==this.dataFormat&&(i=t.transpose(i,[0,2,3,1]));let v=t.conv2dTranspose(i,this.kernel.read(),z,this.strides,this.padding);return"channelsLast"!==this.dataFormat&&(v=t.transpose(v,[0,3,1,2])),null!=this.bias&&(v=n.biasAdd(v,this.bias.read(),this.dataFormat)),null!=this.activation&&(v=this.activation.apply(v)),v})}computeOutputShape(e){const t=(e=(0,c.getExactlyOneShape)(e)).slice();let i,r,n;"channelsFirst"===this.dataFormat?(i=1,r=2,n=3):(i=3,r=1,n=2);const s=this.kernelSize[0],a=this.kernelSize[1],o=this.strides[0],l=this.strides[1];return t[i]=this.filters,t[r]=(0,p.deconvLength)(t[r],o,s,this.padding),t[n]=(0,p.deconvLength)(t[n],l,a,this.padding),t}getConfig(){const e=super.getConfig();return delete e.dilationRate,e}}exports.Conv2DTranspose=R,R.className="Conv2DTranspose",e.serialization.registerClass(R);class E extends F{constructor(e){if(super(e),this.inputSpec=[new o.InputSpec({ndim:5})],"same"!==this.padding&&"valid"!==this.padding)throw new l.ValueError("Conv3DTranspose currently supports only padding modes 'same' "+`and 'valid', but received padding mode ${this.padding}`)}build(e){if(5!==(e=(0,c.getExactlyOneShape)(e)).length)throw new l.ValueError("Input should have rank 5; Received input shape: "+JSON.stringify(e));const t="channelsFirst"===this.dataFormat?1:e.length-1;if(null==e[t])throw new l.ValueError("The channel dimension of the inputs should be defined. Found `None`.");const i=e[t],r=this.kernelSize.concat([this.filters,i]);this.kernel=this.addWeight("kernel",r,"float32",this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[new o.InputSpec({ndim:5,axes:{[t]:i}})],this.built=!0}call(e,i){return t.tidy(()=>{let i=(0,c.getExactlyOneTensor)(e);if(5!==i.shape.length)throw new l.ValueError("Conv3DTranspose.call() expects input tensor to be rank-4, but "+`received a tensor of rank-${i.shape.length}`);const r=i.shape,s=r[0];let a,o,h;"channelsFirst"===this.dataFormat?(h=2,a=3,o=4):(h=1,a=2,o=3);const d=r[h],u=r[a],g=r[o],f=this.kernelSize[0],m=this.kernelSize[1],z=this.kernelSize[2],v=this.strides[0],k=this.strides[1],b=this.strides[2],w=[s,(0,p.deconvLength)(d,v,f,this.padding),(0,p.deconvLength)(u,k,m,this.padding),(0,p.deconvLength)(g,b,z,this.padding),this.filters];"channelsLast"!==this.dataFormat&&(i=t.transpose(i,[0,2,3,4,1]));let C=t.conv3dTranspose(i,this.kernel.read(),w,this.strides,this.padding);return"channelsLast"!==this.dataFormat&&(C=t.transpose(C,[0,4,1,2,3])),null!==this.bias&&(C=n.biasAdd(C,this.bias.read(),this.dataFormat)),null!==this.activation&&(C=this.activation.apply(C)),C})}computeOutputShape(e){const t=(e=(0,c.getExactlyOneShape)(e)).slice();let i,r,n,s;"channelsFirst"===this.dataFormat?(i=1,r=2,n=3,s=4):(i=4,r=1,n=2,s=3);const a=this.kernelSize[0],o=this.kernelSize[1],l=this.kernelSize[2],h=this.strides[0],d=this.strides[1],u=this.strides[2];return t[i]=this.filters,t[r]=(0,p.deconvLength)(t[r],h,a,this.padding),t[n]=(0,p.deconvLength)(t[n],d,o,this.padding),t[s]=(0,p.deconvLength)(t[s],u,l,this.padding),t}getConfig(){const e=super.getConfig();return delete e.dilationRate,e}}exports.Conv3DTranspose=E,E.className="Conv3DTranspose",e.serialization.registerClass(E);class x extends S{constructor(e,t){if(super(e,t),this.DEFAULT_DEPTHWISE_INITIALIZER="glorotUniform",this.DEFAULT_POINTWISE_INITIALIZER="glorotUniform",this.depthwiseKernel=null,this.pointwiseKernel=null,null==t.filters)throw new l.ValueError("The `filters` configuration field is required by SeparableConv, but is unspecified.");if(null!=t.kernelInitializer||null!=t.kernelRegularizer||null!=t.kernelConstraint)throw new l.ValueError("Fields kernelInitializer, kernelRegularizer and kernelConstraint are invalid for SeparableConv2D. Use depthwiseInitializer, depthwiseRegularizer, depthwiseConstraint, pointwiseInitializer, pointwiseRegularizer and pointwiseConstraint instead.");if(null!=t.padding&&"same"!==t.padding&&"valid"!==t.padding)throw new l.ValueError(`SeparableConv${this.rank}D supports only padding modes: `+`'same' and 'valid', but received ${JSON.stringify(t.padding)}`);this.depthMultiplier=null==t.depthMultiplier?1:t.depthMultiplier,this.depthwiseInitializer=(0,h.getInitializer)(t.depthwiseInitializer||this.DEFAULT_DEPTHWISE_INITIALIZER),this.depthwiseRegularizer=(0,d.getRegularizer)(t.depthwiseRegularizer),this.depthwiseConstraint=(0,a.getConstraint)(t.depthwiseConstraint),this.pointwiseInitializer=(0,h.getInitializer)(t.depthwiseInitializer||this.DEFAULT_POINTWISE_INITIALIZER),this.pointwiseRegularizer=(0,d.getRegularizer)(t.pointwiseRegularizer),this.pointwiseConstraint=(0,a.getConstraint)(t.pointwiseConstraint)}build(e){if((e=(0,c.getExactlyOneShape)(e)).length<this.rank+2)throw new l.ValueError(`Inputs to SeparableConv${this.rank}D should have rank `+`${this.rank+2}, but received input shape: `+`${JSON.stringify(e)}`);const t="channelsFirst"===this.dataFormat?1:e.length-1;if(null==e[t]||e[t]<0)throw new l.ValueError("The channel dimension of the inputs should be defined, "+`but found ${JSON.stringify(e[t])}`);const i=e[t],r=this.kernelSize.concat([i,this.depthMultiplier]),n=[];for(let s=0;s<this.rank;++s)n.push(1);n.push(i*this.depthMultiplier,this.filters);this.depthwiseKernel=this.addWeight("depthwise_kernel",r,"float32",this.depthwiseInitializer,this.depthwiseRegularizer,!0,this.depthwiseConstraint),this.pointwiseKernel=this.addWeight("pointwise_kernel",n,"float32",this.pointwiseInitializer,this.pointwiseRegularizer,!0,this.pointwiseConstraint),this.useBias?this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.inputSpec=[new o.InputSpec({ndim:this.rank+2,axes:{[t]:i}})],this.built=!0}call(i,r){return(0,e.tidy)(()=>{let e;if(i=(0,c.getExactlyOneTensor)(i),1===this.rank)throw new l.NotImplementedError("1D separable convolution is not implemented yet.");return 2===this.rank&&("channelsFirst"===this.dataFormat&&(i=t.transpose(i,[0,2,3,1])),e=t.separableConv2d(i,this.depthwiseKernel.read(),this.pointwiseKernel.read(),this.strides,this.padding,this.dilationRate,"NHWC")),this.useBias&&(e=n.biasAdd(e,this.bias.read(),this.dataFormat)),null!=this.activation&&(e=this.activation.apply(e)),"channelsFirst"===this.dataFormat&&(e=t.transpose(e,[0,3,1,2])),e})}getConfig(){const e=super.getConfig();return delete e.rank,delete e.kernelInitializer,delete e.kernelRegularizer,delete e.kernelConstraint,e.depthwiseInitializer=(0,h.serializeInitializer)(this.depthwiseInitializer),e.pointwiseInitializer=(0,h.serializeInitializer)(this.pointwiseInitializer),e.depthwiseRegularizer=(0,d.serializeRegularizer)(this.depthwiseRegularizer),e.pointwiseRegularizer=(0,d.serializeRegularizer)(this.pointwiseRegularizer),e.depthwiseConstraint=(0,a.serializeConstraint)(this.depthwiseConstraint),e.pointwiseConstraint=(0,a.serializeConstraint)(this.pointwiseConstraint),e}}exports.SeparableConv=x,x.className="SeparableConv";class A extends x{constructor(e){super(2,e)}}exports.SeparableConv2D=A,A.className="SeparableConv2D",e.serialization.registerClass(A);class D extends S{constructor(e){super(1,e),D.verifyArgs(e),this.inputSpec=[{ndim:3}]}getConfig(){const e=super.getConfig();return delete e.rank,delete e.dataFormat,e}static verifyArgs(e){if("number"!=typeof e.kernelSize&&!u.checkArrayTypeAndLength(e.kernelSize,"number",1,1))throw new l.ValueError("Conv1D expects config.kernelSize to be number or number[] with "+`length 1, but received ${JSON.stringify(e.kernelSize)}.`)}}exports.Conv1D=D,D.className="Conv1D",e.serialization.registerClass(D);class T extends o.Layer{constructor(e){super(e),"number"==typeof e.cropping?this.cropping=[[e.cropping,e.cropping],[e.cropping,e.cropping]]:"number"==typeof e.cropping[0]?this.cropping=[[e.cropping[0],e.cropping[0]],[e.cropping[1],e.cropping[1]]]:this.cropping=e.cropping,this.dataFormat=void 0===e.dataFormat?"channelsLast":e.dataFormat,this.inputSpec=[{ndim:4}]}computeOutputShape(e){return"channelsFirst"===this.dataFormat?[e[0],e[1],e[2]-this.cropping[0][0]-this.cropping[0][1],e[3]-this.cropping[1][0]-this.cropping[1][1]]:[e[0],e[1]-this.cropping[0][0]-this.cropping[0][1],e[2]-this.cropping[1][0]-this.cropping[1][1],e[3]]}call(t,i){return(0,e.tidy)(()=>{if(t=(0,c.getExactlyOneTensor)(t),"channelsLast"===this.dataFormat){const e=n.sliceAlongAxis(t,this.cropping[0][0],t.shape[1]-this.cropping[0][0]-this.cropping[0][1],2);return n.sliceAlongAxis(e,this.cropping[1][0],t.shape[2]-this.cropping[1][1]-this.cropping[1][0],3)}{const e=n.sliceAlongAxis(t,this.cropping[0][0],t.shape[2]-this.cropping[0][0]-this.cropping[0][1],3);return n.sliceAlongAxis(e,this.cropping[1][0],t.shape[3]-this.cropping[1][1]-this.cropping[1][0],4)}})}getConfig(){const e={cropping:this.cropping,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}}exports.Cropping2D=T,T.className="Cropping2D",e.serialization.registerClass(T);class N extends o.Layer{constructor(e){super(e),this.DEFAULT_SIZE=[2,2],this.inputSpec=[{ndim:4}],this.size=null==e.size?this.DEFAULT_SIZE:e.size,this.dataFormat=null==e.dataFormat?"channelsLast":e.dataFormat,(0,s.checkDataFormat)(this.dataFormat),this.interpolation=null==e.interpolation?"nearest":e.interpolation,(0,s.checkInterpolationFormat)(this.interpolation)}computeOutputShape(e){if("channelsFirst"===this.dataFormat){const t=null==e[2]?null:this.size[0]*e[2],i=null==e[3]?null:this.size[1]*e[3];return[e[0],e[1],t,i]}{const t=null==e[1]?null:this.size[0]*e[1],i=null==e[2]?null:this.size[1]*e[2];return[e[0],t,i,e[3]]}}call(e,i){return t.tidy(()=>{let i=(0,c.getExactlyOneTensor)(e);const r=i.shape;if("channelsFirst"===this.dataFormat){i=t.transpose(i,[0,2,3,1]);const e=this.size[0]*r[2],n=this.size[1]*r[3],s="nearest"===this.interpolation?t.image.resizeNearestNeighbor(i,[e,n]):t.image.resizeBilinear(i,[e,n]);return t.transpose(s,[0,3,1,2])}{const e=this.size[0]*r[1],n=this.size[1]*r[2];return"nearest"===this.interpolation?t.image.resizeNearestNeighbor(i,[e,n]):t.image.resizeBilinear(i,[e,n])}})}getConfig(){const e={size:this.size,dataFormat:this.dataFormat,interpolation:this.interpolation},t=super.getConfig();return Object.assign(e,t),e}}exports.UpSampling2D=N,N.className="UpSampling2D",e.serialization.registerClass(N);
},{"@tensorflow/tfjs-core":"kSBl","../activations":"NY2V","../backend/common":"VOlA","../backend/tfjs_backend":"Ftmo","../common":"sR6u","../constraints":"zJV2","../engine/topology":"wHpB","../errors":"iJtr","../initializers":"Ltyq","../regularizers":"TEkX","../utils/conv_utils":"cPzX","../utils/generic_utils":"VKwv","../utils/types_utils":"mOET"}],"X56d":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.DepthwiseConv2D=void 0,exports.depthwiseConv2d=c;var e=d(require("@tensorflow/tfjs-core")),t=e,i=require("../backend/common"),r=d(require("../backend/tfjs_backend")),s=require("../common"),n=require("../constraints"),a=require("../errors"),l=require("../initializers"),h=require("../regularizers"),o=require("../utils/conv_utils"),u=require("../utils/types_utils"),p=require("./convolutional");function d(e,t){if("function"==typeof WeakMap)var i=new WeakMap,r=new WeakMap;return(d=function(e,t){if(!t&&e&&e.__esModule)return e;var s,n,a={__proto__:null,default:e};if(null===e||"object"!=typeof e&&"function"!=typeof e)return a;if(s=t?r:i){if(s.has(e))return s.get(e);s.set(e,a)}for(const i in e)"default"!==i&&{}.hasOwnProperty.call(e,i)&&((n=(s=Object.defineProperty)&&Object.getOwnPropertyDescriptor(e,i))&&(n.get||n.set)?s(a,i,n):a[i]=e[i]);return a})(e,t)}function c(r,n,l=[1,1],h="valid",o,u){return(0,e.tidy)(()=>{null==o&&(o=(0,i.imageDataFormat)()),(0,s.checkDataFormat)(o);let e=(0,p.preprocessConv2DInput)(r,o);if(4!==r.rank)throw new a.ValueError("Input for depthwiseConv2d is required to be 4-D, but is instead "+`${r.rank}-D`);if(4!==n.rank)throw new a.ValueError("depthwiseKernel is required to be 4-D, but is instead "+`${n.rank}-D`);return e=t.depthwiseConv2d(e,n,l,"same"===h?"same":"valid","NHWC",u),"channelsFirst"===o&&(e=t.transpose(e,[0,3,1,2])),e})}class w extends p.BaseConv{constructor(e){super(2,e),this.depthwiseKernel=null,this.depthMultiplier=null==e.depthMultiplier?1:e.depthMultiplier,this.depthwiseInitializer=(0,l.getInitializer)(e.depthwiseInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.depthwiseConstraint=(0,n.getConstraint)(e.depthwiseConstraint),this.depthwiseRegularizer=(0,h.getRegularizer)(e.depthwiseRegularizer)}build(e){if((e=(0,u.getExactlyOneShape)(e)).length<4)throw new a.ValueError("Inputs to DepthwiseConv2D should have rank 4. "+`Received input shape: ${JSON.stringify(e)}.`);const t="channelsFirst"===this.dataFormat?1:3;if(null==e[t]||e[t]<0)throw new a.ValueError("The channel dimension of the inputs to DepthwiseConv2D should "+`be defined, but is not (${e[t]}).`);const i=e[t],r=[this.kernelSize[0],this.kernelSize[1],i,this.depthMultiplier];this.depthwiseKernel=this.addWeight("depthwise_kernel",r,null,this.depthwiseInitializer,this.depthwiseRegularizer,!0,this.depthwiseConstraint),this.useBias?this.bias=this.addWeight("bias",[i*this.depthMultiplier],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(t,i){return(0,e.tidy)(()=>{let e=c(t=(0,u.getExactlyOneTensor)(t),this.depthwiseKernel.read(),this.strides,this.padding,this.dataFormat,null);return this.useBias&&(e=r.biasAdd(e,this.bias.read(),this.dataFormat)),null!=this.activation&&(e=this.activation.apply(e)),e})}computeOutputShape(e){e=(0,u.getExactlyOneShape)(e);const t="channelsFirst"===this.dataFormat?e[2]:e[1],i="channelsFirst"===this.dataFormat?e[3]:e[2],r="channelsFirst"===this.dataFormat?e[1]*this.depthMultiplier:e[3]*this.depthMultiplier,s=(0,o.convOutputLength)(t,this.kernelSize[0],this.padding,this.strides[0]),n=(0,o.convOutputLength)(i,this.kernelSize[1],this.padding,this.strides[1]);return"channelsFirst"===this.dataFormat?[e[0],r,s,n]:[e[0],s,n,r]}getConfig(){const e=super.getConfig();return e.depthMultiplier=this.depthMultiplier,e.depthwiseInitializer=(0,l.serializeInitializer)(this.depthwiseInitializer),e.depthwiseRegularizer=(0,h.serializeRegularizer)(this.depthwiseRegularizer),e.depthwiseConstraint=(0,n.serializeConstraint)(this.depthwiseRegularizer),e}}exports.DepthwiseConv2D=w,w.className="DepthwiseConv2D",e.serialization.registerClass(w);
},{"@tensorflow/tfjs-core":"kSBl","../backend/common":"VOlA","../backend/tfjs_backend":"Ftmo","../common":"sR6u","../constraints":"zJV2","../errors":"iJtr","../initializers":"Ltyq","../regularizers":"TEkX","../utils/conv_utils":"cPzX","../utils/types_utils":"mOET","./convolutional":"sbhA"}],"SdIK":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.StackedRNNCells=exports.SimpleRNNCell=exports.SimpleRNN=exports.RNNCell=exports.RNN=exports.LSTMCell=exports.LSTM=exports.GRUCell=exports.GRU=void 0,exports.generateDropoutMask=E,exports.rnn=R,exports.standardizeArgs=I;var t=z(require("@tensorflow/tfjs-core")),e=t,i=require("../activations"),r=z(require("../backend/tfjs_backend")),s=require("../common"),n=require("../constraints"),a=require("../engine/topology"),l=require("../errors"),u=require("../initializers"),o=require("../regularizers"),h=require("../utils/generic_utils"),c=z(require("../utils/math_utils")),p=require("../utils/types_utils"),g=require("../variables"),d=require("./serialization");function z(t,e){if("function"==typeof WeakMap)var i=new WeakMap,r=new WeakMap;return(z=function(t,e){if(!e&&t&&t.__esModule)return t;var s,n,a={__proto__:null,default:t};if(null===t||"object"!=typeof t&&"function"!=typeof t)return a;if(s=e?r:i){if(s.has(t))return s.get(t);s.set(t,a)}for(const i in t)"default"!==i&&{}.hasOwnProperty.call(t,i)&&((n=(s=Object.defineProperty)&&Object.getOwnPropertyDescriptor(t,i))&&(n.get||n.set)?s(a,i,n):a[i]=t[i]);return a})(t,e)}function I(t,e,i,r){if(Array.isArray(t)){if(null!=e||null!=i)throw new l.ValueError("When inputs is an array, neither initialState or constants should be provided");null!=r&&(i=t.slice(t.length-r,t.length),t=t.slice(0,t.length-r)),t.length>1&&(e=t.slice(1,t.length)),t=t[0]}function s(t){return null==t||Array.isArray(t)?t:[t]}return{inputs:t,initialState:e=s(e),constants:i=s(i)}}function R(t,i,r,s=!1,n,a,u=!1,o=!1){return e.tidy(()=>{const h=i.shape.length;if(h<3)throw new l.ValueError(`Input should be at least 3D, but is ${h}D.`);const p=[1,0].concat(c.range(2,h));if(i=e.transpose(i,p),null!=a)throw new l.NotImplementedError("The rnn() functoin of the deeplearn.js backend does not support constants yet.");u&&console.warn("Backend rnn(): the unroll = true option is not applicable to the imperative deeplearn.js backend."),null!=n&&((n=e.cast(e.cast(n,"bool"),"float32")).rank===h-1&&(n=e.expandDims(n,-1)),n=e.transpose(n,p)),s&&(i=e.reverse(i,0),null!=n&&(n=e.reverse(n,0)));const g=[];let d,z=r;const I=i.shape[0],R=e.unstack(i);let k,m;null!=n&&(k=e.unstack(n));for(let i=0;i<I;++i){const r=R[i],s=e.tidy(()=>t(r,z));if(null==n)d=s[0],z=s[1];else{const t=e.tidy(()=>{const t=k[i],r=e.sub(e.onesLike(t),t);return{output:e.add(e.mul(s[0],t),e.mul(z[0],r)),newStates:z.map((i,n)=>e.add(e.mul(s[1][n],t),e.mul(i,r)))}});d=t.output,z=t.newStates}o&&g.push(d)}if(o){const t=1;m=e.stack(g,t)}return[d,m,z]})}class k extends a.Layer{constructor(t){let e;if(super(t),null==t.cell)throw new l.ValueError("cell property is missing for the constructor of RNN.");if(null==(e=Array.isArray(t.cell)?new N({cells:t.cell}):t.cell).stateSize)throw new l.ValueError("The RNN cell should have an attribute `stateSize` (tuple of integers, one integer per RNN state).");this.cell=e,this.returnSequences=null!=t.returnSequences&&t.returnSequences,this.returnState=null!=t.returnState&&t.returnState,this.goBackwards=null!=t.goBackwards&&t.goBackwards,this._stateful=null!=t.stateful&&t.stateful,this.unroll=null!=t.unroll&&t.unroll,this.supportsMasking=!0,this.inputSpec=[new a.InputSpec({ndim:3})],this.stateSpec=null,this.states_=null,this.numConstants=null,this.keptStates=[]}getStates(){if(null==this.states_){const t=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1;return c.range(0,t).map(t=>null)}return this.states_}setStates(t){this.states_=t}computeOutputShape(t){(0,p.isArrayOfShapes)(t)&&(t=t[0]),t=t;let e=this.cell.stateSize;Array.isArray(e)||(e=[e]);const i=e[0];let r;if(r=this.returnSequences?[t[0],t[1],i]:[t[0],i],this.returnState){const i=[];for(const r of e)i.push([t[0],r]);return[r].concat(i)}return r}computeMask(t,i){return e.tidy(()=>{Array.isArray(i)&&(i=i[0]);const t=this.returnSequences?i:null;if(this.returnState){const e=this.states.map(t=>null);return[t].concat(e)}return t})}get states(){if(null==this.states_){const t=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1,e=[];for(let i=0;i<t;++i)e.push(null);return e}return this.states_}set states(t){this.states_=t}build(e){if(null!=this.numConstants)throw new l.NotImplementedError("Constants support is not implemented in RNN yet.");(0,p.isArrayOfShapes)(e)&&(e=e[0]),e=e;const i=this.stateful?e[0]:null,r=e.slice(2);this.inputSpec[0]=new a.InputSpec({shape:[i,null,...r]});const s=[e[0]].concat(e.slice(2));let n;if(this.cell.build(s),n=Array.isArray(this.cell.stateSize)?this.cell.stateSize:[this.cell.stateSize],null!=this.stateSpec){if(!t.util.arraysEqual(this.stateSpec.map(t=>t.shape[t.shape.length-1]),n))throw new l.ValueError("An initialState was passed that is not compatible with "+`cell.stateSize. Received stateSpec=${this.stateSpec}; `+`However cell.stateSize is ${this.cell.stateSize}`)}else this.stateSpec=n.map(t=>new a.InputSpec({shape:[null,t]}));this.stateful&&this.resetStates()}resetStates(i,r=!1){(0,t.tidy)(()=>{if(!this.stateful)throw new l.AttributeError("Cannot call resetStates() on an RNN Layer that is not stateful.");const s=this.inputSpec[0].shape[0];if(null==s)throw new l.ValueError("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");if(null==this.states_)Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(t=>e.zeros([s,t])):this.states_=[e.zeros([s,this.cell.stateSize])];else if(null==i)e.dispose(this.states_),null!=this.keptStates&&(e.dispose(this.keptStates),this.keptStates=[]),Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(t=>e.zeros([s,t])):this.states_[0]=e.zeros([s,this.cell.stateSize]);else{if(Array.isArray(i)||(i=[i]),i.length!==this.states_.length)throw new l.ValueError(`Layer ${this.name} expects ${this.states_.length} state(s), `+`but it received ${i.length} state value(s). Input `+`received: ${i}`);!0===r?this.keptStates.push(this.states_.slice()):e.dispose(this.states_);for(let e=0;e<this.states_.length;++e){const r=i[e],n=Array.isArray(this.cell.stateSize)?this.cell.stateSize[e]:this.cell.stateSize,a=[s,n];if(!t.util.arraysEqual(r.shape,a))throw new l.ValueError(`State ${e} is incompatible with layer ${this.name}: `+`expected shape=${a}, received shape=${r.shape}`);this.states_[e]=r}}this.states_=this.states_.map(t=>e.keep(t.clone()))})}apply(t,e){let i=null==e?null:e.initialState,r=null==e?null:e.constants;null==e&&(e={});const s=I(t,i,r,this.numConstants);t=s.inputs,i=s.initialState,r=s.constants;let n=[],l=[];if(null!=i){e.initialState=i,n=n.concat(i),this.stateSpec=[];for(const t of i)this.stateSpec.push(new a.InputSpec({shape:t.shape}));l=l.concat(this.stateSpec)}if(null!=r&&(e.constants=r,n=n.concat(r),this.numConstants=r.length),n[0]instanceof a.SymbolicTensor){const i=[t].concat(n),r=this.inputSpec.concat(l),s=this.inputSpec;this.inputSpec=r;const a=super.apply(i,e);return this.inputSpec=s,a}return super.apply(t,e)}call(e,i){return(0,t.tidy)(()=>{const t=null==i?null:i.mask,r=null==i?null:i.training;let s=null==i?null:i.initialState;e=(0,p.getExactlyOneTensor)(e),null==s&&(s=this.stateful?this.states_:this.getInitialState(e));const n=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1;if(s.length!==n)throw new l.ValueError(`RNN Layer has ${n} state(s) but was passed `+`${s.length} initial state(s).`);this.unroll&&console.warn("Ignoring unroll = true for RNN layer, due to imperative backend.");const a={training:r},u=R((t,e)=>{const i=this.cell.call([t].concat(e),a);return[i[0],i.slice(1)]},e,s,this.goBackwards,t,null,this.unroll,this.returnSequences),o=u[0],h=u[1],c=u[2];this.stateful&&this.resetStates(c,r);const g=this.returnSequences?h:o;return this.returnState?[g].concat(c):g})}getInitialState(i){return(0,t.tidy)(()=>{let t=e.zeros(i.shape);return t=e.sum(t,[1,2]),t=r.expandDims(t),Array.isArray(this.cell.stateSize)?this.cell.stateSize.map(e=>e>1?r.tile(t,[1,e]):t):this.cell.stateSize>1?[r.tile(t,[1,this.cell.stateSize])]:[t]})}get trainableWeights(){return this.trainable?this.cell.trainableWeights:[]}get nonTrainableWeights(){return this.trainable?this.cell.nonTrainableWeights:this.cell.weights}setFastWeightInitDuringBuild(t){super.setFastWeightInitDuringBuild(t),null!=this.cell&&this.cell.setFastWeightInitDuringBuild(t)}getConfig(){const t=super.getConfig(),e={returnSequences:this.returnSequences,returnState:this.returnState,goBackwards:this.goBackwards,stateful:this.stateful,unroll:this.unroll};null!=this.numConstants&&(e.numConstants=this.numConstants);const i=this.cell.getConfig();return this.getClassName()===k.className&&(e.cell={className:this.cell.getClassName(),config:i}),Object.assign(Object.assign(Object.assign({},i),t),e)}static fromConfig(t,e,i={}){const r=e.cell,s=(0,d.deserialize)(r,i);return new t(Object.assign(e,{cell:s}))}}exports.RNN=k,k.className="RNN",t.serialization.registerClass(k);class m extends a.Layer{}exports.RNNCell=m;class A extends m{constructor(t){super(t),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",this.units=t.units,(0,h.assertPositiveInteger)(this.units,"units"),this.activation=(0,i.getActivation)(null==t.activation?this.DEFAULT_ACTIVATION:t.activation),this.useBias=null==t.useBias||t.useBias,this.kernelInitializer=(0,u.getInitializer)(t.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=(0,u.getInitializer)(t.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=(0,u.getInitializer)(t.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelRegularizer=(0,o.getRegularizer)(t.kernelRegularizer),this.recurrentRegularizer=(0,o.getRegularizer)(t.recurrentRegularizer),this.biasRegularizer=(0,o.getRegularizer)(t.biasRegularizer),this.kernelConstraint=(0,n.getConstraint)(t.kernelConstraint),this.recurrentConstraint=(0,n.getConstraint)(t.recurrentConstraint),this.biasConstraint=(0,n.getConstraint)(t.biasConstraint),this.dropout=c.min([1,c.max([0,null==t.dropout?0:t.dropout])]),this.recurrentDropout=c.min([1,c.max([0,null==t.recurrentDropout?0:t.recurrentDropout])]),this.dropoutFunc=t.dropoutFunc,this.stateSize=this.units,this.dropoutMask=null,this.recurrentDropoutMask=null}build(t){t=(0,p.getExactlyOneShape)(t),this.kernel=this.addWeight("kernel",[t[t.length-1],this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,this.units],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias?this.bias=this.addWeight("bias",[this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(i,s){return(0,t.tidy)(()=>{if(2!==(i=i).length)throw new l.ValueError(`SimpleRNNCell expects 2 input Tensors, got ${i.length}.`);let t=i[1];i=i[0];const n=null!=s.training&&s.training;let a;0<this.dropout&&this.dropout<1&&null==this.dropoutMask&&(this.dropoutMask=E({ones:()=>e.onesLike(i),rate:this.dropout,training:n,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&null==this.recurrentDropoutMask&&(this.recurrentDropoutMask=E({ones:()=>e.onesLike(t),rate:this.recurrentDropout,training:n,dropoutFunc:this.dropoutFunc}));const u=this.dropoutMask,o=this.recurrentDropoutMask;a=null!=u?r.dot(e.mul(i,u),this.kernel.read()):r.dot(i,this.kernel.read()),null!=this.bias&&(a=r.biasAdd(a,this.bias.read())),null!=o&&(t=e.mul(t,o));let h=e.add(a,r.dot(t,this.recurrentKernel.read()));return null!=this.activation&&(h=this.activation.apply(h)),[h,h]})}getConfig(){const t=super.getConfig(),e={units:this.units,activation:(0,i.serializeActivation)(this.activation),useBias:this.useBias,kernelInitializer:(0,u.serializeInitializer)(this.kernelInitializer),recurrentInitializer:(0,u.serializeInitializer)(this.recurrentInitializer),biasInitializer:(0,u.serializeInitializer)(this.biasInitializer),kernelRegularizer:(0,o.serializeRegularizer)(this.kernelRegularizer),recurrentRegularizer:(0,o.serializeRegularizer)(this.recurrentRegularizer),biasRegularizer:(0,o.serializeRegularizer)(this.biasRegularizer),activityRegularizer:(0,o.serializeRegularizer)(this.activityRegularizer),kernelConstraint:(0,n.serializeConstraint)(this.kernelConstraint),recurrentConstraint:(0,n.serializeConstraint)(this.recurrentConstraint),biasConstraint:(0,n.serializeConstraint)(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout};return Object.assign(Object.assign({},t),e)}}exports.SimpleRNNCell=A,A.className="SimpleRNNCell",t.serialization.registerClass(A);class f extends k{constructor(t){t.cell=new A(t),super(t)}call(i,r){return(0,t.tidy)(()=>{null!=this.cell.dropoutMask&&(e.dispose(this.cell.dropoutMask),this.cell.dropoutMask=null),null!=this.cell.recurrentDropoutMask&&(e.dispose(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);const t=null==r?null:r.mask,s=null==r?null:r.training,n=null==r?null:r.initialState;return super.call(i,{mask:t,training:s,initialState:n})})}static fromConfig(t,e){return new t(e)}}exports.SimpleRNN=f,f.className="SimpleRNN",t.serialization.registerClass(f);class S extends m{constructor(t){if(super(t),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_RECURRENT_ACTIVATION="hardSigmoid",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",t.resetAfter)throw new l.ValueError("GRUCell does not support reset_after parameter set to true.");this.units=t.units,(0,h.assertPositiveInteger)(this.units,"units"),this.activation=(0,i.getActivation)(void 0===t.activation?this.DEFAULT_ACTIVATION:t.activation),this.recurrentActivation=(0,i.getActivation)(void 0===t.recurrentActivation?this.DEFAULT_RECURRENT_ACTIVATION:t.recurrentActivation),this.useBias=null==t.useBias||t.useBias,this.kernelInitializer=(0,u.getInitializer)(t.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=(0,u.getInitializer)(t.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=(0,u.getInitializer)(t.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelRegularizer=(0,o.getRegularizer)(t.kernelRegularizer),this.recurrentRegularizer=(0,o.getRegularizer)(t.recurrentRegularizer),this.biasRegularizer=(0,o.getRegularizer)(t.biasRegularizer),this.kernelConstraint=(0,n.getConstraint)(t.kernelConstraint),this.recurrentConstraint=(0,n.getConstraint)(t.recurrentConstraint),this.biasConstraint=(0,n.getConstraint)(t.biasConstraint),this.dropout=c.min([1,c.max([0,null==t.dropout?0:t.dropout])]),this.recurrentDropout=c.min([1,c.max([0,null==t.recurrentDropout?0:t.recurrentDropout])]),this.dropoutFunc=t.dropoutFunc,this.implementation=t.implementation,this.stateSize=this.units,this.dropoutMask=null,this.recurrentDropoutMask=null}build(t){const e=(t=(0,p.getExactlyOneShape)(t))[t.length-1];this.kernel=this.addWeight("kernel",[e,3*this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,3*this.units],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias?this.bias=this.addWeight("bias",[3*this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(i,s){return(0,t.tidy)(()=>{if(2!==(i=i).length)throw new l.ValueError("GRUCell expects 2 input Tensors (inputs, h, c), got "+`${i.length}.`);const t=null!=s.training&&s.training;let n=i[1];i=i[0],0<this.dropout&&this.dropout<1&&null==this.dropoutMask&&(this.dropoutMask=E({ones:()=>e.onesLike(i),rate:this.dropout,training:t,count:3,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&null==this.recurrentDropoutMask&&(this.recurrentDropoutMask=E({ones:()=>e.onesLike(n),rate:this.recurrentDropout,training:t,count:3,dropoutFunc:this.dropoutFunc}));const a=this.dropoutMask,u=this.recurrentDropoutMask;let o,h,c;0<this.dropout&&this.dropout<1&&(i=e.mul(i,a[0]));let p=r.dot(i,this.kernel.read());this.useBias&&(p=r.biasAdd(p,this.bias.read())),0<this.recurrentDropout&&this.recurrentDropout<1&&(n=e.mul(n,u[0]));const g=this.recurrentKernel.read(),[d,z]=e.split(g,[2*this.units,this.units],g.rank-1),I=r.dot(n,d),[R,k,m]=e.split(p,3,p.rank-1),[A,f]=e.split(I,2,I.rank-1);o=this.recurrentActivation.apply(e.add(R,A)),h=this.recurrentActivation.apply(e.add(k,f));const S=r.dot(e.mul(h,n),z);c=this.activation.apply(e.add(m,S));const C=e.add(e.mul(o,n),e.mul(e.add(1,e.neg(o)),c));return[C,C]})}getConfig(){const t=super.getConfig(),e={units:this.units,activation:(0,i.serializeActivation)(this.activation),recurrentActivation:(0,i.serializeActivation)(this.recurrentActivation),useBias:this.useBias,kernelInitializer:(0,u.serializeInitializer)(this.kernelInitializer),recurrentInitializer:(0,u.serializeInitializer)(this.recurrentInitializer),biasInitializer:(0,u.serializeInitializer)(this.biasInitializer),kernelRegularizer:(0,o.serializeRegularizer)(this.kernelRegularizer),recurrentRegularizer:(0,o.serializeRegularizer)(this.recurrentRegularizer),biasRegularizer:(0,o.serializeRegularizer)(this.biasRegularizer),activityRegularizer:(0,o.serializeRegularizer)(this.activityRegularizer),kernelConstraint:(0,n.serializeConstraint)(this.kernelConstraint),recurrentConstraint:(0,n.serializeConstraint)(this.recurrentConstraint),biasConstraint:(0,n.serializeConstraint)(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation,resetAfter:!1};return Object.assign(Object.assign({},t),e)}}exports.GRUCell=S,S.className="GRUCell",t.serialization.registerClass(S);class C extends k{constructor(t){0===t.implementation&&console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."),t.cell=new S(t),super(t)}call(i,r){return(0,t.tidy)(()=>{null!=this.cell.dropoutMask&&(e.dispose(this.cell.dropoutMask),this.cell.dropoutMask=null),null!=this.cell.recurrentDropoutMask&&(e.dispose(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);const t=null==r?null:r.mask,s=null==r?null:r.training,n=null==r?null:r.initialState;return super.call(i,{mask:t,training:s,initialState:n})})}static fromConfig(t,e){return 0===e.implmentation&&(e.implementation=1),new t(e)}}exports.GRU=C,C.className="GRU",t.serialization.registerClass(C);class b extends m{constructor(t){super(t),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_RECURRENT_ACTIVATION="hardSigmoid",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",this.units=t.units,(0,h.assertPositiveInteger)(this.units,"units"),this.activation=(0,i.getActivation)(void 0===t.activation?this.DEFAULT_ACTIVATION:t.activation),this.recurrentActivation=(0,i.getActivation)(void 0===t.recurrentActivation?this.DEFAULT_RECURRENT_ACTIVATION:t.recurrentActivation),this.useBias=null==t.useBias||t.useBias,this.kernelInitializer=(0,u.getInitializer)(t.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=(0,u.getInitializer)(t.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=(0,u.getInitializer)(t.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.unitForgetBias=t.unitForgetBias,this.kernelRegularizer=(0,o.getRegularizer)(t.kernelRegularizer),this.recurrentRegularizer=(0,o.getRegularizer)(t.recurrentRegularizer),this.biasRegularizer=(0,o.getRegularizer)(t.biasRegularizer),this.kernelConstraint=(0,n.getConstraint)(t.kernelConstraint),this.recurrentConstraint=(0,n.getConstraint)(t.recurrentConstraint),this.biasConstraint=(0,n.getConstraint)(t.biasConstraint),this.dropout=c.min([1,c.max([0,null==t.dropout?0:t.dropout])]),this.recurrentDropout=c.min([1,c.max([0,null==t.recurrentDropout?0:t.recurrentDropout])]),this.dropoutFunc=t.dropoutFunc,this.implementation=t.implementation,this.stateSize=[this.units,this.units],this.dropoutMask=null,this.recurrentDropoutMask=null}build(t){var e;const i=(t=(0,p.getExactlyOneShape)(t))[t.length-1];let s;if(this.kernel=this.addWeight("kernel",[i,4*this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,4*this.units],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias){if(this.unitForgetBias){const t=this.biasInitializer,i=this.units;s=new((e=class extends u.Initializer{apply(e,s){const n=t.apply([i]),a=(new u.Ones).apply([i]),l=t.apply([2*i]);return r.concatAlongFirstAxis(r.concatAlongFirstAxis(n,a),l)}}).className="CustomInit",e)}else s=this.biasInitializer;this.bias=this.addWeight("bias",[4*this.units],null,s,this.biasRegularizer,!0,this.biasConstraint)}else this.bias=null;this.built=!0}call(i,s){return(0,t.tidy)(()=>{const t=null!=s.training&&s.training;if(3!==(i=i).length)throw new l.ValueError("LSTMCell expects 3 input Tensors (inputs, h, c), got "+`${i.length}.`);let n=i[1];const a=i[2];i=i[0],0<this.dropout&&this.dropout<1&&null==this.dropoutMask&&(this.dropoutMask=E({ones:()=>e.onesLike(i),rate:this.dropout,training:t,count:4,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&null==this.recurrentDropoutMask&&(this.recurrentDropoutMask=E({ones:()=>e.onesLike(n),rate:this.recurrentDropout,training:t,count:4,dropoutFunc:this.dropoutFunc}));const u=this.dropoutMask,o=this.recurrentDropoutMask;let h,c,p,g;0<this.dropout&&this.dropout<1&&(i=e.mul(i,u[0]));let d=r.dot(i,this.kernel.read());0<this.recurrentDropout&&this.recurrentDropout<1&&(n=e.mul(n,o[0])),d=e.add(d,r.dot(n,this.recurrentKernel.read())),this.useBias&&(d=r.biasAdd(d,this.bias.read()));const[z,I,R,k]=e.split(d,4,d.rank-1);h=this.recurrentActivation.apply(z),c=this.recurrentActivation.apply(I),p=e.add(e.mul(c,a),e.mul(h,this.activation.apply(R))),g=this.recurrentActivation.apply(k);const m=e.mul(g,this.activation.apply(p));return[m,m,p]})}getConfig(){const t=super.getConfig(),e={units:this.units,activation:(0,i.serializeActivation)(this.activation),recurrentActivation:(0,i.serializeActivation)(this.recurrentActivation),useBias:this.useBias,kernelInitializer:(0,u.serializeInitializer)(this.kernelInitializer),recurrentInitializer:(0,u.serializeInitializer)(this.recurrentInitializer),biasInitializer:(0,u.serializeInitializer)(this.biasInitializer),unitForgetBias:this.unitForgetBias,kernelRegularizer:(0,o.serializeRegularizer)(this.kernelRegularizer),recurrentRegularizer:(0,o.serializeRegularizer)(this.recurrentRegularizer),biasRegularizer:(0,o.serializeRegularizer)(this.biasRegularizer),activityRegularizer:(0,o.serializeRegularizer)(this.activityRegularizer),kernelConstraint:(0,n.serializeConstraint)(this.kernelConstraint),recurrentConstraint:(0,n.serializeConstraint)(this.recurrentConstraint),biasConstraint:(0,n.serializeConstraint)(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation};return Object.assign(Object.assign({},t),e)}}exports.LSTMCell=b,b.className="LSTMCell",t.serialization.registerClass(b);class y extends k{constructor(t){0===t.implementation&&console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."),t.cell=new b(t),super(t)}call(i,r){return(0,t.tidy)(()=>{null!=this.cell.dropoutMask&&(e.dispose(this.cell.dropoutMask),this.cell.dropoutMask=null),null!=this.cell.recurrentDropoutMask&&(e.dispose(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);const t=null==r?null:r.mask,s=null==r?null:r.training,n=null==r?null:r.initialState;return super.call(i,{mask:t,training:s,initialState:n})})}static fromConfig(t,e){return 0===e.implmentation&&(e.implementation=1),new t(e)}}exports.LSTM=y,y.className="LSTM",t.serialization.registerClass(y);class N extends m{constructor(t){super(t),this.cells=t.cells}get stateSize(){const t=[];for(const e of this.cells.slice().reverse())Array.isArray(e.stateSize)?t.push(...e.stateSize):t.push(e.stateSize);return t}call(e,i){return(0,t.tidy)(()=>{let t=(e=e).slice(1);const r=[];for(const e of this.cells.slice().reverse())Array.isArray(e.stateSize)?r.push(t.splice(0,e.stateSize.length)):r.push(t.splice(0,1));r.reverse();const s=[];let n;for(let a=0;a<this.cells.length;++a){const l=this.cells[a];t=r[a],n=0===a?[e[0]].concat(t):[n[0]].concat(t),n=l.call(n,i),s.push(n.slice(1))}t=[];for(const e of s.slice().reverse())t.push(...e);return[n[0]].concat(t)})}build(t){let e;(0,p.isArrayOfShapes)(t)&&(t=t[0]),t=t,this.cells.forEach((i,r)=>{(0,s.nameScope)(`RNNCell_${r}`,()=>{i.build(t),e=Array.isArray(i.stateSize)?i.stateSize[0]:i.stateSize,t=[t[0],e]})}),this.built=!0}getConfig(){const t=super.getConfig(),e={cells:this.cells.map(t=>({className:t.getClassName(),config:t.getConfig()}))};return Object.assign(Object.assign({},t),e)}static fromConfig(t,e,i={}){const r=[];for(const s of e.cells)r.push((0,d.deserialize)(s,i));return new t({cells:r})}get trainableWeights(){if(!this.trainable)return[];const t=[];for(const e of this.cells)t.push(...e.trainableWeights);return t}get nonTrainableWeights(){const t=[];for(const e of this.cells)t.push(...e.nonTrainableWeights);if(!this.trainable){const e=[];for(const t of this.cells)e.push(...t.trainableWeights);return e.concat(t)}return t}getWeights(){const t=[];for(const e of this.cells)t.push(...e.weights);return(0,g.batchGetValue)(t)}setWeights(t){const e=[];for(const i of this.cells){const r=i.weights.length,s=t.splice(r);for(let t=0;t<i.weights.length;++t)e.push([i.weights[t],s[t]])}(0,g.batchSetValue)(e)}}function E(t){const{ones:i,rate:s,training:n=!1,count:a=1,dropoutFunc:l}=t,u=()=>null!=l?l(i(),s):r.dropout(i(),s),o=()=>r.inTrainPhase(u,i,n);return!a||a<=1?e.keep(o().clone()):Array(a).fill(void 0).map(o).map(t=>e.keep(t.clone()))}exports.StackedRNNCells=N,N.className="StackedRNNCells",t.serialization.registerClass(N);
},{"@tensorflow/tfjs-core":"kSBl","../activations":"NY2V","../backend/tfjs_backend":"Ftmo","../common":"sR6u","../constraints":"zJV2","../engine/topology":"wHpB","../errors":"iJtr","../initializers":"Ltyq","../regularizers":"TEkX","../utils/generic_utils":"VKwv","../utils/math_utils":"eQAy","../utils/types_utils":"mOET","../variables":"mwlr","./serialization":"bKFn"}],"lmh8":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.ConvLSTM2DCell=exports.ConvLSTM2D=void 0;var t=c(require("@tensorflow/tfjs-core")),e=t,s=c(require("../backend/tfjs_backend")),i=require("../common"),r=require("../engine/topology"),n=require("../errors"),a=require("../initializers"),l=require("../utils/conv_utils"),o=require("../utils/generic_utils"),u=require("../utils/types_utils"),h=require("./recurrent");function c(t,e){if("function"==typeof WeakMap)var s=new WeakMap,i=new WeakMap;return(c=function(t,e){if(!e&&t&&t.__esModule)return t;var r,n,a={__proto__:null,default:t};if(null===t||"object"!=typeof t&&"function"!=typeof t)return a;if(r=e?i:s){if(r.has(t))return r.get(t);r.set(t,a)}for(const s in t)"default"!==s&&{}.hasOwnProperty.call(t,s)&&((n=(r=Object.defineProperty)&&Object.getOwnPropertyDescriptor(t,s))&&(n.get||n.set)?r(a,s,n):a[s]=t[s]);return a})(t,e)}var p=function(t,e){var s={};for(var i in t)Object.prototype.hasOwnProperty.call(t,i)&&e.indexOf(i)<0&&(s[i]=t[i]);if(null!=t&&"function"==typeof Object.getOwnPropertySymbols){var r=0;for(i=Object.getOwnPropertySymbols(t);r<i.length;r++)e.indexOf(i[r])<0&&Object.prototype.propertyIsEnumerable.call(t,i[r])&&(s[i[r]]=t[i[r]])}return s};class d extends h.RNNCell{}class f extends h.RNN{constructor(t){if(t.unroll)throw new n.NotImplementedError("Unrolling is not possible with convolutional RNNs.");if(Array.isArray(t.cell))throw new n.NotImplementedError("It is not possible at the moment to stack convolutional cells.");super(t),this.inputSpec=[new r.InputSpec({ndim:5})]}call(t,s){return e.tidy(()=>{if(null!=this.cell.dropoutMask&&(e.dispose(this.cell.dropoutMask),this.cell.dropoutMask=null),null!=this.cell.recurrentDropoutMask&&(e.dispose(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null),s&&s.constants)throw new n.ValueError("ConvRNN2D cell does not support constants");const i=null==s?null:s.mask,r=null==s?null:s.training,a=null==s?null:s.initialState;return super.call(t,{mask:i,training:r,initialState:a})})}computeOutputShape(t){let e=this.computeSingleOutputShape(t);return this.returnSequences||(e=[e[0],...e.slice(2)]),this.returnState&&(e=[e,...Array(2).fill([t[0],...e.slice(-3)])]),e}getInitialState(t){return e.tidy(()=>{const{stateSize:s}=this.cell,i=t.shape,r=this.computeSingleOutputShape(i),n=[r[0],...r.slice(2)],a=e.zeros(n);return Array.isArray(s)?Array(s.length).fill(a):[a]})}resetStates(s,i=!1){e.tidy(()=>{if(!this.stateful)throw new n.AttributeError("Cannot call resetStates() on an RNN Layer that is not stateful.");const r=this.inputSpec[0].shape,a=this.computeSingleOutputShape(r),l=[a[0],...a.slice(2)];if(null==r[0])throw new n.ValueError("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");if(null==this.getStates())Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(()=>e.zeros(l)):this.states_=[e.zeros(l)];else if(null==s)e.dispose(this.states_),null!=this.keptStates&&(e.dispose(this.keptStates),this.keptStates=[]),Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(()=>e.zeros(l)):this.states_[0]=e.zeros(l);else{if(Array.isArray(s)||(s=[s]),s.length!==this.states_.length)throw new n.ValueError(`Layer ${this.name} expects ${this.states_.length} state(s), `+`but it received ${s.length} state value(s). Input `+`received: ${s}`);i?this.keptStates.push(this.states_.slice()):e.dispose(this.states_);for(let e=0;e<this.states_.length;++e){const i=s[e],r=l;if(!t.util.arraysEqual(i.shape,r))throw new n.ValueError(`State ${e} is incompatible with layer ${this.name}: `+`expected shape=${r}, received shape=${i.shape}`);this.states_[e]=i}}this.states_=this.states_.map(t=>e.keep(t.clone()))})}computeSingleOutputShape(t){const{dataFormat:e,filters:s,kernelSize:i,padding:r,strides:n,dilationRate:a}=this.cell,o="channelsFirst"===e,u=t[o?3:2],h=t[o?4:3],c=(0,l.convOutputLength)(u,i[0],r,n[0],a[0]),p=(0,l.convOutputLength)(h,i[1],r,n[1],a[1]);return[...t.slice(0,2),...o?[s,c,p]:[c,p,s]]}}f.className="ConvRNN2D";class g extends h.LSTMCell{constructor(t){const{filters:e,kernelSize:s,strides:r,padding:n,dataFormat:a,dilationRate:u}=t;super(Object.assign(Object.assign({},t),{units:e})),this.filters=e,(0,o.assertPositiveInteger)(this.filters,"filters"),this.kernelSize=(0,l.normalizeArray)(s,2,"kernelSize"),this.kernelSize.forEach(t=>(0,o.assertPositiveInteger)(t,"kernelSize")),this.strides=(0,l.normalizeArray)(r||1,2,"strides"),this.strides.forEach(t=>(0,o.assertPositiveInteger)(t,"strides")),this.padding=n||"valid",(0,i.checkPaddingMode)(this.padding),this.dataFormat=a||"channelsLast",(0,i.checkDataFormat)(this.dataFormat),this.dilationRate=(0,l.normalizeArray)(u||1,2,"dilationRate"),this.dilationRate.forEach(t=>(0,o.assertPositiveInteger)(t,"dilationRate"))}build(t){var i;t=(0,u.getExactlyOneShape)(t);const r="channelsFirst"===this.dataFormat?1:t.length-1;if(null==t[r])throw new n.ValueError("The channel dimension of the input should be defined. "+`Found ${t[r]}`);const l=t[r],o=this.kernelSize.concat([l,4*this.filters]);this.kernel=this.addWeight("kernel",o,null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint);const h=this.kernelSize.concat([this.filters,4*this.filters]);if(this.recurrentKernel=this.addWeight("recurrent_kernel",h,null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias){let t;if(this.unitForgetBias){const r=this.biasInitializer,n=this.filters;t=new((i=class extends a.Initializer{apply(t,i){const a=r.apply([n]),l=e.ones([n]),o=r.apply([2*n]);return s.concatenate([a,l,o])}}).className="CustomInit",i)}else t=this.biasInitializer;this.bias=this.addWeight("bias",[4*this.filters],null,t,this.biasRegularizer,!0,this.biasConstraint)}this.built=!0}call(t,s){return e.tidy(()=>{if(3!==t.length)throw new n.ValueError("ConvLSTM2DCell expects 3 input Tensors (inputs, h, c), got "+`${t.length}.`);const i=s.training||!1,r=t[0],a=t[1],l=t[2];0<this.dropout&&this.dropout<1&&null==this.dropoutMask&&(this.dropoutMask=(0,h.generateDropoutMask)({ones:()=>e.onesLike(r),rate:this.dropout,training:i,count:4,dropoutFunc:this.dropoutFunc}));const o=this.dropoutMask,u=(t,s,i)=>s&&s[i]?e.mul(s[i],t):t;let c=u(r,o,0),p=u(r,o,1),d=u(r,o,2),f=u(r,o,3);0<this.recurrentDropout&&this.recurrentDropout<1&&null==this.recurrentDropoutMask&&(this.recurrentDropoutMask=(0,h.generateDropoutMask)({ones:()=>e.onesLike(a),rate:this.recurrentDropout,training:i,count:4,dropoutFunc:this.dropoutFunc}));const g=this.recurrentDropoutMask;let y=u(a,g,0),S=u(a,g,1),m=u(a,g,2),v=u(a,g,3);const[k,b,C,z]=e.split(this.kernel.read(),4,3),[w,M,O,_]=this.useBias?e.split(this.bias.read(),4):[null,null,null,null];c=this.inputConv(c,k,w,this.padding),p=this.inputConv(p,b,M,this.padding),d=this.inputConv(d,C,O,this.padding),f=this.inputConv(f,z,_,this.padding);const[N,I,D,A]=e.split(this.recurrentKernel.read(),4,3);y=this.recurrentConv(y,N),S=this.recurrentConv(S,I),m=this.recurrentConv(m,D),v=this.recurrentConv(v,A);const F=this.recurrentActivation.apply(e.add(c,y)),R=this.recurrentActivation.apply(e.add(p,S)),j=e.add(e.mul(R,l),e.mul(F,this.activation.apply(e.add(d,m)))),x=e.mul(this.recurrentActivation.apply(e.add(f,v)),this.activation.apply(j));return[x,x,j]})}getConfig(){const t=super.getConfig(),{units:e}=t,s=p(t,["units"]),i={filters:this.filters,kernelSize:this.kernelSize,padding:this.padding,dataFormat:this.dataFormat,dilationRate:this.dilationRate,strides:this.strides};return Object.assign(Object.assign({},s),i)}inputConv(t,i,r,n){const a=e.conv2d(t,i,this.strides,n||"valid","channelsFirst"===this.dataFormat?"NCHW":"NHWC",this.dilationRate);return r?s.biasAdd(a,r,this.dataFormat):a}recurrentConv(t,s){return e.conv2d(t,s,1,"same","channelsFirst"===this.dataFormat?"NCHW":"NHWC")}}exports.ConvLSTM2DCell=g,g.className="ConvLSTM2DCell",e.serialization.registerClass(g);class y extends f{constructor(t){const e=new g(t);super(Object.assign(Object.assign({},t),{cell:e}))}static fromConfig(t,e){return new t(e)}}exports.ConvLSTM2D=y,y.className="ConvLSTM2D",e.serialization.registerClass(y);
},{"@tensorflow/tfjs-core":"kSBl","../backend/tfjs_backend":"Ftmo","../common":"sR6u","../engine/topology":"wHpB","../errors":"iJtr","../initializers":"Ltyq","../utils/conv_utils":"cPzX","../utils/generic_utils":"VKwv","../utils/types_utils":"mOET","./recurrent":"SdIK"}],"xEXF":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.SpatialDropout1D=exports.Reshape=exports.RepeatVector=exports.Permute=exports.Masking=exports.Flatten=exports.Dropout=exports.Dense=exports.Activation=void 0;var t=require("@tensorflow/tfjs-core"),e=require("../activations"),i=c(require("../backend/tfjs_backend")),s=require("../constraints"),r=require("../engine/topology"),n=require("../errors"),a=require("../initializers"),o=require("../regularizers"),l=require("../utils/generic_utils"),u=require("../utils/math_utils"),h=require("../utils/types_utils");function c(t,e){if("function"==typeof WeakMap)var i=new WeakMap,s=new WeakMap;return(c=function(t,e){if(!e&&t&&t.__esModule)return t;var r,n,a={__proto__:null,default:t};if(null===t||"object"!=typeof t&&"function"!=typeof t)return a;if(r=e?s:i){if(r.has(t))return r.get(t);r.set(t,a)}for(const i in t)"default"!==i&&{}.hasOwnProperty.call(t,i)&&((n=(r=Object.defineProperty)&&Object.getOwnPropertyDescriptor(t,i))&&(n.get||n.set)?r(a,i,n):a[i]=t[i]);return a})(t,e)}class p extends r.Layer{constructor(t){super(t),this.rate=Math.max(Math.min(t.rate,1),0),this.noiseShape=t.noiseShape,this.seed=t.seed,this.supportsMasking=!0}getNoiseShape(t){if(null==this.noiseShape)return this.noiseShape;const e=t.shape,i=[];for(let s=0;s<this.noiseShape.length;++s)i.push(null==this.noiseShape[s]?e[s]:this.noiseShape[s]);return i}call(e,s){return(0,t.tidy)(()=>{this.invokeCallHook(e,s);const t=(0,h.getExactlyOneTensor)(e);if(0<this.rate&&this.rate<1){const e=null!=s.training&&s.training,r=this.getNoiseShape(t);return i.inTrainPhase(()=>i.dropout(t,this.rate,r,this.seed),()=>t,e)}return e})}getConfig(){const t={rate:this.rate,noiseShape:this.noiseShape,seed:this.seed},e=super.getConfig();return Object.assign(t,e),t}dispose(){return super.dispose()}}exports.Dropout=p,p.className="Dropout",t.serialization.registerClass(p);class g extends p{constructor(t){super(t),this.inputSpec=[{ndim:3}]}getNoiseShape(t){const e=t.shape;return[e[0],1,e[2]]}}exports.SpatialDropout1D=g,g.className="SpatialDropout1D",t.serialization.registerClass(g);class d extends r.Layer{constructor(t){if(super(t),this.activation=null,this.useBias=!0,this.kernel=null,this.bias=null,this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_BIAS_INITIALIZER="zeros",null==t.batchInputShape&&null==t.inputShape&&null!=t.inputDim){let e=null;null!=t.batchSize&&(e=t.batchSize),this.batchInputShape=[e,t.inputDim]}this.units=t.units,(0,l.assertPositiveInteger)(this.units,"units"),this.activation=(0,e.getActivation)(t.activation),null!=t.useBias&&(this.useBias=t.useBias),this.kernelInitializer=(0,a.getInitializer)(t.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.biasInitializer=(0,a.getInitializer)(t.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelConstraint=(0,s.getConstraint)(t.kernelConstraint),this.biasConstraint=(0,s.getConstraint)(t.biasConstraint),this.kernelRegularizer=(0,o.getRegularizer)(t.kernelRegularizer),this.biasRegularizer=(0,o.getRegularizer)(t.biasRegularizer),this.activityRegularizer=(0,o.getRegularizer)(t.activityRegularizer),this.supportsMasking=!0,this.inputSpec=[{minNDim:2}]}build(t){const e=(t=(0,h.getExactlyOneShape)(t))[t.length-1];null==this.kernel&&(this.kernel=this.addWeight("kernel",[e,this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint))),this.inputSpec=[{minNDim:2,axes:{[-1]:e}}],this.built=!0}computeOutputShape(t){const e=(t=(0,h.getExactlyOneShape)(t)).slice();return e[e.length-1]=this.units,e}call(e,s){return(0,t.tidy)(()=>{this.invokeCallHook(e,s);const t=(0,h.getExactlyOneTensor)(e),r=(0,l.mapActivationToFusedKernel)(this.activation.getClassName());let n;return null!=r?n=i.dot(t,this.kernel.read(),r,this.bias?this.bias.read():null):(n=i.dot(t,this.kernel.read()),null!=this.bias&&(n=i.biasAdd(n,this.bias.read())),null!=this.activation&&(n=this.activation.apply(n))),n})}getConfig(){const t={units:this.units,activation:(0,e.serializeActivation)(this.activation),useBias:this.useBias,kernelInitializer:(0,a.serializeInitializer)(this.kernelInitializer),biasInitializer:(0,a.serializeInitializer)(this.biasInitializer),kernelRegularizer:(0,o.serializeRegularizer)(this.kernelRegularizer),biasRegularizer:(0,o.serializeRegularizer)(this.biasRegularizer),activityRegularizer:(0,o.serializeRegularizer)(this.activityRegularizer),kernelConstraint:(0,s.serializeConstraint)(this.kernelConstraint),biasConstraint:(0,s.serializeConstraint)(this.biasConstraint)},i=super.getConfig();return Object.assign(t,i),t}}exports.Dense=d,d.className="Dense",t.serialization.registerClass(d);class m extends r.Layer{constructor(t){super(t=t||{}),this.inputSpec=[{minNDim:3}],this.dataFormat=t.dataFormat}computeOutputShape(t){t=(0,h.getExactlyOneShape)(t);for(const e of t.slice(1))if(null==e)throw new n.ValueError('The shape of the input to "Flatten" is not fully defined '+`(got ${t.slice(1)}). Make sure to pass a complete `+'"input_shape" or "batch_input_shape" argument to the first layer in your model.');return[t[0],(0,u.arrayProd)(t,1)]}call(e,s){return(0,t.tidy)(()=>{this.invokeCallHook(e,s);let r=(0,h.getExactlyOneTensor)(e);if("channelsFirst"===this.dataFormat&&r.rank>1){const e=[0];for(let t=2;t<r.rank;++t)e.push(t);e.push(1),r=(0,t.transpose)(r,e)}return i.batchFlatten(r)})}getConfig(){const t={};null!=this.dataFormat&&(t.dataFormat=this.dataFormat);const e=super.getConfig();return Object.assign(t,e),t}}exports.Flatten=m,m.className="Flatten",t.serialization.registerClass(m);class f extends r.Layer{constructor(t){super(t),this.supportsMasking=!0,this.activation=(0,e.getActivation)(t.activation)}call(e,i){return(0,t.tidy)(()=>{this.invokeCallHook(e,i);const t=(0,h.getExactlyOneTensor)(e);return this.activation.apply(t)})}getConfig(){const t={activation:(0,e.serializeActivation)(this.activation)},i=super.getConfig();return Object.assign(t,i),t}}exports.Activation=f,f.className="Activation",t.serialization.registerClass(f);class k extends r.Layer{constructor(t){super(t),this.n=t.n,this.inputSpec=[{ndim:2}]}computeOutputShape(t){return[t[0],this.n,t[1]]}call(e,s){return(0,t.tidy)(()=>(e=(0,h.getExactlyOneTensor)(e),i.repeat(e,this.n)))}getConfig(){const t={n:this.n},e=super.getConfig();return Object.assign(t,e),t}}exports.RepeatVector=k,k.className="RepeatVector",t.serialization.registerClass(k);class y extends r.Layer{constructor(t){super(t),this.targetShape=t.targetShape;for(let e=0;e<this.targetShape.length;++e)this.isUnknown(this.targetShape[e])&&(this.targetShape[e]=null)}isUnknown(t){return t<0||null==t}fixUnknownDimension(t,e){const i="Total size of new array must be unchanged.",s=e.slice();let r=1,a=null;for(let l=0;l<s.length;++l){const t=s[l];if(this.isUnknown(t)){if(null!==a)throw new n.ValueError("Can only specifiy one unknown dimension.");a=l}else r*=t}const o=(0,u.arrayProd)(t);if(null!==a){if(0===r||o%r!=0)throw new n.ValueError(i);s[a]=o/r}else if(o!==r)throw new n.ValueError(i);return s}computeOutputShape(t){let e=!1;for(let i=0;i<t.length;++i)if(this.isUnknown(t[i])){e=!0;break}return e?t.slice(0,1).concat(this.targetShape):t.slice(0,1).concat(this.fixUnknownDimension(t.slice(1),this.targetShape))}call(e,i){return(0,t.tidy)(()=>{this.invokeCallHook(e,i);const s=(0,h.getExactlyOneTensor)(e),r=s.shape,n=r.slice(0,1).concat(this.fixUnknownDimension(r.slice(1),this.targetShape));return(0,t.reshape)(s,n)})}getConfig(){const t={targetShape:this.targetShape},e=super.getConfig();return Object.assign(t,e),t}}exports.Reshape=y,y.className="Reshape",t.serialization.registerClass(y);class z extends r.Layer{constructor(e){if(super(e),null==e.dims)throw new Error("Required configuration field `dims` is missing during Permute constructor call.");if(!Array.isArray(e.dims))throw new Error("Permute constructor requires `dims` to be an Array, but received "+`${e.dims} instead.`);const i=(0,u.range)(1,e.dims.length+1);if(!t.util.arraysEqual(e.dims.slice().sort(),i))throw new Error("Invalid permutation `dims`: "+JSON.stringify(e.dims)+" `dims` must contain consecutive integers starting from 1.");this.dims=e.dims,this.dimsIncludingBatch=[0].concat(this.dims),this.inputSpec=[new r.InputSpec({ndim:this.dims.length+1})]}computeOutputShape(t){const e=(t=(0,h.getExactlyOneShape)(t)).slice();return this.dims.forEach((i,s)=>{e[s+1]=t[i]}),e}call(e,i){return(0,t.transpose)((0,h.getExactlyOneTensor)(e),this.dimsIncludingBatch)}getConfig(){const t={dims:this.dims},e=super.getConfig();return Object.assign(t,e),t}}exports.Permute=z,z.className="Permute",t.serialization.registerClass(z);class S extends r.Layer{constructor(t){super(null==t?{}:t),this.supportsMasking=!0,this.maskValue=null!=t?null==t.maskValue?0:t.maskValue:0}computeOutputShape(t){return t}getConfig(){const t=super.getConfig(),e={maskValue:this.maskValue};return Object.assign(e,t),e}computeMask(e,i){const s=(0,h.getExactlyOneTensor)(e);return(0,t.any)((0,t.notEqual)(s,this.maskValue),-1)}call(e,i){return(0,t.tidy)(()=>{this.invokeCallHook(e,i);const s=(0,h.getExactlyOneTensor)(e),r=(0,t.any)((0,t.notEqual)(s,this.maskValue),-1,!0);return(0,t.mul)(s,(0,t.cast)(r,s.dtype))})}}exports.Masking=S,S.className="Masking",t.serialization.registerClass(S);
},{"@tensorflow/tfjs-core":"kSBl","../activations":"NY2V","../backend/tfjs_backend":"Ftmo","../constraints":"zJV2","../engine/topology":"wHpB","../errors":"iJtr","../initializers":"Ltyq","../regularizers":"TEkX","../utils/generic_utils":"VKwv","../utils/math_utils":"eQAy","../utils/types_utils":"mOET"}],"Utk7":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.Embedding=void 0;var e=require("@tensorflow/tfjs-core"),t=h(require("../backend/tfjs_backend")),i=require("../constraints"),n=require("../engine/topology"),r=require("../errors"),s=require("../initializers"),u=require("../regularizers"),a=h(require("../utils/generic_utils")),l=require("../utils/types_utils");function h(e,t){if("function"==typeof WeakMap)var i=new WeakMap,n=new WeakMap;return(h=function(e,t){if(!t&&e&&e.__esModule)return e;var r,s,u={__proto__:null,default:e};if(null===e||"object"!=typeof e&&"function"!=typeof e)return u;if(r=t?n:i){if(r.has(e))return r.get(e);r.set(e,u)}for(const i in e)"default"!==i&&{}.hasOwnProperty.call(e,i)&&((s=(r=Object.defineProperty)&&Object.getOwnPropertyDescriptor(e,i))&&(s.get||s.set)?r(u,i,s):u[i]=e[i]);return u})(e,t)}class o extends n.Layer{constructor(e){if(super(e),this.embeddings=null,this.DEFAULT_EMBEDDINGS_INITIALIZER="randomUniform",null==e.batchInputShape&&null==e.inputShape){let t=null;null!=e.batchSize&&(t=e.batchSize),null==e.inputLength?this.batchInputShape=[t,null]:this.batchInputShape=[t].concat(a.toList(e.inputLength))}this.inputDim=e.inputDim,a.assertPositiveInteger(this.inputDim,"inputDim"),this.outputDim=e.outputDim,a.assertPositiveInteger(this.outputDim,"outputDim"),this.embeddingsInitializer=(0,s.getInitializer)(e.embeddingsInitializer||this.DEFAULT_EMBEDDINGS_INITIALIZER),this.embeddingsRegularizer=(0,u.getRegularizer)(e.embeddingsRegularizer),this.activityRegularizer=(0,u.getRegularizer)(e.activityRegularizer),this.embeddingsConstraint=(0,i.getConstraint)(e.embeddingsConstraint),this.maskZero=e.maskZero,this.supportsMasking=e.maskZero,this.inputLength=e.inputLength}build(e){this.embeddings=this.addWeight("embeddings",[this.inputDim,this.outputDim],this.dtype,this.embeddingsInitializer,this.embeddingsRegularizer,!0,this.embeddingsConstraint),this.built=!0}warnOnIncompatibleInputShape(e){}computeMask(t,i){return(0,e.tidy)(()=>this.maskZero?(t=(0,l.getExactlyOneTensor)(t),(0,e.notEqual)(t,(0,e.zerosLike)(t))):null)}computeOutputShape(e){if(e=(0,l.getExactlyOneShape)(e),null==this.inputLength)return[...e,this.outputDim];const t=a.toList(this.inputLength);if(t.length!==e.length-1)throw new r.ValueError(`"inputLength" is ${this.inputLength}, but received `+`input shape has shape ${e}`);{let i=0;for(let n=0;n<t.length;++n){const s=t[n],u=e[n+1];if(null!=s&&null!=u&&s!==u)throw new r.ValueError(`"inputLength" is ${this.inputLength}, but received `+`input shape has shape ${e}`);null==s&&(t[i]=u),i++}}return[e[0],...t,this.outputDim]}call(i,n){return(0,e.tidy)(()=>{this.invokeCallHook(i,n);let r=(0,l.getExactlyOneTensor)(i);"int32"!==r.dtype&&(r=t.cast(r,"int32"));const s=t.gather(this.embeddings.read(),(0,e.reshape)(r,[r.size]));return(0,e.reshape)(s,(0,l.getExactlyOneShape)(this.computeOutputShape(r.shape)))})}getConfig(){const e={inputDim:this.inputDim,outputDim:this.outputDim,embeddingsInitializer:(0,s.serializeInitializer)(this.embeddingsInitializer),embeddingsRegularizer:(0,u.serializeRegularizer)(this.embeddingsRegularizer),activityRegularizer:(0,u.serializeRegularizer)(this.activityRegularizer),embeddingsConstraint:(0,i.serializeConstraint)(this.embeddingsConstraint),maskZero:this.maskZero,inputLength:this.inputLength},t=super.getConfig();return Object.assign(e,t),e}}exports.Embedding=o,o.className="Embedding",e.serialization.registerClass(o);
},{"@tensorflow/tfjs-core":"kSBl","../backend/tfjs_backend":"Ftmo","../constraints":"zJV2","../engine/topology":"wHpB","../errors":"iJtr","../initializers":"Ltyq","../regularizers":"TEkX","../utils/generic_utils":"VKwv","../utils/types_utils":"mOET"}],"Ghc9":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.Multiply=exports.Minimum=exports.Merge=exports.Maximum=exports.Dot=exports.Concatenate=exports.Average=exports.Add=void 0,exports.add=c,exports.average=m,exports.concatenate=k,exports.maximum=x,exports.minimum=w,exports.multiply=g;var e=u(require("@tensorflow/tfjs-core")),t=e,r=u(require("../backend/tfjs_backend")),n=require("../engine/topology"),s=require("../errors"),l=require("../losses"),a=u(require("../utils/generic_utils")),i=u(require("../utils/math_utils")),o=require("../utils/types_utils");function u(e,t){if("function"==typeof WeakMap)var r=new WeakMap,n=new WeakMap;return(u=function(e,t){if(!t&&e&&e.__esModule)return e;var s,l,a={__proto__:null,default:e};if(null===e||"object"!=typeof e&&"function"!=typeof e)return a;if(s=t?n:r){if(s.has(e))return s.get(e);s.set(e,a)}for(const r in e)"default"!==r&&{}.hasOwnProperty.call(e,r)&&((l=(s=Object.defineProperty)&&Object.getOwnPropertyDescriptor(e,r))&&(l.get||l.set)?s(a,r,l):a[r]=e[r]);return a})(e,t)}class h extends n.Layer{constructor(e){super(e||{}),this.supportsMasking=!0}mergeFunction(e){throw new s.NotImplementedError}computeElementwiseOpOutputShape(e,t){if(null==e||null==t)return null;if(e.length<t.length)return this.computeElementwiseOpOutputShape(t,e);if(0===t.length)return e;const r=e.slice(0,e.length-t.length);for(let n=0;n<t.length;++n){const l=e[e.length-t.length+n],a=t[n];if(null==l||null==a||l<0||a<0)r.push(null);else if(1===l)r.push(a);else if(1===a)r.push(l);else{if(l!==a)throw new s.ValueError("Operands could not be broadcast together with shapes "+JSON.stringify(e)+" "+JSON.stringify(t));r.push(l)}}return r}build(e){if(Array.isArray(e)&&!Array.isArray(e[0])&&(e=[(0,o.getExactlyOneShape)(e)]),(e=e).length<2)throw new s.ValueError("A merge layer should be called on an Array of at least 2 inputs."+` Got ${e.length} input(s).`);let t=[];for(const s of e)null!=s&&null!==s[0]&&t.push(s[0]);if((t=a.unique(t)).length>1)throw new s.ValueError("Can not merge tensors with different batch sizes. "+`Got tensors with shapes: ${JSON.stringify(e)}.`);let r=null==e[0]?null:e[0].slice(1);for(let s=1;s<e.length;++s){const t=null==e[s]?null:e[s].slice(1);r=this.computeElementwiseOpOutputShape(r,t)}const n=e.map(e=>e.length);-1===e.indexOf(null)&&1===a.unique(n).length?this.reshapeRequired=!1:this.reshapeRequired=!0}call(n,s){return(0,e.tidy)(()=>{if(n=n,this.reshapeRequired){const e=[],s=n.map(e=>e.rank);if(-1===s.indexOf(null)){const t=i.max(s);for(let s of n){const n=s.rank;for(let e=0;e<t-n;++e)s=r.expandDims(s,1);e.push(s)}return this.mergeFunction(e)}{let r=!1;for(const a of n){const n=a.rank;if(null==n){const n=a.shape,s=n[0],l=n.slice(1).concat([s]);let o=t.reshape(a,[s].concat(i.arrayProd(n.slice(1))));o=t.transpose(o,[1,0]),o=t.reshape(o,l),e.push(o),r=!0}else if(n>1){const s=i.range(1,n).concat([0]);e.push(t.transpose(a,s)),r=!0}else e.push(a)}let s=this.mergeFunction(e);const l=s.rank;if(r)if(null==l){const e=s.shape,r=e[e.length-1],n=[r].concat(e.slice(0,e.length-1));s=t.reshape(t.transpose(t.reshape(s,[-1,r]),[1,0]),n)}else if(l>1){const e=[l-1].concat(i.range(0,l-1));s=t.transpose(s,e)}return s}}return this.mergeFunction(n)})}computeOutputShape(e){let t;t=null==(e=e)[0]?null:e[0].slice(1);for(let n=1;n<e.length;++n){const r=null==e[n]?null:e[n].slice(1);t=this.computeElementwiseOpOutputShape(t,r)}let r=[];for(const n of e)null!=n&&null!==n[0]&&r.push(n[0]);return t=1===(r=a.unique(r)).length?r.concat(t):[null].concat(t)}computeMask(e,r){return t.tidy(()=>{if(null==r)return null;if(!Array.isArray(r))throw new s.ValueError("`mask` should be an Array");if(!Array.isArray(e))throw new s.ValueError("`inputs` should be an Array");if(r.length!==e.length)throw new s.ValueError("The Array 'inputs' and 'mask' are expected to have the same length, but have different lengths "+`(${e.length} vs ${r.length})`);if(r.every(e=>null==e))return null;let n=(r=r.map(e=>null==e?e:t.expandDims(e,0)))[0];for(let e=1;e<r.length-1;++e)n=t.logicalAnd(n,r[e]);return n})}}exports.Merge=h;class p extends h{constructor(e){super(e)}mergeFunction(r){return(0,e.tidy)(()=>{let e=r[0].clone();for(let n=1;n<r.length;++n)e=t.add(e,r[n]);return e})}}function c(e){if(Array.isArray(e)){return new p({}).apply(e)}return new p(e)}exports.Add=p,p.className="Add",e.serialization.registerClass(p);class f extends h{constructor(e){super(e)}mergeFunction(r){return(0,e.tidy)(()=>{let e=r[0].clone();for(let n=1;n<r.length;++n)e=t.mul(e,r[n]);return e})}}function g(e){if(Array.isArray(e)){return new f({}).apply(e)}return new f(e)}exports.Multiply=f,f.className="Multiply",e.serialization.registerClass(f);class y extends h{constructor(e){super(e)}mergeFunction(r){return(0,e.tidy)(()=>{let e=r[0].clone();for(let n=1;n<r.length;++n)e=t.add(e,r[n]);return t.mul(1/r.length,e)})}}function m(e){if(Array.isArray(e)){return new y({}).apply(e)}return new y(e)}exports.Average=y,y.className="Average",e.serialization.registerClass(y);class d extends h{constructor(e){super(e)}mergeFunction(r){return(0,e.tidy)(()=>{let e=r[0];for(let n=1;n<r.length;++n)e=t.maximum(e,r[n]);return e})}}function x(e){if(Array.isArray(e)){return new d({}).apply(e)}return new d(e)}exports.Maximum=d,d.className="Maximum",e.serialization.registerClass(d);class A extends h{constructor(e){super(e)}mergeFunction(r){return(0,e.tidy)(()=>{let e=r[0];for(let n=1;n<r.length;++n)e=t.minimum(e,r[n]);return e})}}function w(e){if(Array.isArray(e)){return new A({}).apply(e)}return new A(e)}exports.Minimum=A,A.className="Minimum",e.serialization.registerClass(A);class b extends h{constructor(e){super(e),this.DEFAULT_AXIS=-1,null==e&&(e={}),this.axis=null==e.axis?this.DEFAULT_AXIS:e.axis,this.supportsMasking=!0,this.reshapeRequired=!1}build(t){if(!Array.isArray(t)||!Array.isArray(t[0])||1===t.length)throw new s.ValueError("A `Concatenate` layer should be called on a list of at least 2 inputs");t=t;let r=!0;for(const e of t)if(null!=e){r=!1;break}if(r)return;const n=[];for(let s=0;s<t.length;++s){const r=t[s].slice();r.splice(this.axis,1);let l=!1;for(const t of n)if(e.util.arraysEqual(t,r)){l=!0;break}l||n.push(r)}if(n.length>1)throw new s.ValueError("A `Concatenate` layer requires inputs with matching shapes except for the concat axis. Got input shapes: "+JSON.stringify(t))}mergeFunction(t){return(0,e.tidy)(()=>r.concatenate(t,this.axis))}computeOutputShape(e){if(!Array.isArray(e)||!Array.isArray(e[0]))throw new s.ValueError("A `Concatenate` layer should be called on a list of inputs.");const t=e,r=t[0].slice(),n=this.axis<0?r.length+this.axis:this.axis;for(const s of t.slice(1)){if(null==r[n]||null==s[n]){r[n]=null;break}r[n]+=s[n]}return r}computeMask(e,r){if(null==r)return null;if(!Array.isArray(r))throw new s.ValueError("`mask` should be an array for Concatenate");if(!Array.isArray(e))throw new s.ValueError("`inputs` should be an array for Concatenate");if(r.length!==e.length)throw new s.ValueError(`Mismatch in the length of mask (${r.length}) `+`and the legnth of inputs (${e.length})`);return t.tidy(()=>{let n=!0;if(r.forEach(e=>{null==e||(n=!1)}),n)return null;const s=[];for(let a=0;a<e.length;++a)null==r[a]?s.push(t.cast(t.onesLike(e[a]),"bool")):r[a].rank<e[a].rank?s.push(t.expandDims(r[a],-1)):s.push(r[a]);const l=t.concat(s,this.axis);return t.all(l,-1,!1)})}getConfig(){const e={axis:this.axis},t=super.getConfig();return Object.assign(e,t),e}}function k(e){if(Array.isArray(e)){return new b({}).apply(e)}return new b(e)}function E(e,t){for(;e<0;)e+=t;return e}function O(e,r,n){if(e.shape.length>3||r.shape.length>3)throw new s.NotImplementedError("batchDot is not implemented for tensors of 4D or higher rank yet");if(t.util.assert(e.shape.length>=2,()=>"batchDot requires the rank of x to be >= 2, "+`but got ${e.shape.length}`),t.util.assert(e.shape.length>=2,()=>"batchDot requires the rank of y to be >= 2, "+`but got ${r.shape.length}`),"number"==typeof n&&(n=[n,n]),"complex64"===e.dtype||"complex64"===r.dtype)throw new s.NotImplementedError("batchDot is not implemented for complex64-type Tensors yet.");const l=e.shape.length,a=r.shape.length;null==n&&(n=[l-1,a-2]);const i=n;return t.tidy(()=>{let n,s;if(l>a){n=l-a;const e=[];for(let t=0;t<n;++t)e.push(1);r=t.reshape(r,r.shape.concat(e))}else if(a>l){n=a-l;const r=[];for(let e=0;e<n;++e)r.push(1);e=t.reshape(e,e.shape.concat(r))}else n=0;if(2===e.shape.length&&2===r.shape.length)s=i[0]===i[1]?t.sum(t.mul(e,r),i[0]):t.sum(t.mul(t.transpose(e,[1,0]),r),i[1]);else{const n=i[0]!==e.shape.length-1,l=i[1]===r.shape.length-1;s=t.matMul(e,r,n,l)}if(n>0){let e;const r=[];for(let t=e=l>a?l+a-3:l-1;t<e+n;++t)r.push(t);s=t.squeeze(s,r)}return 1===s.shape.length&&(s=t.expandDims(s,1)),s})}exports.Concatenate=b,b.className="Concatenate",e.serialization.registerClass(b);class M extends h{constructor(e){super(e),this.axes=e.axes,this.normalize=null!=e.normalize&&e.normalize,this.supportsMasking=!0,this.reshapeRequired=!1}build(e){t.util.assert(Array.isArray(e)&&2===e.length&&Array.isArray(e[0])&&Array.isArray(e[1]),()=>"A `Dot` layer should be called on a list of exactly 2 inputs.");const r=e[0],n=e[1];if(r.length>3||n.length>3)throw new s.NotImplementedError("Dot layer does not support tensors of 4D or higher rank yet.");const l=this.interpretAxes(r,n);if(r[l[0]]!==n[l[1]])throw new s.ValueError("Dimension incompatibility: "+`${r[l[0]]} !== ${n[l[1]]}`)}mergeFunction(e){if(2!==e.length)throw new s.ValueError("A `Dot` layer must be called on exactly 2 inputs, "+`but received ${e.length} input(s).`);let t,r=e[0],n=e[1];return t=Array.isArray(this.axes)?this.axes.map((t,r)=>E(t,e[r].shape.length)):[E(this.axes,r.shape.length),E(this.axes,n.shape.length)],this.normalize&&(r=(0,l.l2Normalize)(r,t[0]),n=(0,l.l2Normalize)(n,t[1])),O(r,n,t)}interpretAxes(e,t){let r;return r=Array.isArray(this.axes)?this.axes:[E(this.axes,e.length),E(this.axes,t.length)]}computeOutputShape(e){t.util.assert(Array.isArray(e)&&2===e.length&&Array.isArray(e[0])&&Array.isArray(e[1]),()=>"A `Dot` layer should be called on a list of exactly 2 inputs.");const r=e[0].slice(),n=e[1].slice();if(r.length>3||n.length>3)throw new s.NotImplementedError("Dot layer does not support tensors of 4D or higher rank yet.");const l=this.interpretAxes(r,n);r.splice(l[0],1),n.splice(l[1],1),n.splice(0,1);const a=r.concat(n);return 1===a.length&&a.push(1),a}computeMask(e,t){return null}getConfig(){const e={axes:this.axes,normalize:this.normalize},t=super.getConfig();return Object.assign(e,t),e}}exports.Dot=M,M.className="Dot",e.serialization.registerClass(M);
},{"@tensorflow/tfjs-core":"kSBl","../backend/tfjs_backend":"Ftmo","../engine/topology":"wHpB","../errors":"iJtr","../losses":"EG90","../utils/generic_utils":"VKwv","../utils/math_utils":"eQAy","../utils/types_utils":"mOET"}],"gWXq":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.GaussianNoise=exports.GaussianDropout=exports.AlphaDropout=void 0;var t=require("@tensorflow/tfjs-core"),e=a(require("../backend/tfjs_backend")),r=require("../engine/topology"),s=require("../utils/types_utils");function a(t,e){if("function"==typeof WeakMap)var r=new WeakMap,s=new WeakMap;return(a=function(t,e){if(!e&&t&&t.__esModule)return t;var a,n,i={__proto__:null,default:t};if(null===t||"object"!=typeof t&&"function"!=typeof t)return i;if(a=e?s:r){if(a.has(t))return a.get(t);a.set(t,i)}for(const r in t)"default"!==r&&{}.hasOwnProperty.call(t,r)&&((n=(a=Object.defineProperty)&&Object.getOwnPropertyDescriptor(t,r))&&(n.get||n.set)?a(i,r,n):i[r]=t[r]);return i})(t,e)}class n extends r.Layer{constructor(t){super(t),this.supportsMasking=!0,this.stddev=t.stddev}computeOutputShape(t){return t}getConfig(){const t=super.getConfig(),e={stddev:this.stddev};return Object.assign(e,t),e}call(r,a){return(0,t.tidy)(()=>{this.invokeCallHook(r,a);const n=(0,s.getExactlyOneTensor)(r);return e.inTrainPhase(()=>(0,t.add)(e.randomNormal(n.shape,0,this.stddev),n),()=>n,a.training||!1)})}}exports.GaussianNoise=n,n.className="GaussianNoise",t.serialization.registerClass(n);class i extends r.Layer{constructor(t){super(t),this.supportsMasking=!0,this.rate=t.rate}computeOutputShape(t){return t}getConfig(){const t=super.getConfig(),e={rate:this.rate};return Object.assign(e,t),e}call(r,a){return(0,t.tidy)(()=>{this.invokeCallHook(r,a);const n=(0,s.getExactlyOneTensor)(r);if(this.rate>0&&this.rate<1){const r=()=>{const r=Math.sqrt(this.rate/(1-this.rate));return(0,t.mul)(n,e.randomNormal(n.shape,1,r))};return e.inTrainPhase(r,()=>n,a.training||!1)}return n})}}exports.GaussianDropout=i,i.className="GaussianDropout",t.serialization.registerClass(i);class o extends r.Layer{constructor(t){super(t),this.supportsMasking=!0,this.rate=t.rate,this.noiseShape=t.noiseShape}_getNoiseShape(t){return this.noiseShape||(0,s.getExactlyOneTensor)(t).shape}computeOutputShape(t){return t}getConfig(){const t=super.getConfig(),e={rate:this.rate};return Object.assign(e,t),e}call(r,a){return(0,t.tidy)(()=>{if(this.rate<1&&this.rate>0){const n=this._getNoiseShape(r),i=()=>{const a=(0,s.getExactlyOneTensor)(r),i=-1.7580993408473766;let o=(0,t.greaterEqual)((0,t.randomUniform)(n),this.rate);o=e.cast(o,"float32");const u=((1-this.rate)*(1+this.rate*i**2))**-.5,p=-u*i*this.rate,l=(0,t.add)((0,t.mul)(a,o),(0,t.mul)((0,t.add)(o,-1),i));return(0,t.add)((0,t.mul)(l,u),p)};return e.inTrainPhase(i,()=>(0,s.getExactlyOneTensor)(r),a.training||!1)}return r})}}exports.AlphaDropout=o,o.className="AlphaDropout",t.serialization.registerClass(o);
},{"@tensorflow/tfjs-core":"kSBl","../backend/tfjs_backend":"Ftmo","../engine/topology":"wHpB","../utils/types_utils":"mOET"}],"C8io":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.LayerNormalization=exports.BatchNormalization=void 0,exports.batchNormalization=g,exports.normalizeBatchInTraining=z;var i=u(require("@tensorflow/tfjs-core")),e=i,t=require("../constraints"),a=require("../engine/topology"),r=require("../errors"),s=require("../initializers"),n=require("../regularizers"),l=u(require("../utils/generic_utils")),o=u(require("../utils/math_utils")),h=require("../utils/types_utils");function u(i,e){if("function"==typeof WeakMap)var t=new WeakMap,a=new WeakMap;return(u=function(i,e){if(!e&&i&&i.__esModule)return i;var r,s,n={__proto__:null,default:i};if(null===i||"object"!=typeof i&&"function"!=typeof i)return n;if(r=e?a:t){if(r.has(i))return r.get(i);r.set(i,n)}for(const t in i)"default"!==t&&{}.hasOwnProperty.call(i,t)&&((s=(r=Object.defineProperty)&&Object.getOwnPropertyDescriptor(i,t))&&(s.get||s.set)?r(n,t,s):n[t]=i[t]);return n})(i,e)}function g(i,t,a,s,n,l=.001){let o;if(2===i.rank)o=e.batchNorm2d(i,t,a,s,n,l);else if(3===i.rank)o=e.batchNorm3d(i,t,a,s,n,l);else{if(4!==i.rank)throw new r.NotImplementedError(`batchNormalization is not implemented for array of rank ${i.rank} `+"yet");o=e.batchNorm4d(i,t,a,s,n,l)}return o}function m(t,a,r,s,n=.001){return(0,i.tidy)(()=>{const i=e.moments(t,s),l=i.mean,o=i.variance;return[g(t,l,o,r,a,n),l,o]})}function c(t,a,r,s,n=.001){return(0,i.tidy)(()=>{const l=e.moments(t,s),h=l.mean,u=l.variance,m=[];for(const i of o.range(0,t.rank))-1!==s.indexOf(i)?m.push(1):m.push(t.shape[i]);const c=(0,i.reshape)(h,m),z=(0,i.reshape)(u,m),p=null==a?null:(0,i.reshape)(a,m),f=null==r?null:(0,i.reshape)(r,m);return[g(t,c,z,f,p,n),h,u]})}function z(e,t,a,r,s=.001){return i.util.arraysEqual(r.slice().sort(),o.range(0,e.rank-1))?m(e,t,a,r,s):c(e,t,a,r,s)}class p extends a.Layer{constructor(i){null==i&&(i={}),super(i),this.supportsMasking=!0,this.axis=null==i.axis?-1:i.axis,this.momentum=null==i.momentum?.99:i.momentum,this.epsilon=null==i.epsilon?.001:i.epsilon,this.center=null==i.center||i.center,this.scale=null==i.scale||i.scale,this.betaInitializer=(0,s.getInitializer)(i.betaInitializer||"zeros"),this.gammaInitializer=(0,s.getInitializer)(i.gammaInitializer||"ones"),this.movingMeanInitializer=(0,s.getInitializer)(i.movingMeanInitializer||"zeros"),this.movingVarianceInitializer=(0,s.getInitializer)(i.movingVarianceInitializer||"ones"),this.betaConstraint=(0,t.getConstraint)(i.betaConstraint),this.gammaConstraint=(0,t.getConstraint)(i.gammaConstraint),this.betaRegularizer=(0,n.getRegularizer)(i.betaRegularizer),this.gammaRegularizer=(0,n.getRegularizer)(i.gammaRegularizer)}build(i){i=(0,h.getExactlyOneShape)(i);const e=this.axis>=0?this.axis:this.axis+i.length,t=i[e];if(null==t)throw new r.ValueError(`Axis ${e} of input tensor should have a defined dimension but `+"the layer received an input with shape "+`${JSON.stringify(i)}.`);this.inputSpec=[new a.InputSpec({ndim:i.length,axes:{[e]:t}})];const s=[t];this.scale&&(this.gamma=this.addWeight("gamma",s,null,this.gammaInitializer,this.gammaRegularizer,!0,this.gammaConstraint)),this.center&&(this.beta=this.addWeight("beta",s,null,this.betaInitializer,this.betaRegularizer,!0,this.betaConstraint)),this.movingMean=this.addWeight("moving_mean",s,null,this.movingMeanInitializer,null,!1),this.movingVariance=this.addWeight("moving_variance",s,null,this.movingVarianceInitializer,null,!1),this.built=!0}call(t,a){return(0,i.tidy)(()=>{const r=null!=a.training&&a.training,s=(0,h.getExactlyOneTensor)(t),n=s.shape,u=n.length,m=o.range(0,u),c=this.axis>=0?this.axis:this.axis+u;m.splice(c,1);const p=l.pyListRepeat(1,u);p[c]=n[c];const f=m.slice();f.sort();const b=!i.util.arraysEqual(f,o.range(0,u).slice(0,u-1));if(!r)return(()=>{if(b){const e=(0,i.reshape)(this.movingMean.read(),p),t=(0,i.reshape)(this.movingVariance.read(),p),a=this.center?(0,i.reshape)(this.beta.read(),p):null,r=this.scale?(0,i.reshape)(this.gamma.read(),p):null;return g(s,e,t,a,r,this.epsilon)}return g(s,this.movingMean.read(),this.movingVariance.read(),null==this.beta?null:this.beta.read(),null==this.gamma?null:this.gamma.read(),this.epsilon)})();const[d,x,I]=z(s,this.gamma.read(),this.beta.read(),m,this.epsilon),y=(i,t,a)=>{e.tidy(()=>{const r=1-a,s=i.read(),n=e.mul(e.sub(s,t),r);i.write(e.sub(s,n))})};return(()=>{y(this.movingMean,x,this.momentum),y(this.movingVariance,I,this.momentum)})(),d})}getConfig(){const i={axis:this.axis,momentum:this.momentum,epsilon:this.epsilon,center:this.center,scale:this.scale,betaInitializer:(0,s.serializeInitializer)(this.betaInitializer),gammaInitializer:(0,s.serializeInitializer)(this.gammaInitializer),movingMeanInitializer:(0,s.serializeInitializer)(this.movingMeanInitializer),movingVarianceInitializer:(0,s.serializeInitializer)(this.movingVarianceInitializer),betaRegularizer:(0,n.serializeRegularizer)(this.betaRegularizer),gammaRegularizer:(0,n.serializeRegularizer)(this.gammaRegularizer),betaConstraint:(0,t.serializeConstraint)(this.betaConstraint),gammaConstraint:(0,t.serializeConstraint)(this.gammaConstraint)},e=super.getConfig();return Object.assign(i,e),i}}exports.BatchNormalization=p,p.className="BatchNormalization",i.serialization.registerClass(p);class f extends a.Layer{constructor(i){if(null==i&&(i={}),super(i),this.axis=null==i.axis?-1:i.axis,"number"==typeof this.axis){if(!Number.isInteger(this.axis))throw new Error(`Expected axis to be an integer, but received ${this.axis}`)}else{if(!Array.isArray(this.axis))throw new Error("Expected axis to be an integer or an array of integers, "+`but received ${JSON.stringify(this.axis)}`);for(const i of this.axis)if(!Number.isInteger(i))throw new Error("Expected axis to be an array of integers, "+`but received ${JSON.stringify(this.axis)}`)}this.epsilon=null==i.epsilon?.001:i.epsilon,this.center=null==i.center||i.center,this.scale=null==i.scale||i.scale,this.betaInitializer=(0,s.getInitializer)(i.betaInitializer||"zeros"),this.gammaInitializer=(0,s.getInitializer)(i.gammaInitializer||"ones"),this.betaRegularizer=(0,n.getRegularizer)(i.betaRegularizer),this.gammaRegularizer=(0,n.getRegularizer)(i.gammaRegularizer),this.supportsMasking=!0}build(i){const e=(i=(0,h.getExactlyOneShape)(i)).length;"number"==typeof this.axis&&(this.axis=[this.axis]);for(let a=0;a<this.axis.length;++a)this.axis[a]<0&&(this.axis[a]+=e);for(const a of this.axis)if(a<0||a>=e)throw new Error(`Invalid axis: ${a}`);if(this.axis.length!==l.unique(this.axis).length)throw new Error(`Found duplicate axes in: ${this.axis}`);const t=this.axis.map(e=>i[e]);this.scale?this.gamma=this.addWeight("gamma",t,"float32",this.gammaInitializer,this.gammaRegularizer,!0):this.gamma=null,this.center?this.beta=this.addWeight("beta",t,"float32",this.betaInitializer,this.betaRegularizer,!0):this.beta=null,this.built=!0}call(t,a){const r=(0,h.getExactlyOneTensor)(t),s=r.shape,n=s.length;return(0,i.tidy)(()=>{let{mean:t,variance:a}=(0,i.moments)(r,this.axis,!0);const o=l.pyListRepeat(1,n);for(const i of this.axis)o[i]=s[i];const h=i=>null!=i&&i.shape.length!==n?e.reshape(i,o):i;let u=this.scale?h(this.gamma.read()):null,m=this.center?h(this.beta.read()):null;const c=[],z=[];for(let i=0;i<n;++i)-1!==this.axis.indexOf(i)?(c.push(s[i]),z.push(1)):(c.push(1),z.push(s[i]));return t=e.tile(t,c),a=e.tile(a,c),null!=u&&(u=e.tile(u,z)),null!=m&&(m=e.tile(m,z)),g(r,t,a,m,u,this.epsilon)})}getConfig(){const i={axis:this.axis,epsilon:this.epsilon,center:this.center,scale:this.scale,betaInitializer:(0,s.serializeInitializer)(this.betaInitializer),gammaInitializer:(0,s.serializeInitializer)(this.gammaInitializer),betaRegularizer:(0,n.serializeRegularizer)(this.betaRegularizer),gammaRegularizer:(0,n.serializeRegularizer)(this.gammaRegularizer)},e=super.getConfig();return Object.assign(i,e),i}}exports.LayerNormalization=f,f.className="LayerNormalization",i.serialization.registerClass(f);
},{"@tensorflow/tfjs-core":"kSBl","../constraints":"zJV2","../engine/topology":"wHpB","../errors":"iJtr","../initializers":"Ltyq","../regularizers":"TEkX","../utils/generic_utils":"VKwv","../utils/math_utils":"eQAy","../utils/types_utils":"mOET"}],"ZNII":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.ZeroPadding2D=void 0,exports.spatial2dPadding=l,exports.temporalPadding=o;var e=i(require("@tensorflow/tfjs-core")),t=e,a=require("../backend/common"),n=require("../engine/topology"),r=require("../errors"),d=require("../utils/types_utils");function i(e,t){if("function"==typeof WeakMap)var a=new WeakMap,n=new WeakMap;return(i=function(e,t){if(!t&&e&&e.__esModule)return e;var r,d,i={__proto__:null,default:e};if(null===e||"object"!=typeof e&&"function"!=typeof e)return i;if(r=t?n:a){if(r.has(e))return r.get(e);r.set(e,i)}for(const a in e)"default"!==a&&{}.hasOwnProperty.call(e,a)&&((d=(r=Object.defineProperty)&&Object.getOwnPropertyDescriptor(e,a))&&(d.get||d.set)?r(i,a,d):i[a]=e[a]);return i})(e,t)}function o(a,n){return(0,e.tidy)(()=>{if(3!==a.rank)throw new r.ValueError("temporalPadding expects input tensor to be 3-D, but received a "+`${a.rank}-D tensor.`);if(null==n&&(n=[1,1]),2!==n.length)throw new r.ValueError("temporalPadding expects input padding pattern to be a length-2 "+`array, but received a length-${n.length} array.`);const e=[[0,0],n,[0,0]];return t.pad(a,e)})}function l(n,d,i){return(0,e.tidy)(()=>{if(4!==n.rank)throw new r.ValueError("temporalPadding expects input tensor to be 4-D, but received a "+`${n.rank}-D tensor.`);if(null==d&&(d=[[1,1],[1,1]]),2!==d.length||2!==d[0].length||2!==d[1].length)throw new r.ValueError("spatial2dPadding expects `padding` to be an Array of two Arrays, each of which is an Array of two integers.");if(null==i&&(i=(0,a.imageDataFormat)()),"channelsLast"!==i&&"channelsFirst"!==i)throw new r.ValueError(`Unknown data format: ${i}. `+"Supported data formats are 'channelsLast' and 'channelsFirst.");let e;return e="channelsFirst"===i?[[0,0],[0,0],d[0],d[1]]:[[0,0],d[0],d[1],[0,0]],t.pad(n,e)})}class p extends n.Layer{constructor(e){if(null==e&&(e={}),super(e),this.dataFormat=null==e.dataFormat?(0,a.imageDataFormat)():e.dataFormat,null==e.padding)this.padding=[[1,1],[1,1]];else if("number"==typeof e.padding)this.padding=[[e.padding,e.padding],[e.padding,e.padding]];else{if(e.padding=e.padding,2!==e.padding.length)throw new r.ValueError("ZeroPadding2D expects padding to be a length-2 array, but "+`received a length-${e.padding.length} array.`);let t,a;if("number"==typeof e.padding[0])t=[e.padding[0],e.padding[0]],a=[e.padding[1],e.padding[1]];else{if(e.padding=e.padding,2!==e.padding[0].length)throw new r.ValueError("ZeroPadding2D expects height padding to be a length-2 array, "+`but received a length-${e.padding[0].length} array.`);if(t=e.padding[0],2!==e.padding[1].length)throw new r.ValueError("ZeroPadding2D expects width padding to be a length-2 array, "+`but received a length-${e.padding[1].length} array.`);a=e.padding[1]}this.padding=[t,a]}this.inputSpec=[new n.InputSpec({ndim:4})]}computeOutputShape(e){let t,a;return e=(0,d.getExactlyOneShape)(e),"channelsFirst"===this.dataFormat?(t=null!=e[2]&&e[2]>=0?e[2]+this.padding[0][0]+this.padding[0][1]:null,a=null!=e[3]&&e[3]>=0?e[3]+this.padding[1][0]+this.padding[1][1]:null,[e[0],e[1],t,a]):(t=null!=e[1]&&e[1]>=0?e[1]+this.padding[0][0]+this.padding[0][1]:null,a=null!=e[2]&&e[2]>=0?e[2]+this.padding[1][0]+this.padding[1][1]:null,[e[0],t,a,e[3]])}call(t,a){return(0,e.tidy)(()=>l((0,d.getExactlyOneTensor)(t),this.padding,this.dataFormat))}getConfig(){const e={padding:this.padding,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}}exports.ZeroPadding2D=p,p.className="ZeroPadding2D",e.serialization.registerClass(p);
},{"@tensorflow/tfjs-core":"kSBl","../backend/common":"VOlA","../engine/topology":"wHpB","../errors":"iJtr","../utils/types_utils":"mOET"}],"J0qa":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.Pooling3D=exports.Pooling2D=exports.Pooling1D=exports.MaxPooling3D=exports.MaxPooling2D=exports.MaxPooling1D=exports.GlobalPooling2D=exports.GlobalPooling1D=exports.GlobalMaxPooling2D=exports.GlobalMaxPooling1D=exports.GlobalAveragePooling2D=exports.GlobalAveragePooling1D=exports.AveragePooling3D=exports.AveragePooling2D=exports.AveragePooling1D=void 0,exports.pool2d=u,exports.pool3d=g;var e=c(require("@tensorflow/tfjs-core")),t=e,s=require("../backend/common"),o=c(require("../backend/tfjs_backend")),i=require("../common"),r=require("../engine/topology"),a=require("../errors"),n=require("../utils/conv_utils"),l=require("../utils/generic_utils"),d=require("../utils/types_utils"),p=require("./convolutional");function c(e,t){if("function"==typeof WeakMap)var s=new WeakMap,o=new WeakMap;return(c=function(e,t){if(!t&&e&&e.__esModule)return e;var i,r,a={__proto__:null,default:e};if(null===e||"object"!=typeof e&&"function"!=typeof e)return a;if(i=t?o:s){if(i.has(e))return i.get(e);i.set(e,a)}for(const s in e)"default"!==s&&{}.hasOwnProperty.call(e,s)&&((r=(i=Object.defineProperty)&&Object.getOwnPropertyDescriptor(e,s))&&(r.get||r.set)?i(a,s,r):a[s]=e[s]);return a})(e,t)}function u(o,r,a,n,l,d){return(0,e.tidy)(()=>{let e;(0,i.checkDataFormat)(l),(0,i.checkPoolMode)(d),(0,i.checkPaddingMode)(n),null==a&&(a=[1,1]),null==n&&(n="valid"),null==l&&(l=(0,s.imageDataFormat)()),null==d&&(d="max"),o=(0,p.preprocessConv2DInput)(o,l);const c="same"===n?"same":"valid";return e="max"===d?t.maxPool(o,r,a,c):t.avgPool(o,r,a,c),"channelsFirst"===l&&(e=t.transpose(e,[0,3,1,2])),e})}function g(o,r,a,n,l,d){return(0,e.tidy)(()=>{let e;(0,i.checkDataFormat)(l),(0,i.checkPoolMode)(d),(0,i.checkPaddingMode)(n),null==a&&(a=[1,1,1]),null==n&&(n="valid"),null==l&&(l=(0,s.imageDataFormat)()),null==d&&(d="max"),o=(0,p.preprocessConv3DInput)(o,l);const c="same"===n?"same":"valid";return e="max"===d?t.maxPool3d(o,r,a,c):t.avgPool3d(o,r,a,c),"channelsFirst"===l&&(e=t.transpose(e,[0,4,1,2,3])),e})}class h extends r.Layer{constructor(e){if(null==e.poolSize&&(e.poolSize=2),super(e),"number"==typeof e.poolSize)this.poolSize=[e.poolSize];else{if(!Array.isArray(e.poolSize)||1!==e.poolSize.length||"number"!=typeof e.poolSize[0])throw new a.ValueError("poolSize for 1D convolutional layer must be a number or an Array of a single number, but received "+`${JSON.stringify(e.poolSize)}`);this.poolSize=e.poolSize}if((0,l.assertPositiveInteger)(this.poolSize,"poolSize"),null==e.strides)this.strides=this.poolSize;else if("number"==typeof e.strides)this.strides=[e.strides];else{if(!Array.isArray(e.strides)||1!==e.strides.length||"number"!=typeof e.strides[0])throw new a.ValueError("strides for 1D convolutional layer must be a number or an Array of a single number, but received "+`${JSON.stringify(e.strides)}`);this.strides=e.strides}(0,l.assertPositiveInteger)(this.strides,"strides"),this.padding=null==e.padding?"valid":e.padding,(0,i.checkPaddingMode)(this.padding),this.inputSpec=[new r.InputSpec({ndim:3})]}computeOutputShape(e){e=(0,d.getExactlyOneShape)(e);const t=(0,n.convOutputLength)(e[1],this.poolSize[0],this.padding,this.strides[0]);return[e[0],t,e[2]]}call(s,i){return(0,e.tidy)(()=>{this.invokeCallHook(s,i),s=o.expandDims((0,d.getExactlyOneTensor)(s),2);const e=this.poolingFunction((0,d.getExactlyOneTensor)(s),[this.poolSize[0],1],[this.strides[0],1],this.padding,"channelsLast");return t.squeeze(e,[2])})}getConfig(){const e={poolSize:this.poolSize,padding:this.padding,strides:this.strides},t=super.getConfig();return Object.assign(e,t),e}}exports.Pooling1D=h;class m extends h{constructor(e){super(e)}poolingFunction(e,t,s,o,r){return(0,i.checkDataFormat)(r),(0,i.checkPaddingMode)(o),u(e,t,s,o,r,"max")}}exports.MaxPooling1D=m,m.className="MaxPooling1D",e.serialization.registerClass(m);class x extends h{constructor(e){super(e)}poolingFunction(e,t,s,o,r){return(0,i.checkDataFormat)(r),(0,i.checkPaddingMode)(o),u(e,t,s,o,r,"avg")}}exports.AveragePooling1D=x,x.className="AveragePooling1D",e.serialization.registerClass(x);class S extends r.Layer{constructor(e){if(null==e.poolSize&&(e.poolSize=[2,2]),super(e),this.poolSize=Array.isArray(e.poolSize)?e.poolSize:[e.poolSize,e.poolSize],null==e.strides)this.strides=this.poolSize;else if(Array.isArray(e.strides)){if(2!==e.strides.length)throw new a.ValueError("If the strides property of a 2D pooling layer is an Array, it is expected to have a length of 2, but received length "+`${e.strides.length}.`);this.strides=e.strides}else this.strides=[e.strides,e.strides];(0,l.assertPositiveInteger)(this.poolSize,"poolSize"),(0,l.assertPositiveInteger)(this.strides,"strides"),this.padding=null==e.padding?"valid":e.padding,this.dataFormat=null==e.dataFormat?"channelsLast":e.dataFormat,(0,i.checkDataFormat)(this.dataFormat),(0,i.checkPaddingMode)(this.padding),this.inputSpec=[new r.InputSpec({ndim:4})]}computeOutputShape(e){e=(0,d.getExactlyOneShape)(e);let t="channelsFirst"===this.dataFormat?e[2]:e[1],s="channelsFirst"===this.dataFormat?e[3]:e[2];return t=(0,n.convOutputLength)(t,this.poolSize[0],this.padding,this.strides[0]),s=(0,n.convOutputLength)(s,this.poolSize[1],this.padding,this.strides[1]),"channelsFirst"===this.dataFormat?[e[0],e[1],t,s]:[e[0],t,s,e[3]]}call(t,s){return(0,e.tidy)(()=>(this.invokeCallHook(t,s),this.poolingFunction((0,d.getExactlyOneTensor)(t),this.poolSize,this.strides,this.padding,this.dataFormat)))}getConfig(){const e={poolSize:this.poolSize,padding:this.padding,strides:this.strides,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}}exports.Pooling2D=S;class P extends S{constructor(e){super(e)}poolingFunction(e,t,s,o,r){return(0,i.checkDataFormat)(r),(0,i.checkPaddingMode)(o),u(e,t,s,o,r,"max")}}exports.MaxPooling2D=P,P.className="MaxPooling2D",e.serialization.registerClass(P);class y extends S{constructor(e){super(e)}poolingFunction(e,t,s,o,r){return(0,i.checkDataFormat)(r),(0,i.checkPaddingMode)(o),u(e,t,s,o,r,"avg")}}exports.AveragePooling2D=y,y.className="AveragePooling2D",e.serialization.registerClass(y);class z extends r.Layer{constructor(e){if(null==e.poolSize&&(e.poolSize=[2,2,2]),super(e),this.poolSize=Array.isArray(e.poolSize)?e.poolSize:[e.poolSize,e.poolSize,e.poolSize],null==e.strides)this.strides=this.poolSize;else if(Array.isArray(e.strides)){if(3!==e.strides.length)throw new a.ValueError("If the strides property of a 3D pooling layer is an Array, it is expected to have a length of 3, but received length "+`${e.strides.length}.`);this.strides=e.strides}else this.strides=[e.strides,e.strides,e.strides];(0,l.assertPositiveInteger)(this.poolSize,"poolSize"),(0,l.assertPositiveInteger)(this.strides,"strides"),this.padding=null==e.padding?"valid":e.padding,this.dataFormat=null==e.dataFormat?"channelsLast":e.dataFormat,(0,i.checkDataFormat)(this.dataFormat),(0,i.checkPaddingMode)(this.padding),this.inputSpec=[new r.InputSpec({ndim:5})]}computeOutputShape(e){e=(0,d.getExactlyOneShape)(e);let t="channelsFirst"===this.dataFormat?e[2]:e[1],s="channelsFirst"===this.dataFormat?e[3]:e[2],o="channelsFirst"===this.dataFormat?e[4]:e[3];return t=(0,n.convOutputLength)(t,this.poolSize[0],this.padding,this.strides[0]),s=(0,n.convOutputLength)(s,this.poolSize[1],this.padding,this.strides[1]),o=(0,n.convOutputLength)(o,this.poolSize[2],this.padding,this.strides[2]),"channelsFirst"===this.dataFormat?[e[0],e[1],t,s,o]:[e[0],t,s,o,e[4]]}call(t,s){return(0,e.tidy)(()=>(this.invokeCallHook(t,s),this.poolingFunction((0,d.getExactlyOneTensor)(t),this.poolSize,this.strides,this.padding,this.dataFormat)))}getConfig(){const e={poolSize:this.poolSize,padding:this.padding,strides:this.strides,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}}exports.Pooling3D=z;class D extends z{constructor(e){super(e)}poolingFunction(e,t,s,o,r){return(0,i.checkDataFormat)(r),(0,i.checkPaddingMode)(o),g(e,t,s,o,r,"max")}}exports.MaxPooling3D=D,D.className="MaxPooling3D",e.serialization.registerClass(D);class F extends z{constructor(e){super(e)}poolingFunction(e,t,s,o,r){return(0,i.checkDataFormat)(r),(0,i.checkPaddingMode)(o),g(e,t,s,o,r,"avg")}}exports.AveragePooling3D=F,F.className="AveragePooling3D",e.serialization.registerClass(F);class v extends r.Layer{constructor(e){super(e),this.inputSpec=[new r.InputSpec({ndim:3})]}computeOutputShape(e){return[e[0],e[2]]}call(e,t){throw new a.NotImplementedError}}exports.GlobalPooling1D=v;class f extends v{constructor(e){super(e||{})}call(s,o){return(0,e.tidy)(()=>{const e=(0,d.getExactlyOneTensor)(s);return t.mean(e,1)})}}exports.GlobalAveragePooling1D=f,f.className="GlobalAveragePooling1D",e.serialization.registerClass(f);class b extends v{constructor(e){super(e||{})}call(s,o){return(0,e.tidy)(()=>{const e=(0,d.getExactlyOneTensor)(s);return t.max(e,1)})}}exports.GlobalMaxPooling1D=b,b.className="GlobalMaxPooling1D",e.serialization.registerClass(b);class k extends r.Layer{constructor(e){super(e),this.dataFormat=null==e.dataFormat?"channelsLast":e.dataFormat,(0,i.checkDataFormat)(this.dataFormat),this.inputSpec=[new r.InputSpec({ndim:4})]}computeOutputShape(e){return e=e,"channelsLast"===this.dataFormat?[e[0],e[3]]:[e[0],e[1]]}call(e,t){throw new a.NotImplementedError}getConfig(){const e={dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}}exports.GlobalPooling2D=k;class M extends k{call(s,o){return(0,e.tidy)(()=>{const e=(0,d.getExactlyOneTensor)(s);return"channelsLast"===this.dataFormat?t.mean(e,[1,2]):t.mean(e,[2,3])})}}exports.GlobalAveragePooling2D=M,M.className="GlobalAveragePooling2D",e.serialization.registerClass(M);class O extends k{call(s,o){return(0,e.tidy)(()=>{const e=(0,d.getExactlyOneTensor)(s);return"channelsLast"===this.dataFormat?t.max(e,[1,2]):t.max(e,[2,3])})}}exports.GlobalMaxPooling2D=O,O.className="GlobalMaxPooling2D",e.serialization.registerClass(O);
},{"@tensorflow/tfjs-core":"kSBl","../backend/common":"VOlA","../backend/tfjs_backend":"Ftmo","../common":"sR6u","../engine/topology":"wHpB","../errors":"iJtr","../utils/conv_utils":"cPzX","../utils/generic_utils":"VKwv","../utils/types_utils":"mOET","./convolutional":"sbhA"}],"GeqG":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.Wrapper=exports.TimeDistributed=exports.Bidirectional=void 0,exports.checkBidirectionalMergeMode=y;var e=h(require("@tensorflow/tfjs-core")),t=e,r=h(require("../backend/tfjs_backend")),a=require("../common"),i=require("../engine/topology"),s=require("../errors"),n=require("../keras_format/common"),l=h(require("../utils/generic_utils")),o=require("../utils/types_utils"),c=require("./recurrent"),u=require("./serialization");function h(e,t){if("function"==typeof WeakMap)var r=new WeakMap,a=new WeakMap;return(h=function(e,t){if(!t&&e&&e.__esModule)return e;var i,s,n={__proto__:null,default:e};if(null===e||"object"!=typeof e&&"function"!=typeof e)return n;if(i=t?a:r){if(i.has(e))return i.get(e);i.set(e,n)}for(const r in e)"default"!==r&&{}.hasOwnProperty.call(e,r)&&((s=(i=Object.defineProperty)&&Object.getOwnPropertyDescriptor(e,r))&&(s.get||s.set)?i(n,r,s):n[r]=e[r]);return n})(e,t)}class d extends i.Layer{constructor(e){super(e),this.layer=e.layer}build(e){this.built=!0}get trainable(){return null!=this.layer&&this.layer.trainable}set trainable(e){null!=this.layer&&(this.layer.trainable=e)}get trainableWeights(){return this.layer.trainableWeights}get nonTrainableWeights(){return this.layer.nonTrainableWeights}get updates(){return this.layer._updates}get losses(){return this.layer.losses}getWeights(){return this.layer.getWeights()}setWeights(e){this.layer.setWeights(e)}getConfig(){const e={layer:{className:this.layer.getClassName(),config:this.layer.getConfig()}},t=super.getConfig();return Object.assign(e,t),e}setFastWeightInitDuringBuild(e){super.setFastWeightInitDuringBuild(e),null!=this.layer&&this.layer.setFastWeightInitDuringBuild(e)}static fromConfig(e,t,r={}){const a=t.layer,i=(0,u.deserialize)(a,r);delete t.layer;const s={layer:i};return Object.assign(s,t),new e(s)}}exports.Wrapper=d;class g extends d{constructor(e){super(e),this.supportsMasking=!0}build(e){if((e=(0,o.getExactlyOneShape)(e)).length<3)throw new s.ValueError("TimeDistributed layer expects an input shape >= 3D, but received "+`input shape ${JSON.stringify(e)}`);this.inputSpec=[{shape:e}];const t=[e[0]].concat(e.slice(2));this.layer.built||(this.layer.build(t),this.layer.built=!0),super.build(e)}computeOutputShape(e){const t=[(e=(0,o.getExactlyOneShape)(e))[0]].concat(e.slice(2)),r=this.layer.computeOutputShape(t),a=e[1];return[r[0],a].concat(r.slice(1))}call(t,r){return(0,e.tidy)(()=>{t=(0,o.getExactlyOneTensor)(t);return(0,c.rnn)((e,t)=>{return[(0,o.getExactlyOneTensor)(this.layer.call(e,r)),[]]},t,[],!1,null,null,!1,!0)[1]})}}function y(e){l.checkStringTypeUnionValue(n.VALID_BIDIRECTIONAL_MERGE_MODES,"BidirectionalMergeMode",e)}exports.TimeDistributed=g,g.className="TimeDistributed",e.serialization.registerClass(g);const p="concat";class f extends d{constructor(e){super(e);const t=e.layer.getConfig(),r={};r.className=e.layer.getClassName(),r.config=t,this.forwardLayer=(0,u.deserialize)(r),t.goBackwards=!0!==t.goBackwards;const a={};if(a.className=e.layer.getClassName(),a.config=t,this.backwardLayer=(0,u.deserialize)(a),this.forwardLayer.name="forward_"+this.forwardLayer.name,this.backwardLayer.name="backward_"+this.backwardLayer.name,this.mergeMode=void 0===e.mergeMode?p:e.mergeMode,y(this.mergeMode),e.weights)throw new s.NotImplementedError("weights support is not implemented for Bidirectional layer yet.");this._stateful=e.layer.stateful,this.returnSequences=e.layer.returnSequences,this.returnState=e.layer.returnState,this.supportsMasking=!0,this._trainable=!0,this.inputSpec=e.layer.inputSpec,this.numConstants=null}get trainable(){return this._trainable}set trainable(e){this._trainable=e,null!=this.forwardLayer&&(this.forwardLayer.trainable=e),null!=this.backwardLayer&&(this.backwardLayer.trainable=e)}getWeights(){return this.forwardLayer.getWeights().concat(this.backwardLayer.getWeights())}setWeights(e){const t=e.length,r=Math.floor(t/2);this.forwardLayer.setWeights(e.slice(0,r)),this.backwardLayer.setWeights(e.slice(r))}computeOutputShape(e){let t,r,a,i=this.forwardLayer.computeOutputShape(e);return Array.isArray(i)&&Array.isArray(i[0])||(i=[i]),i=i,this.returnState?(a=i.slice(1),t=i[0]):t=i[0],t=t,"concat"===this.mergeMode?(t[t.length-1]*=2,r=[t]):r=null==this.mergeMode?[t,t.slice()]:[t],this.returnState?null==this.mergeMode?r.concat(a).concat(a.slice()):[t].concat(a).concat(a.slice()):l.singletonOrArray(r)}apply(e,t){let r=null==t?null:t.initialState,a=null==t?null:t.constants;null==t&&(t={});const n=(0,c.standardizeArgs)(e,r,a,this.numConstants);if(e=n.inputs,r=n.initialState,a=n.constants,Array.isArray(e)&&(r=e.slice(1),e=e[0]),(null==r||0===r.length)&&null==a)return super.apply(e,t);const l=[],o=[];if(null!=r){const e=r.length;if(e%2>0)throw new s.ValueError("When passing `initialState` to a Bidrectional RNN, the state should be an Array containing the states of the underlying RNNs.");t.initialState=r,l.push(...r);const a=r.map(e=>new i.InputSpec({shape:e.shape}));this.forwardLayer.stateSpec=a.slice(0,e/2),this.backwardLayer.stateSpec=a.slice(e/2),o.push(...a)}if(null!=a)throw new s.NotImplementedError("Support for constants in Bidirectional layers is not implemented yet.");const u=l[0]instanceof i.SymbolicTensor;for(const c of l)if(c instanceof i.SymbolicTensor!==u)throw new s.ValueError("The initial state of a Bidirectional layer cannot be specified as a mix of symbolic and non-symbolic tensors");if(u){const r=[e].concat(l),a=this.inputSpec.concat(o),i=this.inputSpec;this.inputSpec=a;const s=super.apply(r,t);return this.inputSpec=i,s}return super.apply(e,t)}call(a,i){return(0,e.tidy)(()=>{const e=i.initialState;let s,n,l,o;if(null==e)s=this.forwardLayer.call(a,i),n=this.backwardLayer.call(a,i);else{const t=e.slice(0,e.length/2),r=e.slice(e.length/2);s=this.forwardLayer.call(a,Object.assign(i,{initialState:t})),n=this.backwardLayer.call(a,Object.assign(i,{initialState:r}))}return this.returnState&&(Array.isArray(s)&&(l=s.slice(1).concat(n.slice(1))),s=s[0],n=n[0]),this.returnSequences&&(n=t.reverse(n,1)),"concat"===this.mergeMode?o=r.concatenate([s,n]):"sum"===this.mergeMode?o=t.add(s,n):"ave"===this.mergeMode?o=t.mul(.5,t.add(s,n)):"mul"===this.mergeMode?o=t.mul(s,n):null==this.mergeMode&&(o=[s,n]),this.returnState?null==this.mergeMode?o.concat(l):[o].concat(l):o})}resetStates(e){this.forwardLayer.resetStates(),this.backwardLayer.resetStates()}build(e){(0,a.nameScope)(this.forwardLayer.name,()=>{this.forwardLayer.build(e)}),(0,a.nameScope)(this.backwardLayer.name,()=>{this.backwardLayer.build(e)}),this.built=!0}computeMask(e,t){let r;if(Array.isArray(t)&&(t=t[0]),r=this.returnSequences?null==this.mergeMode?[t,t]:t:null==this.mergeMode?[null,null]:null,this.returnState){const e=this.forwardLayer.states.map(e=>null);return Array.isArray(r)?r.concat(e).concat(e):[r].concat(e).concat(e)}return r}get trainableWeights(){return this.forwardLayer.trainableWeights.concat(this.backwardLayer.trainableWeights)}get nonTrainableWeights(){return this.forwardLayer.nonTrainableWeights.concat(this.backwardLayer.nonTrainableWeights)}setFastWeightInitDuringBuild(e){super.setFastWeightInitDuringBuild(e),null!=this.forwardLayer&&this.forwardLayer.setFastWeightInitDuringBuild(e),null!=this.backwardLayer&&this.backwardLayer.setFastWeightInitDuringBuild(e)}getConfig(){const e={mergeMode:this.mergeMode},t=super.getConfig();return Object.assign(e,t),e}static fromConfig(e,t){const r=(0,u.deserialize)(t.layer);if(delete t.layer,null!=t.numConstants)throw new s.NotImplementedError("Deserialization of a Bidirectional layer with numConstants present is not supported yet.");const a=t;return a.layer=r,new e(a)}}exports.Bidirectional=f,f.className="Bidirectional",e.serialization.registerClass(f);
},{"@tensorflow/tfjs-core":"kSBl","../backend/tfjs_backend":"Ftmo","../common":"sR6u","../engine/topology":"wHpB","../errors":"iJtr","../keras_format/common":"pmP2","../utils/generic_utils":"VKwv","../utils/types_utils":"mOET","./recurrent":"SdIK","./serialization":"bKFn"}],"UbXx":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.Rescaling=void 0;var e=require("../../engine/topology"),t=require("@tensorflow/tfjs-core"),s=require("../../utils/types_utils"),r=o(require("../../backend/tfjs_backend"));function o(e,t){if("function"==typeof WeakMap)var s=new WeakMap,r=new WeakMap;return(o=function(e,t){if(!t&&e&&e.__esModule)return e;var o,n,i={__proto__:null,default:e};if(null===e||"object"!=typeof e&&"function"!=typeof e)return i;if(o=t?r:s){if(o.has(e))return o.get(e);o.set(e,i)}for(const s in e)"default"!==s&&{}.hasOwnProperty.call(e,s)&&((n=(o=Object.defineProperty)&&Object.getOwnPropertyDescriptor(e,s))&&(n.get||n.set)?o(i,s,n):i[s]=e[s]);return i})(e,t)}class n extends e.Layer{constructor(e){super(e),this.scale=e.scale,e.offset?this.offset=e.offset:this.offset=0}getConfig(){const e={scale:this.scale,offset:this.offset},t=super.getConfig();return Object.assign(e,t),e}call(e,o){return(0,t.tidy)(()=>("float32"!==(e=(0,s.getExactlyOneTensor)(e)).dtype&&(e=r.cast(e,"float32")),(0,t.add)((0,t.mul)(e,this.scale),this.offset)))}}exports.Rescaling=n,n.className="Rescaling",t.serialization.registerClass(n);
},{"../../engine/topology":"wHpB","@tensorflow/tfjs-core":"kSBl","../../utils/types_utils":"mOET","../../backend/tfjs_backend":"Ftmo"}],"GuPQ":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.CenterCrop=void 0;var t=require("@tensorflow/tfjs-core"),e=require("../../utils/types_utils"),r=require("../../engine/topology"),i=n(require("../../backend/tfjs_backend"));function n(t,e){if("function"==typeof WeakMap)var r=new WeakMap,i=new WeakMap;return(n=function(t,e){if(!e&&t&&t.__esModule)return t;var n,s,h={__proto__:null,default:t};if(null===t||"object"!=typeof t&&"function"!=typeof t)return h;if(n=e?i:r){if(n.has(t))return n.get(t);n.set(t,h)}for(const r in t)"default"!==r&&{}.hasOwnProperty.call(t,r)&&((s=(n=Object.defineProperty)&&Object.getOwnPropertyDescriptor(t,r))&&(s.get||s.set)?n(h,r,s):h[r]=t[r]);return h})(t,e)}const{resizeBilinear:s,cropAndResize:h}=t.image;class o extends r.Layer{constructor(t){super(t),this.height=t.height,this.width=t.width}centerCrop(r,n,s,o,a,u,c,l){return(0,t.tidy)(()=>{let p,g=!1;const f=[n/u,s/c,(o+n)/u,(a+s)/c],d=[];3===r.rank?(g=!0,p=(0,t.stack)([r])):p=r;for(let t=0;t<p.shape[0];t++)d.push(f);const y=(0,t.tensor)(d,[d.length,4]),w=(0,t.range)(0,d.length,1,"int32"),C=h(p,y,w,[o,a],"nearest");return g?i.cast((0,e.getExactlyOneTensor)((0,t.unstack)(C)),l):i.cast(C,l)})}upsize(e,r,n,h){return(0,t.tidy)(()=>{const t=s(e,[r,n]);return i.cast(t,h)})}call(r,i){return(0,t.tidy)(()=>{const t=(0,e.getExactlyOneTensor)(r),i=t.dtype,n=t.shape,s=n[n.length-3],h=n[n.length-2];let o=0;s!==this.height&&(o=Math.floor((s-this.height)/2));let a=0;return h!==this.width&&0===(a=Math.floor((h-this.width)/2))&&(a=1),o>=0&&a>=0?this.centerCrop(t,o,a,this.height,this.width,s,h,i):this.upsize(r,this.height,this.width,i)})}getConfig(){const t={height:this.height,width:this.width},e=super.getConfig();return Object.assign(t,e),t}computeOutputShape(t){const r=(t=(0,e.getExactlyOneShape)(t)).length-3,i=t.length-2;return t[r]=this.height,t[i]=this.width,t}}exports.CenterCrop=o,o.className="CenterCrop",t.serialization.registerClass(o);
},{"@tensorflow/tfjs-core":"kSBl","../../utils/types_utils":"mOET","../../engine/topology":"wHpB","../../backend/tfjs_backend":"Ftmo"}],"tx1a":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.encodeCategoricalInputs=u;var e=require("@tensorflow/tfjs-core"),t=require("../../utils/types_utils"),n=require("../../errors"),r=o(require("../../backend/tfjs_backend"));function o(e,t){if("function"==typeof WeakMap)var n=new WeakMap,r=new WeakMap;return(o=function(e,t){if(!t&&e&&e.__esModule)return e;var o,u,i={__proto__:null,default:e};if(null===e||"object"!=typeof e&&"function"!=typeof e)return i;if(o=t?r:n){if(o.has(e))return o.get(e);o.set(e,i)}for(const n in e)"default"!==n&&{}.hasOwnProperty.call(e,n)&&((u=(o=Object.defineProperty)&&Object.getOwnPropertyDescriptor(e,n))&&(u.get||u.set)?o(i,n,u):i[n]=e[n]);return i})(e,t)}function u(o,u,i,s){let a=(0,t.getExactlyOneTensor)(o);if("int32"!==a.dtype&&(a=r.cast(a,"int32")),"int"===u)return a;const p=a.shape;if(0===a.rank&&(a=(0,e.expandDims)(a,-1)),"oneHot"===u&&1!==a.shape[a.shape.length-1]&&(a=(0,e.expandDims)(a,-1)),a.rank>2)throw new n.ValueError("When outputMode is not int, maximum output rank is 2"+` Received outputMode ${u} and input shape ${p}`+` which would result in output rank ${a.rank}.`);const f=["multiHot","oneHot"].includes(u),c=a;let d;if(d=void 0!==s&&"count"===u?(0,e.denseBincount)(c,s,i,f):(0,e.denseBincount)(c,[],i,f),"tfIdf"!==u)return d;if(s)return(0,e.mul)(d,s);throw new n.ValueError("When outputMode is 'tfIdf', weights must be provided.")}
},{"@tensorflow/tfjs-core":"kSBl","../../utils/types_utils":"mOET","../../errors":"iJtr","../../backend/tfjs_backend":"Ftmo"}],"TBFc":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.CategoryEncoding=void 0;var e=require("../../engine/topology"),t=require("@tensorflow/tfjs-core"),n=require("../../utils/types_utils"),o=require("../../errors"),u=s(require("../../backend/tfjs_backend")),r=s(require("./preprocessing_utils"));function s(e,t){if("function"==typeof WeakMap)var n=new WeakMap,o=new WeakMap;return(s=function(e,t){if(!t&&e&&e.__esModule)return e;var u,r,s={__proto__:null,default:e};if(null===e||"object"!=typeof e&&"function"!=typeof e)return s;if(u=t?o:n){if(u.has(e))return u.get(e);u.set(e,s)}for(const n in e)"default"!==n&&{}.hasOwnProperty.call(e,n)&&((r=(u=Object.defineProperty)&&Object.getOwnPropertyDescriptor(e,n))&&(r.get||r.set)?u(s,n,r):s[n]=e[n]);return s})(e,t)}class i extends e.Layer{constructor(e){super(e),this.numTokens=e.numTokens,e.outputMode?this.outputMode=e.outputMode:this.outputMode="multiHot"}getConfig(){const e={numTokens:this.numTokens,outputMode:this.outputMode},t=super.getConfig();return Object.assign(e,t),e}computeOutputShape(e){return null==(e=(0,n.getExactlyOneShape)(e))?[this.numTokens]:"oneHot"===this.outputMode&&1!==e[e.length-1]?(e.push(this.numTokens),e):(e[e.length-1]=this.numTokens,e)}call(e,s){return(0,t.tidy)(()=>{let i;if("int32"!==(e=(0,n.getExactlyOneTensor)(e)).dtype&&(e=u.cast(e,"int32")),void 0!==s.countWeights){if("count"!==this.outputMode)throw new o.ValueError(`countWeights is not used when outputMode !== count.\n              Received countWeights=${s.countWeights}`);i=(0,n.getExactlyOneTensor)(s.countWeights)}const a=(0,t.max)(e),c=(0,t.min)(e),p=(0,t.greater)(this.numTokens,a).bufferSync().get(0),l=(0,t.greaterEqual)(c,0).bufferSync().get(0);if(!p||!l)throw new o.ValueError("Input values must be between 0 < values <="+` numTokens with numTokens=${this.numTokens}`);return r.encodeCategoricalInputs(e,this.outputMode,this.numTokens,i)})}}exports.CategoryEncoding=i,i.className="CategoryEncoding",t.serialization.registerClass(i);
},{"../../engine/topology":"wHpB","@tensorflow/tfjs-core":"kSBl","../../utils/types_utils":"mOET","../../errors":"iJtr","../../backend/tfjs_backend":"Ftmo","./preprocessing_utils":"tx1a"}],"zub4":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.Resizing=void 0;var t=require("@tensorflow/tfjs-core"),e=require("../../engine/topology"),i=require("../../errors"),r=require("../../utils/types_utils");const o=["bilinear","nearest"],s=new Set(o);class n extends e.Layer{constructor(t){if(super(t),this.height=t.height,this.width=t.width,t.interpolation){if(!s.has(t.interpolation))throw new i.ValueError(`Invalid interpolation parameter: ${t.interpolation} is not implemented`);this.interpolation=t.interpolation}else this.interpolation="bilinear";this.cropToAspectRatio=Boolean(t.cropToAspectRatio)}computeOutputShape(t){const e=(t=(0,r.getExactlyOneShape)(t))[2];return[this.height,this.width,e]}getConfig(){const t={height:this.height,width:this.width,interpolation:this.interpolation,cropToAspectRatio:this.cropToAspectRatio},e=super.getConfig();return Object.assign(t,e),t}call(e,i){return(0,t.tidy)(()=>{const i=[this.height,this.width];if("bilinear"===this.interpolation)return t.image.resizeBilinear(e,i,!this.cropToAspectRatio);if("nearest"===this.interpolation)return t.image.resizeNearestNeighbor(e,i,!this.cropToAspectRatio);throw new Error(`Interpolation is ${this.interpolation} but only ${[...s]} are supported`)})}}exports.Resizing=n,n.className="Resizing",t.serialization.registerClass(n);
},{"@tensorflow/tfjs-core":"kSBl","../../engine/topology":"wHpB","../../errors":"iJtr","../../utils/types_utils":"mOET"}],"eSK0":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.RandomSeed=void 0;class e{constructor(e){this.seed=e}next(){if(void 0!==this.seed)return this.seed++}}exports.RandomSeed=e,e.className="RandomSeed";
},{}],"gNOq":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.BaseRandomLayer=void 0;var e=require("./topology"),r=require("../backend/random_seed");class s extends e.Layer{constructor(e){super(e),this.randomGenerator=new r.RandomSeed(e.seed)}getConfig(){const e={seed:this.randomGenerator.seed},r=super.getConfig();return Object.assign(e,r),e}}exports.BaseRandomLayer=s,s.className="BaseRandomLayer";
},{"./topology":"wHpB","../backend/random_seed":"eSK0"}],"XMyw":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.RandomWidth=exports.INTERPOLATION_METHODS=void 0;var t=require("@tensorflow/tfjs-core"),e=require("../../utils/types_utils"),r=require("../../errors"),i=require("../../engine/base_random_layer");const o=["bilinear","nearest"],s=exports.INTERPOLATION_METHODS=new Set(o);class a extends i.BaseRandomLayer{constructor(t){super(t);const{factor:e,interpolation:i="bilinear"}=t;if(this.factor=e,Array.isArray(this.factor)&&2===this.factor.length)this.widthLower=this.factor[0],this.widthUpper=this.factor[1];else{if(Array.isArray(this.factor)||!(this.factor>0))throw new r.ValueError(`Invalid factor: ${this.factor}. Must be positive number or tuple of 2 numbers`);this.widthLower=-this.factor,this.widthUpper=this.factor}if(this.widthLower<-1||this.widthUpper<-1)throw new r.ValueError(`factor must have values larger than -1. Got: ${this.factor}`);if(this.widthUpper<this.widthLower)throw new r.ValueError(`factor cannot have upper bound less than lower bound.\n        Got upper bound: ${this.widthUpper}.\n        Got lower bound: ${this.widthLower}\n      `);if(i){if(!s.has(i))throw new r.ValueError(`Invalid interpolation parameter: ${i} is not implemented`);this.interpolation=i}}getConfig(){const t={factor:this.factor,interpolation:this.interpolation},e=super.getConfig();return Object.assign(t,e),t}computeOutputShape(t){const r=(t=(0,e.getExactlyOneShape)(t))[2];return[this.imgHeight,-1,r]}call(r,i){return(0,t.tidy)(()=>{const i=(0,e.getExactlyOneTensor)(r);this.imgHeight=i.shape[i.shape.length-3];const o=i.shape[i.shape.length-2];this.widthFactor=(0,t.randomUniform)([1],1+this.widthLower,1+this.widthUpper,"float32",this.randomGenerator.next());let a=this.widthFactor.dataSync()[0]*o;a=Math.round(a);const n=[this.imgHeight,a];switch(this.interpolation){case"bilinear":return t.image.resizeBilinear(r,n);case"nearest":return t.image.resizeNearestNeighbor(r,n);default:throw new Error(`Interpolation is ${this.interpolation}\n          but only ${[...s]} are supported`)}})}}exports.RandomWidth=a,a.className="RandomWidth",t.serialization.registerClass(a);
},{"@tensorflow/tfjs-core":"kSBl","../../utils/types_utils":"mOET","../../errors":"iJtr","../../engine/base_random_layer":"gNOq"}],"Ceu1":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),Object.defineProperty(exports,"Layer",{enumerable:!0,get:function(){return n.Layer}}),Object.defineProperty(exports,"RNN",{enumerable:!0,get:function(){return d.RNN}}),Object.defineProperty(exports,"RNNCell",{enumerable:!0,get:function(){return d.RNNCell}}),exports.activation=k,exports.add=Z,exports.alphaDropout=Ge,exports.average=H,exports.averagePooling1d=re,exports.averagePooling2d=ie,exports.averagePooling3d=ae,exports.avgPool1d=oe,exports.avgPool2d=ue,exports.avgPool3d=pe,exports.avgPooling1d=te,exports.avgPooling2d=se,exports.avgPooling3d=le,exports.batchNormalization=$,exports.bidirectional=Me,exports.categoryEncoding=Be,exports.centerCrop=Oe,exports.concatenate=J,exports.conv1d=M,exports.conv2d=h,exports.conv2dTranspose=S,exports.conv3d=A,exports.conv3dTranspose=U,exports.convLstm2d=Ne,exports.convLstm2dCell=Re,exports.cropping2D=T,exports.dense=j,exports.depthwiseConv2d=G,exports.dot=Y,exports.dropout=O,exports.elu=b,exports.embedding=I,exports.flatten=B,exports.gaussianDropout=ze,exports.gaussianNoise=Te,exports.globalAveragePooling1d=ce,exports.globalAveragePooling2d=xe,exports.globalMaxPool2d=exports.globalMaxPool1d=void 0,exports.globalMaxPooling1d=ge,exports.globalMaxPooling2d=de,exports.gru=ve,exports.gruCell=Pe,Object.defineProperty(exports,"input",{enumerable:!0,get:function(){return r.input}}),exports.inputLayer=D,exports.layerNormalization=ee,exports.leakyReLU=N,exports.lstm=ye,exports.lstmCell=De,exports.masking=ke,exports.maxPool2d=exports.maxPool1d=void 0,exports.maxPooling1d=fe,exports.maxPooling2d=we,exports.maxPooling3d=me,exports.maximum=K,exports.minimum=Q,exports.multiply=X,exports.permute=F,exports.prelu=R,exports.randomWidth=Ve,exports.reLU=C,exports.repeatVector=V,exports.rescaling=je,exports.reshape=W,exports.resizing=Ee,exports.rnn=qe,exports.separableConv2d=_,exports.simpleRNN=be,exports.simpleRNNCell=Ce,exports.softmax=q,exports.spatialDropout1d=E,exports.stackedRNNCells=Le,exports.thresholdedReLU=L,exports.timeDistributed=he,exports.upSampling2d=z,exports.zeroPadding2d=ne;var e=require("./engine/input_layer"),n=require("./engine/topology"),r=require("./exports"),o=require("./layers/advanced_activations"),t=require("./layers/convolutional"),i=require("./layers/convolutional_depthwise"),u=require("./layers/convolutional_recurrent"),s=require("./layers/core"),a=require("./layers/embeddings"),p=require("./layers/merge"),l=require("./layers/noise"),c=require("./layers/normalization"),x=require("./layers/padding"),g=require("./layers/pooling"),d=require("./layers/recurrent"),f=require("./layers/wrappers"),w=require("./layers/preprocessing/image_preprocessing"),m=require("./layers/preprocessing/center_crop"),v=require("./layers/preprocessing/category_encoding"),P=require("./layers/preprocessing/image_resizing"),y=require("./layers/preprocessing/random_width");function D(n){return new e.InputLayer(n)}function b(e){return new o.ELU(e)}function C(e){return new o.ReLU(e)}function N(e){return new o.LeakyReLU(e)}function R(e){return new o.PReLU(e)}function q(e){return new o.Softmax(e)}function L(e){return new o.ThresholdedReLU(e)}function M(e){return new t.Conv1D(e)}function h(e){return new t.Conv2D(e)}function S(e){return new t.Conv2DTranspose(e)}function A(e){return new t.Conv3D(e)}function U(e){return new t.Conv3DTranspose(e)}function _(e){return new t.SeparableConv2D(e)}function T(e){return new t.Cropping2D(e)}function z(e){return new t.UpSampling2D(e)}function G(e){return new i.DepthwiseConv2D(e)}function k(e){return new s.Activation(e)}function j(e){return new s.Dense(e)}function O(e){return new s.Dropout(e)}function E(e){return new s.SpatialDropout1D(e)}function B(e){return new s.Flatten(e)}function V(e){return new s.RepeatVector(e)}function W(e){return new s.Reshape(e)}function F(e){return new s.Permute(e)}function I(e){return new a.Embedding(e)}function Z(e){return new p.Add(e)}function H(e){return new p.Average(e)}function J(e){return new p.Concatenate(e)}function K(e){return new p.Maximum(e)}function Q(e){return new p.Minimum(e)}function X(e){return new p.Multiply(e)}function Y(e){return new p.Dot(e)}function $(e){return new c.BatchNormalization(e)}function ee(e){return new c.LayerNormalization(e)}function ne(e){return new x.ZeroPadding2D(e)}function re(e){return new g.AveragePooling1D(e)}function oe(e){return re(e)}function te(e){return re(e)}function ie(e){return new g.AveragePooling2D(e)}function ue(e){return ie(e)}function se(e){return ie(e)}function ae(e){return new g.AveragePooling3D(e)}function pe(e){return ae(e)}function le(e){return ae(e)}function ce(e){return new g.GlobalAveragePooling1D(e)}function xe(e){return new g.GlobalAveragePooling2D(e)}function ge(e){return new g.GlobalMaxPooling1D(e)}function de(e){return new g.GlobalMaxPooling2D(e)}function fe(e){return new g.MaxPooling1D(e)}function we(e){return new g.MaxPooling2D(e)}function me(e){return new g.MaxPooling3D(e)}function ve(e){return new d.GRU(e)}function Pe(e){return new d.GRUCell(e)}function ye(e){return new d.LSTM(e)}function De(e){return new d.LSTMCell(e)}function be(e){return new d.SimpleRNN(e)}function Ce(e){return new d.SimpleRNNCell(e)}function Ne(e){return new u.ConvLSTM2D(e)}function Re(e){return new u.ConvLSTM2DCell(e)}function qe(e){return new d.RNN(e)}function Le(e){return new d.StackedRNNCells(e)}function Me(e){return new f.Bidirectional(e)}function he(e){return new f.TimeDistributed(e)}const Se=exports.globalMaxPool1d=ge,Ae=exports.globalMaxPool2d=de,Ue=exports.maxPool1d=fe,_e=exports.maxPool2d=we;function Te(e){return new l.GaussianNoise(e)}function ze(e){return new l.GaussianDropout(e)}function Ge(e){return new l.AlphaDropout(e)}function ke(e){return new s.Masking(e)}function je(e){return new w.Rescaling(e)}function Oe(e){return new m.CenterCrop(e)}function Ee(e){return new P.Resizing(e)}function Be(e){return new v.CategoryEncoding(e)}function Ve(e){return new y.RandomWidth(e)}
},{"./engine/input_layer":"xdtw","./engine/topology":"wHpB","./exports":"FxJ6","./layers/advanced_activations":"S626","./layers/convolutional":"sbhA","./layers/convolutional_depthwise":"X56d","./layers/convolutional_recurrent":"lmh8","./layers/core":"xEXF","./layers/embeddings":"Utk7","./layers/merge":"Ghc9","./layers/noise":"gWXq","./layers/normalization":"C8io","./layers/padding":"ZNII","./layers/pooling":"J0qa","./layers/recurrent":"SdIK","./layers/wrappers":"GeqG","./layers/preprocessing/image_preprocessing":"UbXx","./layers/preprocessing/center_crop":"GuPQ","./layers/preprocessing/category_encoding":"TBFc","./layers/preprocessing/image_resizing":"zub4","./layers/preprocessing/random_width":"XMyw"}],"ecf1":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.MAPE=y,exports.MSE=b,exports.binaryAccuracy=n,exports.binaryCrossentropy=o,exports.categoricalAccuracy=u,exports.categoricalCrossentropy=a,exports.cosineProximity=p,exports.mape=x,exports.meanAbsoluteError=f,exports.meanAbsolutePercentageError=l,exports.meanSquaredError=m,exports.mse=g,exports.precision=s,exports.r2Score=A,exports.recall=i,exports.sparseCategoricalAccuracy=c;var r=t(require("./losses")),e=t(require("./metrics"));function t(r,e){if("function"==typeof WeakMap)var n=new WeakMap,o=new WeakMap;return(t=function(r,e){if(!e&&r&&r.__esModule)return r;var t,c,u={__proto__:null,default:r};if(null===r||"object"!=typeof r&&"function"!=typeof r)return u;if(t=e?o:n){if(t.has(r))return t.get(r);t.set(r,u)}for(const n in r)"default"!==n&&{}.hasOwnProperty.call(r,n)&&((c=(t=Object.defineProperty)&&Object.getOwnPropertyDescriptor(r,n))&&(c.get||c.set)?t(u,n,c):u[n]=r[n]);return u})(r,e)}function n(r,t){return e.binaryAccuracy(r,t)}function o(r,t){return e.binaryCrossentropy(r,t)}function c(r,t){return e.sparseCategoricalAccuracy(r,t)}function u(r,t){return e.categoricalAccuracy(r,t)}function a(r,t){return e.categoricalCrossentropy(r,t)}function s(r,t){return e.precision(r,t)}function i(r,t){return e.recall(r,t)}function p(e,t){return r.cosineProximity(e,t)}function f(e,t){return r.meanAbsoluteError(e,t)}function l(e,t){return r.meanAbsolutePercentageError(e,t)}function y(e,t){return r.meanAbsolutePercentageError(e,t)}function x(e,t){return r.meanAbsolutePercentageError(e,t)}function m(e,t){return r.meanSquaredError(e,t)}function b(e,t){return r.meanSquaredError(e,t)}function g(e,t){return r.meanSquaredError(e,t)}function A(r,t){return e.r2Score(r,t)}
},{"./losses":"EG90","./metrics":"kNCu"}],"Oyoc":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),Object.defineProperty(exports,"modelFromJSON",{enumerable:!0,get:function(){return e.modelFromJSON}});var e=require("./models");
},{"./models":"GBM9"}],"yTCt":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.l1=o,exports.l1l2=n,exports.l2=u;var e=r(require("./regularizers")),t=e;function r(e,t){if("function"==typeof WeakMap)var n=new WeakMap,o=new WeakMap;return(r=function(e,t){if(!t&&e&&e.__esModule)return e;var r,u,f={__proto__:null,default:e};if(null===e||"object"!=typeof e&&"function"!=typeof e)return f;if(r=t?o:n){if(r.has(e))return r.get(e);r.set(e,f)}for(const n in e)"default"!==n&&{}.hasOwnProperty.call(e,n)&&((u=(r=Object.defineProperty)&&Object.getOwnPropertyDescriptor(e,n))&&(u.get||u.set)?r(f,n,u):f[n]=e[n]);return f})(e,t)}function n(t){return new e.L1L2(t)}function o(e){return t.l1(e)}function u(e){return t.l2(e)}
},{"./regularizers":"TEkX"}],"m0xP":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.callbacks=exports.EarlyStopping=exports.Callback=void 0,exports.earlyStopping=l;var t=require("./base_callbacks"),e=require("./engine/training"),o=require("./errors"),i=require("./logs");class s extends t.BaseCallback{constructor(){super(...arguments),this.model=null}setModel(t){if(!(t instanceof e.LayersModel))throw new Error("model must be a LayersModel, not some other Container");this.model=t}}function n(t,e){return t<e}function r(t,e){return t>e}exports.Callback=s;class a extends s{constructor(t){if(super(),null==t&&(t={}),t.restoreBestWeights)throw new o.NotImplementedError("restoreBestWeights = True is not implemented in EarlyStopping yet.");this.monitor=t.monitor||"val_loss",this.minDelta=Math.abs(t.minDelta||0),this.patience=t.patience||0,this.verbose=t.verbose||0,this.mode=t.mode||"auto",this.baseline=t.baseline,-1===["auto","min","max"].indexOf(this.mode)&&(console.warn(`EarlyStopping mode '${this.mode}' is invalid. `+"Falling back to mode 'auto'."),this.mode="auto"),"min"===this.mode?this.monitorFunc=n:"max"===this.mode?this.monitorFunc=r:-1!==this.monitor.indexOf("acc")?this.monitorFunc=r:this.monitorFunc=n,this.monitorFunc===n&&(this.minDelta*=-1)}async onTrainBegin(t){this.wait=0,this.stoppedEpoch=0,null!=this.baseline?this.best=this.baseline:this.best=this.monitorFunc===n?1/0:-1/0}async onEpochEnd(t,e){await(0,i.resolveScalarsInLogs)(e);const o=this.getMonitorValue(e);null!=o&&(this.monitorFunc(o-this.minDelta,this.best)?(this.best=o,this.wait=0):(this.wait++,this.wait>=this.patience&&(this.stoppedEpoch=t,this.model.stopTraining=!0)))}async onTrainEnd(t){this.stoppedEpoch>0&&this.verbose&&console.log(`Epoch ${this.stoppedEpoch}: early stopping.`)}getMonitorValue(t){null==t&&(t={});const e=t[this.monitor];return null==e&&console.warn(`Metric for EarlyStopping ${this.monitor} is not available. `+`Available metrics are: ${Object.keys(t)}`),e}}function l(t){return new a(t)}exports.EarlyStopping=a;const h=exports.callbacks={earlyStopping:l};
},{"./base_callbacks":"GDiE","./engine/training":"BP0g","./errors":"iJtr","./logs":"gooH"}],"lHR2":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),Object.defineProperty(exports,"Callback",{enumerable:!0,get:function(){return u.Callback}}),Object.defineProperty(exports,"CallbackList",{enumerable:!0,get:function(){return s.CallbackList}}),Object.defineProperty(exports,"CustomCallback",{enumerable:!0,get:function(){return s.CustomCallback}}),Object.defineProperty(exports,"EarlyStopping",{enumerable:!0,get:function(){return u.EarlyStopping}}),Object.defineProperty(exports,"History",{enumerable:!0,get:function(){return s.History}}),Object.defineProperty(exports,"InputSpec",{enumerable:!0,get:function(){return a.InputSpec}}),Object.defineProperty(exports,"LayerVariable",{enumerable:!0,get:function(){return f.LayerVariable}}),Object.defineProperty(exports,"LayersModel",{enumerable:!0,get:function(){return l.LayersModel}}),Object.defineProperty(exports,"RNN",{enumerable:!0,get:function(){return p.RNN}}),Object.defineProperty(exports,"Sequential",{enumerable:!0,get:function(){return b.Sequential}}),Object.defineProperty(exports,"SymbolicTensor",{enumerable:!0,get:function(){return a.SymbolicTensor}}),Object.defineProperty(exports,"callbacks",{enumerable:!0,get:function(){return u.callbacks}}),exports.initializers=exports.constraints=void 0,Object.defineProperty(exports,"input",{enumerable:!0,get:function(){return c.input}}),exports.layers=void 0,Object.defineProperty(exports,"loadLayersModel",{enumerable:!0,get:function(){return c.loadLayersModel}}),exports.metrics=void 0,Object.defineProperty(exports,"model",{enumerable:!0,get:function(){return c.model}}),exports.models=void 0,Object.defineProperty(exports,"registerCallbackConstructor",{enumerable:!0,get:function(){return c.registerCallbackConstructor}}),exports.regularizers=void 0,Object.defineProperty(exports,"sequential",{enumerable:!0,get:function(){return c.sequential}}),Object.defineProperty(exports,"version_layers",{enumerable:!0,get:function(){return y.version}}),require("./flags_layers"),require("@tensorflow/tfjs-core"),require("@tensorflow/tfjs-core/dist/register_all_gradients");var e=d(require("./exports_constraints"));exports.constraints=e;var r=d(require("./exports_initializers"));exports.initializers=r;var t=d(require("./exports_layers"));exports.layers=t;var n=d(require("./exports_metrics"));exports.metrics=n;var o=d(require("./exports_models"));exports.models=o;var i=d(require("./exports_regularizers"));exports.regularizers=i;var s=require("./base_callbacks"),u=require("./callbacks"),a=require("./engine/topology"),l=require("./engine/training"),c=require("./exports"),p=require("./layers/recurrent"),b=require("./models"),f=require("./variables"),y=require("./version");function d(e,r){if("function"==typeof WeakMap)var t=new WeakMap,n=new WeakMap;return(d=function(e,r){if(!r&&e&&e.__esModule)return e;var o,i,s={__proto__:null,default:e};if(null===e||"object"!=typeof e&&"function"!=typeof e)return s;if(o=r?n:t){if(o.has(e))return o.get(e);o.set(e,s)}for(const t in e)"default"!==t&&{}.hasOwnProperty.call(e,t)&&((i=(o=Object.defineProperty)&&Object.getOwnPropertyDescriptor(e,t))&&(i.get||i.set)?o(s,t,i):s[t]=e[t]);return s})(e,r)}
},{"./flags_layers":"FSKJ","@tensorflow/tfjs-core":"kSBl","@tensorflow/tfjs-core/dist/register_all_gradients":"qJ5u","./exports_constraints":"E5bG","./exports_initializers":"hrGI","./exports_layers":"Ceu1","./exports_metrics":"ecf1","./exports_models":"Oyoc","./exports_regularizers":"yTCt","./base_callbacks":"GDiE","./callbacks":"m0xP","./engine/topology":"wHpB","./engine/training":"BP0g","./exports":"FxJ6","./layers/recurrent":"SdIK","./models":"GBM9","./variables":"mwlr","./version":"KPnh"}],"ZvkN":[function(require,module,exports) {
"use strict";var e=require("@tensorflow/tfjs-core");const s=(0,e.env)();s.registerFlag("KEEP_INTERMEDIATE_TENSORS",()=>!1,e=>{e&&console.warn("Keep intermediate tensors is ON. This will print the values of all intermediate tensors during model inference. Not all models support this mode. For details, check e2e/benchmarks/ model_config.js. This significantly impacts performance.")});
},{"@tensorflow/tfjs-core":"kSBl"}],"vYlf":[function(require,module,exports) {
"use strict";var T,_;Object.defineProperty(exports,"__esModule",{value:!0}),exports.SaverDef=exports.DataType=void 0,function(T){T[T.DT_INVALID=0]="DT_INVALID",T[T.DT_FLOAT=1]="DT_FLOAT",T[T.DT_DOUBLE=2]="DT_DOUBLE",T[T.DT_INT32=3]="DT_INT32",T[T.DT_UINT8=4]="DT_UINT8",T[T.DT_INT16=5]="DT_INT16",T[T.DT_INT8=6]="DT_INT8",T[T.DT_STRING=7]="DT_STRING",T[T.DT_COMPLEX64=8]="DT_COMPLEX64",T[T.DT_INT64=9]="DT_INT64",T[T.DT_BOOL=10]="DT_BOOL",T[T.DT_QINT8=11]="DT_QINT8",T[T.DT_QUINT8=12]="DT_QUINT8",T[T.DT_QINT32=13]="DT_QINT32",T[T.DT_BFLOAT16=14]="DT_BFLOAT16",T[T.DT_QINT16=15]="DT_QINT16",T[T.DT_QUINT16=16]="DT_QUINT16",T[T.DT_UINT16=17]="DT_UINT16",T[T.DT_COMPLEX128=18]="DT_COMPLEX128",T[T.DT_HALF=19]="DT_HALF",T[T.DT_RESOURCE=20]="DT_RESOURCE",T[T.DT_VARIANT=21]="DT_VARIANT",T[T.DT_UINT32=22]="DT_UINT32",T[T.DT_UINT64=23]="DT_UINT64",T[T.DT_FLOAT_REF=101]="DT_FLOAT_REF",T[T.DT_DOUBLE_REF=102]="DT_DOUBLE_REF",T[T.DT_INT32_REF=103]="DT_INT32_REF",T[T.DT_UINT8_REF=104]="DT_UINT8_REF",T[T.DT_INT16_REF=105]="DT_INT16_REF",T[T.DT_INT8_REF=106]="DT_INT8_REF",T[T.DT_STRING_REF=107]="DT_STRING_REF",T[T.DT_COMPLEX64_REF=108]="DT_COMPLEX64_REF",T[T.DT_INT64_REF=109]="DT_INT64_REF",T[T.DT_BOOL_REF=110]="DT_BOOL_REF",T[T.DT_QINT8_REF=111]="DT_QINT8_REF",T[T.DT_QUINT8_REF=112]="DT_QUINT8_REF",T[T.DT_QINT32_REF=113]="DT_QINT32_REF",T[T.DT_BFLOAT16_REF=114]="DT_BFLOAT16_REF",T[T.DT_QINT16_REF=115]="DT_QINT16_REF",T[T.DT_QUINT16_REF=116]="DT_QUINT16_REF",T[T.DT_UINT16_REF=117]="DT_UINT16_REF",T[T.DT_COMPLEX128_REF=118]="DT_COMPLEX128_REF",T[T.DT_HALF_REF=119]="DT_HALF_REF",T[T.DT_RESOURCE_REF=120]="DT_RESOURCE_REF",T[T.DT_VARIANT_REF=121]="DT_VARIANT_REF",T[T.DT_UINT32_REF=122]="DT_UINT32_REF",T[T.DT_UINT64_REF=123]="DT_UINT64_REF"}(T||(exports.DataType=T={})),function(T){let _;!function(T){T[T.LEGACY=0]="LEGACY",T[T.V1=1]="V1",T[T.V2=2]="V2"}(_=T.CheckpointFormatVersion||(T.CheckpointFormatVersion={}))}(_||(exports.SaverDef=_={}));
},{}],"LNan":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.deregisterOp=s,exports.getRegisteredOp=r,exports.registerOp=t;const e={};function t(t,r){const s={tfOpName:t,category:"custom",inputs:[],attrs:[],customExecutor:r};e[t]=s}function r(t){return e[t]}function s(t){delete e[t]}
},{}],"eBau":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.cloneTensor=c,exports.getNodeNameAndIndex=o,exports.getPadding=a,exports.getParamValue=t,exports.getTensor=n,exports.getTensorsForCurrentContext=r,exports.parseNodeName=i,exports.split=u;var e=require("@tensorflow/tfjs-core");function t(t,r,o,s,i){const u=r.inputParams[t];if(u&&void 0!==u.inputIndexStart){const t=u.inputIndexStart,a=0===u.inputIndexEnd?void 0:void 0===u.inputIndexEnd?t+1:u.inputIndexEnd,c=t<0?r.inputNames.length+t:t;if("tensor"===u.type)return n(r.inputNames[c],o,s,i);if("tensors"===u.type){const e=r.inputs.slice(t,a);return r.inputNames.slice(t,a).filter((t,n)=>{var r;return"NoOp"!==(null===(r=e[n])||void 0===r?void 0:r.op)}).map(e=>n(e,o,s,i))}const l=n(r.inputNames[c],o,s,i),d=l.dataSync();return"number"===u.type?d[0]:e.util.toNestedArray(l.shape,d)}const a=r.attrParams[t];return a&&a.value}function n(e,t,n,r){const[o,u]=i(e,n);if(null!=r){const e=r.getHashTableHandleByName(o);if(null!=e)return e}const a=n.currentContextIds.find(e=>!!t[s(o,e)]);return void 0!==a?t[s(o,a)][u]:void 0}function r(e,t,n){return t[s(e,n.currentContextId)]}function o(e,t){const[n,r,o]=i(e,t);return[s(n,t&&t.currentContextId),r,o]}function s(e,t){return t?`${e}-${t}`:e}function i(e,t){if(""===e)return["",0,void 0];const n=null!=t&&null!=t.parseNodeNameCache;if(n){const n=t.parseNodeNameCache.get(e);if(null!=n)return n}const r=e.split(":");let o;if(1===r.length)o=[e,0,void 0];else{const e=r[0],t=3===r.length?r[1]:void 0;o=[e,Number(r[r.length-1]),t]}return n&&t.parseNodeNameCache.set(e,o),o}function u(e,t){const n=[];for(let r=0;r<e.length;r+=t)n.push(e.slice(r,r+t));return n}function a(e,n,r){let o=t("pad",e,n,r);if("explicit"===o){o=t("explicitPaddings",e,n,r);const s=[[0,0],[0,0],[0,0],[0,0]];for(let e=0;e<4;e++)s[e][0]=o[2*e],s[e][1]=o[2*e+1];return s}return o}function c(t){return t.kept?t:(0,e.clone)(t)}
},{"@tensorflow/tfjs-core":"kSBl"}],"qkVg":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.json=void 0;const t=exports.json=[{tfOpName:"Add",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddV2",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddN",category:"arithmetic",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"BiasAdd",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"Sub",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"RealDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Div",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"DivNoNan",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mul",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Maximum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Minimum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Pow",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SquaredDifference",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorMod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}];
},{}],"gSiX":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.json=void 0;const t=exports.json=[{tfOpName:"Abs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan2",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Ceil",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ClipByValue",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"clipValueMin",type:"number"},{start:2,name:"clipValueMax",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Complex",category:"basic_math",inputs:[{start:0,name:"real",type:"tensor"},{start:1,name:"imag",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ComplexAbs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Elu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Exp",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Floor",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Imag",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Neg",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Real",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Prelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"alpha",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu6",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Selu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sigmoid",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Rsqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Square",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sign",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Round",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Expm1",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log1p",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Reciprocal",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Softplus",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Erf",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LeakyRelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"alpha",name:"alpha",type:"number",defaultValue:.2},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsNan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsFinite",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsInf",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}];
},{}],"hTO9":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.json=void 0;const e=exports.json=[{tfOpName:"EmptyTensorList",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"maxNumElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"LoopCond",category:"control",inputs:[{start:0,name:"pred",type:"tensor"}]},{tfOpName:"Switch",category:"control",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"pred",type:"tensor"}]},{tfOpName:"Merge",category:"control",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"Enter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"frame_name",name:"frameName",type:"string"},{tfName:"is_constant",name:"isConstant",type:"bool"}]},{tfOpName:"Exit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NextIteration",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayV3",category:"control",inputs:[{start:0,name:"size",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"dynamic_size",name:"dynamicSize",type:"bool"},{tfName:"clear_after_read",name:"clearAfterRead",type:"bool"},{tfName:"identical_element_shapes",name:"identicalElementShapes",type:"bool"},{tfName:"tensor_array_name",name:"name",type:"string"}]},{tfOpName:"TensorArrayWriteV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayReadV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayGatherV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"}]},{tfOpName:"TensorArrayScatterV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArrayConcatV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape_except0",name:"elementShapeExcept0",type:"shape",notSupported:!0}]},{tfOpName:"TensorArraySplitV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"tensor",type:"tensor"},{start:2,name:"lengths",type:"number[]"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArraySizeV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}]},{tfOpName:"TensorArrayCloseV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"}]},{tfOpName:"StatelessIf",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"If",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"StatelessWhile",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"While",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"TensorListScatter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListScatterV2",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"},{start:3,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGather",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListSetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListReserve",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListFromTensor",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListStack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"},{tfName:"num_elements",name:"numElements",type:"dtype"}]},{tfOpName:"TensorListSplit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"},{start:2,name:"lengths",type:"number[]"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListConcat",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}],attrs:[{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListConcatV2",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}],attrs:[{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPopBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPushBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListLength",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}]},{tfOpName:"TensorListResize",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"size",type:"number"}]}];
},{}],"zEHf":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.json=void 0;const t=exports.json=[{tfOpName:"AvgPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[],notSupported:!0},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPoolWithArgmax",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"include_batch_in_index",name:"includeBatchInIndex",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AvgPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Conv1D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"stride",name:"stride",type:"number"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NWC"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"dilation",name:"dilation",type:"number",defaultValue:1}]},{tfOpName:"Conv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"useCudnnOnGpu",name:"useCudnnOnGpu",type:"bool"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"_FusedConv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"use_cudnn_on_gpu",name:"useCudnnOnGpu",type:"bool",defaultValue:!0},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"leakyrelu_alpha",name:"leakyreluAlpha",type:"number",defaultValue:.2}]},{tfOpName:"Conv2DBackpropInput",category:"convolution",inputs:[{start:2,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:0,name:"outputShape",type:"number[]"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]",notSupported:!0}]},{tfOpName:"DepthwiseConv2d",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"DepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"FusedDepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]}]},{tfOpName:"Conv3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"Dilation2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"rates",name:"dilations",type:"number[]"},{tfName:"padding",name:"pad",type:"string"}]}];
},{}],"lWlx":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.json=void 0;const e=exports.json=[{tfOpName:"Fill",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"},{start:1,name:"value",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"LinSpace",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"num",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"OneHot",category:"creation",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"depth",type:"number"},{start:2,name:"onValue",type:"number",defaultValue:1},{start:3,name:"offValue",type:"number",defaultValue:0}],attrs:[{tfName:"axis",name:"axis",type:"number",notSupported:!0},{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"Ones",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"OnesLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"RandomStandardNormal",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"RandomUniform",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"minval",name:"minval",type:"number",defaultValue:0},{tfName:"maxval",name:"maxval",type:"number",defaultValue:1},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"RandomUniformInt",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"minval",name:"minval",type:"number"},{tfName:"maxval",name:"maxval",type:"number"},{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0}]},{tfOpName:"Range",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"step",type:"number",defaultValue:0}],attrs:[{tfName:"Tidx",name:"dtype",type:"dtype"}]},{tfOpName:"TruncatedNormal",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"means",name:"mean",type:"number",defaultValue:0},{tfName:"stddev",name:"stdDev",type:"number",defaultValue:1},{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"Zeros",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"ZerosLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"Multinomial",category:"creation",inputs:[{start:0,name:"logits",type:"tensor"},{start:1,name:"numSamples",type:"number"}],attrs:[{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number"},{tfName:"T",name:"dtype",type:"dtype"},{tfName:"output_dtype",name:"output_dtype",type:"dtype"}]}];
},{}],"n11C":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.json=void 0;const t=exports.json=[{tfOpName:"NonMaxSuppressionV2",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV3",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV4",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"T_threshold",name:"threshold",type:"dtype",notSupported:!0},{tfName:"pad_to_max_output_size",name:"padToMaxOutputSize",type:"bool"}]},{tfOpName:"NonMaxSuppressionV5",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"},{start:5,name:"softNmsSigma",type:"number"}]},{tfOpName:"Where",category:"dynamic",inputs:[{start:0,name:"condition",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ListDiff",category:"dynamic",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}];
},{}],"qR2a":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.json=void 0;const e=exports.json=[{tfOpName:"LowerBound",category:"evaluation",inputs:[{start:0,name:"sortedSequence",type:"tensor"},{start:1,name:"values",type:"tensor"}]},{tfOpName:"TopKV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"k",type:"number"}],attrs:[{tfName:"sorted",name:"sorted",type:"bool"}]},{tfOpName:"UpperBound",category:"evaluation",inputs:[{start:0,name:"sortedSequence",type:"tensor"},{start:1,name:"values",type:"tensor"}]},{tfOpName:"Unique",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"UniqueV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]}];
},{}],"ohbw":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.json=void 0;const t=exports.json=[{tfOpName:"PlaceholderWithDefault",category:"graph",inputs:[{start:0,name:"default",type:"tensor"}],attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Placeholder",category:"graph",attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Const",category:"graph"},{tfOpName:"Identity",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IdentityN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Snapshot",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Rank",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Size",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Shape",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"ShapeN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Print",category:"graph",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"data",type:"tensors"}],attrs:[{tfName:"message",name:"message",type:"string"},{tfName:"first_n",name:"firstN",type:"number",notSupported:!0},{tfName:"summarize",name:"summarize",type:"number",defaultValue:3}]},{tfOpName:"NoOp",category:"graph",inputs:[]},{tfOpName:"StopGradient",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"FakeQuantWithMinMaxVars",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"min",name:"min",type:"number"},{tfName:"max",name:"max",type:"number"}]}];
},{}],"dtjV":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.json=void 0;const e=exports.json=[{tfOpName:"HashTable",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"HashTableV2",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"LookupTableImport",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableImportV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFind",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFindV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableSize",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"}]},{tfOpName:"LookupTableSizeV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"}]},{tfOpName:"InitializeTable",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}]},{tfOpName:"InitializeTableV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}]}];
},{}],"DnM7":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.json=void 0;const e=exports.json=[{tfOpName:"ResizeBilinear",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ResizeNearestNeighbor",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"CropAndResize",category:"image",inputs:[{start:0,name:"image",type:"tensor"},{start:1,name:"boxes",type:"tensor"},{start:2,name:"boxInd",type:"tensor"},{start:3,name:"cropSize",type:"number[]"}],attrs:[{tfName:"method",name:"method",type:"string"},{tfName:"extrapolation_value",name:"extrapolationValue",type:"number"}]},{tfOpName:"ImageProjectiveTransformV3",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"transforms",type:"tensor"},{start:2,name:"outputShape",type:"number[]"},{start:3,name:"fillValue",type:"number"}],attrs:[{tfName:"interpolation",name:"interpolation",type:"string"},{tfName:"fill_mode",name:"fillMode",type:"string"}]}];
},{}],"MpO5":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.json=void 0;const t=exports.json=[{tfOpName:"Equal",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NotEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Greater",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"GreaterEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Less",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LessEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalAnd",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalNot",category:"logical",inputs:[{start:0,name:"a",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalOr",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Select",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SelectV2",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BitwiseAnd",category:"logical",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}]}];
},{}],"Tnxn":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.json=void 0;const e=exports.json=[{tfOpName:"_FusedMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"leakyrelu_alpha",name:"leakyreluAlpha",type:"number",defaultValue:.2},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMulV2",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Transpose",category:"matrices",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"perm",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Einsum",category:"matrices",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"equation",name:"equation",type:"string"},{tfName:"N",name:"n",type:"number",defaultValue:2},{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"MatrixBandPart",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"numLower",type:"tensor"},{start:1,name:"numUpper",type:"tensor"}]}];
},{}],"rf0I":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.json=void 0;const t=exports.json=[{tfOpName:"EuclideanNorm",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool",defaultValue:!1}]},{tfOpName:"FusedBatchNorm",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV2",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV3",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"LRN",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"depth_radius",name:"radius",type:"number",defaultValue:5},{tfName:"bias",name:"bias",type:"number",defaultValue:1},{tfName:"alpha",name:"alpha",type:"number",defaultValue:1},{tfName:"beta",name:"beta",type:"number",defaultValue:.5}]},{tfOpName:"Softmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"LogSoftmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]}];
},{}],"lx5W":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.json=void 0;const e=exports.json=[{tfOpName:"Bincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}]},{tfOpName:"DenseBincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}],attrs:[{tfName:"binary_output",name:"binaryOutput",type:"bool"}]},{tfOpName:"Max",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Mean",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Min",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Sum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"All",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Any",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"ArgMax",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"ArgMin",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"Prod",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cumprod",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}],attrs:[{tfName:"exclusive",name:"exclusive",type:"bool"},{tfName:"reverse",name:"reverse",type:"bool"}]},{tfOpName:"Cumsum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}],attrs:[{tfName:"exclusive",name:"exclusive",type:"bool"},{tfName:"reverse",name:"reverse",type:"bool"}]}];
},{}],"BYbb":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.json=void 0;const e=exports.json=[{tfOpName:"ConcatV2",category:"slice_join",inputs:[{start:0,end:-1,name:"tensors",type:"tensors"},{start:-1,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"Concat",category:"slice_join",inputs:[{start:1,end:0,name:"tensors",type:"tensors"},{start:0,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"GatherV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"axis",type:"number",defaultValue:0}],attrs:[{tfName:"batch_dims",name:"batchDims",type:"number",defaultValue:0}]},{tfOpName:"Gather",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",notSupported:!0}]},{tfOpName:"Reverse",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"dims",type:"bool[]"}]},{tfOpName:"ReverseV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}]},{tfOpName:"Slice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"size",type:"number[]"}]},{tfOpName:"StridedSlice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"end",type:"number[]"},{start:3,name:"strides",type:"number[]"}],attrs:[{tfName:"begin_mask",name:"beginMask",type:"number",defaultValue:0},{tfName:"end_mask",name:"endMask",type:"number",defaultValue:0},{tfName:"new_axis_mask",name:"newAxisMask",type:"number",defaultValue:0},{tfName:"ellipsis_mask",name:"ellipsisMask",type:"number",defaultValue:0},{tfName:"shrink_axis_mask",name:"shrinkAxisMask",type:"number",defaultValue:0}]},{tfOpName:"Pack",category:"slice_join",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0}]},{tfOpName:"Unpack",category:"slice_join",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0},{tfName:"num",name:"num",type:"number",defaultValue:0,notSupported:!0}]},{tfOpName:"Tile",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"reps",type:"number[]"}]},{tfOpName:"Split",category:"slice_join",inputs:[{start:0,name:"axis",type:"number",defaultValue:0},{start:1,name:"x",type:"tensor"}],attrs:[{tfName:"num_split",name:"numOrSizeSplits",type:"number",defaultValue:1}]},{tfOpName:"SplitV",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"numOrSizeSplits",type:"number[]"},{start:2,name:"axis",type:"number",defaultValue:0}]},{tfOpName:"ScatterNd",category:"slice_join",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"values",type:"tensor"},{start:2,name:"shape",type:"number[]"}]},{tfOpName:"GatherNd",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}]},{tfOpName:"SparseToDense",category:"slice_join",inputs:[{start:0,name:"sparseIndices",type:"tensor"},{start:1,name:"outputShape",type:"number[]"},{start:2,name:"sparseValues",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",defaultValue:!1,notSupported:!0}]},{tfOpName:"TensorScatterUpdate",category:"slice_join",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"values",type:"tensor"}]}];
},{}],"mrEg":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.json=void 0;const e=exports.json=[{tfOpName:"SparseFillEmptyRows",category:"sparse",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"values",type:"tensor"},{start:2,name:"denseShape",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}]},{tfOpName:"SparseReshape",category:"sparse",inputs:[{start:0,name:"inputIndices",type:"tensor"},{start:1,name:"inputShape",type:"tensor"},{start:2,name:"newShape",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SparseSegmentMean",category:"sparse",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"segmentIds",type:"tensor"}]},{tfOpName:"SparseSegmentSum",category:"sparse",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"segmentIds",type:"tensor"}]}];
},{}],"ZasE":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.json=void 0;const t=exports.json=[{tfOpName:"FFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"RFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]},{tfOpName:"IRFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]}];
},{}],"tCvz":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.json=void 0;const t=exports.json=[{tfOpName:"StaticRegexReplace",category:"string",inputs:[{start:0,name:"input",type:"tensor"}],attrs:[{tfName:"pattern",name:"pattern",type:"string"},{tfName:"rewrite",name:"rewrite",type:"string"},{tfName:"replace_global",name:"replaceGlobal",type:"bool"}]},{tfOpName:"StringNGrams",category:"string",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"dataSplits",type:"tensor"}],attrs:[{tfName:"separator",name:"separator",type:"string"},{tfName:"ngram_widths",name:"nGramWidths",type:"number[]"},{tfName:"left_pad",name:"leftPad",type:"string"},{tfName:"right_pad",name:"rightPad",type:"string"},{tfName:"pad_width",name:"padWidth",type:"number"},{tfName:"preserve_short_sequences",name:"preserveShortSequences",type:"bool"}],outputs:["ngrams","ngrams_splits"]},{tfOpName:"StringSplit",category:"string",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"delimiter",type:"tensor"}],attrs:[{tfName:"skip_empty",name:"skipEmpty",type:"bool"}],outputs:["indices","values","shape"]},{tfOpName:"StringToHashBucketFast",category:"string",inputs:[{start:0,name:"input",type:"tensor"}],attrs:[{tfName:"num_buckets",name:"numBuckets",type:"number"}]}];
},{}],"wJwh":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.json=void 0;const t=exports.json=[{tfOpName:"Cast",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"SrcT",name:"sdtype",type:"dtype",notSupported:!0},{tfName:"DstT",name:"dtype",type:"dtype"}]},{tfOpName:"ExpandDims",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"MirrorPad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"mode",name:"mode",type:"string"}]},{tfOpName:"Pad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"constant_value",name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"PadV2",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"},{start:2,name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"Reshape",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}]},{tfOpName:"EnsureShape",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}]},{tfOpName:"Squeeze",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"axis",tfDeprecatedName:"squeeze_dims",name:"axis",type:"number[]"}]},{tfOpName:"SpaceToBatchND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"paddings",type:"number[]"}]},{tfOpName:"BatchToSpaceND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"crops",type:"number[]"}]},{tfOpName:"DepthToSpace",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"block_size",name:"blockSize",type:"number"},{tfName:"data_format",name:"dataFormat",type:"string"}]},{tfOpName:"BroadcastTo",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}],attrs:[]},{tfOpName:"BroadcastArgs",category:"transformation",inputs:[{start:0,name:"s0",type:"tensor"},{start:1,name:"s1",type:"tensor"}],attrs:[]}];
},{}],"L12J":[function(require,module,exports) {
var global = arguments[3];
var Buffer = require("buffer").Buffer;
var e=arguments[3],t=require("buffer").Buffer;Object.defineProperty(exports,"__esModule",{value:!0}),exports.OperationMapper=void 0,exports.decodeBase64=O,exports.getBoolArrayParam=F,exports.getBoolParam=V,exports.getDtypeArrayParam=j,exports.getDtypeParam=S,exports.getFuncParam=E,exports.getNumberParam=I,exports.getNumericArrayParam=C,exports.getStringArrayParam=L,exports.getStringParam=q,exports.getTensorShapeArrayParam=$,exports.getTensorShapeParam=B,exports.parseDtypeParam=w,exports.parseStringParam=k,exports.parseTensorShapeParam=M;var a=require("@tensorflow/tfjs-core"),r=v(require("../data/compiled_api")),n=require("./custom_op/register"),s=require("./executors/utils"),u=v(require("./op_list/arithmetic")),o=v(require("./op_list/basic_math")),i=v(require("./op_list/control")),p=v(require("./op_list/convolution")),l=v(require("./op_list/creation")),c=v(require("./op_list/dynamic")),f=v(require("./op_list/evaluation")),d=v(require("./op_list/graph")),m=v(require("./op_list/hash_table")),h=v(require("./op_list/image")),g=v(require("./op_list/logical")),y=v(require("./op_list/matrices")),N=v(require("./op_list/normalization")),D=v(require("./op_list/reduction")),b=v(require("./op_list/slice_join")),_=v(require("./op_list/sparse")),T=v(require("./op_list/spectral")),x=v(require("./op_list/string")),P=v(require("./op_list/transformation"));function v(e,t){if("function"==typeof WeakMap)var a=new WeakMap,r=new WeakMap;return(v=function(e,t){if(!t&&e&&e.__esModule)return e;var n,s,u={__proto__:null,default:e};if(null===e||"object"!=typeof e&&"function"!=typeof e)return u;if(n=t?r:a){if(n.has(e))return n.get(e);n.set(e,u)}for(const a in e)"default"!==a&&{}.hasOwnProperty.call(e,a)&&((s=(n=Object.defineProperty)&&Object.getOwnPropertyDescriptor(e,a))&&(s.get||s.set)?n(u,a,s):u[a]=e[a]);return u})(e,t)}class A{static get Instance(){return this._instance||(this._instance=new this)}constructor(){const e=[].concat(...[u,o,i,p,l,c,f,d,m,h,g,y,N,D,b,_,T,x,P].map(e=>e.json));this.opMappers=e.reduce((e,t)=>(e[t.tfOpName]=t,e),{})}transformGraph(e,t={}){const a=e.node,r=[],n=[],u=[],o=a.reduce((e,t)=>(e[t.name]=this.mapNode(t),t.op.startsWith("Placeholder")?r.push(e[t.name]):"Const"===t.op?n.push(e[t.name]):null!=t.input&&0!==t.input.length||u.push(e[t.name]),e),{});let i=[];const p=[];let l={},c={};null!=t&&(l=this.mapSignatureEntries(t.inputs),c=this.mapSignatureEntries(t.outputs));const f=Object.keys(o);f.forEach(e=>{const t=o[e];t.inputNames.forEach((e,a)=>{const[r,,n]=(0,s.getNodeNameAndIndex)(e),u=o[r];if(null!=u.outputs){const e=u.outputs.indexOf(n);if(-1!==e){const n=`${r}:${e}`;t.inputNames[a]=n}}t.inputs.push(u),u.children.push(t)})}),0===Object.keys(c).length?f.forEach(e=>{const t=o[e];0===t.children.length&&p.push(t)}):Object.keys(c).forEach(e=>{const[t]=(0,s.getNodeNameAndIndex)(e),a=o[t];null!=a&&(a.signatureKey=c[e],p.push(a))}),Object.keys(l).length>0?Object.keys(l).forEach(e=>{const[t]=(0,s.getNodeNameAndIndex)(e),a=o[t];a&&(a.signatureKey=l[e],i.push(a))}):i=r;let d={};null!=e.library&&null!=e.library.function&&(d=e.library.function.reduce((e,t)=>(e[t.signature.name]=this.mapFunction(t),e),{}));const m={nodes:o,inputs:i,outputs:p,weights:n,placeholders:r,signature:t,functions:d};return u.length>0&&(m.initNodes=u),m}mapSignatureEntries(e){return Object.keys(e||{}).reduce((t,a)=>(t[e[a].name]=a,t),{})}mapNode(e){const t=(0,n.getRegisteredOp)(e.op)||this.opMappers[e.op]||{};null==e.attr&&(e.attr={});const a={name:e.name,op:e.op,category:t.category,inputNames:(e.input||[]).map(e=>e.startsWith("^")?e.slice(1):e),inputs:[],children:[],inputParams:{},attrParams:{},rawAttrs:e.attr,outputs:t.outputs};return null!=t.inputs&&(a.inputParams=t.inputs.reduce((e,t)=>(e[t.name]={type:t.type,inputIndexStart:t.start,inputIndexEnd:t.end},e),{})),null!=t.attrs&&(a.attrParams=t.attrs.reduce((t,a)=>{const r=a.type;let n=void 0;switch(a.type){case"string":void 0===(n=q(e.attr,a.tfName,a.defaultValue))&&a.tfDeprecatedName&&(n=q(e.attr,a.tfDeprecatedName,a.defaultValue));break;case"string[]":void 0===(n=L(e.attr,a.tfName,a.defaultValue))&&a.tfDeprecatedName&&(n=L(e.attr,a.tfDeprecatedName,a.defaultValue));break;case"number":void 0===(n=I(e.attr,a.tfName,a.defaultValue||0))&&a.tfDeprecatedName&&(n=I(e.attr,a.tfDeprecatedName,a.defaultValue));break;case"number[]":void 0===(n=C(e.attr,a.tfName,a.defaultValue))&&a.tfDeprecatedName&&(n=C(e.attr,a.tfDeprecatedName,a.defaultValue));break;case"bool":void 0===(n=V(e.attr,a.tfName,a.defaultValue))&&a.tfDeprecatedName&&(n=V(e.attr,a.tfDeprecatedName,a.defaultValue));break;case"bool[]":void 0===(n=F(e.attr,a.tfName,a.defaultValue))&&a.tfDeprecatedName&&(n=F(e.attr,a.tfDeprecatedName,a.defaultValue));break;case"shape":void 0===(n=B(e.attr,a.tfName,a.defaultValue))&&a.tfDeprecatedName&&(n=B(e.attr,a.tfDeprecatedName,a.defaultValue));break;case"shape[]":void 0===(n=$(e.attr,a.tfName,a.defaultValue))&&a.tfDeprecatedName&&(n=$(e.attr,a.tfDeprecatedName,a.defaultValue));break;case"dtype":void 0===(n=S(e.attr,a.tfName,a.defaultValue))&&a.tfDeprecatedName&&(n=S(e.attr,a.tfDeprecatedName,a.defaultValue));break;case"dtype[]":void 0===(n=j(e.attr,a.tfName,a.defaultValue))&&a.tfDeprecatedName&&(n=j(e.attr,a.tfDeprecatedName,a.defaultValue));break;case"func":void 0===(n=E(e.attr,a.tfName,a.defaultValue))&&a.tfDeprecatedName&&(n=E(e.attr,a.tfDeprecatedName,a.defaultValue));break;case"tensor":case"tensors":break;default:throw new Error(`Unsupported param type: ${a.type} for op: ${e.op}`)}return t[a.name]={value:n,type:r},t},{})),a}mapFunction(e){const t=e.nodeDef,a=[];let r={};null!=t&&(r=t.reduce((e,t)=>(e[t.name]=this.mapNode(t),"Const"===t.op&&a.push(e[t.name]),e),{}));const n=[],u=[];e.signature.inputArg.forEach(e=>{const[t]=(0,s.getNodeNameAndIndex)(e.name),a={name:t,op:"Placeholder",inputs:[],inputNames:[],category:"graph",inputParams:{},attrParams:{dtype:{value:w(e.type),type:"dtype"}},children:[]};a.signatureKey=e.name,n.push(a),r[t]=a}),Object.keys(r).forEach(e=>{const t=r[e];t.inputNames.forEach((e,a)=>{const[n,,u]=(0,s.getNodeNameAndIndex)(e),o=r[n];if(null!=o.outputs){const e=o.outputs.indexOf(u);if(-1!==e){const r=`${n}:${e}`;t.inputNames[a]=r}}t.inputs.push(o),o.children.push(t)})});const o=e.ret;e.signature.outputArg.forEach(e=>{const[t,a]=(0,s.getNodeNameAndIndex)(o[e.name]),n=r[t];null!=n&&(n.defaultOutput=a,u.push(n))});const i=this.mapArgsToSignature(e);return{nodes:r,inputs:n,outputs:u,weights:a,placeholders:[],signature:i}}mapArgsToSignature(e){return{methodName:e.signature.name,inputs:e.signature.inputArg.reduce((e,t)=>(e[t.name]=this.mapArgToTensorInfo(t),e),{}),outputs:e.signature.outputArg.reduce((t,a)=>(t[a.name]=this.mapArgToTensorInfo(a,e.ret),t),{})}}mapArgToTensorInfo(e,t){let a=e.name;return null!=t&&(a=t[a]),{name:a,dtype:e.type}}}function O(e){const r=(0,a.env)().global;if(void 0!==r.atob)return r.atob(e);if(void 0!==t)return new t(e,"base64").toString();throw new Error("Unable to decode base64 in this environment. Missing built-in atob() or Buffer()")}function k(e,t){const a=Array.isArray(e)?String.fromCharCode.apply(null,e):O(e);return t?a:a.toLowerCase()}function q(e,t,a,r=!1){const n=e[t];return null!=n?k(n.s,r):a}function V(e,t,a){const r=e[t];return r?r.b:a}function I(e,t,a){const r=e[t]||{},n=null!=r.i?r.i:null!=r.f?r.f:a;return"number"==typeof n?n:parseInt(n,10)}function w(e){switch("string"==typeof e&&(e=r.DataType[e]),e){case r.DataType.DT_FLOAT:case r.DataType.DT_HALF:return"float32";case r.DataType.DT_INT32:case r.DataType.DT_INT64:case r.DataType.DT_INT8:case r.DataType.DT_UINT8:return"int32";case r.DataType.DT_BOOL:return"bool";case r.DataType.DT_DOUBLE:return"float32";case r.DataType.DT_STRING:return"string";case r.DataType.DT_COMPLEX64:case r.DataType.DT_COMPLEX128:return"complex64";default:return null}}function E(e,t,a){const r=e[t];return r&&r.func?r.func.name:a}function S(e,t,a){const r=e[t];return r&&r.type?w(r.type):a}function j(e,t,a){const r=e[t];return r&&r.list&&r.list.type?r.list.type.map(e=>w(e)):a}function M(e){if(!e.unknownRank)return null!=e.dim?e.dim.map(e=>"number"==typeof e.size?e.size:parseInt(e.size,10)):[]}function B(e,t,a){const r=e[t];return r&&r.shape?M(r.shape):a}function C(e,t,a){const r=e[t];return r?((r.list.f&&r.list.f.length?r.list.f:r.list.i)||[]).map(e=>"number"==typeof e?e:parseInt(e,10)):a}function L(e,t,a,r=!1){const n=e[t];return n&&n.list&&n.list.s?n.list.s.map(e=>k(e,r)):a}function $(e,t,a){const r=e[t];return r&&r.list&&r.list.shape?r.list.shape.map(e=>M(e)):a}function F(e,t,a){const r=e[t];return r&&r.list&&r.list.b?r.list.b:a}exports.OperationMapper=A;
},{"@tensorflow/tfjs-core":"kSBl","../data/compiled_api":"vYlf","./custom_op/register":"LNan","./executors/utils":"eBau","./op_list/arithmetic":"qkVg","./op_list/basic_math":"gSiX","./op_list/control":"hTO9","./op_list/convolution":"zEHf","./op_list/creation":"lWlx","./op_list/dynamic":"n11C","./op_list/evaluation":"qR2a","./op_list/graph":"ohbw","./op_list/hash_table":"dtjV","./op_list/image":"DnM7","./op_list/logical":"MpO5","./op_list/matrices":"Tnxn","./op_list/normalization":"rf0I","./op_list/reduction":"lx5W","./op_list/slice_join":"BYbb","./op_list/sparse":"mrEg","./op_list/spectral":"ZasE","./op_list/string":"tCvz","./op_list/transformation":"wJwh","buffer":"RTGM"}],"N9rI":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.NodeValueImpl=void 0;var t=require("../executors/utils"),r=require("../operation_mapper");class e{constructor(t,r,e){this.node=t,this.tensorMap=r,this.context=e,this.inputs=[],this.attrs={},this.inputs=t.inputNames.map(t=>this.getInput(t)),null!=t.rawAttrs&&(this.attrs=Object.keys(t.rawAttrs).reduce((t,r)=>(t[r]=this.getAttr(r),t),{}))}getInput(r){return(0,t.getTensor)(r,this.tensorMap,this.context)}getAttr(e,s){const n=this.node.rawAttrs[e];if(null!=n.tensor)return(0,t.getTensor)(e,this.tensorMap,this.context);if(null!=n.i||null!=n.f)return(0,r.getNumberParam)(this.node.rawAttrs,e,s);if(null!=n.s)return(0,r.getStringParam)(this.node.rawAttrs,e,s);if(null!=n.b)return(0,r.getBoolParam)(this.node.rawAttrs,e,s);if(null!=n.shape)return(0,r.getTensorShapeParam)(this.node.rawAttrs,e,s);if(null!=n.type)return(0,r.getDtypeParam)(this.node.rawAttrs,e,s);if(null!=n.list){if(null!=n.list.i||null!=n.list.f)return(0,r.getNumericArrayParam)(this.node.rawAttrs,e,s);if(null!=n.list.s)return(0,r.getStringArrayParam)(this.node.rawAttrs,e,s);if(null!=n.list.shape)return(0,r.getTensorShapeArrayParam)(this.node.rawAttrs,e,s);if(null!=n.list.b)return(0,r.getBoolArrayParam)(this.node.rawAttrs,e,s);if(null!=n.list.type)return(0,r.getDtypeArrayParam)(this.node.rawAttrs,e,s)}return s}}exports.NodeValueImpl=e;
},{"../executors/utils":"eBau","../operation_mapper":"L12J"}],"bcFm":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0});var e=require("./ops");Object.keys(e).forEach(function(r){"default"!==r&&"__esModule"!==r&&(r in exports&&exports[r]===e[r]||Object.defineProperty(exports,r,{enumerable:!0,get:function(){return e[r]}}))});
},{"./ops":"hfXJ"}],"WLe9":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.executeOp=exports.CATEGORY=void 0;var e=r(require("@tensorflow/tfjs-core/dist/ops/ops_for_converter")),a=require("./utils");function r(e,a){if("function"==typeof WeakMap)var t=new WeakMap,u=new WeakMap;return(r=function(e,a){if(!a&&e&&e.__esModule)return e;var r,o,n={__proto__:null,default:e};if(null===e||"object"!=typeof e&&"function"!=typeof e)return n;if(r=a?u:t){if(r.has(e))return r.get(e);r.set(e,n)}for(const t in e)"default"!==t&&{}.hasOwnProperty.call(e,t)&&((o=(r=Object.defineProperty)&&Object.getOwnPropertyDescriptor(e,t))&&(o.get||o.set)?r(n,t,o):n[t]=e[t]);return n})(e,a)}const t=(r,t,u,o=e)=>{switch(r.op){case"BiasAdd":case"AddV2":case"Add":return[o.add((0,a.getParamValue)("a",r,t,u),(0,a.getParamValue)("b",r,t,u))];case"AddN":return[o.addN((0,a.getParamValue)("tensors",r,t,u))];case"FloorMod":case"Mod":return[o.mod((0,a.getParamValue)("a",r,t,u),(0,a.getParamValue)("b",r,t,u))];case"Mul":return[o.mul((0,a.getParamValue)("a",r,t,u),(0,a.getParamValue)("b",r,t,u))];case"RealDiv":case"Div":return[o.div((0,a.getParamValue)("a",r,t,u),(0,a.getParamValue)("b",r,t,u))];case"DivNoNan":return[o.divNoNan((0,a.getParamValue)("a",r,t,u),(0,a.getParamValue)("b",r,t,u))];case"FloorDiv":return[o.floorDiv((0,a.getParamValue)("a",r,t,u),(0,a.getParamValue)("b",r,t,u))];case"Sub":return[o.sub((0,a.getParamValue)("a",r,t,u),(0,a.getParamValue)("b",r,t,u))];case"Minimum":return[o.minimum((0,a.getParamValue)("a",r,t,u),(0,a.getParamValue)("b",r,t,u))];case"Maximum":return[o.maximum((0,a.getParamValue)("a",r,t,u),(0,a.getParamValue)("b",r,t,u))];case"Pow":return[o.pow((0,a.getParamValue)("a",r,t,u),(0,a.getParamValue)("b",r,t,u))];case"SquaredDifference":return[o.squaredDifference((0,a.getParamValue)("a",r,t,u),(0,a.getParamValue)("b",r,t,u))];default:throw TypeError(`Node type ${r.op} is not implemented`)}};exports.executeOp=t;const u=exports.CATEGORY="arithmetic";
},{"@tensorflow/tfjs-core/dist/ops/ops_for_converter":"bcFm","./utils":"eBau"}],"RUi0":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.executeOp=exports.CATEGORY=void 0;var e=r(require("@tensorflow/tfjs-core/dist/ops/ops_for_converter")),a=require("./utils");function r(e,a){if("function"==typeof WeakMap)var t=new WeakMap,u=new WeakMap;return(r=function(e,a){if(!a&&e&&e.__esModule)return e;var r,s,n={__proto__:null,default:e};if(null===e||"object"!=typeof e&&"function"!=typeof e)return n;if(r=a?u:t){if(r.has(e))return r.get(e);r.set(e,n)}for(const t in e)"default"!==t&&{}.hasOwnProperty.call(e,t)&&((s=(r=Object.defineProperty)&&Object.getOwnPropertyDescriptor(e,t))&&(s.get||s.set)?r(n,t,s):n[t]=e[t]);return n})(e,a)}const t=(r,t,u,s=e)=>{switch(r.op){case"Abs":case"ComplexAbs":return[s.abs((0,a.getParamValue)("x",r,t,u))];case"Acos":return[s.acos((0,a.getParamValue)("x",r,t,u))];case"Acosh":return[s.acosh((0,a.getParamValue)("x",r,t,u))];case"Asin":return[s.asin((0,a.getParamValue)("x",r,t,u))];case"Asinh":return[s.asinh((0,a.getParamValue)("x",r,t,u))];case"Atan":return[s.atan((0,a.getParamValue)("x",r,t,u))];case"Atan2":return[s.atan2((0,a.getParamValue)("x",r,t,u),(0,a.getParamValue)("y",r,t,u))];case"Atanh":return[s.atanh((0,a.getParamValue)("x",r,t,u))];case"Ceil":return[s.ceil((0,a.getParamValue)("x",r,t,u))];case"Complex":return[s.complex((0,a.getParamValue)("real",r,t,u),(0,a.getParamValue)("imag",r,t,u))];case"Cos":return[s.cos((0,a.getParamValue)("x",r,t,u))];case"Cosh":return[s.cosh((0,a.getParamValue)("x",r,t,u))];case"Elu":return[s.elu((0,a.getParamValue)("x",r,t,u))];case"Erf":return[s.erf((0,a.getParamValue)("x",r,t,u))];case"Exp":return[s.exp((0,a.getParamValue)("x",r,t,u))];case"Expm1":return[s.expm1((0,a.getParamValue)("x",r,t,u))];case"Floor":return[s.floor((0,a.getParamValue)("x",r,t,u))];case"Log":return[s.log((0,a.getParamValue)("x",r,t,u))];case"Log1p":return[s.log1p((0,a.getParamValue)("x",r,t,u))];case"Imag":return[s.imag((0,a.getParamValue)("x",r,t,u))];case"Neg":return[s.neg((0,a.getParamValue)("x",r,t,u))];case"Reciprocal":return[s.reciprocal((0,a.getParamValue)("x",r,t,u))];case"Real":return[s.real((0,a.getParamValue)("x",r,t,u))];case"Relu":return[s.relu((0,a.getParamValue)("x",r,t,u))];case"Round":return[s.round((0,a.getParamValue)("x",r,t,u))];case"Selu":return[s.selu((0,a.getParamValue)("x",r,t,u))];case"Sigmoid":return[s.sigmoid((0,a.getParamValue)("x",r,t,u))];case"Sin":return[s.sin((0,a.getParamValue)("x",r,t,u))];case"Sign":return[s.sign((0,a.getParamValue)("x",r,t,u))];case"Sinh":return[s.sinh((0,a.getParamValue)("x",r,t,u))];case"Softplus":return[s.softplus((0,a.getParamValue)("x",r,t,u))];case"Sqrt":return[s.sqrt((0,a.getParamValue)("x",r,t,u))];case"Square":return[s.square((0,a.getParamValue)("x",r,t,u))];case"Tanh":return[s.tanh((0,a.getParamValue)("x",r,t,u))];case"Tan":return[s.tan((0,a.getParamValue)("x",r,t,u))];case"ClipByValue":return[s.clipByValue((0,a.getParamValue)("x",r,t,u),(0,a.getParamValue)("clipValueMin",r,t,u),(0,a.getParamValue)("clipValueMax",r,t,u))];case"Relu6":return[s.relu6((0,a.getParamValue)("x",r,t,u))];case"Rsqrt":return[s.rsqrt((0,a.getTensor)(r.inputNames[0],t,u))];case"LeakyRelu":return[s.leakyRelu((0,a.getParamValue)("x",r,t,u),(0,a.getParamValue)("alpha",r,t,u))];case"Prelu":return[s.prelu((0,a.getParamValue)("x",r,t,u),(0,a.getParamValue)("alpha",r,t,u))];case"IsNan":return[s.isNaN((0,a.getTensor)(r.inputNames[0],t,u))];case"IsInf":return[s.isInf((0,a.getTensor)(r.inputNames[0],t,u))];case"IsFinite":return[s.isFinite((0,a.getTensor)(r.inputNames[0],t,u))];default:throw TypeError(`Node type ${r.op} is not implemented`)}};exports.executeOp=t;const u=exports.CATEGORY="basic_math";
},{"@tensorflow/tfjs-core/dist/ops/ops_for_converter":"bcFm","./utils":"eBau"}],"RRxz":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.assertShapesMatchAllowUndefinedSize=t,exports.fullDefinedShape=r,exports.inferElementShape=n,exports.mergeElementShape=o;var e=require("@tensorflow/tfjs-core");function t(t,r,n=""){if("number"!=typeof t&&"number"!=typeof r){e.util.assert(t.length===r.length,()=>n+` Shapes ${t} and ${r} must match`);for(let o=0;o<t.length;o++){const l=t[o],s=r[o];e.util.assert(l<0||s<0||l===s,()=>n+` Shapes ${t} and ${r} must match`)}}}function r(e){return"number"!=typeof e&&!e.some(e=>e<0)}function n(e,t,n){let l=o(e,n);const s=!r(l);if(s&&0===t.length)throw new Error("Tried to calculate elements of an empty list"+` with non-fully-defined elementShape: ${l}`);if(s&&t.forEach(e=>{l=o(e.shape,l)}),!r(l))throw new Error(`Non-fully-defined elementShape: ${l}`);return l}function o(e,t){if("number"==typeof e)return t;if("number"==typeof t)return e;if(e.length!==t.length)throw new Error(`Incompatible ranks during merge: ${e} vs. ${t}`);const r=[];for(let n=0;n<e.length;++n){const o=e[n],l=t[n];if(o>=0&&l>=0&&o!==l)throw new Error(`Incompatible shape during merge: ${e} vs. ${t}`);r[n]=o>=0?o:l}return r}
},{"@tensorflow/tfjs-core":"kSBl"}],"Ht5L":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.TensorArray=void 0;var e=require("@tensorflow/tfjs-core"),t=require("./tensor_utils");class s{constructor(t,s,r,i,n,a,h){this.name=t,this.dtype=s,this.maxSize=r,this.elementShape=i,this.identicalElementShapes=n,this.dynamicSize=a,this.clearAfterRead=h,this.tensors=[],this.closed_=!1,this.idTensor=(0,e.scalar)(0),(0,e.keep)(this.idTensor)}get id(){return this.idTensor.id}get closed(){return this.closed_}clearAndClose(e){this.tensors.forEach(t=>{null!=e&&e.has(t.tensor.id)||t.tensor.dispose()}),this.tensors=[],this.closed_=!0,this.idTensor.dispose()}size(){return this.tensors.length}read(e){if(this.closed_)throw new Error(`TensorArray ${this.name} has already been closed.`);if(e<0||e>=this.size())throw new Error(`Tried to read from index ${e}, but array size is: ${this.size()}`);const t=this.tensors[e];if(t.cleared)throw new Error(`TensorArray ${this.name}: Could not read index ${e} twice because it was cleared after a previous read `+"(perhaps try setting clear_after_read = false?).");return this.clearAfterRead&&(t.cleared=!0),t.read=!0,t.tensor}readMany(e){return e.map(e=>this.read(e))}write(s,r){if(this.closed_)throw new Error(`TensorArray ${this.name} has already been closed.`);if(s<0||!this.dynamicSize&&s>=this.maxSize)throw new Error(`Tried to write to index ${s}, but array is not resizeable and size is: ${this.maxSize}`);const i=this.tensors[s]||{};if(r.dtype!==this.dtype)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${s},\n          because the value dtype is ${r.dtype}, but TensorArray dtype is ${this.dtype}.`);if(0!==this.size()||null!=this.elementShape&&0!==this.elementShape.length||(this.elementShape=r.shape),(0,t.assertShapesMatchAllowUndefinedSize)(this.elementShape,r.shape,`TensorArray ${this.name}: Could not write to TensorArray index ${s}.`),i.read)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${s}, because it has already been read.`);if(i.written)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${s}, because it has already been written.`);i.tensor=r,(0,e.keep)(r),i.written=!0,this.tensors[s]=i}writeMany(e,t){if(e.length!==t.length)throw new Error(`TensorArray ${this.name}: could not write multiple tensors,`+`because the index size: ${e.length} is not the same as tensors size: ${t.length}.`);e.forEach((e,s)=>this.write(e,t[s]))}gather(s,r){if(r&&r!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but gather requested dtype ${r}`);if(s)s=s.slice(0,this.size());else{s=[];for(let e=0;e<this.size();e++)s.push(e)}if(0===s.length)return(0,e.tensor)([],[0].concat(this.elementShape));const i=this.readMany(s);return(0,t.assertShapesMatchAllowUndefinedSize)(this.elementShape,i[0].shape,"TensorArray shape mismatch: "),(0,e.stack)(i,0)}concat(s){if(s&&s!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but concat requested dtype ${s}`);if(0===this.size())return(0,e.tensor)([],[0].concat(this.elementShape));const r=[];for(let e=0;e<this.size();e++)r.push(e);const i=this.readMany(r);return(0,t.assertShapesMatchAllowUndefinedSize)(this.elementShape,i[0].shape,`TensorArray shape mismatch: tensor array shape (${this.elementShape}) vs first tensor shape (${i[0].shape})`),(0,e.concat)(i,0)}scatter(t,s){if(s.dtype!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${s.dtype}`);if(t.length!==s.shape[0])throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${t.length} vs. ${s.shape[0]}`);const r=Math.max(...t);if(!this.dynamicSize&&r>=this.maxSize)throw new Error(`Max index must be < array size (${r}  vs. ${this.maxSize})`);this.writeMany(t,(0,e.unstack)(s,0))}split(t,s){if(s.dtype!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${s.dtype}`);let r=0;const i=t.map(e=>r+=e);if(r!==s.shape[0])throw new Error(`Expected sum of lengths to be equal to\n          tensor.shape[0], but sum of lengths is\n        ${r}, and tensor's shape is: ${s.shape}`);if(!this.dynamicSize&&t.length!==this.maxSize)throw new Error(`TensorArray's size is not equal to the size of lengths (${this.maxSize} vs. ${t.length}), `+"and the TensorArray is not marked as dynamically resizeable");const n=0===r?0:s.size/r,a=[];(0,e.tidy)(()=>{s=(0,e.reshape)(s,[1,r,n]);for(let r=0;r<t.length;++r){const h=[0,0===r?0:i[r-1],0],o=[1,t[r],n];a[r]=(0,e.reshape)((0,e.slice)(s,h,o),this.elementShape)}return a});const h=[];for(let e=0;e<t.length;e++)h[e]=e;this.writeMany(h,a)}}exports.TensorArray=s;
},{"@tensorflow/tfjs-core":"kSBl","./tensor_utils":"RRxz"}],"w2j0":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.TensorList=void 0,exports.fromTensor=n,exports.reserve=r,exports.scatter=i,exports.split=h;var e=require("@tensorflow/tfjs-core"),t=require("./tensor_utils");class s{get id(){return this.idTensor.id}constructor(s,n,r,i=-1){this.tensors=s,this.elementShape=n,this.elementDtype=r,null!=s&&s.forEach(s=>{if(r!==s.dtype)throw new Error(`Invalid data types; op elements ${r}, but list elements ${s.dtype}`);(0,t.assertShapesMatchAllowUndefinedSize)(n,s.shape,"TensorList shape mismatch: "),(0,e.keep)(s)}),this.idTensor=(0,e.scalar)(0),this.maxNumElements=i,(0,e.keep)(this.idTensor)}copy(){return new s([...this.tensors],this.elementShape,this.elementDtype)}clearAndClose(e){this.tensors.forEach(t=>{null!=e&&e.has(t.id)||t.dispose()}),this.tensors.length=0,this.idTensor.dispose()}size(){return this.tensors.length}stack(s,n,r=-1){if(n!==this.elementDtype)throw new Error(`Invalid data types; op elements ${n}, but list elements ${this.elementDtype}`);if(-1!==r&&this.tensors.length!==r)throw new Error(`Operation expected a list with ${r} elements but got a list with ${this.tensors.length} elements.`);(0,t.assertShapesMatchAllowUndefinedSize)(s,this.elementShape,"TensorList shape mismatch: ");const i=(0,t.inferElementShape)(this.elementShape,this.tensors,s);return(0,e.tidy)(()=>{const t=this.tensors.map(t=>(0,e.reshape)(t,i));return(0,e.stack)(t,0)})}popBack(s,n){if(n!==this.elementDtype)throw new Error(`Invalid data types; op elements ${n}, but list elements ${this.elementDtype}`);if(0===this.size())throw new Error("Trying to pop from an empty list.");const r=(0,t.inferElementShape)(this.elementShape,this.tensors,s),i=this.tensors.pop();return i.kept=!1,(0,t.assertShapesMatchAllowUndefinedSize)(i.shape,s,"TensorList shape mismatch: "),(0,e.reshape)(i,r)}pushBack(s){if(s.dtype!==this.elementDtype)throw new Error(`Invalid data types; op elements ${s.dtype}, but list elements ${this.elementDtype}`);if((0,t.assertShapesMatchAllowUndefinedSize)(s.shape,this.elementShape,"TensorList shape mismatch: "),this.maxNumElements===this.size())throw new Error("Trying to push element into a full list.");(0,e.keep)(s),this.tensors.push(s)}resize(e){if(e<0)throw new Error(`TensorListResize expects size to be non-negative. Got: ${e}`);if(-1!==this.maxNumElements&&e>this.maxNumElements)throw new Error(`TensorListResize input size ${e} is greater maxNumElement ${this.maxNumElements}.`);const t=new s([],this.elementShape,this.elementDtype,this.maxNumElements);t.tensors.length=e;for(let s=0;s<Math.min(this.tensors.length,e);++s)t.tensors[s]=this.tensors[s];return t}getItem(s,n,r){if(r!==this.elementDtype)throw new Error(`Invalid data types; op elements ${r}, but list elements ${this.elementDtype}`);if(s<0||s>this.tensors.length)throw new Error(`Trying to access element ${s} in a list with ${this.tensors.length} elements.`);if(null==this.tensors[s])throw new Error(`element at index ${s} is null.`);(0,t.assertShapesMatchAllowUndefinedSize)(this.tensors[s].shape,n,"TensorList shape mismatch: ");const i=(0,t.inferElementShape)(this.elementShape,this.tensors,n);return(0,e.reshape)(this.tensors[s],i)}setItem(s,n){if(n.dtype!==this.elementDtype)throw new Error(`Invalid data types; op elements ${n.dtype}, but list elements ${this.elementDtype}`);if(s<0||-1!==this.maxNumElements&&s>=this.maxNumElements)throw new Error(`Trying to set element ${s} in a list with max ${this.maxNumElements} elements.`);(0,t.assertShapesMatchAllowUndefinedSize)(this.elementShape,n.shape,"TensorList shape mismatch: "),(0,e.keep)(n),null!=this.tensors[s]&&(this.tensors[s].kept=!1),this.tensors[s]=n}gather(s,n,r){if(n!==this.elementDtype)throw new Error(`Invalid data types; op elements ${n}, but list elements ${this.elementDtype}`);(0,t.assertShapesMatchAllowUndefinedSize)(this.elementShape,r,"TensorList shape mismatch: "),s=s.slice(0,this.size());const i=(0,t.inferElementShape)(this.elementShape,this.tensors,r);return 0===s.length?(0,e.tensor)([],[0].concat(i)):(0,e.tidy)(()=>{const t=s.map(t=>(0,e.reshape)(this.tensors[t],i));return(0,e.stack)(t,0)})}concat(s,n){if(s&&s!==this.elementDtype)throw new Error(`TensorList dtype is ${this.elementDtype} but concat requested dtype ${s}`);(0,t.assertShapesMatchAllowUndefinedSize)(this.elementShape,n,"TensorList shape mismatch: ");const r=(0,t.inferElementShape)(this.elementShape,this.tensors,n);return 0===this.size()?(0,e.tensor)([],[0].concat(r)):(0,e.tidy)(()=>{const t=this.tensors.map(t=>(0,e.reshape)(t,r));return(0,e.concat)(t,0)})}}function n(n,r,i){const h=n.dtype;if(n.shape.length<1)throw new Error(`Tensor must be at least a vector, but saw shape: ${n.shape}`);if(n.dtype!==i)throw new Error(`Invalid data types; op elements ${n.dtype}, but list elements ${i}`);const o=n.shape.slice(1);(0,t.assertShapesMatchAllowUndefinedSize)(o,r,"TensorList shape mismatch: ");const a=(0,e.unstack)(n);return new s(a,r,h)}function r(e,t,n,r){return new s([],e,t,r)}function i(t,n,r,i){if(n.length!==t.shape[0])throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${n.length} vs. ${t.shape[0]}`);const h=Math.max(...n);if(null!=i&&-1!==i&&h>=i)throw new Error(`Max index must be < array size (${h}  vs. ${i})`);const o=new s([],r,t.dtype,i),a=(0,e.unstack)(t,0);return n.forEach((e,t)=>{o.setItem(e,a[t])}),o}function h(n,r,i){let h=0;const o=r.map(e=>h+=e);if(h!==n.shape[0])throw new Error(`Expected sum of lengths to be equal to\n          tensor.shape[0], but sum of lengths is\n        ${h}, and tensor's shape is: ${n.shape}`);const a=n.shape.slice(1),l=(0,t.mergeElementShape)(a,i),p=0===h?0:n.size/h,m=(0,e.tidy)(()=>{const t=[];n=(0,e.reshape)(n,[1,h,p]);for(let s=0;s<r.length;++s){const i=[0,0===s?0:o[s-1],0],h=[1,r[s],p];t[s]=(0,e.reshape)((0,e.slice)(n,i,h),l)}return n.dispose(),t}),c=new s([],i,n.dtype,r.length);for(let e=0;e<m.length;e++)c.setItem(e,m[e]);return c}exports.TensorList=s;
},{"@tensorflow/tfjs-core":"kSBl","./tensor_utils":"RRxz"}],"vqcE":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.executeOp=exports.CATEGORY=void 0;var e=require("@tensorflow/tfjs-core"),a=require("../../executor/tensor_array"),t=require("../../executor/tensor_list"),r=require("./utils");const s=async(s,n,o)=>{switch(s.op){case"If":case"StatelessIf":{const e=(0,r.getParamValue)("thenBranch",s,n,o),a=(0,r.getParamValue)("elseBranch",s,n,o),t=(0,r.getParamValue)("cond",s,n,o),i=(0,r.getParamValue)("args",s,n,o);return(await t.data())[0]?o.functionMap[e].executeFunctionAsync(i,o.tensorArrayMap,o.tensorListMap):o.functionMap[a].executeFunctionAsync(i,o.tensorArrayMap,o.tensorListMap)}case"While":case"StatelessWhile":{const e=(0,r.getParamValue)("body",s,n,o),a=(0,r.getParamValue)("cond",s,n,o),t=(0,r.getParamValue)("args",s,n,o),i=await o.functionMap[a].executeFunctionAsync(t,o.tensorArrayMap,o.tensorListMap),c=t.map(e=>e.id);let u=await i[0].data();i.forEach(e=>{e.kept||-1!==c.indexOf(e.id)||e.dispose()});let l=t;for(;u[0];){const t=l,r=(l=await o.functionMap[e].executeFunctionAsync(l,o.tensorArrayMap,o.tensorListMap)).map(e=>e.id);t.forEach(e=>{e.kept||-1!==c.indexOf(e.id)||-1!==r.indexOf(e.id)||e.dispose()});const s=await o.functionMap[a].executeFunctionAsync(l,o.tensorArrayMap,o.tensorListMap);u=await s[0].data(),s.forEach(e=>{e.kept||-1!==c.indexOf(e.id)||-1!==r.indexOf(e.id)||e.dispose()})}return l}case"LoopCond":{const e=(0,r.getParamValue)("pred",s,n,o);return[(0,r.cloneTensor)(e)]}case"Switch":{const e=(0,r.getParamValue)("pred",s,n,o);let a=(0,r.getParamValue)("data",s,n,o);return a.kept||(a=(0,r.cloneTensor)(a)),(await e.data())[0]?[void 0,a]:[a,void 0]}case"Merge":{const e=s.inputNames.find(e=>void 0!==(0,r.getTensor)(e,n,o));if(e){const a=(0,r.getTensor)(e,n,o);return[(0,r.cloneTensor)(a)]}return}case"Enter":{const e=(0,r.getParamValue)("frameName",s,n,o),a=(0,r.getParamValue)("tensor",s,n,o);return o.enterFrame(e),[(0,r.cloneTensor)(a)]}case"Exit":{const e=(0,r.getParamValue)("tensor",s,n,o);return o.exitFrame(),[(0,r.cloneTensor)(e)]}case"NextIteration":{const e=(0,r.getParamValue)("tensor",s,n,o);return o.nextIteration(),[(0,r.cloneTensor)(e)]}case"TensorArrayV3":{const t=(0,r.getParamValue)("size",s,n,o),i=(0,r.getParamValue)("dtype",s,n,o),c=(0,r.getParamValue)("elementShape",s,n,o),u=(0,r.getParamValue)("dynamicSize",s,n,o),l=(0,r.getParamValue)("clearAfterRead",s,n,o),m=(0,r.getParamValue)("identicalElementShapes",s,n,o),d=(0,r.getParamValue)("name",s,n,o),g=new a.TensorArray(d,i,t,c,m,u,l);return o.addTensorArray(g),[g.idTensor,(0,e.scalar)(1)]}case"TensorArrayWriteV3":{const e=(0,r.getParamValue)("tensorArrayId",s,n,o),a=(0,r.getParamValue)("index",s,n,o),t=(0,r.getParamValue)("tensor",s,n,o),i=o.getTensorArray(e.id);return i.write(a,t),[i.idTensor]}case"TensorArrayReadV3":{const e=(0,r.getParamValue)("tensorArrayId",s,n,o),a=(0,r.getParamValue)("index",s,n,o);return[o.getTensorArray(e.id).read(a)]}case"TensorArrayGatherV3":{const e=(0,r.getParamValue)("tensorArrayId",s,n,o),a=(0,r.getParamValue)("indices",s,n,o),t=(0,r.getParamValue)("dtype",s,n,o);return[o.getTensorArray(e.id).gather(a,t)]}case"TensorArrayScatterV3":{const e=(0,r.getParamValue)("tensorArrayId",s,n,o),a=(0,r.getParamValue)("indices",s,n,o),t=(0,r.getParamValue)("tensor",s,n,o),i=o.getTensorArray(e.id);return i.scatter(a,t),[i.idTensor]}case"TensorArrayConcatV3":{const e=(0,r.getParamValue)("tensorArrayId",s,n,o),a=o.getTensorArray(e.id),t=(0,r.getParamValue)("dtype",s,n,o);return[a.concat(t)]}case"TensorArraySplitV3":{const e=(0,r.getParamValue)("tensorArrayId",s,n,o),a=(0,r.getParamValue)("tensor",s,n,o),t=(0,r.getParamValue)("lengths",s,n,o),i=o.getTensorArray(e.id);return i.split(t,a),[i.idTensor]}case"TensorArraySizeV3":{const a=(0,r.getParamValue)("tensorArrayId",s,n,o),t=o.getTensorArray(a.id);return[(0,e.scalar)(t.size(),"int32")]}case"TensorArrayCloseV3":{const e=(0,r.getParamValue)("tensorArrayId",s,n,o),a=o.getTensorArray(e.id);return a.clearAndClose(),[a.idTensor]}case"TensorListSetItem":{const e=(0,r.getParamValue)("tensorListId",s,n,o),a=(0,r.getParamValue)("index",s,n,o),t=(0,r.getParamValue)("tensor",s,n,o),i=o.getTensorList(e.id);return i.setItem(a,t),[i.idTensor]}case"TensorListGetItem":{const e=(0,r.getParamValue)("tensorListId",s,n,o),a=(0,r.getParamValue)("index",s,n,o),t=(0,r.getParamValue)("elementShape",s,n,o),i=(0,r.getParamValue)("elementDType",s,n,o);return[o.getTensorList(e.id).getItem(a,t,i)]}case"TensorListScatterV2":case"TensorListScatter":{const e=(0,r.getParamValue)("indices",s,n,o),a=(0,r.getParamValue)("tensor",s,n,o),i=(0,r.getParamValue)("elementShape",s,n,o),c=(0,r.getParamValue)("numElements",s,n,o),u=(0,t.scatter)(a,e,i,c);return o.addTensorList(u),[u.idTensor]}case"TensorListReserve":case"EmptyTensorList":{const e=(0,r.getParamValue)("elementShape",s,n,o),a=(0,r.getParamValue)("elementDType",s,n,o);let i;i="TensorListReserve"===s.op?"numElements":"maxNumElements";const c=(0,r.getParamValue)(i,s,n,o),u="TensorListReserve"===s.op?-1:c,l=(0,t.reserve)(e,a,c,u);return o.addTensorList(l),[l.idTensor]}case"TensorListGather":{const e=(0,r.getParamValue)("tensorListId",s,n,o),a=(0,r.getParamValue)("indices",s,n,o),t=(0,r.getParamValue)("elementShape",s,n,o),i=(0,r.getParamValue)("elementDType",s,n,o);return[o.getTensorList(e.id).gather(a,i,t)]}case"TensorListStack":{const e=(0,r.getParamValue)("tensorListId",s,n,o),a=(0,r.getParamValue)("elementShape",s,n,o),t=(0,r.getParamValue)("elementDType",s,n,o),i=(0,r.getParamValue)("numElements",s,n,o);return[o.getTensorList(e.id).stack(a,t,i)]}case"TensorListFromTensor":{const e=(0,r.getParamValue)("tensor",s,n,o),a=(0,r.getParamValue)("elementShape",s,n,o),i=(0,r.getParamValue)("elementDType",s,n,o),c=(0,t.fromTensor)(e,a,i);return o.addTensorList(c),[c.idTensor]}case"TensorListConcat":case"TensorListConcatV2":{const e=(0,r.getParamValue)("tensorListId",s,n,o),a=o.getTensorList(e.id),t=(0,r.getParamValue)("dtype",s,n,o),i=(0,r.getParamValue)("elementShape",s,n,o);return[a.concat(t,i)]}case"TensorListPushBack":{const e=(0,r.getParamValue)("tensorListId",s,n,o),a=(0,r.getParamValue)("tensor",s,n,o),t=o.getTensorList(e.id);return t.pushBack(a),[t.idTensor]}case"TensorListPopBack":{const e=(0,r.getParamValue)("tensorListId",s,n,o),a=(0,r.getParamValue)("elementShape",s,n,o),t=(0,r.getParamValue)("elementDType",s,n,o);return[o.getTensorList(e.id).popBack(a,t)]}case"TensorListSplit":{const e=(0,r.getParamValue)("tensor",s,n,o),a=(0,r.getParamValue)("elementShape",s,n,o),i=(0,r.getParamValue)("lengths",s,n,o),c=(0,t.split)(e,i,a);return o.addTensorList(c),[c.idTensor]}case"TensorListLength":{const a=(0,r.getParamValue)("tensorListId",s,n,o),t=o.getTensorList(a.id);return[(0,e.scalar)(t.size(),"int32")]}case"TensorListResize":{const e=(0,r.getParamValue)("tensorListId",s,n,o),a=(0,r.getParamValue)("size",s,n,o),t=o.getTensorList(e.id).resize(a);return o.addTensorList(t),[t.idTensor]}default:throw TypeError(`Node type ${s.op} is not implemented`)}};exports.executeOp=s;const n=exports.CATEGORY="control";
},{"@tensorflow/tfjs-core":"kSBl","../../executor/tensor_array":"Ht5L","../../executor/tensor_list":"w2j0","./utils":"eBau"}],"I0Jg":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.executeOp=exports.CATEGORY=void 0;var a=t(require("@tensorflow/tfjs-core/dist/ops/ops_for_converter")),e=require("./utils");function t(a,e){if("function"==typeof WeakMap)var r=new WeakMap,o=new WeakMap;return(t=function(a,e){if(!e&&a&&a.__esModule)return a;var t,l,s={__proto__:null,default:a};if(null===a||"object"!=typeof a&&"function"!=typeof a)return s;if(t=e?o:r){if(t.has(a))return t.get(a);t.set(a,s)}for(const r in a)"default"!==r&&{}.hasOwnProperty.call(a,r)&&((l=(t=Object.defineProperty)&&Object.getOwnPropertyDescriptor(a,r))&&(l.get||l.set)?t(s,r,l):s[r]=a[r]);return s})(a,e)}function r(a,t,r){const[o,l]=(0,e.getParamValue)("fusedOps",a,t,r),s="biasadd"===o,u=!s,n="prelu"===l,i="fusedbatchnorm"===o,d=(0,e.getParamValue)("numArgs",a,t,r);if(s){if(n&&2!==d)throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!n&&s&&1!==d)throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd must have one extra argument: bias.")}if(i)throw new Error("FusedConv2d and DepthwiseConv2d with FusedBatchNorm is not supported");const g=(0,e.getParamValue)("strides",a,t,r),m=(0,e.getPadding)(a,t,r),P=(0,e.getParamValue)("dataFormat",a,t,r).toUpperCase(),p=(0,e.getParamValue)("dilations",a,t,r);let[c,V]=(0,e.getParamValue)("args",a,t,r);return u&&(V=c,c=void 0),{stride:g,pad:m,dataFormat:P,dilations:p,biasArg:c,preluArg:V,activationFunc:l,leakyreluAlpha:(0,e.getParamValue)("leakyreluAlpha",a,t,r)}}const o=(t,o,l,s=a)=>{switch(t.op){case"Conv1D":{const a=(0,e.getParamValue)("stride",t,o,l),r=(0,e.getParamValue)("pad",t,o,l),u=(0,e.getParamValue)("dataFormat",t,o,l).toUpperCase(),n=(0,e.getParamValue)("dilation",t,o,l);return[s.conv1d((0,e.getParamValue)("x",t,o,l),(0,e.getParamValue)("filter",t,o,l),a,r,u,n)]}case"Conv2D":{const a=(0,e.getParamValue)("strides",t,o,l),r=(0,e.getPadding)(t,o,l),u=(0,e.getParamValue)("dataFormat",t,o,l).toUpperCase(),n=(0,e.getParamValue)("dilations",t,o,l);return[s.conv2d((0,e.getParamValue)("x",t,o,l),(0,e.getParamValue)("filter",t,o,l),[a[1],a[2]],r,u,[n[1],n[2]])]}case"_FusedConv2D":{const{stride:a,pad:u,dataFormat:n,dilations:i,biasArg:d,preluArg:g,activationFunc:m,leakyreluAlpha:P}=r(t,o,l);return[s.fused.conv2d({x:(0,e.getParamValue)("x",t,o,l),filter:(0,e.getParamValue)("filter",t,o,l),strides:[a[1],a[2]],pad:u,dataFormat:n,dilations:[i[1],i[2]],bias:d,activation:m,preluActivationWeights:g,leakyreluAlpha:P})]}case"FusedDepthwiseConv2dNative":{const{stride:a,pad:u,dataFormat:n,dilations:i,biasArg:d,preluArg:g,activationFunc:m,leakyreluAlpha:P}=r(t,o,l);return[s.fused.depthwiseConv2d({x:(0,e.getParamValue)("x",t,o,l),filter:(0,e.getParamValue)("filter",t,o,l),strides:[a[1],a[2]],pad:u,dataFormat:n,dilations:[i[1],i[2]],bias:d,activation:m,preluActivationWeights:g,leakyreluAlpha:P})]}case"Conv2DBackpropInput":case"Conv2dTranspose":{const a=(0,e.getParamValue)("outputShape",t,o,l),r=(0,e.getParamValue)("strides",t,o,l),u=(0,e.getPadding)(t,o,l);return[s.conv2dTranspose((0,e.getParamValue)("x",t,o,l),(0,e.getParamValue)("filter",t,o,l),a,[r[1],r[2]],u)]}case"DepthwiseConv2dNative":case"DepthwiseConv2d":{const a=(0,e.getParamValue)("strides",t,o,l),r=(0,e.getPadding)(t,o,l),u=(0,e.getParamValue)("dilations",t,o,l),n=(0,e.getParamValue)("dataFormat",t,o,l).toUpperCase();return[s.depthwiseConv2d((0,e.getParamValue)("input",t,o,l),(0,e.getParamValue)("filter",t,o,l),[a[1],a[2]],r,n,[u[1],u[2]])]}case"Conv3D":{const a=(0,e.getParamValue)("strides",t,o,l),r=(0,e.getParamValue)("pad",t,o,l),u=(0,e.getParamValue)("dataFormat",t,o,l).toUpperCase(),n=(0,e.getParamValue)("dilations",t,o,l);return[s.conv3d((0,e.getParamValue)("x",t,o,l),(0,e.getParamValue)("filter",t,o,l),[a[1],a[2],a[3]],r,u,[n[1],n[2],n[3]])]}case"AvgPool":{const a=(0,e.getParamValue)("strides",t,o,l),r=(0,e.getParamValue)("pad",t,o,l),u=(0,e.getParamValue)("kernelSize",t,o,l);return[s.avgPool((0,e.getParamValue)("x",t,o,l),[u[1],u[2]],[a[1],a[2]],r)]}case"MaxPool":{const a=(0,e.getParamValue)("strides",t,o,l),r=(0,e.getParamValue)("pad",t,o,l),u=(0,e.getParamValue)("kernelSize",t,o,l);return[s.maxPool((0,e.getParamValue)("x",t,o,l),[u[1],u[2]],[a[1],a[2]],r)]}case"MaxPoolWithArgmax":{const a=(0,e.getParamValue)("strides",t,o,l),r=(0,e.getParamValue)("pad",t,o,l),u=(0,e.getParamValue)("kernelSize",t,o,l),n=(0,e.getParamValue)("includeBatchInIndex",t,o,l),{result:i,indexes:d}=s.maxPoolWithArgmax((0,e.getParamValue)("x",t,o,l),[u[1],u[2]],[a[1],a[2]],r,n);return[i,d]}case"AvgPool3D":{const a=(0,e.getParamValue)("strides",t,o,l),r=(0,e.getParamValue)("pad",t,o,l),u=(0,e.getParamValue)("kernelSize",t,o,l);return[s.avgPool3d((0,e.getParamValue)("x",t,o,l),[u[1],u[2],u[3]],[a[1],a[2],a[3]],r)]}case"MaxPool3D":{const a=(0,e.getParamValue)("strides",t,o,l),r=(0,e.getParamValue)("pad",t,o,l),u=(0,e.getParamValue)("kernelSize",t,o,l);return[s.maxPool3d((0,e.getParamValue)("x",t,o,l),[u[1],u[2],u[3]],[a[1],a[2],a[3]],r)]}case"Dilation2D":{const a=(0,e.getParamValue)("strides",t,o,l),r=(0,e.getParamValue)("pad",t,o,l),u=(0,e.getParamValue)("dilations",t,o,l),n=a[1],i=a[2],d=u[1],g=u[2];return[s.dilation2d((0,e.getParamValue)("x",t,o,l),(0,e.getParamValue)("filter",t,o,l),[n,i],r,[d,g],"NHWC")]}default:throw TypeError(`Node type ${t.op} is not implemented`)}};exports.executeOp=o;const l=exports.CATEGORY="convolution";
},{"@tensorflow/tfjs-core/dist/ops/ops_for_converter":"bcFm","./utils":"eBau"}],"S7Bc":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.executeOp=exports.CATEGORY=void 0;var e=t(require("@tensorflow/tfjs-core/dist/ops/ops_for_converter")),a=require("./utils");function t(e,a){if("function"==typeof WeakMap)var r=new WeakMap,u=new WeakMap;return(t=function(e,a){if(!a&&e&&e.__esModule)return e;var t,n,l={__proto__:null,default:e};if(null===e||"object"!=typeof e&&"function"!=typeof e)return l;if(t=a?u:r){if(t.has(e))return t.get(e);t.set(e,l)}for(const r in e)"default"!==r&&{}.hasOwnProperty.call(e,r)&&((n=(t=Object.defineProperty)&&Object.getOwnPropertyDescriptor(e,r))&&(n.get||n.set)?t(l,r,n):l[r]=e[r]);return l})(e,a)}const r=(t,r,u,n=e)=>{switch(t.op){case"Fill":{const e=(0,a.getParamValue)("shape",t,r,u),l=(0,a.getParamValue)("dtype",t,r,u),o=(0,a.getParamValue)("value",t,r,u);return[n.fill(e,o,l)]}case"LinSpace":{const e=(0,a.getParamValue)("start",t,r,u),l=(0,a.getParamValue)("stop",t,r,u),o=(0,a.getParamValue)("num",t,r,u);return[n.linspace(e,l,o)]}case"Multinomial":{const e=(0,a.getParamValue)("logits",t,r,u),l=(0,a.getParamValue)("numSamples",t,r,u),o=(0,a.getParamValue)("seed",t,r,u);return[n.multinomial(e,l,o)]}case"OneHot":{const e=(0,a.getParamValue)("indices",t,r,u),l=(0,a.getParamValue)("depth",t,r,u),o=(0,a.getParamValue)("onValue",t,r,u),s=(0,a.getParamValue)("offValue",t,r,u),m=(0,a.getParamValue)("dtype",t,r,u);return[n.oneHot(e,l,o,s,m)]}case"Ones":return[n.ones((0,a.getParamValue)("shape",t,r,u),(0,a.getParamValue)("dtype",t,r,u))];case"OnesLike":return[n.onesLike((0,a.getParamValue)("x",t,r,u))];case"RandomStandardNormal":return[n.randomStandardNormal((0,a.getParamValue)("shape",t,r,u),(0,a.getParamValue)("dtype",t,r,u),(0,a.getParamValue)("seed",t,r,u))];case"RandomUniform":return[n.randomUniform((0,a.getParamValue)("shape",t,r,u),(0,a.getParamValue)("minval",t,r,u),(0,a.getParamValue)("maxval",t,r,u),(0,a.getParamValue)("dtype",t,r,u))];case"RandomUniformInt":return[n.randomUniformInt((0,a.getParamValue)("shape",t,r,u),(0,a.getParamValue)("minval",t,r,u),(0,a.getParamValue)("maxval",t,r,u),(0,a.getParamValue)("seed",t,r,u))];case"Range":{const e=(0,a.getParamValue)("start",t,r,u),l=(0,a.getParamValue)("stop",t,r,u),o=(0,a.getParamValue)("step",t,r,u);return[n.range(e,l,o,(0,a.getParamValue)("dtype",t,r,u))]}case"TruncatedNormal":{const e=(0,a.getParamValue)("shape",t,r,u),l=(0,a.getParamValue)("mean",t,r,u),o=(0,a.getParamValue)("stdDev",t,r,u),s=(0,a.getParamValue)("seed",t,r,u);return[n.truncatedNormal(e,l,o,(0,a.getParamValue)("dtype",t,r,u),s)]}case"Zeros":return[n.zeros((0,a.getParamValue)("shape",t,r,u),(0,a.getParamValue)("dtype",t,r,u))];case"ZerosLike":return[n.zerosLike((0,a.getParamValue)("x",t,r,u))];default:throw TypeError(`Node type ${t.op} is not implemented`)}};exports.executeOp=r;const u=exports.CATEGORY="creation";
},{"@tensorflow/tfjs-core/dist/ops/ops_for_converter":"bcFm","./utils":"eBau"}],"DfzY":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.executeOp=exports.CATEGORY=void 0;var e=t(require("@tensorflow/tfjs-core/dist/ops/ops_for_converter")),s=require("./utils");function t(e,s){if("function"==typeof WeakMap)var o=new WeakMap,r=new WeakMap;return(t=function(e,s){if(!s&&e&&e.__esModule)return e;var t,a,n={__proto__:null,default:e};if(null===e||"object"!=typeof e&&"function"!=typeof e)return n;if(t=s?r:o){if(t.has(e))return t.get(e);t.set(e,n)}for(const o in e)"default"!==o&&{}.hasOwnProperty.call(e,o)&&((a=(t=Object.defineProperty)&&Object.getOwnPropertyDescriptor(e,o))&&(a.get||a.set)?t(n,o,a):n[o]=e[o]);return n})(e,s)}function o(e,t,o){return{boxes:(0,s.getParamValue)("boxes",e,t,o),scores:(0,s.getParamValue)("scores",e,t,o),maxOutputSize:(0,s.getParamValue)("maxOutputSize",e,t,o),iouThreshold:(0,s.getParamValue)("iouThreshold",e,t,o),scoreThreshold:(0,s.getParamValue)("scoreThreshold",e,t,o),softNmsSigma:(0,s.getParamValue)("softNmsSigma",e,t,o)}}const r=async(t,r,a,n,u=e)=>{switch(t.op){case"NonMaxSuppressionV5":{const{boxes:e,scores:s,maxOutputSize:n,iouThreshold:i,scoreThreshold:c,softNmsSigma:p}=o(t,r,a),l=await u.image.nonMaxSuppressionWithScoreAsync(e,s,n,i,c,p);return[l.selectedIndices,l.selectedScores]}case"NonMaxSuppressionV4":{const{boxes:e,scores:n,maxOutputSize:i,iouThreshold:c,scoreThreshold:p}=o(t,r,a),l=(0,s.getParamValue)("padToMaxOutputSize",t,r,a),d=await u.image.nonMaxSuppressionPaddedAsync(e,n,i,c,p,l);return[d.selectedIndices,d.validOutputs]}case"NonMaxSuppressionV3":case"NonMaxSuppressionV2":{const{boxes:e,scores:s,maxOutputSize:n,iouThreshold:i,scoreThreshold:c}=o(t,r,a);return[await u.image.nonMaxSuppressionAsync(e,s,n,i,c)]}case"Where":{const e=u.cast((0,s.getParamValue)("condition",t,r,a),"bool"),o=[await u.whereAsync(e)];return e.dispose(),o}case"ListDiff":return u.setdiff1dAsync((0,s.getParamValue)("x",t,r,a),(0,s.getParamValue)("y",t,r,a));default:throw TypeError(`Node type ${t.op} is not implemented`)}};exports.executeOp=r;const a=exports.CATEGORY="dynamic";
},{"@tensorflow/tfjs-core/dist/ops/ops_for_converter":"bcFm","./utils":"eBau"}],"j06l":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.executeOp=exports.CATEGORY=void 0;var e=r(require("@tensorflow/tfjs-core/dist/ops/ops_for_converter")),t=require("./utils");function r(e,t){if("function"==typeof WeakMap)var a=new WeakMap,o=new WeakMap;return(r=function(e,t){if(!t&&e&&e.__esModule)return e;var r,u,n={__proto__:null,default:e};if(null===e||"object"!=typeof e&&"function"!=typeof e)return n;if(r=t?o:a){if(r.has(e))return r.get(e);r.set(e,n)}for(const a in e)"default"!==a&&{}.hasOwnProperty.call(e,a)&&((u=(r=Object.defineProperty)&&Object.getOwnPropertyDescriptor(e,a))&&(u.get||u.set)?r(n,a,u):n[a]=e[a]);return n})(e,t)}const a=(r,a,o,u=e)=>{switch(r.op){case"LowerBound":{const e=(0,t.getParamValue)("sortedSequence",r,a,o),n=(0,t.getParamValue)("values",r,a,o);return[u.lowerBound(e,n)]}case"TopKV2":{const e=(0,t.getParamValue)("x",r,a,o),n=(0,t.getParamValue)("k",r,a,o),s=(0,t.getParamValue)("sorted",r,a,o),c=u.topk(e,n,s);return[c.values,c.indices]}case"UpperBound":{const e=(0,t.getParamValue)("sortedSequence",r,a,o),n=(0,t.getParamValue)("values",r,a,o);return[u.upperBound(e,n)]}case"Unique":{const e=(0,t.getParamValue)("x",r,a,o),n=u.unique(e);return[n.values,n.indices]}case"UniqueV2":{const e=(0,t.getParamValue)("x",r,a,o),n=(0,t.getParamValue)("axis",r,a,o),s=u.unique(e,n);return[s.values,s.indices]}default:throw TypeError(`Node type ${r.op} is not implemented`)}};exports.executeOp=a;const o=exports.CATEGORY="evaluation";
},{"@tensorflow/tfjs-core/dist/ops/ops_for_converter":"bcFm","./utils":"eBau"}],"c6LN":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.executeOp=exports.CATEGORY=void 0;var e=a(require("@tensorflow/tfjs-core/dist/ops/ops_for_converter")),t=require("./utils");function a(e,t){if("function"==typeof WeakMap)var r=new WeakMap,n=new WeakMap;return(a=function(e,t){if(!t&&e&&e.__esModule)return e;var a,o,s={__proto__:null,default:e};if(null===e||"object"!=typeof e&&"function"!=typeof e)return s;if(a=t?n:r){if(a.has(e))return a.get(e);a.set(e,s)}for(const r in e)"default"!==r&&{}.hasOwnProperty.call(e,r)&&((o=(a=Object.defineProperty)&&Object.getOwnPropertyDescriptor(e,r))&&(o.get||o.set)?a(s,r,o):s[r]=e[r]);return s})(e,t)}const r=(a,r,n,o=e)=>{switch(a.op){case"Const":return r[a.name];case"PlaceholderWithDefault":const e=(0,t.getParamValue)("default",a,r,n);return[(0,t.getTensor)(a.name,r,n)||e];case"Placeholder":return[(0,t.getTensor)(a.name,r,n)];case"Identity":case"StopGradient":case"FakeQuantWithMinMaxVars":{const e=(0,t.getParamValue)("x",a,r,n);return[(0,t.cloneTensor)(e)]}case"IdentityN":return(0,t.getParamValue)("x",a,r,n).map(e=>(0,t.cloneTensor)(e));case"Snapshot":const s=(0,t.getParamValue)("x",a,r,n);return[(0,t.cloneTensor)(s)];case"Shape":return[o.tensor1d((0,t.getParamValue)("x",a,r,n).shape,"int32")];case"ShapeN":return(0,t.getParamValue)("x",a,r,n).map(e=>o.tensor1d(e.shape));case"Size":return[o.scalar((0,t.getParamValue)("x",a,r,n).size,"int32")];case"Rank":return[o.scalar((0,t.getParamValue)("x",a,r,n).rank,"int32")];case"NoOp":return[o.scalar(1)];case"Print":const u=(0,t.getParamValue)("x",a,r,n),c=(0,t.getParamValue)("data",a,r,n),l=(0,t.getParamValue)("message",a,r,n),p=(0,t.getParamValue)("summarize",a,r,n);console.warn("The graph has a tf.print() operation,usually used for debugging, which slows down performance."),console.log(l);for(let t=0;t<c.length;t++)console.log(Array.prototype.slice.call(c[t].dataSync()).slice(0,p));return[u];default:throw TypeError(`Node type ${a.op} is not implemented`)}};exports.executeOp=r;const n=exports.CATEGORY="graph";
},{"@tensorflow/tfjs-core/dist/ops/ops_for_converter":"bcFm","./utils":"eBau"}],"zdwQ":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.HashTable=void 0;var e=require("@tensorflow/tfjs-core"),t=s(require("@tensorflow/tfjs-core/dist/ops/ops_for_converter"));function s(e,t){if("function"==typeof WeakMap)var r=new WeakMap,n=new WeakMap;return(s=function(e,t){if(!t&&e&&e.__esModule)return e;var s,o,a={__proto__:null,default:e};if(null===e||"object"!=typeof e&&"function"!=typeof e)return a;if(s=t?n:r){if(s.has(e))return s.get(e);s.set(e,a)}for(const r in e)"default"!==r&&{}.hasOwnProperty.call(e,r)&&((o=(s=Object.defineProperty)&&Object.getOwnPropertyDescriptor(e,r))&&(o.get||o.set)?s(a,r,o):a[r]=e[r]);return a})(e,t)}class r{get id(){return this.handle.id}constructor(t,s){this.keyDType=t,this.valueDType=s,this.handle=(0,e.scalar)(0),this.tensorMap=new Map,(0,e.keep)(this.handle)}clearAndClose(){this.tensorMap.forEach(e=>e.dispose()),this.tensorMap.clear(),this.handle.dispose()}size(){return this.tensorMap.size}tensorSize(){return t.scalar(this.size(),"int32")}async import(t,s){this.checkKeyAndValueTensor(t,s);const r=await t.data();return this.tensorMap.forEach(e=>e.dispose()),this.tensorMap.clear(),(0,e.tidy)(()=>{const t=(0,e.unstack)(s),n=r.length,o=t.length;e.util.assert(n===o,()=>"The number of elements doesn't match, keys has "+`${n} elements, the values has ${o} `+"elements.");for(let s=0;s<n;s++){const n=r[s],o=t[s];(0,e.keep)(o),this.tensorMap.set(n,o)}return this.handle})}async find(t,s){this.checkKeyAndValueTensor(t,s);const r=await t.data();return(0,e.tidy)(()=>{const t=[];for(let e=0;e<r.length;e++){const n=r[e],o=this.findWithDefault(n,s);t.push(o)}return(0,e.stack)(t)})}findWithDefault(e,t){const s=this.tensorMap.get(e);return null!=s?s:t}checkKeyAndValueTensor(e,t){if(e.dtype!==this.keyDType)throw new Error(`Expect key dtype ${this.keyDType}, but got `+`${e.dtype}`);if(t.dtype!==this.valueDType)throw new Error(`Expect value dtype ${this.valueDType}, but got `+`${t.dtype}`)}}exports.HashTable=r;
},{"@tensorflow/tfjs-core":"kSBl","@tensorflow/tfjs-core/dist/ops/ops_for_converter":"bcFm"}],"qYIJ":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.executeOp=exports.CATEGORY=void 0;var e=require("../../executor/hash_table"),a=require("./utils");const t=async(t,l,s,r)=>{switch(t.op){case"HashTable":case"HashTableV2":{const o=r.getHashTableHandleByName(t.name);if(null!=o)return[o];{const o=(0,a.getParamValue)("keyDType",t,l,s),u=(0,a.getParamValue)("valueDType",t,l,s),n=new e.HashTable(o,u);return r.addHashTable(t.name,n),[n.handle]}}case"InitializeTable":case"InitializeTableV2":case"LookupTableImport":case"LookupTableImportV2":{const e=(0,a.getParamValue)("tableHandle",t,l,s,r),o=(0,a.getParamValue)("keys",t,l,s),u=(0,a.getParamValue)("values",t,l,s),n=r.getHashTableById(e.id);return[await n.import(o,u)]}case"LookupTableFind":case"LookupTableFindV2":{const e=(0,a.getParamValue)("tableHandle",t,l,s,r),o=(0,a.getParamValue)("keys",t,l,s),u=(0,a.getParamValue)("defaultValue",t,l,s),n=r.getHashTableById(e.id);return[await n.find(o,u)]}case"LookupTableSize":case"LookupTableSizeV2":{const e=(0,a.getParamValue)("tableHandle",t,l,s,r);return[r.getHashTableById(e.id).tensorSize()]}default:throw TypeError(`Node type ${t.op} is not implemented`)}};exports.executeOp=t;const l=exports.CATEGORY="hash_table";
},{"../../executor/hash_table":"zdwQ","./utils":"eBau"}],"P01n":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.executeOp=exports.CATEGORY=void 0;var e=r(require("@tensorflow/tfjs-core/dist/ops/ops_for_converter")),a=require("./utils");function r(e,a){if("function"==typeof WeakMap)var t=new WeakMap,o=new WeakMap;return(r=function(e,a){if(!a&&e&&e.__esModule)return e;var r,s,i={__proto__:null,default:e};if(null===e||"object"!=typeof e&&"function"!=typeof e)return i;if(r=a?o:t){if(r.has(e))return r.get(e);r.set(e,i)}for(const t in e)"default"!==t&&{}.hasOwnProperty.call(e,t)&&((s=(r=Object.defineProperty)&&Object.getOwnPropertyDescriptor(e,t))&&(s.get||s.set)?r(i,t,s):i[t]=e[t]);return i})(e,a)}const t=(r,t,o,s=e)=>{switch(r.op){case"ResizeBilinear":{const e=(0,a.getParamValue)("images",r,t,o),i=(0,a.getParamValue)("size",r,t,o),n=(0,a.getParamValue)("alignCorners",r,t,o),l=(0,a.getParamValue)("halfPixelCenters",r,t,o);return[s.image.resizeBilinear(e,[i[0],i[1]],n,l)]}case"ResizeNearestNeighbor":{const e=(0,a.getParamValue)("images",r,t,o),i=(0,a.getParamValue)("size",r,t,o),n=(0,a.getParamValue)("alignCorners",r,t,o),l=(0,a.getParamValue)("halfPixelCenters",r,t,o);return[s.image.resizeNearestNeighbor(e,[i[0],i[1]],n,l)]}case"CropAndResize":{const e=(0,a.getParamValue)("image",r,t,o),i=(0,a.getParamValue)("boxes",r,t,o),n=(0,a.getParamValue)("boxInd",r,t,o),l=(0,a.getParamValue)("cropSize",r,t,o),u=(0,a.getParamValue)("method",r,t,o),g=(0,a.getParamValue)("extrapolationValue",r,t,o);return[s.image.cropAndResize(e,i,n,l,u,g)]}case"ImageProjectiveTransformV3":{const e=(0,a.getParamValue)("images",r,t,o),i=(0,a.getParamValue)("transforms",r,t,o),n=(0,a.getParamValue)("outputShape",r,t,o),l=(0,a.getParamValue)("fillValue",r,t,o),u=(0,a.getParamValue)("interpolation",r,t,o),g=(0,a.getParamValue)("fillMode",r,t,o);return[s.image.transform(e,i,u.toLowerCase(),g.toLowerCase(),l,n)]}default:throw TypeError(`Node type ${r.op} is not implemented`)}};exports.executeOp=t;const o=exports.CATEGORY="image";
},{"@tensorflow/tfjs-core/dist/ops/ops_for_converter":"bcFm","./utils":"eBau"}],"fJEP":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.executeOp=exports.CATEGORY=void 0;var e=r(require("@tensorflow/tfjs-core/dist/ops/ops_for_converter")),a=require("./utils");function r(e,a){if("function"==typeof WeakMap)var t=new WeakMap,u=new WeakMap;return(r=function(e,a){if(!a&&e&&e.__esModule)return e;var r,l,o={__proto__:null,default:e};if(null===e||"object"!=typeof e&&"function"!=typeof e)return o;if(r=a?u:t){if(r.has(e))return r.get(e);r.set(e,o)}for(const t in e)"default"!==t&&{}.hasOwnProperty.call(e,t)&&((l=(r=Object.defineProperty)&&Object.getOwnPropertyDescriptor(e,t))&&(l.get||l.set)?r(o,t,l):o[t]=e[t]);return o})(e,a)}const t=(r,t,u,l=e)=>{switch(r.op){case"Equal":return[l.equal((0,a.getParamValue)("a",r,t,u),(0,a.getParamValue)("b",r,t,u))];case"NotEqual":return[l.notEqual((0,a.getParamValue)("a",r,t,u),(0,a.getParamValue)("b",r,t,u))];case"Greater":return[l.greater((0,a.getParamValue)("a",r,t,u),(0,a.getParamValue)("b",r,t,u))];case"GreaterEqual":return[l.greaterEqual((0,a.getParamValue)("a",r,t,u),(0,a.getParamValue)("b",r,t,u))];case"Less":return[l.less((0,a.getParamValue)("a",r,t,u),(0,a.getParamValue)("b",r,t,u))];case"LessEqual":return[l.lessEqual((0,a.getParamValue)("a",r,t,u),(0,a.getParamValue)("b",r,t,u))];case"LogicalAnd":return[l.logicalAnd((0,a.getParamValue)("a",r,t,u),(0,a.getParamValue)("b",r,t,u))];case"LogicalNot":return[l.logicalNot((0,a.getParamValue)("a",r,t,u))];case"LogicalOr":return[l.logicalOr((0,a.getParamValue)("a",r,t,u),(0,a.getParamValue)("b",r,t,u))];case"Select":case"SelectV2":return[l.where((0,a.getParamValue)("condition",r,t,u),(0,a.getParamValue)("a",r,t,u),(0,a.getParamValue)("b",r,t,u))];case"BitwiseAnd":return[l.bitwiseAnd((0,a.getParamValue)("a",r,t,u),(0,a.getParamValue)("b",r,t,u))];default:throw TypeError(`Node type ${r.op} is not implemented`)}};exports.executeOp=t;const u=exports.CATEGORY="logical";
},{"@tensorflow/tfjs-core/dist/ops/ops_for_converter":"bcFm","./utils":"eBau"}],"Rlpz":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.executeOp=exports.CATEGORY=void 0;var e=t(require("@tensorflow/tfjs-core/dist/ops/ops_for_converter")),a=require("./utils");function t(e,a){if("function"==typeof WeakMap)var r=new WeakMap,u=new WeakMap;return(t=function(e,a){if(!a&&e&&e.__esModule)return e;var t,s,n={__proto__:null,default:e};if(null===e||"object"!=typeof e&&"function"!=typeof e)return n;if(t=a?u:r){if(t.has(e))return t.get(e);t.set(e,n)}for(const r in e)"default"!==r&&{}.hasOwnProperty.call(e,r)&&((s=(t=Object.defineProperty)&&Object.getOwnPropertyDescriptor(e,r))&&(s.get||s.set)?t(n,r,s):n[r]=e[r]);return n})(e,a)}const r=(t,r,u,s=e)=>{switch(t.op){case"BatchMatMul":case"BatchMatMulV2":case"MatMul":return[s.matMul((0,a.getParamValue)("a",t,r,u),(0,a.getParamValue)("b",t,r,u),(0,a.getParamValue)("transposeA",t,r,u),(0,a.getParamValue)("transposeB",t,r,u))];case"Einsum":return[s.einsum((0,a.getParamValue)("equation",t,r,u),...(0,a.getParamValue)("tensors",t,r,u))];case"Transpose":return[s.transpose((0,a.getParamValue)("x",t,r,u),(0,a.getParamValue)("perm",t,r,u))];case"_FusedMatMul":const[e,n]=(0,a.getParamValue)("fusedOps",t,r,u),o="biasadd"===e,l="prelu"===n,i=(0,a.getParamValue)("numArgs",t,r,u),p=(0,a.getParamValue)("leakyreluAlpha",t,r,u);if(o){if(l&&2!==i)throw new Error("Fused MatMul with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!l&&1!==i)throw new Error("Fused MatMul with BiasAdd must have one extra argument: bias.")}const[m,c]=(0,a.getParamValue)("args",t,r,u);return[s.fused.matMul({a:(0,a.getParamValue)("a",t,r,u),b:(0,a.getParamValue)("b",t,r,u),transposeA:(0,a.getParamValue)("transposeA",t,r,u),transposeB:(0,a.getParamValue)("transposeB",t,r,u),bias:m,activation:n,preluActivationWeights:c,leakyreluAlpha:p})];case"MatrixBandPart":return[s.linalg.bandPart((0,a.getParamValue)("a",t,r,u),(0,a.getParamValue)("numLower",t,r,u),(0,a.getParamValue)("numUpper",t,r,u))];default:throw TypeError(`Node type ${t.op} is not implemented`)}};exports.executeOp=r;const u=exports.CATEGORY="matrices";
},{"@tensorflow/tfjs-core/dist/ops/ops_for_converter":"bcFm","./utils":"eBau"}],"Pftj":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.executeOp=exports.CATEGORY=void 0;var e=t(require("@tensorflow/tfjs-core/dist/ops/ops_for_converter")),a=require("./utils");function t(e,a){if("function"==typeof WeakMap)var r=new WeakMap,o=new WeakMap;return(t=function(e,a){if(!a&&e&&e.__esModule)return e;var t,u,s={__proto__:null,default:e};if(null===e||"object"!=typeof e&&"function"!=typeof e)return s;if(t=a?o:r){if(t.has(e))return t.get(e);t.set(e,s)}for(const r in e)"default"!==r&&{}.hasOwnProperty.call(e,r)&&((u=(t=Object.defineProperty)&&Object.getOwnPropertyDescriptor(e,r))&&(u.get||u.set)?t(s,r,u):s[r]=e[r]);return s})(e,a)}const r=(t,r,o,u=e)=>{switch(t.op){case"EuclideanNorm":return[u.euclideanNorm((0,a.getParamValue)("x",t,r,o),(0,a.getParamValue)("axis",t,r,o),(0,a.getParamValue)("keepDims",t,r,o))];case"FusedBatchNorm":case"FusedBatchNormV2":case"FusedBatchNormV3":return[u.batchNorm((0,a.getParamValue)("x",t,r,o),(0,a.getParamValue)("mean",t,r,o),(0,a.getParamValue)("variance",t,r,o),(0,a.getParamValue)("offset",t,r,o),(0,a.getParamValue)("scale",t,r,o),(0,a.getParamValue)("epsilon",t,r,o))];case"LRN":return[u.localResponseNormalization((0,a.getParamValue)("x",t,r,o),(0,a.getParamValue)("radius",t,r,o),(0,a.getParamValue)("bias",t,r,o),(0,a.getParamValue)("alpha",t,r,o),(0,a.getParamValue)("beta",t,r,o))];case"Softmax":return[u.softmax((0,a.getParamValue)("x",t,r,o))];case"LogSoftmax":return[u.logSoftmax((0,a.getParamValue)("x",t,r,o))];default:throw TypeError(`Node type ${t.op} is not implemented`)}};exports.executeOp=r;const o=exports.CATEGORY="normalization";
},{"@tensorflow/tfjs-core/dist/ops/ops_for_converter":"bcFm","./utils":"eBau"}],"wIW8":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.executeOp=exports.CATEGORY=void 0;var e=a(require("@tensorflow/tfjs-core/dist/ops/ops_for_converter")),t=require("./utils");function a(e,t){if("function"==typeof WeakMap)var r=new WeakMap,s=new WeakMap;return(a=function(e,t){if(!t&&e&&e.__esModule)return e;var a,o,u={__proto__:null,default:e};if(null===e||"object"!=typeof e&&"function"!=typeof e)return u;if(a=t?s:r){if(a.has(e))return a.get(e);a.set(e,u)}for(const r in e)"default"!==r&&{}.hasOwnProperty.call(e,r)&&((o=(a=Object.defineProperty)&&Object.getOwnPropertyDescriptor(e,r))&&(o.get||o.set)?a(u,r,o):u[r]=e[r]);return u})(e,t)}const r=(a,r,s,o=e)=>{switch(a.op){case"RaggedGather":{const{outputNestedSplits:e,outputDenseValues:u}=o.raggedGather((0,t.getParamValue)("paramsNestedSplits",a,r,s),(0,t.getParamValue)("paramsDenseValues",a,r,s),(0,t.getParamValue)("indices",a,r,s),(0,t.getParamValue)("outputRaggedRank",a,r,s));return e.concat(u)}case"RaggedRange":{const{rtNestedSplits:e,rtDenseValues:u}=o.raggedRange((0,t.getParamValue)("starts",a,r,s),(0,t.getParamValue)("limits",a,r,s),(0,t.getParamValue)("splits",a,r,s));return[e,u]}case"RaggedTensorToTensor":return[o.raggedTensorToTensor((0,t.getParamValue)("shape",a,r,s),(0,t.getParamValue)("values",a,r,s),(0,t.getParamValue)("defaultValue",a,r,s),(0,t.getParamValue)("rowPartitionTensors",a,r,s),(0,t.getParamValue)("rowPartitionTypes",a,r,s))];default:throw TypeError(`Node type ${a.op} is not implemented`)}};exports.executeOp=r;const s=exports.CATEGORY="ragged";
},{"@tensorflow/tfjs-core/dist/ops/ops_for_converter":"bcFm","./utils":"eBau"}],"ftj2":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.executeOp=exports.CATEGORY=void 0;var e=t(require("@tensorflow/tfjs-core/dist/ops/ops_for_converter")),a=require("./utils");function t(e,a){if("function"==typeof WeakMap)var r=new WeakMap,u=new WeakMap;return(t=function(e,a){if(!a&&e&&e.__esModule)return e;var t,s,n={__proto__:null,default:e};if(null===e||"object"!=typeof e&&"function"!=typeof e)return n;if(t=a?u:r){if(t.has(e))return t.get(e);t.set(e,n)}for(const r in e)"default"!==r&&{}.hasOwnProperty.call(e,r)&&((s=(t=Object.defineProperty)&&Object.getOwnPropertyDescriptor(e,r))&&(s.get||s.set)?t(n,r,s):n[r]=e[r]);return n})(e,a)}const r=(t,r,u,s=e)=>{switch(t.op){case"Max":{const e=(0,a.getParamValue)("axis",t,r,u),n=(0,a.getParamValue)("keepDims",t,r,u);return[s.max((0,a.getParamValue)("x",t,r,u),e,n)]}case"Mean":{const e=(0,a.getParamValue)("axis",t,r,u),n=(0,a.getParamValue)("keepDims",t,r,u);return[s.mean((0,a.getParamValue)("x",t,r,u),e,n)]}case"Min":{const e=(0,a.getParamValue)("axis",t,r,u),n=(0,a.getParamValue)("keepDims",t,r,u);return[s.min((0,a.getParamValue)("x",t,r,u),e,n)]}case"Sum":{const e=(0,a.getParamValue)("axis",t,r,u),n=(0,a.getParamValue)("keepDims",t,r,u);return[s.sum((0,a.getParamValue)("x",t,r,u),e,n)]}case"All":{const e=(0,a.getParamValue)("axis",t,r,u),n=(0,a.getParamValue)("keepDims",t,r,u);return[s.all((0,a.getParamValue)("x",t,r,u),e,n)]}case"Any":{const e=(0,a.getParamValue)("axis",t,r,u),n=(0,a.getParamValue)("keepDims",t,r,u);return[s.any((0,a.getParamValue)("x",t,r,u),e,n)]}case"ArgMax":{const e=(0,a.getParamValue)("axis",t,r,u);return[s.argMax((0,a.getParamValue)("x",t,r,u),e)]}case"ArgMin":{const e=(0,a.getParamValue)("axis",t,r,u);return[s.argMin((0,a.getParamValue)("x",t,r,u),e)]}case"Prod":{const e=(0,a.getParamValue)("axis",t,r,u),n=(0,a.getParamValue)("keepDims",t,r,u);return[s.prod((0,a.getParamValue)("x",t,r,u),e,n)]}case"Cumprod":{const e=(0,a.getParamValue)("axis",t,r,u),n=(0,a.getParamValue)("exclusive",t,r,u),o=(0,a.getParamValue)("reverse",t,r,u);return[s.cumprod((0,a.getParamValue)("x",t,r,u),e,n,o)]}case"Cumsum":{const e=(0,a.getParamValue)("axis",t,r,u),n=(0,a.getParamValue)("exclusive",t,r,u),o=(0,a.getParamValue)("reverse",t,r,u);return[s.cumsum((0,a.getParamValue)("x",t,r,u),e,n,o)]}case"Bincount":const e=(0,a.getParamValue)("x",t,r,u),n=(0,a.getParamValue)("weights",t,r,u),o=(0,a.getParamValue)("size",t,r,u);return[s.bincount(e,n,o)];case"DenseBincount":{const e=(0,a.getParamValue)("x",t,r,u),n=(0,a.getParamValue)("weights",t,r,u),o=(0,a.getParamValue)("size",t,r,u),l=(0,a.getParamValue)("binaryOutput",t,r,u);return[s.denseBincount(e,n,o,l)]}default:throw TypeError(`Node type ${t.op} is not implemented`)}};exports.executeOp=r;const u=exports.CATEGORY="reduction";
},{"@tensorflow/tfjs-core/dist/ops/ops_for_converter":"bcFm","./utils":"eBau"}],"inkj":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.executeOp=exports.CATEGORY=void 0;var e=require("@tensorflow/tfjs-core"),a=r(require("@tensorflow/tfjs-core/dist/ops/ops_for_converter")),t=require("./utils");function r(e,a){if("function"==typeof WeakMap)var t=new WeakMap,s=new WeakMap;return(r=function(e,a){if(!a&&e&&e.__esModule)return e;var r,u,n={__proto__:null,default:e};if(null===e||"object"!=typeof e&&"function"!=typeof e)return n;if(r=a?s:t){if(r.has(e))return r.get(e);r.set(e,n)}for(const t in e)"default"!==t&&{}.hasOwnProperty.call(e,t)&&((u=(r=Object.defineProperty)&&Object.getOwnPropertyDescriptor(e,t))&&(u.get||u.set)?r(n,t,u):n[t]=e[t]);return n})(e,a)}const s=(r,s,u,n=a)=>{switch(r.op){case"ConcatV2":case"Concat":{const e=(0,t.getParamValue)("n",r,s,u),a=(0,t.getParamValue)("axis",r,s,u);let l=(0,t.getParamValue)("tensors",r,s,u);return l=l.slice(0,e),[n.concat(l,a)]}case"Gather":{const e=(0,t.getParamValue)("x",r,s,u),a=(0,t.getParamValue)("indices",r,s,u);return[n.gather(e,n.cast(a,"int32"),0)]}case"GatherV2":{const e=(0,t.getParamValue)("axis",r,s,u),a=(0,t.getParamValue)("batchDims",r,s,u),l=(0,t.getParamValue)("x",r,s,u),c=(0,t.getParamValue)("indices",r,s,u);return[n.gather(l,n.cast(c,"int32"),e,a)]}case"Reverse":{const e=(0,t.getParamValue)("dims",r,s,u),a=[];for(let t=0;t<e.length;t++)e[t]&&a.push(t);const l=(0,t.getParamValue)("x",r,s,u);return[n.reverse(l,a)]}case"ReverseV2":{const e=(0,t.getParamValue)("axis",r,s,u),a=(0,t.getParamValue)("x",r,s,u);return[n.reverse(a,e)]}case"Slice":{const e=(0,t.getParamValue)("begin",r,s,u),a=(0,t.getParamValue)("size",r,s,u);return[n.slice((0,t.getParamValue)("x",r,s,u),e,a)]}case"StridedSlice":{const e=(0,t.getParamValue)("begin",r,s,u),a=(0,t.getParamValue)("end",r,s,u),l=(0,t.getParamValue)("strides",r,s,u),c=(0,t.getParamValue)("beginMask",r,s,u),o=(0,t.getParamValue)("endMask",r,s,u),i=(0,t.getParamValue)("ellipsisMask",r,s,u),g=(0,t.getParamValue)("newAxisMask",r,s,u),p=(0,t.getParamValue)("shrinkAxisMask",r,s,u),m=(0,t.getParamValue)("x",r,s,u);return[n.stridedSlice(m,e,a,l,c,o,i,g,p)]}case"Pack":return(0,e.tidy)(()=>{const a=(0,t.getParamValue)("axis",r,s,u),l=(0,t.getParamValue)("tensors",r,s,u),c=l[0].shape,o=n.squeeze(l[0]).shape,i=l.map(a=>{const t=e.util.arraysEqual(a.shape,c);if(!t&&!e.util.arraysEqual(n.squeeze(a).shape,o))throw new Error("the input tensors shape does not match");return t?a:n.reshape(a,c)});return[n.stack(i,a)]});case"Unpack":{const e=(0,t.getParamValue)("axis",r,s,u),a=(0,t.getParamValue)("tensor",r,s,u);return n.unstack(a,e)}case"Tile":{const e=(0,t.getParamValue)("reps",r,s,u);return[n.tile((0,t.getParamValue)("x",r,s,u),e)]}case"Split":case"SplitV":{const e=(0,t.getParamValue)("axis",r,s,u),a=(0,t.getParamValue)("numOrSizeSplits",r,s,u),l=(0,t.getParamValue)("x",r,s,u);return n.split(l,a,e)}case"ScatterNd":{const e=(0,t.getParamValue)("indices",r,s,u),a=(0,t.getParamValue)("values",r,s,u),l=(0,t.getParamValue)("shape",r,s,u);return[n.scatterND(e,a,l)]}case"GatherNd":{const e=(0,t.getParamValue)("x",r,s,u),a=(0,t.getParamValue)("indices",r,s,u);return[n.gatherND(e,a)]}case"SparseToDense":{const e=(0,t.getParamValue)("sparseIndices",r,s,u),a=(0,t.getParamValue)("outputShape",r,s,u),l=(0,t.getParamValue)("sparseValues",r,s,u),c=(0,t.getParamValue)("defaultValue",r,s,u);return[n.sparseToDense(e,l,a,l.dtype===c.dtype?c:n.cast(c,l.dtype))]}case"TensorScatterUpdate":{const e=(0,t.getParamValue)("indices",r,s,u),a=(0,t.getParamValue)("values",r,s,u),l=(0,t.getParamValue)("tensor",r,s,u);return[n.tensorScatterUpdate(l,e,a)]}default:throw TypeError(`Node type ${r.op} is not implemented`)}};exports.executeOp=s;const u=exports.CATEGORY="slice_join";
},{"@tensorflow/tfjs-core":"kSBl","@tensorflow/tfjs-core/dist/ops/ops_for_converter":"bcFm","./utils":"eBau"}],"zdfJ":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.executeOp=exports.CATEGORY=void 0;var e=a(require("@tensorflow/tfjs-core/dist/ops/ops_for_converter")),t=require("./utils");function a(e,t){if("function"==typeof WeakMap)var r=new WeakMap,s=new WeakMap;return(a=function(e,t){if(!t&&e&&e.__esModule)return e;var a,u,n={__proto__:null,default:e};if(null===e||"object"!=typeof e&&"function"!=typeof e)return n;if(a=t?s:r){if(a.has(e))return a.get(e);a.set(e,n)}for(const r in e)"default"!==r&&{}.hasOwnProperty.call(e,r)&&((u=(a=Object.defineProperty)&&Object.getOwnPropertyDescriptor(e,r))&&(u.get||u.set)?a(n,r,u):n[r]=e[r]);return n})(e,t)}const r=(a,r,s,u=e)=>{switch(a.op){case"SparseFillEmptyRows":{const{outputIndices:e,outputValues:n,emptyRowIndicator:p,reverseIndexMap:o}=u.sparse.sparseFillEmptyRows((0,t.getParamValue)("indices",a,r,s),(0,t.getParamValue)("values",a,r,s),(0,t.getParamValue)("denseShape",a,r,s),(0,t.getParamValue)("defaultValue",a,r,s));return[e,n,p,o]}case"SparseReshape":{const{outputIndices:e,outputShape:n}=u.sparse.sparseReshape((0,t.getParamValue)("inputIndices",a,r,s),(0,t.getParamValue)("inputShape",a,r,s),(0,t.getParamValue)("newShape",a,r,s));return[e,n]}case"SparseSegmentMean":return[u.sparse.sparseSegmentMean((0,t.getParamValue)("data",a,r,s),(0,t.getParamValue)("indices",a,r,s),(0,t.getParamValue)("segmentIds",a,r,s))];case"SparseSegmentSum":return[u.sparse.sparseSegmentSum((0,t.getParamValue)("data",a,r,s),(0,t.getParamValue)("indices",a,r,s),(0,t.getParamValue)("segmentIds",a,r,s))];default:throw TypeError(`Node type ${a.op} is not implemented`)}};exports.executeOp=r;const s=exports.CATEGORY="sparse";
},{"@tensorflow/tfjs-core/dist/ops/ops_for_converter":"bcFm","./utils":"eBau"}],"Xups":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.executeOp=exports.CATEGORY=void 0;var e=r(require("@tensorflow/tfjs-core/dist/ops/ops_for_converter")),t=require("./utils");function r(e,t){if("function"==typeof WeakMap)var o=new WeakMap,a=new WeakMap;return(r=function(e,t){if(!t&&e&&e.__esModule)return e;var r,n,u={__proto__:null,default:e};if(null===e||"object"!=typeof e&&"function"!=typeof e)return u;if(r=t?a:o){if(r.has(e))return r.get(e);r.set(e,u)}for(const o in e)"default"!==o&&{}.hasOwnProperty.call(e,o)&&((n=(r=Object.defineProperty)&&Object.getOwnPropertyDescriptor(e,o))&&(n.get||n.set)?r(u,o,n):u[o]=e[o]);return u})(e,t)}const o=(r,o,a,n=e)=>{switch(r.op){case"FFT":return[n.fft((0,t.getParamValue)("x",r,o,a))];case"IFFT":return[n.ifft((0,t.getParamValue)("x",r,o,a))];case"RFFT":return[n.rfft((0,t.getParamValue)("x",r,o,a))];case"IRFFT":return[n.irfft((0,t.getParamValue)("x",r,o,a))];default:throw TypeError(`Node type ${r.op} is not implemented`)}};exports.executeOp=o;const a=exports.CATEGORY="spectral";
},{"@tensorflow/tfjs-core/dist/ops/ops_for_converter":"bcFm","./utils":"eBau"}],"aetQ":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.executeOp=exports.CATEGORY=void 0;var e=a(require("@tensorflow/tfjs-core/dist/ops/ops_for_converter")),t=require("./utils");function a(e,t){if("function"==typeof WeakMap)var r=new WeakMap,s=new WeakMap;return(a=function(e,t){if(!t&&e&&e.__esModule)return e;var a,n,u={__proto__:null,default:e};if(null===e||"object"!=typeof e&&"function"!=typeof e)return u;if(a=t?s:r){if(a.has(e))return a.get(e);a.set(e,u)}for(const r in e)"default"!==r&&{}.hasOwnProperty.call(e,r)&&((n=(a=Object.defineProperty)&&Object.getOwnPropertyDescriptor(e,r))&&(n.get||n.set)?a(u,r,n):u[r]=e[r]);return u})(e,t)}const r=(a,r,s,n=e)=>{switch(a.op){case"StaticRegexReplace":return[n.string.staticRegexReplace((0,t.getParamValue)("input",a,r,s),(0,t.getParamValue)("pattern",a,r,s),(0,t.getParamValue)("rewrite",a,r,s),(0,t.getParamValue)("replaceGlobal",a,r,s))];case"StringNGrams":{const{nGrams:e,nGramsSplits:u}=n.string.stringNGrams((0,t.getParamValue)("data",a,r,s),(0,t.getParamValue)("dataSplits",a,r,s),(0,t.getParamValue)("separator",a,r,s),(0,t.getParamValue)("nGramWidths",a,r,s),(0,t.getParamValue)("leftPad",a,r,s),(0,t.getParamValue)("rightPad",a,r,s),(0,t.getParamValue)("padWidth",a,r,s),(0,t.getParamValue)("preserveShortSequences",a,r,s));return[e,u]}case"StringSplit":{const{indices:e,values:u,shape:i}=n.string.stringSplit((0,t.getParamValue)("input",a,r,s),(0,t.getParamValue)("delimiter",a,r,s),(0,t.getParamValue)("skipEmpty",a,r,s));return[e,u,i]}case"StringToHashBucketFast":return[n.string.stringToHashBucketFast((0,t.getParamValue)("input",a,r,s),(0,t.getParamValue)("numBuckets",a,r,s))];default:throw TypeError(`Node type ${a.op} is not implemented`)}};exports.executeOp=r;const s=exports.CATEGORY="string";
},{"@tensorflow/tfjs-core/dist/ops/ops_for_converter":"bcFm","./utils":"eBau"}],"m1J1":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.executeOp=exports.CATEGORY=void 0;var e=t(require("@tensorflow/tfjs-core/dist/ops/ops_for_converter")),a=require("./utils");function t(e,a){if("function"==typeof WeakMap)var r=new WeakMap,s=new WeakMap;return(t=function(e,a){if(!a&&e&&e.__esModule)return e;var t,o,u={__proto__:null,default:e};if(null===e||"object"!=typeof e&&"function"!=typeof e)return u;if(t=a?s:r){if(t.has(e))return t.get(e);t.set(e,u)}for(const r in e)"default"!==r&&{}.hasOwnProperty.call(e,r)&&((o=(t=Object.defineProperty)&&Object.getOwnPropertyDescriptor(e,r))&&(o.get||o.set)?t(u,r,o):u[r]=e[r]);return u})(e,a)}const r=(t,r,s,o=e)=>{switch(t.op){case"Cast":return[o.cast((0,a.getParamValue)("x",t,r,s),(0,a.getParamValue)("dtype",t,r,s))];case"ExpandDims":{const e=(0,a.getParamValue)("axis",t,r,s);return[o.expandDims((0,a.getParamValue)("x",t,r,s),e)]}case"Squeeze":{const e=(0,a.getParamValue)("axis",t,r,s);return[o.squeeze((0,a.getParamValue)("x",t,r,s),e)]}case"Reshape":return[o.reshape((0,a.getParamValue)("x",t,r,s),(0,a.getParamValue)("shape",t,r,s))];case"EnsureShape":return[o.ensureShape((0,a.getParamValue)("x",t,r,s),(0,a.getParamValue)("shape",t,r,s))];case"MirrorPad":return[o.mirrorPad((0,a.getParamValue)("x",t,r,s),(0,a.getParamValue)("padding",t,r,s),(0,a.getParamValue)("mode",t,r,s))];case"PadV2":case"Pad":return[o.pad((0,a.getParamValue)("x",t,r,s),(0,a.getParamValue)("padding",t,r,s),(0,a.getParamValue)("constantValue",t,r,s))];case"SpaceToBatchND":{const e=(0,a.getParamValue)("blockShape",t,r,s),u=(0,a.getParamValue)("paddings",t,r,s);return[o.spaceToBatchND((0,a.getParamValue)("x",t,r,s),e,u)]}case"BatchToSpaceND":{const e=(0,a.getParamValue)("blockShape",t,r,s),u=(0,a.getParamValue)("crops",t,r,s);return[o.batchToSpaceND((0,a.getParamValue)("x",t,r,s),e,u)]}case"DepthToSpace":{const e=(0,a.getParamValue)("blockSize",t,r,s),u=(0,a.getParamValue)("dataFormat",t,r,s).toUpperCase();return[o.depthToSpace((0,a.getParamValue)("x",t,r,s),e,u)]}case"BroadcastTo":return[o.broadcastTo((0,a.getParamValue)("x",t,r,s),(0,a.getParamValue)("shape",t,r,s))];case"BroadcastArgs":return[o.broadcastArgs((0,a.getParamValue)("s0",t,r,s),(0,a.getParamValue)("s1",t,r,s))];default:throw TypeError(`Node type ${t.op} is not implemented`)}};exports.executeOp=r;const s=exports.CATEGORY="transformation";
},{"@tensorflow/tfjs-core/dist/ops/ops_for_converter":"bcFm","./utils":"eBau"}],"hN1H":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.executeOp=v;var e=b(require("@tensorflow/tfjs-core")),r=require("./custom_op/node_value_impl"),t=require("./custom_op/register"),u=b(require("./executors/arithmetic_executor")),c=b(require("./executors/basic_math_executor")),o=b(require("./executors/control_executor")),s=b(require("./executors/convolution_executor")),i=b(require("./executors/creation_executor")),n=b(require("./executors/dynamic_executor")),a=b(require("./executors/evaluation_executor")),x=b(require("./executors/graph_executor")),p=b(require("./executors/hash_table_executor")),l=b(require("./executors/image_executor")),_=b(require("./executors/logical_executor")),O=b(require("./executors/matrices_executor")),f=b(require("./executors/normalization_executor")),m=b(require("./executors/ragged_executor")),g=b(require("./executors/reduction_executor")),q=b(require("./executors/slice_join_executor")),d=b(require("./executors/sparse_executor")),h=b(require("./executors/spectral_executor")),w=b(require("./executors/string_executor")),y=b(require("./executors/transformation_executor"));function b(e,r){if("function"==typeof WeakMap)var t=new WeakMap,u=new WeakMap;return(b=function(e,r){if(!r&&e&&e.__esModule)return e;var c,o,s={__proto__:null,default:e};if(null===e||"object"!=typeof e&&"function"!=typeof e)return s;if(c=r?u:t){if(c.has(e))return c.get(e);c.set(e,s)}for(const t in e)"default"!==t&&{}.hasOwnProperty.call(e,t)&&((o=(c=Object.defineProperty)&&Object.getOwnPropertyDescriptor(e,t))&&(o.get||o.set)?c(s,t,o):s[t]=e[t]);return s})(e,r)}function v(b,v,j,M,P=e.tidy){const k=((e,b,v)=>{switch(e.category){case"arithmetic":return P(()=>u.executeOp(e,b,v));case"basic_math":return P(()=>c.executeOp(e,b,v));case"control":return o.executeOp(e,b,v);case"convolution":return P(()=>s.executeOp(e,b,v));case"creation":return P(()=>i.executeOp(e,b,v));case"dynamic":return n.executeOp(e,b,v);case"evaluation":return P(()=>a.executeOp(e,b,v));case"image":return P(()=>l.executeOp(e,b,v));case"graph":return P(()=>x.executeOp(e,b,v));case"logical":return P(()=>_.executeOp(e,b,v));case"matrices":return P(()=>O.executeOp(e,b,v));case"normalization":return P(()=>f.executeOp(e,b,v));case"ragged":return P(()=>m.executeOp(e,b,v));case"reduction":return P(()=>g.executeOp(e,b,v));case"slice_join":return P(()=>q.executeOp(e,b,v));case"sparse":return P(()=>d.executeOp(e,b,v));case"spectral":return P(()=>h.executeOp(e,b,v));case"string":return P(()=>w.executeOp(e,b,v));case"transformation":return P(()=>y.executeOp(e,b,v));case"hash_table":return p.executeOp(e,b,v,M);case"custom":const j=(0,t.getRegisteredOp)(e.op);if(j&&j.customExecutor)return j.customExecutor(new r.NodeValueImpl(e,b,v));throw TypeError(`Custom op ${e.op} is not registered.`);default:throw TypeError(`Unknown op '${e.op}'. File an issue at `+"https://github.com/tensorflow/tfjs/issues so we can add it, or register a custom execution with tf.registerOp()")}})(b,v,j);return e.util.isPromise(k)?k.then(e=>[].concat(e)):[].concat(k)}
},{"@tensorflow/tfjs-core":"kSBl","./custom_op/node_value_impl":"N9rI","./custom_op/register":"LNan","./executors/arithmetic_executor":"WLe9","./executors/basic_math_executor":"RUi0","./executors/control_executor":"vqcE","./executors/convolution_executor":"I0Jg","./executors/creation_executor":"S7Bc","./executors/dynamic_executor":"DfzY","./executors/evaluation_executor":"j06l","./executors/graph_executor":"c6LN","./executors/hash_table_executor":"qYIJ","./executors/image_executor":"P01n","./executors/logical_executor":"fJEP","./executors/matrices_executor":"Rlpz","./executors/normalization_executor":"Pftj","./executors/ragged_executor":"wIW8","./executors/reduction_executor":"ftj2","./executors/slice_join_executor":"inkj","./executors/sparse_executor":"zdfJ","./executors/spectral_executor":"Xups","./executors/string_executor":"aetQ","./executors/transformation_executor":"m1J1"}],"TN5w":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.ExecutionContext=void 0;class t{constructor(t={},e={},s={},n={},r){this.weightMap=t,this.tensorArrayMap=e,this.tensorListMap=s,this.functionMap=n,this.parseNodeNameCache=r,this.rootContext={id:0,frameName:"",iterationId:0},this.contexts=[this.rootContext],this.lastId=0,this.generateCurrentContextIds()}newFrame(t,e){return{id:t,frameName:e,iterationId:0}}set currentContext(t){this.contexts!==t&&(this.contexts=t,this.generateCurrentContextIds())}get currentContext(){return this.contexts}get currentContextId(){return this._currentContextIds[0]}get currentContextIds(){return this._currentContextIds}generateCurrentContextIds(){const t=[];for(let e=0;e<this.contexts.length-1;e++){const s=this.contexts.slice(0,this.contexts.length-e);t.push(this.contextIdforContexts(s))}t.push(""),this._currentContextIds=t}contextIdforContexts(t){return t?t.map(t=>0===t.id&&0===t.iterationId?"":`${t.frameName}-${t.iterationId}`).join("/"):""}enterFrame(t){this.contexts&&(this.lastId++,this.contexts=this.contexts.slice(),this.contexts.push(this.newFrame(this.lastId,t)),this._currentContextIds.unshift(this.contextIdforContexts(this.contexts)))}exitFrame(){if(!(this.contexts&&this.contexts.length>1))throw new Error("Cannot exit frame, the context is empty");this.contexts=this.contexts.slice(),this.contexts.splice(-1),this.currentContextIds.shift()}nextIteration(){if(!(this.contexts&&this.contexts.length>0))throw new Error("Cannot increase frame iteration, the context is empty");{this.contexts=this.contexts.slice(),this.lastId++;const t=Object.assign({},this.contexts[this.contexts.length-1]);t.iterationId+=1,t.id=this.lastId,this.contexts.splice(-1,1,t),this._currentContextIds.splice(0,1,this.contextIdforContexts(this.contexts))}}getWeight(t){return this.weightMap[t]}addTensorArray(t){this.tensorArrayMap[t.id]=t}getTensorArray(t){return this.tensorArrayMap[t]}addTensorList(t){this.tensorListMap[t.id]=t}getTensorList(t){return this.tensorListMap[t]}dispose(t){for(const e in this.tensorArrayMap)this.tensorArrayMap[e].clearAndClose(t);for(const e in this.tensorListMap)this.tensorListMap[e].clearAndClose(t)}}exports.ExecutionContext=t;
},{}],"dNrC":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.getExecutionSubgraph=n,exports.getNodeLiveUntilMap=r,exports.getNodesInTopologicalOrder=t,exports.isControlFlow=u,exports.isDynamicShape=c,exports.isHashTable=l;var e=require("../operations/executors/utils");function n(n,t,a,o){const s=new Set,r=[];let p=null,i=null;const m=new Set,h=new Set(Object.keys(n).map(n=>(0,e.parseNodeName)(n)[0]));o=o||[];const f=new Set(o.map(n=>(0,e.parseNodeName)(n.name)[0])),d=[...t];for(;d.length>0;){const e=d.pop();(u(e)||c(e)||l(e))&&null==p&&(i=(p=e).children.map(e=>e.name).filter(e=>s.has(e))),s.add(e.name),null==a[e.name]&&(h.has(e.name)||f.has(e.name)||(0!==e.inputs.length?e.inputs.forEach(e=>{m.has(e.name)||(m.add(e.name),d.push(e))}):r.push(e.name)))}return{inputs:n,outputs:t,usedNodes:s,missingInputs:r,dynamicNode:p,syncInputs:i}}function t(n,t){const{usedNodes:o,inputs:r}=t,p=Object.keys(r).map(n=>(0,e.parseNodeName)(n)[0]).map(e=>n.nodes[e]),i=n.initNodes||[],m=e=>o.has("string"==typeof e?e:e.name);function u(e){return[...new Map(e.map(e=>[e.name,e])).values()]}const c=u([...p,...n.weights,...i]).filter(m),l=u([...c,...Object.values(n.nodes)]).filter(m),h=new Map(l.map(e=>[e.name,e])),f={};for(const e of l){f[e.name]=f[e.name]||0;for(const n of e.children)m(n)||(f[n.name]=Number.POSITIVE_INFINITY),f[n.name]=(f[n.name]||0)+1}const d=Object.entries(f).filter(([,e])=>0===e).map(([e])=>e),w=[...d];for(;d.length>0;){const e=d.pop(),n=h.get(e);for(const t of n.children.filter(m))0==--f[t.name]&&(w.push(t.name),d.push(t.name))}const g=a(w.map(e=>h.get(e)),c);return s(g,c),g}function a(e,n){const t=new Map(e.map(e=>[e.name,e])),a=n.map(e=>e.name),o=new Set(a);for(;a.length>0;){const e=a.pop(),n=t.get(e);for(const s of n.children)t.has(s.name)&&!o.has(s.name)&&(o.add(s.name),a.push(s.name))}return e.filter(e=>o.has(e.name))}class o extends Error{constructor(e){super(`NodesExecutionOrderError: ${e}`)}}function s(e,n){const t=new Map(e.map((e,n)=>[e.name,n])),a=new Set(n.map(e=>e.name)),s=e=>a.has("string"==typeof e?e:e.name),r=new Set(e.map(e=>e.name)),p=e=>r.has("string"==typeof e?e:e.name);for(const i of e){for(const e of i.children.filter(p)){if(!t.has(e.name))throw new o(`Child ${e.name} of node ${i.name} is unreachable.`);if(t.get(i.name)>t.get(e.name))throw new o(`Node ${i.name} is scheduled to run after its child ${e.name}.`)}if(!s(i))for(const e of i.inputs){if(!t.has(e.name))throw new o(`Input ${e.name} of node ${i.name} is unreachable.`);if(t.get(e.name)>t.get(i.name))throw new o(`Node ${i.name} is scheduled to run before its input ${e.name}.`)}}}function r(e){const n=new Map(e.map((e,n)=>[e.name,n])),t=Number.MAX_SAFE_INTEGER,a=e.map((e,n)=>u(e)?t:n),o=e=>{const t=a[n.get(e.name)];return null==t?-1:t},s=e.map((e,n)=>e.children.map(o).reduce((e,n)=>Math.max(e,n),a[n])),r=new Map;for(let p=0;p<e.length;++p){const n=s[p];if(n===t)continue;const a=e[p],o=e[n];r.has(o.name)||r.set(o.name,[]),r.get(o.name).push(a)}return r}const p=new Set(["Switch","Merge","Enter","Exit","NextIteration","StatelessIf","StatelessWhile","if","While"]),i=new Set(["NonMaxSuppressionV2","NonMaxSuppressionV3","NonMaxSuppressionV5","Where"]),m=new Set(["HashTable","HashTableV2","LookupTableImport","LookupTableImportV2","LookupTableFind","LookupTableFindV2","LookupTableSize","LookupTableSizeV2"]);function u(e){return p.has(e.op)}function c(e){return i.has(e.op)}function l(e){return m.has(e.op)}
},{"../operations/executors/utils":"eBau"}],"tpB1":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.GraphExecutor=void 0;var e=require("@tensorflow/tfjs-core"),t=require("../operations/executors/utils"),s=require("../operations/operation_executor"),n=require("./execution_context"),o=require("./model_analysis");class i{get weightIds(){return this.parent?this.parent.weightIds:this._weightIds}get functionExecutorMap(){return this.parent?this.parent.functionExecutorMap:this._functionExecutorMap}get weightMap(){return this.parent?this.parent.weightMap:this._weightMap}set weightMap(e){const t=Object.keys(e).map(t=>e[t].map(e=>e.id));this._weightIds=[].concat(...t),this._weightMap=e}set resourceManager(e){this._resourceManager=e}get inputs(){return this._inputs.map(e=>({name:e.name,shape:e.attrParams.shape?e.attrParams.shape.value:void 0,dtype:e.attrParams.dtype?e.attrParams.dtype.value:void 0}))}get outputs(){return this._outputs.map(e=>({name:e.name,shape:e.attrParams.shape?e.attrParams.shape.value:void 0,dtype:e.attrParams.dtype?e.attrParams.dtype.value:void 0}))}get inputNodes(){return this._inputs.map(e=>e.signatureKey||e.name)}get outputNodes(){return this._outputs.map(e=>{const t=e.signatureKey||e.name;return e.defaultOutput?`${t}:${e.defaultOutput}`:t})}get functions(){return Object.keys(this._functions).reduce((e,t)=>(e[t]=this._functions[t].signature,e),{})}constructor(e,t){this.graph=e,this.parent=t,this.compiledMap=new Map,this.parseNodeNameCache=new Map,this._weightMap={},this.SEPARATOR=",",this._functions={},this._functionExecutorMap={},this.keepIntermediateTensors=!1,this._outputs=e.outputs,this._inputs=e.inputs,this._initNodes=e.initNodes,this._signature=e.signature,this._functions=e.functions,null!=e.functions&&Object.keys(e.functions).forEach(t=>{this._functionExecutorMap[t]=new i(e.functions[t],this)})}getCompilationKey(e,t){const s=e.map(e=>e.name).sort(),n=t.map(e=>e.name).sort();return s.join(this.SEPARATOR)+"--"+n.join(this.SEPARATOR)}compile(e,t){const s=(0,o.getExecutionSubgraph)(e,t,this.weightMap,this._initNodes),{missingInputs:n,dynamicNode:i,syncInputs:r}=s;if(null!=i)throw new Error(`This execution contains the node '${i.name}', which has `+`the dynamic op '${i.op}'. Please use `+"model.executeAsync() instead. Alternatively, to avoid the "+`dynamic ops, specify the inputs [${r}]`);if(n.length>0){const s=t.map(e=>e.name),o=Object.keys(e);throw new Error(`Cannot compute the outputs [${s}] from the provided inputs `+`[${o}]. Missing the following inputs: [${n}]`)}const a=(0,o.getNodesInTopologicalOrder)(this.graph,s);return{orderedNodes:a,nodeLiveUntilMap:(0,o.getNodeLiveUntilMap)(a)}}cloneAndKeepTensor(t){if(null==t)return null;const s=t.clone();return(0,e.keep)(s),s}cloneTensorList(e){if(!e)return null;return e.map(e=>this.cloneAndKeepTensor(e))}cloneTensorMap(e){return Object.fromEntries(Object.entries(e).map(([e,t])=>[e,this.cloneTensorList(t)]))}execute(o,i){this.disposeIntermediateTensors(),o=this.mapInputs(o);const r=Object.keys(o).sort();this.checkInputs(o),this.checkInputShapeAndType(o),i=this.mapOutputs(i),this.checkOutputs(i);const a=r.map(e=>this.graph.nodes[(0,t.parseNodeName)(e)[0]]),p=i.map(e=>(0,t.parseNodeName)(e)[0]),h=new Set(p);let c=p.map(e=>this.graph.nodes[e]);0===c.length&&(c=this._outputs);const u=this.getCompilationKey(a,c);let d=this.compiledMap.get(u);null==d&&(d=this.compile(o,c),this.compiledMap.set(u,d));try{this.keepIntermediateTensors=(0,e.env)().getBool("KEEP_INTERMEDIATE_TENSORS")}catch(g){this.keepIntermediateTensors=!1,console.warn(g.message)}const l={},m={};return(0,e.tidy)(()=>{const r=new n.ExecutionContext(this.weightMap,l,m,this.functionExecutorMap,this.parseNodeNameCache),a=Object.assign({},this.weightMap);this.keepIntermediateTensors&&(this.clonedTensorsMap=this.cloneTensorMap(this.weightMap)),Object.keys(o).forEach(e=>{const[s,n]=(0,t.parseNodeName)(e,r),i=[];i[n]=o[e],a[s]=i,this.keepIntermediateTensors&&(this.clonedTensorsMap[s]=this.cloneTensorList(i))});const p=this.getFrozenTensorIds(a),{orderedNodes:c,nodeLiveUntilMap:u}=d;for(const t of c){if(a[t.name])continue;const n=(0,s.executeOp)(t,a,r,this._resourceManager);if(e.util.isPromise(n))throw new Error(`The execution of the op '${t.op}' returned a promise. `+"Please use model.executeAsync() instead.");a[t.name]=n,this.keepIntermediateTensors&&(this.clonedTensorsMap[t.name]=this.cloneTensorList(n)),this.checkTensorForDisposalWithNodeLiveUntilInfo(t,a,r,p,h,u.get(t.name))}return null==this.parent&&r.dispose(p),i.map(e=>(0,t.getTensor)(e,a,r))})}getFrozenTensorIds(e){const t=[].concat.apply([],Object.keys(e).map(t=>e[t]).map(e=>e.map(e=>e.id)));return new Set(t)}checkTensorForDisposal(e,s,n,i,r,a,p){if(!(0,o.isControlFlow)(s)&&!a.has(e)){for(const t of n[e])null!=t&&(p[t.id]=(p[t.id]||0)+s.children.length);for(const e of s.inputs){if((0,o.isControlFlow)(e))continue;const s=(0,t.getTensorsForCurrentContext)(e.name,n,i);if(null!=s)for(const e of s){if(!e||e.kept||r.has(e.id))continue;const t=p[e.id];1===t?(e.dispose(),delete p[e.id]):null!=t&&p[e.id]--}}}}checkTensorForDisposalWithNodeLiveUntilInfo(e,s,n,i,r,a){function p(e){return(0,o.isControlFlow)(e)||r.has(e.name)}if(!(0,o.isControlFlow)(e)&&null!=a)for(const o of a){if(p(o))continue;const e=(0,t.getTensorsForCurrentContext)(o.name,s,n);for(const t of e)!t||t.kept||i.has(t.id)||t.dispose()}}async executeAsync(e,t){return this._executeAsync(e,t)}disposeIntermediateTensors(){this.clonedTensorsMap&&(Object.values(this.clonedTensorsMap).forEach(e=>{for(const t of e)t&&!t.isDisposed&&t.dispose()}),this.clonedTensorsMap=null)}getIntermediateTensors(){return this.clonedTensorsMap}async _executeAsync(s,o,i=!1,r={},a={}){this.disposeIntermediateTensors(),i||(s=this.mapInputs(s),this.checkInputs(s),this.checkInputShapeAndType(s),o=this.mapOutputs(o),this.checkOutputs(o));try{this.keepIntermediateTensors=(0,e.env)().getBool("KEEP_INTERMEDIATE_TENSORS")}catch(m){this.keepIntermediateTensors=!1,console.warn(m.message)}const p=new n.ExecutionContext(this.weightMap,r,a,this.functionExecutorMap,this.parseNodeNameCache);this.keepIntermediateTensors&&(this.clonedTensorsMap=this.cloneTensorMap(this.weightMap));const h=await this.executeWithControlFlow(s,p,o,i),c=o.map(e=>(0,t.getTensor)(e,h,p)),u=c.map(e=>e.id),d=Object.keys(s).map(e=>s[e].id),l=new Set([...u,...d,...this.weightIds]);return Object.values(h).forEach(e=>{e.forEach(e=>{!e||e.isDisposed||l.has(e.id)||e.dispose()})}),null==this.parent&&p.dispose(l),c}async executeFunctionAsync(e,t,s){const n=e.reduce((e,t,s)=>(e[this.inputs[s].name]=t,e),{});return this._executeAsync(n,this.outputNodes,!0,t,s)}async executeWithControlFlow(e,s,n,i){const r=Object.keys(e),a=r.map(e=>this.graph.nodes[(0,t.parseNodeName)(e)[0]]),p=n.map(e=>(0,t.parseNodeName)(e)[0]),h=new Set(p);let c=p.map(e=>this.graph.nodes[e]);0===c.length&&(c=this._outputs);const{usedNodes:u,missingInputs:d,dynamicNode:l,syncInputs:m}=(0,o.getExecutionSubgraph)(e,c,this.weightMap,this._initNodes),g=[...a,...this.graph.weights,...this._initNodes||[]].map(e=>({node:e,contexts:s.currentContext})),f=Object.assign({},this.weightMap);Object.keys(e).forEach(s=>{const[n,o]=(0,t.parseNodeName)(s),i=[];i[o]=e[s],f[n]=i});const T={},y=this.getFrozenTensorIds(f),w={};for(;g.length>0;){const e=this.processStack(a,g,s,f,w,y,h,T,u);await Promise.all(e)}null!=l||i||console.warn("This model execution did not contain any nodes with control flow or dynamic output shapes. You can use model.execute() instead.");const x=c.filter(e=>!(0,o.isControlFlow)(e)&&!(0,t.getTensor)(e.name,f,s)).map(e=>e.name);if(x.length>0){let e="";throw null!=l&&(e="Alternatively, to avoid the dynamic ops, use model.execute() "+`and specify the inputs [${m}]`),new Error(`Cannot compute the outputs [${x}] from the provided `+`inputs [${r}]. Consider providing the following inputs: `+`[${d}]. ${e}`)}return f}processStack(n,o,i,r,a,p,h,c,u){const d=[];for(;o.length>0;){const n=o.pop();i.currentContext=n.contexts;let l="";if("Enter"===n.node.op&&(0,t.getParamValue)("isConstant",n.node,r,i)&&([l]=(0,t.getNodeNameAndIndex)(n.node.name,i)),null==r[n.node.name]){const m=(0,s.executeOp)(n.node,r,i,this._resourceManager);l||([l]=(0,t.getNodeNameAndIndex)(n.node.name,i));const g=i.currentContext;e.util.isPromise(m)?d.push(m.then(e=>(r[l]=e,this.keepIntermediateTensors&&(this.clonedTensorsMap[l]=this.cloneTensorList(e)),i.currentContext=g,this.checkTensorForDisposal(l,n.node,r,i,p,h,c),this.processChildNodes(n.node,o,i,r,a,u),e))):(r[l]=m,this.keepIntermediateTensors&&(this.clonedTensorsMap[l]=this.cloneTensorList(m)),this.checkTensorForDisposal(l,n.node,r,i,p,h,c),this.processChildNodes(n.node,o,i,r,a,u))}else this.processChildNodes(n.node,o,i,r,a,u)}return d}processChildNodes(e,s,n,o,i,r){e.children.forEach(e=>{const[a]=(0,t.getNodeNameAndIndex)(e.name,n);!i[a]&&r.has(e.name)&&("Merge"===e.op?e.inputNames.some(e=>!!(0,t.getTensor)(e,o,n))&&(i[a]=!0,s.push({contexts:n.currentContext,node:e})):e.inputNames.every(e=>!!(0,t.getTensor)(e,o,n))&&(i[a]=!0,s.push({contexts:n.currentContext,node:e})))})}dispose(){Object.keys(this.weightMap).forEach(e=>this.weightMap[e].forEach(e=>e.dispose()))}checkInputShapeAndType(s){Object.keys(s).forEach(n=>{const o=s[n],[i]=(0,t.parseNodeName)(n),r=this.graph.nodes[i];if(r.attrParams.shape&&r.attrParams.shape.value){const t=r.attrParams.shape.value,s=t.length===o.shape.length&&o.shape.every((e,s)=>-1===t[s]||t[s]===e);e.util.assert(s,()=>`The shape of dict['${r.name}'] provided in `+`model.execute(dict) must be [${t}], but was `+`[${o.shape}]`)}r.attrParams.dtype&&r.attrParams.dtype.value&&e.util.assert(o.dtype===r.attrParams.dtype.value,()=>`The dtype of dict['${r.name}'] provided in `+"model.execute(dict) must be "+`${r.attrParams.dtype.value}, but was ${o.dtype}`)})}mapInputs(e){var t,s;const n={};for(const o in e){const i=null===(s=null===(t=this._signature)||void 0===t?void 0:t.inputs)||void 0===s?void 0:s[o];null!=i?n[i.name]=e[o]:n[o]=e[o]}return n}checkInputs(e){const s=Object.keys(e).filter(e=>{const[s]=(0,t.parseNodeName)(e);return null==this.graph.nodes[s]});if(s.length>0)throw new Error("The dict provided in model.execute(dict) has "+`keys: [${s}] that are not part of graph`)}mapOutputs(e){return e.map(e=>{var t,s;const n=null===(s=null===(t=this._signature)||void 0===t?void 0:t.outputs)||void 0===s?void 0:s[e];return null!=n?n.name:e},{})}checkOutputs(e){e.forEach(e=>{const[s]=(0,t.parseNodeName)(e);if(!this.graph.nodes[s])throw new Error(`The output '${e}' is not found in the graph`)})}}exports.GraphExecutor=i;
},{"@tensorflow/tfjs-core":"kSBl","../operations/executors/utils":"eBau","../operations/operation_executor":"hN1H","./execution_context":"TN5w","./model_analysis":"dNrC"}],"F3Mj":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.ResourceManager=void 0;class e{constructor(e={},a={}){this.hashTableNameToHandle=e,this.hashTableMap=a}addHashTable(e,a){this.hashTableNameToHandle[e]=a.handle,this.hashTableMap[a.id]=a}getHashTableHandleByName(e){return this.hashTableNameToHandle[e]}getHashTableById(e){return this.hashTableMap[e]}dispose(){for(const e in this.hashTableMap)this.hashTableMap[e].clearAndClose(),delete this.hashTableMap[e];for(const e in this.hashTableNameToHandle)this.hashTableNameToHandle[e].dispose(),delete this.hashTableNameToHandle[e]}}exports.ResourceManager=e;
},{}],"McTv":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.TFHUB_SEARCH_PARAM=exports.GraphModel=exports.DEFAULT_MODEL_NAME=void 0,exports.loadGraphModel=u,exports.loadGraphModelSync=l;var e=require("@tensorflow/tfjs-core"),t=require("../operations/operation_mapper"),r=require("./graph_executor"),i=require("./resource_manager"),s=require("@tensorflow/tfjs-core/dist/io/io_utils");const n=exports.TFHUB_SEARCH_PARAM="?tfjs-format=file",o=exports.DEFAULT_MODEL_NAME="model.json";class a{get modelVersion(){return this.version}get inputNodes(){return this.executor.inputNodes}get outputNodes(){return this.executor.outputNodes}get inputs(){return this.executor.inputs}get outputs(){return this.executor.outputs}get weights(){return this.executor.weightMap}get metadata(){return this.artifacts.userDefinedMetadata}get modelSignature(){return this.signature}get modelStructuredOutputKeys(){return this.structuredOutputKeys}constructor(t,r={},s=e.io){this.modelUrl=t,this.loadOptions=r,this.version="n/a",this.io=s,null==r&&(this.loadOptions={}),this.resourceManager=new i.ResourceManager}findIOHandler(){const e=this.modelUrl;if(null!=e.load)this.handler=e;else if(null!=this.loadOptions.requestInit)this.handler=this.io.browserHTTPRequest(e,this.loadOptions);else{const t=this.io.getLoadHandlers(e,this.loadOptions);if(0===t.length)t.push(this.io.browserHTTPRequest(e,this.loadOptions));else if(t.length>1)throw new Error(`Found more than one (${t.length}) load handlers for `+`URL '${[e]}'`);this.handler=t[0]}}load(){if(this.findIOHandler(),null==this.handler.load)throw new Error("Cannot proceed with model loading because the IOHandler provided does not have the `load` method implemented.");const t=this.handler.load();return e.util.isPromise(t)?t.then(e=>null==e.getWeightStream?this.loadSync(e):this.loadStreaming(e)):this.loadSync(t)}loadSync(e){const t=this.io.decodeWeights(e.weightData,e.weightSpecs);return this.loadWithWeightMap(e,t)}async loadStreaming(e){if(null==e.getWeightStream)throw new Error("Model artifacts missing streamWeights function");const t=await(0,s.decodeWeightsStream)(e.getWeightStream(),e.weightSpecs);return this.loadWithWeightMap(e,t)}loadWithWeightMap(e,i){this.artifacts=e;const s=this.artifacts.modelTopology;let n=this.artifacts.signature;if(null!=this.artifacts.userDefinedMetadata){const e=this.artifacts.userDefinedMetadata;null!=e.signature&&(n=e.signature),null!=e.structuredOutputKeys&&(this.structuredOutputKeys=e.structuredOutputKeys)}if(this.signature=n,this.version=`${s.versions.producer}.${s.versions.minConsumer}`,this.executor=new r.GraphExecutor(t.OperationMapper.Instance.transformGraph(s,this.signature)),this.executor.weightMap=this.convertTensorMapToTensorsMap(i),this.executor.resourceManager=this.resourceManager,null!=e.modelInitializer&&null!=e.modelInitializer.node){const i=t.OperationMapper.Instance.transformGraph(e.modelInitializer);this.initializer=new r.GraphExecutor(i),this.initializer.weightMap=this.executor.weightMap,this.initializer.resourceManager=this.resourceManager,this.initializerSignature=e.initializerSignature}return!0}async save(e,t){if("string"==typeof e){const t=this.io.getSaveHandlers(e);if(0===t.length)throw new Error(`Cannot find any save handlers for URL '${e}'`);if(t.length>1)throw new Error(`Found more than one (${t.length}) save handlers for `+`URL '${e}'`);e=t[0]}if(null==e.save)throw new Error("GraphModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");return e.save(this.artifacts)}addStructuredOutputNames(t){if(this.structuredOutputKeys){const r=t instanceof e.Tensor?[t]:t,i={};return r.forEach((e,t)=>i[this.structuredOutputKeys[t]]=e),i}return t}predict(e,t){const r=this.execute(e,this.outputNodes);return this.addStructuredOutputNames(r)}async predictAsync(e,t){const r=await this.executeAsync(e,this.outputNodes);return this.addStructuredOutputNames(r)}normalizeInputs(t){var r;if(!(t instanceof e.Tensor||Array.isArray(t))){const e=null===(r=this.signature)||void 0===r?void 0:r.inputs;if(null!=e)for(const r in e){const i=e[r];null!=i.resourceId&&(t[r]=this.resourceIdToCapturedInput[i.resourceId])}return t}t=Array.isArray(t)?t:[t];const i=Object.keys(this.resourceIdToCapturedInput).length;if(t.length+i!==this.inputNodes.length)throw new Error(`Input tensor count mismatch, the graph model has ${this.inputNodes.length-i} non-resource placeholders, while there are ${t.length} input tensors provided.`);let s=0;return this.inputNodes.reduce((e,r)=>{var i,n,o;const a=null===(o=null===(n=null===(i=this.signature)||void 0===i?void 0:i.inputs)||void 0===n?void 0:n[r])||void 0===o?void 0:o.resourceId;return e[r]=null!=a?this.resourceIdToCapturedInput[a]:t[s++],e},{})}normalizeOutputs(e){return e=e||this.outputNodes,Array.isArray(e)?e:[e]}executeInitializerGraph(){return null==this.initializer?[]:null==this.initializerSignature?this.initializer.execute({},[]):this.initializer.execute({},Object.keys(this.initializerSignature.outputs))}async executeInitializerGraphAsync(){return null==this.initializer?[]:null==this.initializerSignature?this.initializer.executeAsync({},[]):this.initializer.executeAsync({},Object.keys(this.initializerSignature.outputs))}setResourceIdToCapturedInput(e){if(this.resourceIdToCapturedInput={},this.initializerSignature){const t=this.initializerSignature.outputs,r=Object.keys(t);for(let i=0;i<r.length;i++){const s=t[r[i]];this.resourceIdToCapturedInput[s.resourceId]=e[i]}}}execute(e,t){null==this.resourceIdToCapturedInput&&this.setResourceIdToCapturedInput(this.executeInitializerGraph()),e=this.normalizeInputs(e),t=this.normalizeOutputs(t);const r=this.executor.execute(e,t);return r.length>1?r:r[0]}async executeAsync(e,t){null==this.resourceIdToCapturedInput&&this.setResourceIdToCapturedInput(await this.executeInitializerGraphAsync()),e=this.normalizeInputs(e),t=this.normalizeOutputs(t);const r=await this.executor.executeAsync(e,t);return r.length>1?r:r[0]}getIntermediateTensors(){return this.executor.getIntermediateTensors()}disposeIntermediateTensors(){this.executor.disposeIntermediateTensors()}convertTensorMapToTensorsMap(e){return Object.keys(e).reduce((t,r)=>(t[r]=[e[r]],t),{})}dispose(){this.executor.dispose(),this.initializer&&(this.initializer.dispose(),this.resourceIdToCapturedInput&&(0,e.dispose)(this.resourceIdToCapturedInput)),this.resourceManager.dispose()}}async function u(t,r={},i=e.io){if(null==t)throw new Error("modelUrl in loadGraphModel() cannot be null. Please provide a url or an IOHandler that loads the model");null==r&&(r={}),r.fromTFHub&&"string"==typeof t&&(t=h(t));const s=new a(t,r,i);return await s.load(),s}function l(t){if(null==t)throw new Error("modelUrl in loadGraphModelSync() cannot be null. Please provide model artifacts or an IOHandler that loads the model");let r;if(t instanceof Array){const[i,s]=t;if(!i)throw new Error("modelJSON must be the first element of the array");if(!(s&&s instanceof ArrayBuffer))throw new Error("An ArrayBuffer of weights must be the second element of the array");if(!("modelTopology"in i))throw new Error("Model JSON is missing 'modelTopology'");if(!("weightsManifest"in i))throw new Error("Model JSON is missing 'weightsManifest'");const n=e.io.getWeightSpecs(i.weightsManifest),o=e.io.getModelArtifactsForJSONSync(i,n,s);r=e.io.fromMemorySync(o)}else if("load"in t)r=t;else{if(!("modelTopology"in t&&"weightSpecs"in t&&"weightData"in t))throw new Error("Unknown model format");r=e.io.fromMemorySync(t)}const i=new a(r);return i.load(),i}function h(e){return e.endsWith("/")||(e+="/"),`${e}${o}${n}`}exports.GraphModel=a;
},{"@tensorflow/tfjs-core":"kSBl","../operations/operation_mapper":"L12J","./graph_executor":"tpB1","./resource_manager":"F3Mj","@tensorflow/tfjs-core/dist/io/io_utils":"kOer"}],"Mtvo":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),Object.defineProperty(exports,"GraphModel",{enumerable:!0,get:function(){return e.GraphModel}}),Object.defineProperty(exports,"deregisterOp",{enumerable:!0,get:function(){return r.deregisterOp}}),Object.defineProperty(exports,"loadGraphModel",{enumerable:!0,get:function(){return e.loadGraphModel}}),Object.defineProperty(exports,"loadGraphModelSync",{enumerable:!0,get:function(){return e.loadGraphModelSync}}),Object.defineProperty(exports,"registerOp",{enumerable:!0,get:function(){return r.registerOp}}),Object.defineProperty(exports,"version_converter",{enumerable:!0,get:function(){return t.version}}),require("./flags");var e=require("./executor/graph_model"),r=require("./operations/custom_op/register"),t=require("./version");
},{"./flags":"ZvkN","./executor/graph_model":"McTv","./operations/custom_op/register":"LNan","./version":"KPnh"}],"UomO":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.canTensorify=c,exports.deepMap=t,exports.deepMapAndAwaitAll=s,exports.deepZip=o,exports.isIterable=a,exports.zipToList=i;var e=r(require("@tensorflow/tfjs-core"));function r(e,t){if("function"==typeof WeakMap)var n=new WeakMap,o=new WeakMap;return(r=function(e,r){if(!r&&e&&e.__esModule)return e;var t,u,i={__proto__:null,default:e};if(null===e||"object"!=typeof e&&"function"!=typeof e)return i;if(t=r?o:n){if(t.has(e))return t.get(e);t.set(e,i)}for(const n in e)"default"!==n&&{}.hasOwnProperty.call(e,n)&&((u=(t=Object.defineProperty)&&Object.getOwnPropertyDescriptor(e,n))&&(u.get||u.set)?t(i,n,u):i[n]=e[n]);return i})(e,t)}function t(e,r){return n(e,r)}function n(e,r,t=new Map,o=new Set){if(null==e)return null;if("function"==typeof Blob&&e instanceof Blob)return e.slice();if(o.has(e))throw new Error("Circular references are not supported.");if(t.has(e))return t.get(e);const u=r(e);if(u.recurse&&null!==u.value)throw new Error("A deep map function may not return both a value and recurse=true.");if(u.recurse){if(a(e)){const u=Array.isArray(e)?[]:{};o.add(e);for(const i in e){const s=n(e[i],r,t,o);u[i]=s}return o.delete(e),e.__proto__&&(u.__proto__=e.__proto__),u}throw new Error(`Can't recurse into non-iterable type: ${e}`)}return t.set(e,u.value),u.value}function o(e,r=i){return u(e,r)}function u(e,r,t=new Set){const n=e[0];if(t.has(n))throw new Error("Circular references are not supported.");const o=r(e);if(o.recurse&&null!==o.value)throw new Error("A deep zip function may not return both a value and recurse=true.");if(o.recurse){if(a(n)){const o=Array.isArray(n)?[]:{};t.add(n);for(const i in n){const n=u(e.map(e=>e[i]),r,t);o[i]=n}return t.delete(n),o}throw new Error(`Can't recurse into non-iterable type: ${n}`)}return o.value}function i(e){return null===e?null:a(e[0])?{value:null,recurse:!0}:{value:e,recurse:!1}}async function s(r,t){const o=new Map;n(r,t,o);for(const n of Array.from(o.keys())){const r=o.get(n);if(e.util.isPromise(r)){const e=await r;o.set(n,e)}}return n(r,t,o)}function a(r){let t=!1;if(e.env().get("IS_BROWSER"))t=r instanceof TextDecoder;else{const{StringDecoder:e}=require("string_decoder");t=r instanceof e}return null!=r&&!ArrayBuffer.isView(r)&&(Array.isArray(r)||"object"==typeof r&&!(r instanceof e.Tensor)&&!(r instanceof Promise)&&!t)}function c(r){return null==r||f(r)||Array.isArray(r)||"object"==typeof r&&r instanceof e.Tensor||e.util.isTypedArray(r)}function f(e){return null===e||"object"!=typeof e&&"function"!=typeof e}
},{"@tensorflow/tfjs-core":"kSBl","string_decoder":"ZOa0"}],"EsVK":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.deepClone=n;var e=t(require("@tensorflow/tfjs-core")),r=require("./deep_map");function t(e,r){if("function"==typeof WeakMap)var n=new WeakMap,o=new WeakMap;return(t=function(e,r){if(!r&&e&&e.__esModule)return e;var t,u,a={__proto__:null,default:e};if(null===e||"object"!=typeof e&&"function"!=typeof e)return a;if(t=r?o:n){if(t.has(e))return t.get(e);t.set(e,a)}for(const n in e)"default"!==n&&{}.hasOwnProperty.call(e,n)&&((u=(t=Object.defineProperty)&&Object.getOwnPropertyDescriptor(e,n))&&(u.get||u.set)?t(a,n,u):a[n]=e[n]);return a})(e,r)}function n(e){return(0,r.deepMap)(e,o)}function o(t){return t instanceof e.Tensor?{value:t.clone(),recurse:!1}:(0,r.isIterable)(t)?{value:null,recurse:!0}:{value:t,recurse:!1}}
},{"@tensorflow/tfjs-core":"kSBl","./deep_map":"UomO"}],"bqKe":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.RingBuffer=void 0;class t{constructor(t){if(this.capacity=t,this.begin=0,this.end=0,null==t)throw new RangeError("Can't create a ring buffer of unknown capacity.");if(t<1)throw new RangeError("Can't create ring buffer of capacity < 1.");this.data=new Array(t),this.doubledCapacity=2*t}wrap(t){for(;t<0;)t+=this.doubledCapacity;return t%this.doubledCapacity}get(t){if(t<0)throw new RangeError("Can't get item at a negative index.");return this.data[t%this.capacity]}set(t,i){if(t<0)throw new RangeError("Can't set item at a negative index.");this.data[t%this.capacity]=i}length(){let t=this.end-this.begin;return t<0&&(t=this.doubledCapacity+t),t}isFull(){return this.length()===this.capacity}isEmpty(){return 0===this.length()}push(t){if(this.isFull())throw new RangeError("Ring buffer is full.");this.set(this.end,t),this.end=this.wrap(this.end+1)}pushAll(t){for(const i of t)this.push(i)}pop(){if(this.isEmpty())throw new RangeError("Ring buffer is empty.");this.end=this.wrap(this.end-1);const t=this.get(this.end);return this.set(this.end,void 0),t}unshift(t){if(this.isFull())throw new RangeError("Ring buffer is full.");this.begin=this.wrap(this.begin-1),this.set(this.begin,t)}shift(){if(this.isEmpty())throw new RangeError("Ring buffer is empty.");const t=this.get(this.begin);return this.set(this.begin,void 0),this.begin=this.wrap(this.begin+1),t}shuffleExcise(t){if(this.isEmpty())throw new RangeError("Ring buffer is empty.");const i=this.wrap(this.begin+t),e=this.get(i);return this.set(i,this.pop()),e}}exports.RingBuffer=t;
},{}],"ZwxG":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.GrowingRingBuffer=void 0;var e=require("./ring_buffer");class s extends e.RingBuffer{constructor(){super(s.INITIAL_CAPACITY)}isFull(){return!1}push(e){super.isFull()&&this.expand(),super.push(e)}unshift(e){super.isFull()&&this.expand(),super.unshift(e)}expand(){const e=2*this.capacity,s=new Array(e),t=this.length();for(let i=0;i<t;i++)s[i]=this.get(this.wrap(this.begin+i));this.data=s,this.capacity=e,this.doubledCapacity=2*this.capacity,this.begin=0,this.end=t}}exports.GrowingRingBuffer=s,s.INITIAL_CAPACITY=32;
},{"./ring_buffer":"bqKe"}],"iw6x":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.ZipMismatchMode=exports.ShuffleIterator=exports.PrefetchIterator=exports.OneToManyIterator=exports.LazyIterator=exports.ChainedIterator=void 0,exports.iteratorFromConcatenated=c,exports.iteratorFromConcatenatedFunction=m,exports.iteratorFromFunction=h,exports.iteratorFromIncrementing=l,exports.iteratorFromItems=o,exports.iteratorFromZipped=d;var t,e=u(require("@tensorflow/tfjs-core")),r=u(require("seedrandom")),s=require("../util/deep_clone"),n=require("../util/deep_map"),a=require("../util/growing_ring_buffer"),i=require("../util/ring_buffer");function u(t,e){if("function"==typeof WeakMap)var r=new WeakMap,s=new WeakMap;return(u=function(t,e){if(!e&&t&&t.__esModule)return t;var n,a,i={__proto__:null,default:t};if(null===t||"object"!=typeof t&&"function"!=typeof t)return i;if(n=e?s:r){if(n.has(t))return n.get(t);n.set(t,i)}for(const r in t)"default"!==r&&{}.hasOwnProperty.call(t,r)&&((a=(n=Object.defineProperty)&&Object.getOwnPropertyDescriptor(t,r))&&(a.get||a.set)?n(i,r,a):i[r]=t[r]);return i})(t,e)}function o(t){return new f(t)}function l(t){let e=t;return h(()=>({value:e++,done:!1}))}function h(t){return new x(t)}function c(t,e){return new _(t,e)}function m(t,e,r){return c(h(t).take(e),r)}function d(e,r=t.FAIL){return new b(e,r)}class p{async toArray(){const t=[];let e=await this.next();for(;!e.done;)t.push(e.value),e=await this.next();return t}async toArrayForTest(){const t=this.prefetch(100),e=[];let r=await t.next();for(;!r.done;)e.push(r.value),r=await t.next();return e}async resolveFully(){let t=await this.next();for(;!t.done;)t=await this.next()}async resolveWhile(t){let e=await this.next(),r=t(e.value);for(;!e.done&&r;)r=t((e=await this.next()).value)}handleErrors(t){return new F(this,t)}filter(t){return new I(this,t)}map(t){return new g(this,t)}mapAsync(t){return new T(this,t)}serialMapAsync(t){return new T(this,t).serial()}flatmap(t){return new S(this,t)}async forEachAsync(t){return this.map(t).resolveFully()}async serialForEach(t){return this.serialMapAsync(t).resolveWhile(t=>!0===t)}rowMajorBatch(t,e=!0){return new R(this,t,e)}columnMajorBatch(t,e=!0,r=n.zipToList){return this.rowMajorBatch(t,e).map(t=>(0,n.deepZip)(t,r))}concatenate(t,e){return new _(o([this,t]),e)}take(t){return t<0||null==t?this:new w(this,t)}skip(t){return t<0||null==t?this:new v(this,t)}prefetch(t){return new E(this,t)}shuffle(t,e){return new C(this,t,e)}serial(){return new y(this)}}exports.LazyIterator=p;class f extends p{constructor(t){super(),this.items=t,this.trav=0}summary(){return`Array of ${this.items.length} items`}async next(){if(this.trav>=this.items.length)return{value:null,done:!0};const t=this.items[this.trav];return this.trav++,{value:(0,s.deepClone)(t),done:!1}}}class x extends p{constructor(t){super(),this.nextFn=t}summary(){return"Function call"}async next(){try{return this.nextFn()}catch(t){throw t.message=`Error thrown while iterating through a dataset: ${t.message}`,t}}}class y extends p{constructor(t){super(),this.upstream=t,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> Serial`}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){return this.upstream.next()}}class v extends p{constructor(t,e){super(),this.upstream=t,this.maxCount=e,this.count=0,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> Skip`}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){for(;this.count++<this.maxCount;){const t=await this.upstream.next();if(t.done)return t;e.dispose(t.value)}return this.upstream.next()}}class w extends p{constructor(t,e){super(),this.upstream=t,this.maxCount=e,this.count=0}summary(){return`${this.upstream.summary()} -> Take`}async next(){return this.count++>=this.maxCount?{value:null,done:!0}:this.upstream.next()}}class R extends p{constructor(t,e,r=!0){super(),this.upstream=t,this.batchSize=e,this.enableSmallLastBatch=r,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> RowMajorBatch`}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){const t=[];for(;t.length<this.batchSize;){const e=await this.upstream.next();if(e.done)return this.enableSmallLastBatch&&t.length>0?{value:t,done:!1}:{value:null,done:!0};t.push(e.value)}return{value:t,done:!1}}}class I extends p{constructor(t,e){super(),this.upstream=t,this.predicate=e,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> Filter`}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){for(;;){const t=await this.upstream.next();if(t.done||this.predicate(t.value))return t;e.dispose(t.value)}}}class g extends p{constructor(t,e){super(),this.upstream=t,this.transform=e}summary(){return`${this.upstream.summary()} -> Map`}async next(){const t=await this.upstream.next();if(t.done)return{value:null,done:!0};const r=e.tensor_util.getTensorsInContainer(t.value),s=this.transform(t.value),n=e.tensor_util.getTensorsInContainer(s);for(const a of r)e.tensor_util.isTensorInList(a,n)||a.dispose();return{value:s,done:!1}}}class F extends p{constructor(t,e){super(),this.upstream=t,this.handler=e,this.count=0,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> handleErrors`}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){for(;;)try{return await this.upstream.next()}catch(t){if(!this.handler(t))return{value:null,done:!0}}}}class T extends p{constructor(t,e){super(),this.upstream=t,this.transform=e}summary(){return`${this.upstream.summary()} -> AsyncMap`}async next(){const t=await this.upstream.next();if(t.done)return{value:null,done:!0};const r=e.tensor_util.getTensorsInContainer(t.value),s=await this.transform(t.value),n=e.tensor_util.getTensorsInContainer(s);for(const a of r)e.tensor_util.isTensorInList(a,n)||a.dispose();return{value:s,done:!1}}}class M extends p{constructor(){super(),this.outputQueue=new a.GrowingRingBuffer,this.lastRead=Promise.resolve({value:null,done:!1})}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){for(;0===this.outputQueue.length();)if(!(await this.pump()))return{value:null,done:!0};return{value:this.outputQueue.shift(),done:!1}}}exports.OneToManyIterator=M;class S extends M{constructor(t,e){super(),this.upstream=t,this.transform=e}summary(){return`${this.upstream.summary()} -> Flatmap`}async pump(){const t=await this.upstream.next();if(t.done)return!1;const r=e.tensor_util.getTensorsInContainer(t.value),s=this.transform(t.value),n=e.tensor_util.getTensorsInContainer(s);this.outputQueue.pushAll(s);for(const a of r)e.tensor_util.isTensorInList(a,n)||a.dispose();return!0}}class _ extends p{constructor(t,e){super(),this.baseErrorHandler=e,this.lastRead=null,this.iterator=null,this.moreIterators=t}summary(){return"TODO: fill in upstream of chained summaries -> Chained"}async next(){return this.lastRead=this.readFromChain(this.lastRead),this.lastRead}async readFromChain(t){if(await t,null==this.iterator){const t=await this.moreIterators.next();if(t.done)return{value:null,done:!0};this.iterator=t.value,null!=this.baseErrorHandler&&(this.iterator=this.iterator.handleErrors(this.baseErrorHandler))}const e=await this.iterator.next();return e.done?(this.iterator=null,this.readFromChain(t)):e}}exports.ChainedIterator=_,function(t){t[t.FAIL=0]="FAIL",t[t.SHORTEST=1]="SHORTEST",t[t.LONGEST=2]="LONGEST"}(t||(exports.ZipMismatchMode=t={}));class b extends p{constructor(e,r=t.FAIL){super(),this.iterators=e,this.mismatchMode=r,this.count=0,this.currentPromise=null}summary(){return"{TODO: fill in upstream of zip summaries} -> Zip"}async nextState(e){await e;let r=0,s=0;const a=await(0,n.deepMapAndAwaitAll)(this.iterators,function(t){if(t instanceof p)return{value:t.next().then(t=>(r++,t.done&&s++,t.value)),recurse:!1};return{value:null,recurse:!0}});if(r===s)return{value:null,done:!0};if(s>0)switch(this.mismatchMode){case t.FAIL:throw new Error("Zipped streams should have the same length. "+`Mismatched at element ${this.count}.`);case t.SHORTEST:return{value:null,done:!0};case t.LONGEST:}return this.count++,{value:a,done:!1}}async next(){return this.currentPromise=this.nextState(this.currentPromise),this.currentPromise}}class E extends p{constructor(t,e){super(),this.upstream=t,this.bufferSize=e,this.buffer=new i.RingBuffer(e)}summary(){return`${this.upstream.summary()} -> Prefetch`}refill(){for(;!this.buffer.isFull();){const t=this.upstream.next();this.buffer.push(t)}}next(){return this.refill(),this.buffer.shift()}}exports.PrefetchIterator=E;class C extends E{constructor(t,s,n){super(t,s),this.upstream=t,this.windowSize=s,this.upstreamExhausted=!1,this.random=r.alea(n||e.util.now().toString()),this.lastRead=Promise.resolve({value:null,done:!1})}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}randomInt(t){return Math.floor(this.random()*t)}chooseIndex(){return this.randomInt(this.buffer.length())}async serialNext(){for(this.upstreamExhausted||this.refill();!this.buffer.isEmpty();){const t=this.chooseIndex(),e=await this.buffer.shuffleExcise(t);if(!e.done)return this.refill(),e;this.upstreamExhausted=!0}return{value:null,done:!0}}}exports.ShuffleIterator=C;
},{"@tensorflow/tfjs-core":"kSBl","seedrandom":"xt2p","../util/deep_clone":"EsVK","../util/deep_map":"UomO","../util/growing_ring_buffer":"ZwxG","../util/ring_buffer":"bqKe"}],"wLsA":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.Dataset=void 0,exports.array=o,exports.datasetFromIteratorFn=a,exports.zip=u;var t=s(require("@tensorflow/tfjs-core")),e=s(require("seedrandom")),r=require("./iterators/lazy_iterator"),i=require("./util/deep_map");function s(t,e){if("function"==typeof WeakMap)var r=new WeakMap,i=new WeakMap;return(s=function(t,e){if(!e&&t&&t.__esModule)return t;var s,n,a={__proto__:null,default:t};if(null===t||"object"!=typeof t&&"function"!=typeof t)return a;if(s=e?i:r){if(s.has(t))return s.get(t);s.set(t,a)}for(const r in t)"default"!==r&&{}.hasOwnProperty.call(t,r)&&((n=(s=Object.defineProperty)&&Object.getOwnPropertyDescriptor(t,r))&&(n.get||n.set)?s(a,r,n):a[r]=t[r]);return a})(t,e)}class n{constructor(){this.size=null}batch(e,r=!0){const i=this;let s;return t.util.assert(e>0,()=>`batchSize needs to be positive, but it is\n      ${e}`),a(async()=>(await i.iterator()).columnMajorBatch(e,r,l),s=this.size===1/0||null==this.size?this.size:r?Math.ceil(this.size/e):Math.floor(this.size/e))}concatenate(t){const e=this;let r;return a(async()=>(await e.iterator()).concatenate(await t.iterator()),r=this.size===1/0||t.size===1/0?1/0:null!=this.size&&null!=t.size?this.size+t.size:null)}filter(e){const r=this;let i;return a(async()=>(await r.iterator()).filter(r=>t.tidy(()=>e(r))),i=this.size===1/0?1/0:null)}async forEachAsync(t){return(await this.iterator()).forEachAsync(t)}map(e){const r=this;return a(async()=>(await r.iterator()).map(r=>t.tidy(()=>e(r))),this.size)}mapAsync(t){const e=this;return a(async()=>(await e.iterator()).mapAsync(t),this.size)}prefetch(t){if(null==t)throw new RangeError("`Dataset.prefetch()` requires bufferSize to be specified.");const e=this;return a(async()=>(await e.iterator()).prefetch(t),this.size)}repeat(t){const e=this;let i;return a(async()=>{const i=(0,r.iteratorFromFunction)(async()=>({value:await e.iterator(),done:!1}));return(0,r.iteratorFromConcatenated)(i.take(t))},i=null!=this.size&&t>0?this.size*t:0===t?0:null!=this.size&&(void 0===t||t<0)?1/0:null)}skip(t){const e=this;let r;return a(async()=>(await e.iterator()).skip(t),r=null!=this.size&&t>=0&&this.size>=t?this.size-t:null!=this.size&&(this.size<t||void 0===t||t<0)?0:null)}shuffle(r,i,s=!0){if(null==r||r<0)throw null==this.size?new RangeError("`Dataset.shuffle()` requires bufferSize to be specified."):new RangeError("`Dataset.shuffle()` requires bufferSize to be specified.  If your data fits in main memory (for regular JS objects), and/or GPU memory (for `tf.Tensor`s), consider setting "+`bufferSize to the dataset size (${this.size} elements)`);const n=this,o=e.alea(i||t.util.now().toString());return a(async()=>{let t=o.int32();return s&&(t+=o.int32()),(await n.iterator()).shuffle(r,t.toString())},this.size)}take(t){const e=this;let r;return a(async()=>(await e.iterator()).take(t),r=null!=this.size&&this.size>t?t:null!=this.size&&this.size<=t?this.size:null)}async toArray(){if(this.size===1/0)throw new Error("Can not convert infinite data stream to array.");return(await this.iterator()).toArray()}async toArrayForTest(){if(this.size===1/0)throw new Error("Can not convert infinite data stream to array.");return(await this.iterator()).toArrayForTest()}}function a(t,e=null){return new class extends n{constructor(){super(...arguments),this.size=e}async iterator(){return t()}}}function o(t){return a(async()=>(0,r.iteratorFromItems)(t),t.length)}function u(t){if(!(0,i.isIterable)(t))throw new Error("The argument to zip() must be an object or array.");let e;if(Array.isArray(t))for(let r=0;r<t.length;r++)e=null==e?t[r].size:Math.min(e,t[r].size);else if(t instanceof Object)for(const r in t)e=null==e?t[r].size:Math.min(e,t[r].size);return a(async()=>{const e=await(0,i.deepMapAndAwaitAll)(t,t=>{if(t instanceof n)return{value:t.iterator(),recurse:!1};if((0,i.isIterable)(t))return{value:null,recurse:!0};throw new Error("Leaves of the structure passed to zip() must be Datasets, not primitives.")});return(0,r.iteratorFromZipped)(e,r.ZipMismatchMode.SHORTEST)},e)}function l(t){if(null===t)return null;const e=t[0];if((0,i.canTensorify)(e)){return{value:c(t),recurse:!1}}return{value:null,recurse:!0}}function c(e){if(0===e.length)throw new Error("Can't make a batch of zero elements.");return e[0]instanceof t.Tensor?t.stack(e):t.tensor(e)}exports.Dataset=n,n.MAX_BUFFER_SIZE=1e4;
},{"@tensorflow/tfjs-core":"kSBl","seedrandom":"xt2p","./iterators/lazy_iterator":"iw6x","./util/deep_map":"UomO"}],"yFx4":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.TextLineDataset=void 0;var t=require("../dataset");class e extends t.Dataset{constructor(t){super(),this.input=t}async iterator(){return(await this.input.iterator()).decodeUTF8().split("\n").map(t=>(t.endsWith("\r")&&(t=t.slice(0,-1)),t))}}exports.TextLineDataset=e;
},{"../dataset":"wLsA"}],"k3yy":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.CSVDataset=void 0;var e=require("@tensorflow/tfjs-core"),t=require("../dataset"),s=require("./text_line_dataset");const i='"',l=Symbol("out"),a=Symbol("field"),n=Symbol("quote"),o=Symbol("quoteafterquote"),r=Symbol("quoteinquote");class u extends t.Dataset{async columnNames(){return this.columnNamesValidated||await this.setColumnNames(),this.configuredColumnsOnly?Object.keys(this.columnConfigs):this.fullColumnNames}async setColumnNames(){const t=await this.maybeReadHeaderLine();if(!this.fullColumnNames&&!t)throw new Error("Column names must be provided if there is no header line.");this.fullColumnNames&&t&&e.util.assert(t.length===this.fullColumnNames.length,()=>"The length of provided columnNames ("+this.fullColumnNames.length.toString()+") does not match the length of the header line read from file ("+t.length.toString()+")."),this.fullColumnNames||(this.fullColumnNames=t);const s=this.fullColumnNames.reduce((e,t)=>(e[t]=e[t]+1||1,e),{}),i=Object.keys(s).filter(e=>s[e]>1);if(e.util.assert(0===i.length,()=>"Duplicate column names found: "+i.toString()),this.columnConfigs)for(const e of Object.keys(this.columnConfigs)){if(-1===this.fullColumnNames.indexOf(e))throw new Error('The key "'+e+'" provided in columnConfigs does not match any of the column names ('+this.fullColumnNames.toString()+").")}this.columnNamesValidated=!0}async maybeReadHeaderLine(){if(this.hasHeader){const e=await this.base.iterator(),t=await e.next();if(t.done)throw new Error("No data was found for CSV parsing.");const s=t.value;return this.parseRow(s,!1)}return null}constructor(t,i){super(),this.input=t,this.hasHeader=!0,this.fullColumnNames=null,this.columnNamesValidated=!1,this.columnConfigs=null,this.configuredColumnsOnly=!1,this.delimiter=",",this.delimWhitespace=!1,this.base=new s.TextLineDataset(t),i||(i={}),this.hasHeader=!1!==i.hasHeader,this.fullColumnNames=i.columnNames,this.columnConfigs=i.columnConfigs,this.configuredColumnsOnly=i.configuredColumnsOnly,i.delimWhitespace?(e.util.assert(null==i.delimiter,()=>"Delimiter should not be provided when delimWhitespace is true."),this.delimWhitespace=!0,this.delimiter=" "):this.delimiter=i.delimiter?i.delimiter:","}async iterator(){this.columnNamesValidated||await this.setColumnNames();let e=await this.base.iterator();return this.hasHeader&&(e=e.skip(1)),e.map(e=>this.makeDataElement(e))}makeDataElement(e){const t=this.parseRow(e),s={},i={};for(let l=0;l<this.fullColumnNames.length;l++){const a=this.fullColumnNames[l],n=this.columnConfigs?this.columnConfigs[a]:null;if(!this.configuredColumnsOnly||n){const o=t[l];let r=null;if(""===o)if(n&&void 0!==n.default)r=n.default;else{if(n&&(n.required||n.isLabel))throw new Error(`Required column ${a} is empty in this line: ${e}`);r=void 0}else{const e=Number(o);if(isNaN(e))r=n&&"bool"===n.dtype?this.getBoolean(o):o;else if(n&&n.dtype)switch(n.dtype){case"float32":r=e;break;case"int32":r=Math.floor(e);break;case"bool":r=this.getBoolean(o);break;default:r=e}else r=e}n&&n.isLabel?i[a]=r:s[a]=r}}return 0===Object.keys(i).length?s:{xs:s,ys:i}}getBoolean(e){return"1"===e||"true"===e.toLowerCase()?1:0}parseRow(e,t=!0){const s=[];let u=0;const h=e.length;let m=l;for(let c=0;c<h;c++)switch(m){case l:switch(e.charAt(c)){case i:u=c+1,m=n;break;case this.delimiter:if(u=c+1," "===this.delimiter&&this.delimWhitespace)break;s.push(""),m=l;break;default:m=a,u=c}break;case a:switch(e.charAt(c)){case this.delimiter:s.push(e.substring(u,c)),m=l,u=c+1}break;case n:switch(e.charAt(c)){case i:m=o}break;case o:switch(e.charAt(c)){case this.delimiter:s.push(e.substring(u,c-1)),m=l,u=c+1;break;case i:m=n;break;default:m=r}break;case r:switch(e.charAt(c)){case i:m=n}}if(m===o?s.push(e.substring(u,h-1)):s.push(e.substring(u)),t&&s.length!==this.fullColumnNames.length)throw new Error(`Invalid row in csv file. Should have ${this.fullColumnNames.length} elements in a row, but got ${s}`);return s}}exports.CSVDataset=u;
},{"@tensorflow/tfjs-core":"kSBl","../dataset":"wLsA","./text_line_dataset":"yFx4"}],"fh9C":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.MicrophoneIterator=void 0;var t=require("@tensorflow/tfjs-core"),e=require("./lazy_iterator");class a extends e.LazyIterator{constructor(t){super(),this.microphoneConfig=t,this.isClosed=!1,this.fftSize=t.fftSize||1024;const e=Math.log2(this.fftSize);if(this.fftSize<0||e<4||e>14||!Number.isInteger(e))throw new Error("Invalid fftSize: it must be a power of 2 between "+`2 to 4 and 2 to 14, but got ${this.fftSize}`);if(this.numFrames=t.numFramesPerSpectrogram||43,this.sampleRateHz=t.sampleRateHz,this.columnTruncateLength=t.columnTruncateLength||this.fftSize,this.audioTrackConstraints=t.audioTrackConstraints,this.smoothingTimeConstant=t.smoothingTimeConstant||0,this.includeSpectrogram=!1!==t.includeSpectrogram,this.includeWaveform=!0===t.includeWaveform,!this.includeSpectrogram&&!this.includeWaveform)throw new Error("Both includeSpectrogram and includeWaveform are false. At least one type of data should be returned.")}summary(){return"microphone"}static async create(e={}){if(!(0,t.env)().get("IS_BROWSER"))throw new Error("microphone API is only supported in browser environment.");const i=new a(e);return await i.start(),i}async start(){try{this.stream=await navigator.mediaDevices.getUserMedia({audio:null==this.audioTrackConstraints||this.audioTrackConstraints,video:!1})}catch(a){throw new Error(`Error thrown while initializing video stream: ${a.message}`)}if(!this.stream)throw new Error("Could not obtain audio from microphone.");const t=window.AudioContext||window.webkitAudioContext;if(this.audioContext=new t,this.sampleRateHz){if(this.audioContext.sampleRate!==this.sampleRateHz)throw new Error("Mismatch in sampling rate: "+`Expected: ${this.sampleRateHz}; `+`Actual: ${this.audioContext.sampleRate}`)}else this.sampleRateHz=this.audioContext.sampleRate;const e=this.audioContext.createMediaStreamSource(this.stream);this.analyser=this.audioContext.createAnalyser(),this.analyser.fftSize=2*this.fftSize,this.analyser.smoothingTimeConstant=this.smoothingTimeConstant,e.connect(this.analyser),this.freqData=new Float32Array(this.fftSize),this.timeData=new Float32Array(this.fftSize)}async next(){if(this.isClosed)return{value:null,done:!0};let t,e;const a=await this.getAudioData();if(this.includeSpectrogram){const e=this.flattenQueue(a.freqDataQueue);t=this.getTensorFromAudioDataArray(e,[this.numFrames,this.columnTruncateLength,1])}if(this.includeWaveform){const t=this.flattenQueue(a.timeDataQueue);e=this.getTensorFromAudioDataArray(t,[this.numFrames*this.fftSize,1])}return{value:{spectrogram:t,waveform:e},done:!1}}async capture(){return(await this.next()).value}async getAudioData(){const t=[],e=[];let a=0;return new Promise(i=>{const r=setInterval(()=>{this.includeSpectrogram&&(this.analyser.getFloatFrequencyData(this.freqData),this.freqData[0]===-1/0&&i({freqDataQueue:t,timeDataQueue:e}),t.push(this.freqData.slice(0,this.columnTruncateLength))),this.includeWaveform&&(this.analyser.getFloatTimeDomainData(this.timeData),e.push(this.timeData.slice())),++a===this.numFrames&&(clearInterval(r),i({freqDataQueue:t,timeDataQueue:e}))},this.fftSize/this.sampleRateHz*1e3)})}stop(){this.isClosed||(this.isClosed=!0,this.analyser.disconnect(),this.audioContext.close(),null!=this.stream&&this.stream.getTracks().length>0&&this.stream.getTracks()[0].stop())}toArray(){throw new Error("Can not convert infinite audio stream to array.")}getSampleRate(){return this.sampleRateHz}flattenQueue(t){const e=t[0].length,a=new Float32Array(t.length*e);return t.forEach((t,i)=>a.set(t,i*e)),a}getTensorFromAudioDataArray(e,a){const i=new Float32Array(t.util.sizeFromShape(a));return i.set(e,i.length-e.length),(0,t.tensor)(i,a)}}exports.MicrophoneIterator=a;
},{"@tensorflow/tfjs-core":"kSBl","./lazy_iterator":"iw6x"}],"L16l":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.WebcamIterator=void 0;var e=require("@tensorflow/tfjs-core"),i=require("./lazy_iterator");class t extends i.LazyIterator{constructor(i,t){if(super(),this.webcamVideoElement=i,this.webcamConfig=t,this.isClosed=!0,this.resize=!1,this.needToResize())if(this.resize=!0,this.cropSize=[this.webcamConfig.resizeHeight,this.webcamConfig.resizeWidth],this.cropBoxInd=(0,e.tensor1d)([0],"int32"),this.webcamConfig.centerCrop){const i=1*this.webcamConfig.resizeWidth/this.webcamVideoElement.width,t=1*this.webcamConfig.resizeHeight/this.webcamVideoElement.height,r=(1-i)/2,s=(1-t)/2,o=r+i,n=t+s;this.cropBox=(0,e.tensor2d)([s,r,n,o],[1,4])}else this.cropBox=(0,e.tensor2d)([0,0,1,1],[1,4])}summary(){return"webcam"}static async create(i,r={}){if(!(0,e.env)().get("IS_BROWSER"))throw new Error("tf.data.webcam is only supported in browser environment.");if(!i){if(i=document.createElement("video"),!r.resizeWidth||!r.resizeHeight)throw new Error("Please provide webcam video element, or resizeWidth and resizeHeight to create a hidden video element.");i.width=r.resizeWidth,i.height=r.resizeHeight}const s=new t(i,r);return await s.start(),s}async start(){this.webcamConfig.facingMode&&e.util.assert("user"===this.webcamConfig.facingMode||"environment"===this.webcamConfig.facingMode,()=>`Invalid webcam facing mode: ${this.webcamConfig.facingMode}. `+"Please provide 'user' or 'environment'");try{this.stream=await navigator.mediaDevices.getUserMedia({video:{deviceId:this.webcamConfig.deviceId,facingMode:this.webcamConfig.facingMode?this.webcamConfig.facingMode:"user",width:this.webcamVideoElement.width,height:this.webcamVideoElement.height}})}catch(i){throw i.message=`Error thrown while initializing video stream: ${i.message}`,i}if(!this.stream)throw new Error("Could not obtain video from webcam.");try{this.webcamVideoElement.srcObject=this.stream}catch(t){console.log(t),this.webcamVideoElement.src=window.URL.createObjectURL(this.stream)}return this.webcamVideoElement.play(),this.isClosed=!1,new Promise(e=>{this.webcamVideoElement.onloadedmetadata=(()=>{e()})})}async next(){if(this.isClosed)return{value:null,done:!0};let i;try{i=e.browser.fromPixels(this.webcamVideoElement)}catch(t){throw new Error(`Error thrown converting video to pixels: ${JSON.stringify(t)}`)}if(!this.resize)return{value:i,done:!1};try{return{value:this.cropAndResizeFrame(i),done:!1}}catch(t){throw new Error(`Error thrown cropping the video: ${t.message}`)}finally{i.dispose()}}needToResize(){return!(!this.webcamConfig.resizeWidth||!this.webcamConfig.resizeHeight||this.webcamVideoElement.width===this.webcamConfig.resizeWidth&&this.webcamVideoElement.height===this.webcamConfig.resizeHeight)}cropAndResizeFrame(i){return(0,e.tidy)(()=>{const t=(0,e.expandDims)((0,e.cast)(i,"float32"),0);let r;const s=(r=e.image.cropAndResize(t,this.cropBox,this.cropBoxInd,this.cropSize,"bilinear")).shape;return(0,e.reshape)(r,s.slice(1))})}async capture(){return(await this.next()).value}stop(){this.stream.getTracks().forEach(e=>e.stop());try{this.webcamVideoElement.srcObject=null}catch(e){console.log(e),this.webcamVideoElement.src=null}this.isClosed=!0}toArray(){throw new Error("Can not convert infinite video stream to array.")}}exports.WebcamIterator=t;
},{"@tensorflow/tfjs-core":"kSBl","./lazy_iterator":"iw6x"}],"C4Cn":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.DataSource=void 0;class e{}exports.DataSource=e;
},{}],"A2EX":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.StringIterator=void 0;var t=require("./lazy_iterator");class r extends t.LazyIterator{split(t){return new e(this,t)}}exports.StringIterator=r;class e extends r{constructor(t,r){super(),this.upstream=t,this.impl=new s(t,r)}summary(){return this.impl.summary()}async next(){return this.impl.next()}}class s extends t.OneToManyIterator{constructor(t,r){super(),this.upstream=t,this.separator=r,this.carryover=""}summary(){return`${this.upstream.summary()} -> Split('${this.separator}')`}async pump(){const t=await this.upstream.next();if(t.done)return""!==this.carryover&&(this.outputQueue.push(this.carryover),this.carryover="",!0);const r=t.value.split(this.separator);r[0]=this.carryover+r[0];for(const e of r.slice(0,-1))this.outputQueue.push(e);return this.carryover=r[r.length-1],!0}}
},{"./lazy_iterator":"iw6x"}],"XOP8":[function(require,module,exports) {
var Buffer = require("buffer").Buffer;
var e=require("buffer").Buffer;Object.defineProperty(exports,"__esModule",{value:!0}),exports.ByteChunkIterator=void 0;var r=require("@tensorflow/tfjs-core"),t=require("./lazy_iterator"),s=require("./string_iterator");class u extends t.LazyIterator{decodeUTF8(){return new o(this)}}exports.ByteChunkIterator=u;class o extends s.StringIterator{constructor(e){super(),this.upstream=e,this.impl=new n(e)}summary(){return this.impl.summary()}async next(){return this.impl.next()}}class n extends t.OneToManyIterator{constructor(e){if(super(),this.upstream=e,(0,r.env)().get("IS_BROWSER"))this.decoder=new TextDecoder("utf-8");else{const{StringDecoder:e}=require("string_decoder");this.decoder=new e("utf8")}}summary(){return`${this.upstream.summary()} -> Utf8`}async pump(){const t=await this.upstream.next();let s,u;return!t.done&&(s=t.value,u=(0,r.env)().get("IS_BROWSER")?this.decoder.decode(s,{stream:!0}):this.decoder.write(e.from(s.buffer)),this.outputQueue.push(u),!0)}}
},{"@tensorflow/tfjs-core":"kSBl","./lazy_iterator":"iw6x","./string_iterator":"A2EX","string_decoder":"ZOa0","buffer":"RTGM"}],"MdGB":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.FileChunkIterator=void 0;var e=require("@tensorflow/tfjs-core"),t=require("./byte_chunk_iterator");class r extends t.ByteChunkIterator{constructor(t,r={}){super(),this.file=t,this.options=r,e.util.assert(t instanceof Uint8Array||!!(0,e.env)().get("IS_BROWSER")&&(t instanceof File||t instanceof Blob),()=>"FileChunkIterator only supports File, Blob and Uint8Array right now."),this.offset=r.offset||0,this.chunkSize=r.chunkSize||1048576}summary(){return`FileChunks ${this.file}`}async next(){if(this.offset>=(this.file instanceof Uint8Array?this.file.byteLength:this.file.size))return{value:null,done:!0};const e=new Promise((e,t)=>{const r=this.offset+this.chunkSize;if(this.file instanceof Uint8Array)e(new Uint8Array(this.file.slice(this.offset,r)));else{const i=new FileReader;i.onload=(r=>{let n=i.result;if(n instanceof ArrayBuffer&&(n=new Uint8Array(n)),!(n instanceof Uint8Array))return t(new TypeError("FileReader returned unknown type."));e(n)}),i.onabort=(e=>t(new Error("Aborted"))),i.onerror=(e=>t(new Error(e.type)));const n=this.file.slice(this.offset,r);i.readAsArrayBuffer(n)}this.offset=r});return{value:await e,done:!1}}}exports.FileChunkIterator=r;
},{"@tensorflow/tfjs-core":"kSBl","./byte_chunk_iterator":"XOP8"}],"GwEk":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.urlChunkIterator=t;var e=require("@tensorflow/tfjs-core"),r=require("./file_chunk_iterator");async function t(t,i={},n){let a,c;"string"==typeof t?a=t:(a=t.url,c=o(t));const s=await(n||e.util.fetch)(a,c);if(s.ok){const e=new Uint8Array(await s.arrayBuffer());return new r.FileChunkIterator(e,i)}throw new Error(s.statusText)}const o=e=>{return{method:e.method,headers:e.headers,body:e.body,mode:e.mode,credentials:e.credentials,cache:e.cache,redirect:e.redirect,referrer:e.referrer,integrity:e.integrity}};
},{"@tensorflow/tfjs-core":"kSBl","./file_chunk_iterator":"MdGB"}],"CcOm":[function(require,module,exports) {
"use strict";function e(e){return"string"==typeof e&&"file://"===e.slice(0,7)}Object.defineProperty(exports,"__esModule",{value:!0}),exports.isLocalPath=e;
},{}],"wfiy":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.FileDataSource=void 0;var e=require("@tensorflow/tfjs-core"),t=require("../datasource"),r=require("../iterators/file_chunk_iterator"),i=require("../util/source_util");class s extends t.DataSource{constructor(e,t={}){super(),this.input=e,this.options=t}async iterator(){if((0,i.isLocalPath)(this.input)&&(0,e.env)().get("IS_NODE")){const e=require("fs");this.input=e.readFileSync(this.input.slice(7))}return new r.FileChunkIterator(this.input,this.options)}}exports.FileDataSource=s;
},{"@tensorflow/tfjs-core":"kSBl","../datasource":"C4Cn","../iterators/file_chunk_iterator":"MdGB","../util/source_util":"CcOm","fs":"ZOa0"}],"tslM":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.URLDataSource=void 0;var r=require("../datasource"),e=require("../iterators/url_chunk_iterator"),t=require("../util/source_util"),i=require("./file_data_source");class s extends r.DataSource{constructor(r,e={}){super(),this.url=r,this.fileOptions=e}async iterator(){return(0,t.isLocalPath)(this.url)?new i.FileDataSource(this.url,this.fileOptions).iterator():(0,e.urlChunkIterator)(this.url,this.fileOptions)}}exports.URLDataSource=s;
},{"../datasource":"C4Cn","../iterators/url_chunk_iterator":"GwEk","../util/source_util":"CcOm","./file_data_source":"wfiy"}],"EqxP":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.csv=s,exports.func=c,exports.generator=i,exports.microphone=p,exports.webcam=u;var r=require("./dataset"),e=require("./datasets/csv_dataset"),t=require("./iterators/lazy_iterator"),a=require("./iterators/microphone_iterator"),o=require("./iterators/webcam_iterator"),n=require("./sources/url_data_source");function s(r,t={}){return new e.CSVDataset(new n.URLDataSource(r),t)}function c(e){const a=(0,t.iteratorFromFunction)(e);return(0,r.datasetFromIteratorFn)(async()=>a)}function i(e){return(0,r.datasetFromIteratorFn)(async()=>{const r=await e();return(0,t.iteratorFromFunction)(()=>r.next())})}async function u(r,e){return o.WebcamIterator.create(r,e)}async function p(r){return a.MicrophoneIterator.create(r)}
},{"./dataset":"wLsA","./datasets/csv_dataset":"k3yy","./iterators/lazy_iterator":"iw6x","./iterators/microphone_iterator":"fh9C","./iterators/webcam_iterator":"L16l","./sources/url_data_source":"tslM"}],"DcRz":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),Object.defineProperty(exports,"CSVDataset",{enumerable:!0,get:function(){return r.CSVDataset}}),Object.defineProperty(exports,"Dataset",{enumerable:!0,get:function(){return e.Dataset}}),Object.defineProperty(exports,"FileDataSource",{enumerable:!0,get:function(){return a.FileDataSource}}),Object.defineProperty(exports,"TextLineDataset",{enumerable:!0,get:function(){return t.TextLineDataset}}),Object.defineProperty(exports,"URLDataSource",{enumerable:!0,get:function(){return u.URLDataSource}}),Object.defineProperty(exports,"array",{enumerable:!0,get:function(){return e.array}}),Object.defineProperty(exports,"csv",{enumerable:!0,get:function(){return n.csv}}),Object.defineProperty(exports,"func",{enumerable:!0,get:function(){return n.func}}),Object.defineProperty(exports,"generator",{enumerable:!0,get:function(){return n.generator}}),Object.defineProperty(exports,"microphone",{enumerable:!0,get:function(){return n.microphone}}),Object.defineProperty(exports,"version_data",{enumerable:!0,get:function(){return o.version}}),Object.defineProperty(exports,"webcam",{enumerable:!0,get:function(){return n.webcam}}),Object.defineProperty(exports,"zip",{enumerable:!0,get:function(){return e.zip}});var e=require("./dataset"),r=require("./datasets/csv_dataset"),t=require("./datasets/text_line_dataset"),n=require("./readers"),a=require("./sources/file_data_source"),u=require("./sources/url_data_source"),o=require("./version");
},{"./dataset":"wLsA","./datasets/csv_dataset":"k3yy","./datasets/text_line_dataset":"yFx4","./readers":"EqxP","./sources/file_data_source":"wfiy","./sources/url_data_source":"tslM","./version":"KPnh"}],"nVKy":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.assertNotComplex=r;var e=require("@tensorflow/tfjs-core");function r(r,t){Array.isArray(r)||(r=[r]),r.forEach(r=>{null!=r&&e.util.assert("complex64"!==r.dtype,()=>`${t} does not support complex64 tensors in the CPU backend.`)})}
},{"@tensorflow/tfjs-core":"kSBl"}],"hTsf":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.MathBackendCPU=void 0;var e=require("@tensorflow/tfjs-core"),t=require("./cpu_util");const a=e.kernel_impls.whereImpl;class r extends e.KernelBackend{nextDataId(){return r.nextDataId++}constructor(){super(),this.blockSize=48,this.firstUse=!0,this.data=new e.DataStorage(this,(0,e.engine)())}write(t,a,r){this.firstUse&&(this.firstUse=!1,(0,e.env)().get("IS_NODE")&&e.backend_util.warn("\n============================\nHi, looks like you are running TensorFlow.js in Node.js. To speed things up dramatically, install our node backend, visit https://github.com/tensorflow/tfjs-node for more details. \n============================"));const s={id:this.nextDataId()};return this.data.set(s,{values:t,dtype:r,refCount:1}),s}makeTensorInfo(t,a,r){let s;if("string"===a&&null!=r&&r.length>0&&e.util.isString(r[0])){const n=r.map(t=>e.util.encodeString(t));s=this.write(n,t,a)}else s=this.write(r,t,a);return{dataId:s,shape:t,dtype:a}}refCount(e){if(this.data.has(e)){return this.data.get(e).refCount}return 0}incRef(e){this.data.get(e).refCount++}decRef(e){if(this.data.has(e)){this.data.get(e).refCount--}}move(e,t,a,r,s){this.data.set(e,{values:t,dtype:r,refCount:s})}numDataIds(){return this.data.numDataIds()}async read(e){return this.readSync(e)}readSync(t){const{dtype:a,complexTensorInfos:r}=this.data.get(t);if("complex64"===a){const t=this.readSync(r.real.dataId),a=this.readSync(r.imag.dataId);return e.backend_util.mergeRealAndImagArrays(t,a)}return e.util.convertBackendValuesAndArrayBuffer(this.data.get(t).values,a)}bufferSync(t){const a=this.readSync(t.dataId);if("string"===t.dtype)try{const s=a.map(t=>e.util.decodeString(t));return(0,e.buffer)(t.shape,t.dtype,s)}catch(r){throw new Error("Failed to decode encoded string bytes into utf-8")}return(0,e.buffer)(t.shape,t.dtype,a)}makeOutput(t,a,r){return(0,e.engine)().makeTensorFromTensorInfo(this.makeTensorInfo(a,r,t),this)}disposeData(e,t=!1){if(this.data.has(e)){if(this.data.get(e).refCount--,!t&&this.data.get(e).refCount>0)return!1;const{complexTensorInfos:a}=this.data.get(e);null!=a&&(this.disposeData(a.real.dataId,!0),this.disposeData(a.imag.dataId,!0)),this.data.delete(e)}return!0}disposeIntermediateTensorInfo(e){this.disposeData(e.dataId)}async time(t){const a=e.util.now();return t(),{kernelMs:e.util.now()-a}}memory(){return{unreliable:!0,reasons:["The reported memory is an upper bound. Due to automatic garbage collection, the true allocated memory may be less."]}}where(e){(0,t.assertNotComplex)([e],"where");const r=this.readSync(e.dataId);return a(e.shape,r)}dispose(){}floatPrecision(){return 32}epsilon(){return super.epsilon()}}exports.MathBackendCPU=r,r.nextDataId=0;
},{"@tensorflow/tfjs-core":"kSBl","./cpu_util":"nVKy"}],"WHC3":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.absConfig=exports.abs=void 0,exports.simpleAbsImpl=s;var e=require("@tensorflow/tfjs-core"),t=require("../cpu_util");function s(e){const t=new Float32Array(e.length);for(let s=0;s<e.length;++s)t[s]=Math.abs(e[s]);return t}const r=r=>{const{x:a}=r.inputs,o=r.backend;(0,t.assertNotComplex)(a,"abs");let n=new Float32Array(e.util.sizeFromShape(a.shape));return n=s(o.data.get(a.dataId).values),o.makeOutput(n,a.shape,a.dtype)};exports.abs=r;const a=exports.absConfig={kernelName:e.Abs,backendName:"cpu",kernelFunc:r};
},{"@tensorflow/tfjs-core":"kSBl","../cpu_util":"nVKy"}],"v0i6":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.createSimpleBinaryKernelImpl=t;var e=require("@tensorflow/tfjs-core");function t(t){return(l,r,o,n,i)=>{const c=e.backend_util.assertAndGetBroadcastShape(l,r),s=c.length,u=e.util.computeStrides(c),a=e.util.sizeFromShape(c),d=e.util.getTypedArrayFromDType(i,a),h=l.length,g=r.length,p=e.util.computeStrides(l),f=e.util.computeStrides(r),m=e.backend_util.getBroadcastDims(l,c),S=e.backend_util.getBroadcastDims(r,c);if(m.length+S.length===0)for(let e=0;e<d.length;++e)d[e]=t(o[e%o.length],n[e%n.length]);else for(let x=0;x<d.length;++x){const l=e.util.indexToLoc(x,s,u),r=l.slice(-h);m.forEach(e=>r[e]=0);const i=e.util.locToIndex(r,h,p),c=l.slice(-g);S.forEach(e=>c[e]=0);const a=e.util.locToIndex(c,g,f);d[x]=t(o[i],n[a])}return[d,c]}}
},{"@tensorflow/tfjs-core":"kSBl"}],"KmEe":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.complex=a,exports.complexConfig=void 0;var e=require("@tensorflow/tfjs-core");function a(e){const{inputs:a,backend:o}=e,{real:t,imag:n}=a,r=o.data.get(t.dataId).values,s=o.data.get(n.dataId).values,l=o.makeTensorInfo(t.shape,"complex64");return o.data.get(l.dataId).complexTensorInfos={real:o.makeTensorInfo(t.shape,"float32",r),imag:o.makeTensorInfo(n.shape,"float32",s)},l}const o=exports.complexConfig={kernelName:e.Complex,backendName:"cpu",kernelFunc:a};
},{"@tensorflow/tfjs-core":"kSBl"}],"QgwK":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.zeros=o;var e=require("@tensorflow/tfjs-core"),r=require("../kernels/Complex");function o(t,s,l="float32"){if("complex64"===l){const e=o(t,s,"float32"),l=o(t,s,"float32");return(0,r.complex)({inputs:{real:e,imag:l},backend:t})}const n=e.util.makeZerosTypedArray(e.util.sizeFromShape(s),l);return t.makeTensorInfo(s,l,n)}
},{"@tensorflow/tfjs-core":"kSBl","../kernels/Complex":"KmEe"}],"nMAE":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.identity=t,exports.identityConfig=void 0;var e=require("@tensorflow/tfjs-core");function t(e){const{inputs:t,backend:n}=e,{x:d}=t;return n.incRef(d.dataId),{dataId:d.dataId,shape:d.shape,dtype:d.dtype}}const n=exports.identityConfig={kernelName:e.Identity,backendName:"cpu",kernelFunc:t};
},{"@tensorflow/tfjs-core":"kSBl"}],"icBn":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.real=t,exports.realConfig=void 0;var e=require("@tensorflow/tfjs-core");function t(e){const{inputs:t,backend:a}=e,{input:r}=t,n=a.data.get(r.dataId).complexTensorInfos.real,o=a.data.get(n.dataId).values;return a.makeTensorInfo(n.shape,n.dtype,o)}const a=exports.realConfig={kernelName:e.Real,backendName:"cpu",kernelFunc:t};
},{"@tensorflow/tfjs-core":"kSBl"}],"Bp6G":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.cast=a,exports.castConfig=void 0,exports.castImpl=i;var e=require("@tensorflow/tfjs-core"),t=require("../utils/binary_impl"),r=require("../utils/zeros_impl"),n=require("./Complex"),o=require("./Identity"),s=require("./Real");function i(r,n,o,s){if("int32"===s){return[n,"int32",Int32Array.from(r)]}if("bool"===s){const s=e.util.toTypedArray([0],o),[i,a]=(0,t.createSimpleBinaryKernelImpl)((e,t)=>e!==t?1:0)(n,[],r,s,"bool");return[a,"bool",i]}throw new Error(`Error in Cast: failed to cast ${o} to ${s}`)}function a(t){const{inputs:p,backend:d,attrs:c}=t,{x:u}=p,{dtype:l}=c;if("complex64"===l){if("complex64"===u.dtype)return(0,o.identity)({inputs:{x:u},backend:d});const e=(0,r.zeros)(d,u.shape,u.dtype),t=a({inputs:{x:u},backend:d,attrs:{dtype:"float32"}}),s=(0,n.complex)({inputs:{real:t,imag:e},backend:d});return d.disposeIntermediateTensorInfo(e),d.disposeIntermediateTensorInfo(t),s}if("complex64"===u.dtype){const e=(0,s.real)({inputs:{input:u},backend:d}),t=a({inputs:{x:e},backend:d,attrs:{dtype:l}});return d.disposeIntermediateTensorInfo(e),t}if(!e.util.hasEncodingLoss(u.dtype,l)){const e=(0,o.identity)({inputs:{x:u},backend:d});return{dataId:e.dataId,shape:e.shape,dtype:l}}const f=d.data.get(u.dataId).values,[m,y,x]=i(f,u.shape,u.dtype,l);return d.makeTensorInfo(m,y,x)}const p=exports.castConfig={kernelName:e.Cast,backendName:"cpu",kernelFunc:a};
},{"@tensorflow/tfjs-core":"kSBl","../utils/binary_impl":"v0i6","../utils/zeros_impl":"QgwK","./Complex":"KmEe","./Identity":"nMAE","./Real":"icBn"}],"FLbP":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.binaryKernelFunc=r,exports.createComplexBinaryKernelImpl=o;var e=require("@tensorflow/tfjs-core"),t=require("../cpu_util"),a=require("../kernels/Cast"),n=require("../kernels/Complex");function r(r,o,s,d){return null==s?({inputs:a,backend:n})=>{const{a:s,b:l}=a,i=n;(0,t.assertNotComplex)([s,l],r);const c=i.data.get(s.dataId).values,u=i.data.get(l.dataId).values,p="string"===s.dtype?e.backend_util.fromUint8ToStringArray(c):c,m="string"===s.dtype?e.backend_util.fromUint8ToStringArray(u):u,g=d||s.dtype,[I,f]=o(s.shape,l.shape,p,m,g);return i.makeTensorInfo(f,g,I)}:({inputs:e,backend:t})=>{const{a:r,b:l}=e,i=t;if("complex64"===r.dtype||"complex64"===l.dtype){const e=(0,a.cast)({inputs:{x:r},backend:i,attrs:{dtype:"complex64"}}),t=i.data.get(e.dataId),o=t.complexTensorInfos.real,d=t.complexTensorInfos.imag,c=i.data.get(o.dataId).values,u=i.data.get(d.dataId).values,p=(0,a.cast)({inputs:{x:l},backend:i,attrs:{dtype:"complex64"}}),m=i.data.get(p.dataId),g=m.complexTensorInfos.real,I=m.complexTensorInfos.imag,f=i.data.get(g.dataId).values,y=i.data.get(I.dataId).values,[T,x,h]=s(r.shape,l.shape,c,u,f,y),k=i.makeTensorInfo(h,"float32",T),b=i.makeTensorInfo(h,"float32",x),v=(0,n.complex)({inputs:{real:k,imag:b},backend:i});return i.disposeIntermediateTensorInfo(e),i.disposeIntermediateTensorInfo(p),i.disposeIntermediateTensorInfo(k),i.disposeIntermediateTensorInfo(b),v}{const e=i.data.get(r.dataId).values,t=i.data.get(l.dataId).values,a=d||r.dtype,[n,s]=o(r.shape,l.shape,e,t,a);return i.makeTensorInfo(s,a,n)}}}function o(t){return(a,n,r,o,s,d)=>{const l=e.backend_util.assertAndGetBroadcastShape(a,n),i=e.util.sizeFromShape(l),c=l.length,u=e.util.computeStrides(l),p=e.util.getTypedArrayFromDType("float32",i),m=e.util.getTypedArrayFromDType("float32",i),g=e.backend_util.getBroadcastDims(a,l),I=e.backend_util.getBroadcastDims(n,l),f=e.backend_util.mergeRealAndImagArrays(r,o),y=e.backend_util.mergeRealAndImagArrays(s,d),T=a.length,x=e.util.computeStrides(a),h=n.length,k=e.util.computeStrides(n);if(g.length+I.length===0)for(let e=0;e<p.length;e++){const a=e%f.length,n=e%y.length,r=t(f[2*a],f[2*a+1],y[2*n],y[2*n+1]);p[e]=r.real,m[e]=r.imag}else for(let b=0;b<p.length;b++){const a=e.util.indexToLoc(b,c,u),n=a.slice(-T);g.forEach(e=>n[e]=0);const r=e.util.locToIndex(n,T,x),o=a.slice(-h);I.forEach(e=>o[e]=0);const s=e.util.locToIndex(o,h,k),d=t(f[2*r],f[2*r+1],y[2*s],y[2*s+1]);p[b]=d.real,m[b]=d.imag}return[p,m,l]}}
},{"@tensorflow/tfjs-core":"kSBl","../cpu_util":"nVKy","../kernels/Cast":"Bp6G","../kernels/Complex":"KmEe"}],"ZBkJ":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.addImpl=exports.addConfig=exports.addComplexImpl=exports.add=void 0;var e=require("@tensorflow/tfjs-core"),r=require("../utils/binary_impl"),d=require("../utils/binary_utils");const l=exports.addImpl=(0,r.createSimpleBinaryKernelImpl)((e,r)=>e+r),a=exports.addComplexImpl=(0,d.createComplexBinaryKernelImpl)((e,r,d,l)=>({real:e+d,imag:r+l})),p=exports.add=(0,d.binaryKernelFunc)(e.Add,l,a),o=exports.addConfig={kernelName:e.Add,backendName:"cpu",kernelFunc:p};
},{"@tensorflow/tfjs-core":"kSBl","../utils/binary_impl":"v0i6","../utils/binary_utils":"FLbP"}],"cUUF":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.bincountImpl=t,exports.bincountReduceImpl=r;var e=require("@tensorflow/tfjs-core");function t(t,r,n,o,s){const u=e.util.sizeFromShape(o),i=e.util.makeZerosTypedArray(s,n);for(let e=0;e<t.length;e++){const n=t[e];if(n<0)throw new Error("Input x must be non-negative!");n>=s||(i[n]+=u>0?r[e]:1)}return i}function r(t,r,n,o=!1){const s=t.shape[0],u=t.shape[1],i=(0,e.buffer)([s,n],r.dtype);for(let e=0;e<s;e++)for(let s=0;s<u;s++){const u=t.get(e,s);if(u<0)throw new Error("Input x must be non-negative!");u>=n||(o?i.set(1,e,u):r.size>0?i.set(i.get(e,u)+r.get(e,s),e,u):i.set(i.get(e,u)+1,e,u))}return i}
},{"@tensorflow/tfjs-core":"kSBl"}],"PuG8":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.bitwiseAndImpl=exports.bitwiseAndConfig=exports.bitwiseAnd=void 0;var e=require("@tensorflow/tfjs-core"),i=require("../utils/binary_impl"),r=require("../utils/binary_utils");const t=exports.bitwiseAndImpl=(0,i.createSimpleBinaryKernelImpl)((e,i)=>e&i),n=exports.bitwiseAnd=(0,r.binaryKernelFunc)(e.BitwiseAnd,t),s=exports.bitwiseAndConfig={kernelName:e.BitwiseAnd,backendName:"cpu",kernelFunc:n};
},{"@tensorflow/tfjs-core":"kSBl","../utils/binary_impl":"v0i6","../utils/binary_utils":"FLbP"}],"FlCa":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.createSimpleUnaryImpl=r;var e=require("@tensorflow/tfjs-core");function r(r){return(t,o,n)=>{const l=e.util.getArrayFromDType(o,t.length);for(let e=0;e<t.length;++e)l[e]=r(t[e],n);return l}}
},{"@tensorflow/tfjs-core":"kSBl"}],"kZAs":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.unaryKernelFunc=n,exports.unaryKernelFuncFromImpl=a;var r=require("@tensorflow/tfjs-core"),e=require("../cpu_util"),t=require("./unary_impl");function n(r,e,n){return a(r,(0,t.createSimpleUnaryImpl)(e),n)}function a(t,n,a){return({inputs:o,attrs:s,backend:u})=>{const{x:i}=o;(0,e.assertNotComplex)(i,t);const l=u,c=l.data.get(i.dataId).values;let p;if("string"===i.dtype){if(!Array.isArray(c))throw new Error("String tensor's value was not an instance of Array");p=r.backend_util.fromUint8ToStringArray(c)}else p=c;const y=a||i.dtype,f=n(p,y,s);return l.makeTensorInfo(i.shape,y,f)}}
},{"@tensorflow/tfjs-core":"kSBl","../cpu_util":"nVKy","./unary_impl":"FlCa"}],"PT9Z":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.ceilImpl=exports.ceilConfig=exports.ceil=void 0;var e=require("@tensorflow/tfjs-core"),r=require("../utils/unary_impl"),l=require("../utils/unary_utils");const i=exports.ceilImpl=(0,r.createSimpleUnaryImpl)(e=>Math.ceil(e)),t=exports.ceil=(0,l.unaryKernelFuncFromImpl)(e.Ceil,i),o=exports.ceilConfig={kernelName:e.Ceil,backendName:"cpu",kernelFunc:t};
},{"@tensorflow/tfjs-core":"kSBl","../utils/unary_impl":"FlCa","../utils/unary_utils":"kZAs"}],"axei":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.concatImpl=t;var e=require("@tensorflow/tfjs-core");function t(t,r,s,o){const a=e.util.getArrayFromDType(s,e.util.sizeFromShape(r));if(o&&"string"!==s){let r=0;t.forEach(t=>{const s=e.util.sizeFromShape(t.shape);a.set(t.vals,r),r+=s})}else{let o=0;t.forEach(t=>{const l="string"===s?e.backend_util.fromUint8ToStringArray(t.vals):t.vals;let i=0;for(let e=0;e<t.shape[0];++e){const s=e*r[1]+o;for(let e=0;e<t.shape[1];++e)a[s+e]=l[i++]}o+=t.shape[1]})}return a}
},{"@tensorflow/tfjs-core":"kSBl"}],"Qy3m":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.equalImpl=exports.equalConfig=exports.equal=void 0;var e=require("@tensorflow/tfjs-core"),r=require("../utils/binary_impl"),l=require("../utils/binary_utils");const u=exports.equalImpl=(0,r.createSimpleBinaryKernelImpl)((e,r)=>e===r?1:0),a=exports.equal=(0,l.binaryKernelFunc)(e.Equal,u,null,"bool"),o=exports.equalConfig={kernelName:e.Equal,backendName:"cpu",kernelFunc:a};
},{"@tensorflow/tfjs-core":"kSBl","../utils/binary_impl":"v0i6","../utils/binary_utils":"FLbP"}],"Q92g":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.expImpl=exports.expConfig=exports.exp=void 0;var e=require("@tensorflow/tfjs-core"),r=require("../utils/unary_impl"),p=require("../utils/unary_utils");const t=exports.expImpl=(0,r.createSimpleUnaryImpl)(e=>Math.exp(e)),o=exports.exp=(0,p.unaryKernelFuncFromImpl)(e.Exp,t,"float32"),l=exports.expConfig={kernelName:e.Exp,backendName:"cpu",kernelFunc:o};
},{"@tensorflow/tfjs-core":"kSBl","../utils/unary_impl":"FlCa","../utils/unary_utils":"kZAs"}],"wiHC":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.expm1Impl=exports.expm1Config=exports.expm1=void 0;var e=require("@tensorflow/tfjs-core"),r=require("../utils/unary_impl"),p=require("../utils/unary_utils");const t=exports.expm1Impl=(0,r.createSimpleUnaryImpl)(e=>Math.expm1(e)),m=exports.expm1=(0,p.unaryKernelFuncFromImpl)(e.Expm1,t),o=exports.expm1Config={kernelName:e.Expm1,backendName:"cpu",kernelFunc:m};
},{"@tensorflow/tfjs-core":"kSBl","../utils/unary_impl":"FlCa","../utils/unary_utils":"kZAs"}],"KFD4":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.floorImpl=exports.floorConfig=exports.floor=void 0;var r=require("@tensorflow/tfjs-core"),e=require("../utils/unary_impl"),o=require("../utils/unary_utils");const l=exports.floorImpl=(0,e.createSimpleUnaryImpl)(r=>Math.floor(r)),t=exports.floor=(0,o.unaryKernelFuncFromImpl)(r.Floor,l),s=exports.floorConfig={kernelName:r.Floor,backendName:"cpu",kernelFunc:t};
},{"@tensorflow/tfjs-core":"kSBl","../utils/unary_impl":"FlCa","../utils/unary_utils":"kZAs"}],"JeKf":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.floorDivImpl=exports.floorDivConfig=exports.floorDiv=void 0;var e=require("@tensorflow/tfjs-core"),r=require("../utils/binary_impl"),o=require("../utils/binary_utils");const i=exports.floorDivImpl=(0,r.createSimpleBinaryKernelImpl)((e,r)=>Math.floor(e/r)),l=exports.floorDiv=(0,o.binaryKernelFunc)(e.FloorDiv,i,null,"int32"),t=exports.floorDivConfig={kernelName:e.FloorDiv,backendName:"cpu",kernelFunc:l};
},{"@tensorflow/tfjs-core":"kSBl","../utils/binary_impl":"v0i6","../utils/binary_utils":"FLbP"}],"kXTU":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.gatherNdImpl=t;var e=require("@tensorflow/tfjs-core");function t(t,o,r,n,s,i,f,l,c){const u=(0,e.buffer)([n,i],r);for(let e=0;e<n;e++){const r=[];let n=0;for(let o=0;o<s;o++){const i=t[e*s+o];n+=i*f[o],r.push(i)}if(n<0||n>=c/i)throw new Error(`Invalid indices: ${r} does not index into ${l}`);for(let t=0;t<i;t++)u.values[e*i+t]=o.get(...o.indexToLoc(n*i+t))}return u}
},{"@tensorflow/tfjs-core":"kSBl"}],"Ea37":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.gatherV2Impl=o;var e=require("@tensorflow/tfjs-core");function o(o,t,s){const r=(0,e.buffer)(s,o.dtype);for(let e=0;e<r.size;++e){const s=r.indexToLoc(e).slice(),l=s[0],n=s[2],c=t.locToIndex([l,n]);s[2]=t.values[c];const u=o.locToIndex(s);0<=u&&u<o.values.length&&(r.values[e]=o.values[u])}return r}
},{"@tensorflow/tfjs-core":"kSBl"}],"QWdt":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.greaterImpl=exports.greaterConfig=exports.greater=void 0;var e=require("@tensorflow/tfjs-core"),r=require("../utils/binary_impl"),t=require("../utils/binary_utils");const a=exports.greaterImpl=(0,r.createSimpleBinaryKernelImpl)((e,r)=>e>r?1:0),l=exports.greater=(0,t.binaryKernelFunc)(e.Greater,a,null,"bool"),o=exports.greaterConfig={kernelName:e.Greater,backendName:"cpu",kernelFunc:l};
},{"@tensorflow/tfjs-core":"kSBl","../utils/binary_impl":"v0i6","../utils/binary_utils":"FLbP"}],"gfwn":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.greaterEqualImpl=exports.greaterEqualConfig=exports.greaterEqual=void 0;var e=require("@tensorflow/tfjs-core"),r=require("../utils/binary_impl"),a=require("../utils/binary_utils");const l=exports.greaterEqualImpl=(0,r.createSimpleBinaryKernelImpl)((e,r)=>e>=r?1:0),t=exports.greaterEqual=(0,a.binaryKernelFunc)(e.GreaterEqual,l,null,"bool"),u=exports.greaterEqualConfig={kernelName:e.GreaterEqual,backendName:"cpu",kernelFunc:t};
},{"@tensorflow/tfjs-core":"kSBl","../utils/binary_impl":"v0i6","../utils/binary_utils":"FLbP"}],"x95l":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.lessImpl=exports.lessConfig=exports.less=void 0;var e=require("@tensorflow/tfjs-core"),s=require("../utils/binary_impl"),r=require("../utils/binary_utils");const l=exports.lessImpl=(0,s.createSimpleBinaryKernelImpl)((e,s)=>e<s?1:0),o=exports.less=(0,r.binaryKernelFunc)(e.Less,l,null,"bool"),t=exports.lessConfig={kernelName:e.Less,backendName:"cpu",kernelFunc:o};
},{"@tensorflow/tfjs-core":"kSBl","../utils/binary_impl":"v0i6","../utils/binary_utils":"FLbP"}],"N5Qh":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.lessEqualImpl=exports.lessEqualConfig=exports.lessEqual=void 0;var e=require("@tensorflow/tfjs-core"),l=require("../utils/binary_impl"),s=require("../utils/binary_utils");const r=exports.lessEqualImpl=(0,l.createSimpleBinaryKernelImpl)((e,l)=>e<=l?1:0),u=exports.lessEqual=(0,s.binaryKernelFunc)(e.LessEqual,r,null,"bool"),a=exports.lessEqualConfig={kernelName:e.LessEqual,backendName:"cpu",kernelFunc:u};
},{"@tensorflow/tfjs-core":"kSBl","../utils/binary_impl":"v0i6","../utils/binary_utils":"FLbP"}],"BmUg":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.linSpaceImpl=r;var e=require("@tensorflow/tfjs-core");function r(r,t,o){const l=(t-r)/(o-1),s=e.util.makeZerosTypedArray(o,"float32");s[0]=r;for(let e=1;e<s.length;e++)s[e]=s[e-1]+l;return s}
},{"@tensorflow/tfjs-core":"kSBl"}],"ipxn":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.logImpl=exports.logConfig=exports.log=void 0;var e=require("@tensorflow/tfjs-core"),r=require("../utils/unary_impl"),o=require("../utils/unary_utils");const l=exports.logImpl=(0,r.createSimpleUnaryImpl)(e=>Math.log(e)),t=exports.log=(0,o.unaryKernelFuncFromImpl)(e.Log,l),s=exports.logConfig={kernelName:e.Log,backendName:"cpu",kernelFunc:t};
},{"@tensorflow/tfjs-core":"kSBl","../utils/unary_impl":"FlCa","../utils/unary_utils":"kZAs"}],"Db4x":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.maxImpl=t;var e=require("@tensorflow/tfjs-core");function t(t,r,o,s){const l=e.util.getTypedArrayFromDType(s,e.util.sizeFromShape(o));for(let e=0;e<l.length;++e){const o=e*r;let s=t[o];for(let e=0;e<r;++e){const r=t[o+e];(Number.isNaN(r)||r>s)&&(s=r)}l[e]=s}return l}
},{"@tensorflow/tfjs-core":"kSBl"}],"DbCK":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.maximumImpl=exports.maximumConfig=exports.maximum=void 0;var e=require("@tensorflow/tfjs-core"),m=require("../utils/binary_impl"),r=require("../utils/binary_utils");const i=exports.maximumImpl=(0,m.createSimpleBinaryKernelImpl)((e,m)=>Math.max(e,m)),a=exports.maximum=(0,r.binaryKernelFunc)(e.Maximum,i),u=exports.maximumConfig={kernelName:e.Maximum,backendName:"cpu",kernelFunc:a};
},{"@tensorflow/tfjs-core":"kSBl","../utils/binary_impl":"v0i6","../utils/binary_utils":"FLbP"}],"pZXl":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.minimumImpl=exports.minimumConfig=exports.minimum=void 0;var e=require("@tensorflow/tfjs-core"),i=require("../utils/binary_impl"),m=require("../utils/binary_utils");const r=exports.minimumImpl=(0,i.createSimpleBinaryKernelImpl)((e,i)=>Math.min(e,i)),n=exports.minimum=(0,m.binaryKernelFunc)(e.Minimum,r),u=exports.minimumConfig={kernelName:e.Minimum,backendName:"cpu",kernelFunc:n};
},{"@tensorflow/tfjs-core":"kSBl","../utils/binary_impl":"v0i6","../utils/binary_utils":"FLbP"}],"N9Eb":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.multiplyImpl=exports.multiplyConfig=exports.multiplyComplexImpl=exports.multiply=void 0;var e=require("@tensorflow/tfjs-core"),l=require("../utils/binary_impl"),r=require("../utils/binary_utils");const p=exports.multiplyImpl=(0,l.createSimpleBinaryKernelImpl)((e,l)=>e*l),t=exports.multiplyComplexImpl=(0,r.createComplexBinaryKernelImpl)((e,l,r,p)=>({real:e*r-l*p,imag:e*p+l*r})),i=exports.multiply=(0,r.binaryKernelFunc)(e.Multiply,p,t),m=exports.multiplyConfig={kernelName:e.Multiply,backendName:"cpu",kernelFunc:i};
},{"@tensorflow/tfjs-core":"kSBl","../utils/binary_impl":"v0i6","../utils/binary_utils":"FLbP"}],"NnAL":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.neg=o,exports.negConfig=void 0,exports.negImpl=r;var e=require("@tensorflow/tfjs-core"),t=require("../cpu_util"),n=require("./Multiply");function r(t,r,o){const s=e.util.createScalarValue(-1,o);return(0,n.multiplyImpl)([],r,s,t,o)}function o(e){const{inputs:n,backend:o}=e,{x:s}=n;(0,t.assertNotComplex)(s,"neg");const u=o.data.get(s.dataId).values,[a,l]=r(u,s.shape,s.dtype);return o.makeTensorInfo(l,s.dtype,a)}const s=exports.negConfig={kernelName:e.Neg,backendName:"cpu",kernelFunc:o};
},{"@tensorflow/tfjs-core":"kSBl","../cpu_util":"nVKy","./Multiply":"N9Eb"}],"VkjO":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.notEqualImpl=exports.notEqualConfig=exports.notEqual=void 0;var e=require("@tensorflow/tfjs-core"),r=require("../utils/binary_impl"),l=require("../utils/binary_utils");const o=exports.notEqualImpl=(0,r.createSimpleBinaryKernelImpl)((e,r)=>e!==r?1:0),t=exports.notEqual=(0,l.binaryKernelFunc)(e.NotEqual,o,null,"bool"),n=exports.notEqualConfig={kernelName:e.NotEqual,backendName:"cpu",kernelFunc:t};
},{"@tensorflow/tfjs-core":"kSBl","../utils/binary_impl":"v0i6","../utils/binary_utils":"FLbP"}],"fDvd":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.transposeImpl=t;var e=require("@tensorflow/tfjs-core");function t(t,r,o,l,i){const s=r.length,u=e.util.sizeFromShape(r),n=e.util.computeStrides(r),p=e.util.computeStrides(i),c=e.util.getTypedArrayFromDType(o,e.util.sizeFromShape(i));for(let a=0;a<u;++a){const r=e.util.indexToLoc(a,s,n),o=new Array(r.length);for(let e=0;e<o.length;e++)o[e]=r[l[e]];c[e.util.locToIndex(o,s,p)]=t[a]}return c}
},{"@tensorflow/tfjs-core":"kSBl"}],"zFLV":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.transpose=r,exports.transposeConfig=void 0;var e=require("@tensorflow/tfjs-core"),t=require("../cpu_util"),s=require("./Transpose_impl");function r(e){const{inputs:r,attrs:a,backend:n}=e,{x:o}=r,{perm:p}=a;(0,t.assertNotComplex)(o,"transpose");const d=o.shape.length,u=new Array(d);for(let t=0;t<u.length;t++)u[t]=o.shape[p[t]];const c=n.data.get(o.dataId).values,i=(0,s.transposeImpl)(c,o.shape,o.dtype,p,u);return{dataId:n.write(i,u,o.dtype),shape:u,dtype:o.dtype}}const a=exports.transposeConfig={kernelName:e.Transpose,backendName:"cpu",kernelFunc:r};
},{"@tensorflow/tfjs-core":"kSBl","../cpu_util":"nVKy","./Transpose_impl":"fDvd"}],"us0k":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.prod=s,exports.prodConfig=void 0,exports.prodImpl=r;var e=require("@tensorflow/tfjs-core"),t=require("../cpu_util"),o=require("./Transpose");function r(t,o,r,s){const[n,a]=e.backend_util.computeOutAndReduceShapes(t,s),p=(0,e.upcastType)(o,"int32"),u=e.util.makeZerosTypedArray(e.util.sizeFromShape(n),p),i=e.util.sizeFromShape(a);for(let e=0;e<u.length;++e){const t=e*i;let o=1;for(let e=0;e<i;++e)o*=r[t+e];u[e]=o}return{outVals:u,outShape:n,outDtype:p}}function s(s){const{inputs:n,backend:a,attrs:p}=s,{x:u}=n,{axis:i,keepDims:l}=p;(0,t.assertNotComplex)(u,"prod");const c=u.shape.length,d=e.util.parseAxisParam(i,u.shape),m=e.backend_util.getAxesPermutation(d,c);let h=d,x=u;const f=[];null!=m&&(x=(0,o.transpose)({inputs:{x:u},backend:a,attrs:{perm:m}}),f.push(x),h=e.backend_util.getInnerMostAxes(h.length,c));const k=a.data.get(x.dataId).values,{outVals:b,outShape:g,outDtype:y}=r(x.shape,x.dtype,k,h);let _=g;return l&&(_=e.backend_util.expandShapeToKeepDim(g,d)),f.forEach(e=>a.disposeIntermediateTensorInfo(e)),a.makeTensorInfo(_,y,b)}const n=exports.prodConfig={kernelName:e.Prod,backendName:"cpu",kernelFunc:s};
},{"@tensorflow/tfjs-core":"kSBl","../cpu_util":"nVKy","./Transpose":"zFLV"}],"mwpO":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.raggedGatherImpl=u;var t=require("@tensorflow/tfjs-core");function e(e,n,r){e.forEach((e,o)=>{if(e<0||e>=r){const l=t.util.indexToLoc(o,n.length,t.util.computeStrides(n)).join(",");throw new Error(`indices[${l}] = ${e} is not in [0, ${r})`)}})}function n(t,e){for(let n=0;n<t.length;++n){const r=t[n],o=n===t.length-1?e:t[n+1].length;if(0===r.length)throw new Error("Ragged splits may not be empty");if(r[0]<0)throw new Error("Ragged splits must be non-negative");if(r[r.length-1]>o)throw new Error("Ragged splits must not point past values");for(let t=1;t<r.length;++t)if(r[t-1]>r[t])throw new Error("Ragged splits must be sorted in ascending order")}}function r(t,e,r,o){const l=[];let s=0;const i=e.length-1+r.length,u=new Array(i).fill(null).map(()=>[0]);n(r,o);let h=1;for(let n=0;n<e.length-1;++n){h*=e[n];const t=e[n+1];for(let e=1;e<h+1;++e)u[n].push(e*t)}for(let n=0;n<t.length;++n){let o=t[n],i=t[n]+1;for(let t=0;t<r.length;++t){const n=r[t],l=t+e.length-1;if(l>=0){const t=u[l],e=t[t.length-1]-n[o];for(let r=o;r<i;++r)u[l].push(n[r+1]+e)}o=n[o],i=n[i]}i!==o&&(l.push([o,i]),s+=i-o)}return{outSplits:u,valueSlices:l,numValues:s}}function o(e){const n=[];for(let r=0;r<e.length;++r){const o=e[r].length,l=t.util.getArrayFromDType("int32",o);n.push(l),e[r].forEach((t,e)=>l[e]=t)}return n}function l(t,e){const n=t.slice(0,e);for(;n.length<e;)n.push(1);for(let r=e;r<t.length;r++)n[e-1]*=t[r];return n}function s(t,e,n,r,o,s){const i=l(e,2)[1],u=l(s,2)[1];let h=0;for(const l of n)for(let e=l[0];e<l[1];++e){for(let n=0;n<r;++n)o[h*u+n]=t[e*i+n];++h}}function i(e,n,r,o,l){const i=n.slice();i[0]=l;const u=t.util.getArrayFromDType(r,t.util.sizeFromShape(i)),h=e.length;return s(e,n,o,0===h?0:h/n[0],u,i),[u,i]}function u(t,n,l,s,u,h,c,f){if(0===t.length)throw new Error("paramsNestedSplits must be non empty");if(0===n[0].length)throw new Error("Split tensors must not be scalars");if(e(h,c,n[0][0]-1),0===s.length)throw new Error("params.rank must be nonzero");const g=s[0],{outSplits:a,valueSlices:p,numValues:m}=r(h,c,t,g),w=o(a),d=i(l,s,u,p,m);return[w,d[0],d[1]]}
},{"@tensorflow/tfjs-core":"kSBl"}],"Xl6V":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.raggedRangeImpl=r;var t=require("@tensorflow/tfjs-core");const e=2147483647;function r(r,o,s,l,a,n,i){if(o.length>1)throw new Error("starts must be a scalar or vector");if(a.length>1)throw new Error("limits must be a scalar or vector");if(i.length>1)throw new Error("deltas must be a scalar or vector");const h=0===o.length,c=0===a.length,u=0===i.length,f=[];h||f.push(o[0]),c||f.push(a[0]),u||f.push(i[0]);for(let t=1;t<f.length;++t)if(f[t]!==f[t-1])throw new Error("starts, limits, and deltas must have the same shape");const g=0===f.length?1:f[0],w=t.util.getArrayFromDType("int32",g+1);w[0]=0;for(let t=0;t<g;++t){const o=h?r[0]:r[t],s=c?l[0]:l[t],a=u?n[0]:n[t];if(0===a)throw new Error("Requires delta != 0");let i;if(a>0&&s<o||a<0&&s>o)i=0;else if((i=Math.ceil(Math.abs((s-o)/a)))>e)throw new Error(`Requires ((limit - start) / delta) <= ${e}`);w[t+1]=w[t]+i}const m=w[g],p=t.util.getArrayFromDType(s,m);let d=0;for(let t=0;t<g;++t){const e=w[t+1]-w[t];let o=h?r[0]:r[t];const s=u?n[0]:n[t];for(let t=0;t<e;++t)p[d++]=o,o+=s}return[w,p]}
},{"@tensorflow/tfjs-core":"kSBl"}],"H940":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.raggedTensorToTensorImpl=s;var t=require("@tensorflow/tfjs-core"),e=t.backend_util.RowPartitionType;class r{constructor(e,r,i,n,s,o,a,l,h,u){this.shape=e,this.shapeShape=r,this.values=i,this.valuesShape=n,this.valuesDType=s,this.defaultValue=o,this.defaultValueShape=a,this.rowPartitionValues=l,this.rowPartitionValuesShapes=h,this.rowPartitionTypes=t.backend_util.getRowPartitionTypesHelper(u),this.raggedRank=t.backend_util.getRaggedRank(this.rowPartitionTypes)}getRowPartitionTypeByDimension(t){return this.rowPartitionTypes[0]===e.FIRST_DIM_SIZE?this.rowPartitionTypes[t+1]:this.rowPartitionTypes[t]}getRowPartitionTensor(t){return this.rowPartitionTypes[0]===e.FIRST_DIM_SIZE?this.rowPartitionValues[t+1]:this.rowPartitionValues[t]}getMaxWidth(t){const i=this.getRowPartitionTensor(t-1);switch(this.getRowPartitionTypeByDimension(t-1)){case e.VALUE_ROWIDS:return r.getMaxWidthValueRowID(i);case e.ROW_SPLITS:return r.getMaxWidthRowSplit(i);default:throw new Error(`Cannot handle partition type ${e[this.getRowPartitionTypeByDimension(t-1)]}`)}}static getMaxWidthRowSplit(t){const e=t.length;if(0===e||1===e)return 0;let r=0;for(let i=0;i<e-1;++i){const e=t[i+1]-t[i];e>r&&(r=e)}return r}static getMaxWidthValueRowID(t){const e=t.length;if(0===e)return 0;let r=0,i=t[0],n=0;for(let s=1;s<e;++s){const e=t[s];e!==i&&(i=e,n=Math.max(s-r,n),r=s)}return Math.max(e-r,n)}tensorShapeFromTensor(t,e,r=!0){if(0===e.length){if(-1===t[0])return[];throw new Error("The only valid scalar shape tensor is the fully unknown shape specified as -1.")}return n(t,r)}calculateOutputSize(e){const r=this.valuesShape,i=this.defaultValueShape;t.backend_util.validateDefaultValueShape(i,r);const n=this.tensorShapeFromTensor(this.shape,this.shapeShape),s=t.backend_util.combineRaggedTensorToTensorShapes(this.raggedRank,n,r);s[0]<0&&(s[0]=e);for(let t=1;t<=this.raggedRank;++t)s[t]<0&&(s[t]=this.getMaxWidth(t));return s}calculateFirstParentOutputIndex(e,r,i){const n=Math.min(e,i),s=[];let o=0;for(let t=0;t<n;++t,o+=r)s.push(o);for(let t=n;t<e;++t)s.push(-1);return t.util.assert(s.length===e,()=>"Final length of result must be equal to firstDimension."),s}calculateOutputIndexRowSplit(t,e,r,i){const n=t.length,s=[];for(let o=0;o<n-1;++o){const n=t[o+1]-t[o];let a=Math.min(i,n),l=e[o];-1===l&&(a=0);for(let t=0;t<a;++t)s.push(l),l+=r;for(let t=0;t<n-a;++t)s.push(-1)}if(n>0&&s.length!==t[n-1])throw new Error("Invalid row split size.");return s}calculateOutputIndexValueRowID(t,e,r,i){const n=t.length,s=[];if(0===n)return[];let o=0,a=t[0];if(a>=e.length)throw new Error(`Got currentValueRowId=${a}, which is not less than ${e.length}`);let l=e[a];s.push(l);for(let h=1;h<n;++h){const n=t[h];if(n===a)l>=0&&(++o<i?l+=r:l=-1);else{if(o=0,a=n,n>=e.length)throw new Error(`Got nextValueRowId=${n} which is not less than ${e.length}`);l=e[n]}s.push(l)}if(s.length!==t.length)throw new Error("Invalid row ids.");return s}calculateOutputIndex(t,r,i,n){const s=this.getRowPartitionTensor(t),o=this.getRowPartitionTypeByDimension(t);switch(o){case e.VALUE_ROWIDS:return this.calculateOutputIndexValueRowID(s,r,i,n);case e.ROW_SPLITS:if(s.length-1>r.length)throw new Error(`Row partition size is greater than output size: ${s.length-1} > ${r.length}`);return this.calculateOutputIndexRowSplit(s,r,i,n);default:throw new Error(`Unsupported partition type: ${e[o]}`)}}getFirstDimensionSize(){const t=this.rowPartitionValues[0];if(0===this.rowPartitionTypes.length)throw new Error("No row_partition_types given.");const r=this.rowPartitionTypes[0];switch(r){case e.FIRST_DIM_SIZE:return t[0];case e.VALUE_ROWIDS:throw new Error("Cannot handle VALUE_ROWIDS in first dimension.");case e.ROW_SPLITS:return this.rowPartitionValuesShapes[0][0]-1;default:throw new Error(`Cannot handle type ${e[r]}`)}}compute(){if(this.rowPartitionValues[0].length<=0)throw new Error("Invalid first partition input. Tensor requires at least one element.");const e=this.getFirstDimensionSize(),r=this.calculateOutputSize(e),i=new Array(this.raggedRank+1);i[i.length-1]=1;for(let t=i.length-2;t>=0;--t)i[t]=i[t+1]*r[t+1];const s=n(r,!1),o=t.util.getArrayFromDType(this.valuesDType,t.util.sizeFromShape(s));if(i[0]*r[0]>0){let t=this.calculateFirstParentOutputIndex(e,i[0],r[0]);for(let e=1;e<=this.raggedRank;++e){t=this.calculateOutputIndex(e-1,t,i[e],r[e])}this.setOutput(this.raggedRank,t,o,s)}return[s,o]}setOutput(e,r,n,s){if(0===n.length)return;const o=this.values,a=n;let l=s.slice();l=l.slice(e+1);const h=t.util.sizeFromShape(l),u=r.length;let p=this.defaultValue;if(p.length!==h&&1!==p.length){const e=this.defaultValueShape;(0,t.tidy)(()=>{const r=(0,t.reshape)(p,e),i=(0,t.broadcastTo)(r,l);p=i.dataSync()})}let c=0,w=0,g=0;for(let t=0;t<=u;++t){let e=t<u?r[t]:-1;if(e!==g){if(w<g){const t=o.subarray(c*h);i(a.subarray(w*h),t,(g-w)*h)}if(t>=u){const t=n.length;e=Math.floor(t/h)}if(e>g)if(1===this.defaultValue.length)a.subarray(g*h,e*h).fill(this.defaultValue[0]),g=e;else for(;e>g;){i(a.slice(g*h),p,h),++g}e<0?(c=t+1,w=g):(c=t,g=(w=g)+1)}else++g}}}function i(t,e,r){for(let i=0;i<r;i++)t[i]=e[i]}function n(t,e){const r=[];for(let i of t){if(i<0){if(!e)throw new Error(`Dimension ${i} must be >= 0`);if(i<-1)throw new Error(`Dimension ${i} must be >= -1`);i=-1}r.push(i)}return r}function s(t,e,i,n,s,o,a,l,h,u){return new r(t,e,i,n,s,o,a,l,h,u).compute()}
},{"@tensorflow/tfjs-core":"kSBl"}],"m7wV":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.rangeImpl=r;var e=require("@tensorflow/tfjs-core");function r(r,t,o,s){if(r===t||r<t&&o<0||t<r&&o>1)return e.util.makeZerosTypedArray(0,s);const a=Math.abs(Math.ceil((t-r)/o)),l=e.util.makeZerosTypedArray(a,s);t<r&&1===o&&(o=-1),l[0]=r;for(let e=1;e<l.length;e++)l[e]=l[e-1]+o;return l}
},{"@tensorflow/tfjs-core":"kSBl"}],"eSbP":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.rsqrtImpl=exports.rsqrtConfig=exports.rsqrt=void 0;var r=require("@tensorflow/tfjs-core"),e=require("../utils/unary_impl"),t=require("../utils/unary_utils");const s=exports.rsqrtImpl=(0,e.createSimpleUnaryImpl)(r=>1/Math.sqrt(r)),o=exports.rsqrt=(0,t.unaryKernelFuncFromImpl)(r.Rsqrt,s),l=exports.rsqrtConfig={kernelName:r.Rsqrt,backendName:"cpu",kernelFunc:o};
},{"@tensorflow/tfjs-core":"kSBl","../utils/unary_impl":"FlCa","../utils/unary_utils":"kZAs"}],"VFSj":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.scatterImpl=t;var e=require("@tensorflow/tfjs-core");function t(t,r,o,s,l,n,f,u,i,a){const c=[s/l,l],p=t.values,v=r.values;if(0===s)return(0,e.buffer)(o,r.dtype);const d=i instanceof e.TensorBuffer?i:(0,e.buffer)(c,r.dtype);"string"==typeof i?d.values.fill(i):"number"==typeof i?d.values.fill(i):"boolean"==typeof i&&d.values.fill(+i);for(let e=0;e<n;e++){const t=[];let n=0;for(let r=0;r<f;r++){const o=p[e*f+r];t.push(o),n+=o*u[r]}if(n<0||n>=s/l)throw new Error(`Invalid indices: ${t} does not index into ${o}`);for(let o=0;o<l;o++)a?d.values[n*l+o]+=v[e*l+o]:d.values[n*l+o]=0===r.rank?v[0]:v[e*l+o]}return d}
},{"@tensorflow/tfjs-core":"kSBl"}],"QVgs":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.sigmoidImpl=exports.sigmoidConfig=exports.sigmoid=void 0;var e=require("@tensorflow/tfjs-core"),i=require("../utils/unary_impl"),r=require("../utils/unary_utils");const o=exports.sigmoidImpl=(0,i.createSimpleUnaryImpl)(e=>1/(1+Math.exp(-e))),s=exports.sigmoid=(0,r.unaryKernelFunc)(e.Sigmoid,e=>1/(1+Math.exp(-e))),t=exports.sigmoidConfig={kernelName:e.Sigmoid,backendName:"cpu",kernelFunc:s};
},{"@tensorflow/tfjs-core":"kSBl","../utils/unary_impl":"FlCa","../utils/unary_utils":"kZAs"}],"i6mc":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.slice=i,exports.sliceConfig=void 0,exports.sliceImpl=s;var e=require("@tensorflow/tfjs-core"),t=require("../cpu_util");function s(t,s,i,r,n){const o=e.slice_util.isSliceContinous(r,s,i),c=e.util.sizeFromShape(i),l=e.util.computeStrides(r);if(o){const i=e.slice_util.computeFlatOffset(s,l);return"string"===n?t.slice(i,i+c):t.subarray(i,i+c)}const a="string"===n?e.backend_util.fromUint8ToStringArray(t):t,u=(0,e.buffer)(r,n,a),p=(0,e.buffer)(i,n);for(let e=0;e<p.size;++e){const t=p.indexToLoc(e),i=t.map((e,t)=>e+s[t]);p.set(u.get(...i),...t)}return"string"===n?e.backend_util.fromStringArrayToUint8(p.values):p.values}function i(i){const{inputs:r,backend:n,attrs:o}=i,{x:c}=r,{begin:l,size:a}=o;(0,t.assertNotComplex)(c,"slice");const[u,p]=e.slice_util.parseSliceParams(c,l,a);e.slice_util.assertParamsValid(c,u,p);const f=s(n.data.get(c.dataId).values,u,p,c.shape,c.dtype);return n.makeTensorInfo(p,c.dtype,f)}const r=exports.sliceConfig={kernelName:e.Slice,backendName:"cpu",kernelFunc:i};
},{"@tensorflow/tfjs-core":"kSBl","../cpu_util":"nVKy"}],"vXdm":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.sparseFillEmptyRowsImpl=e;var r=require("@tensorflow/tfjs-core");function e(e,t,o,l,s,n,i){const a=t[0],f=n[0],c=new Array(f),p=new Array(a),y=t[1];if(0===f){if(0!==a)throw new Error(r.backend_util.getSparseFillEmptyRowsIndicesDenseShapeMismatch(a));return[r.util.getArrayFromDType(o,0),[0,y],r.util.getArrayFromDType(s,0),c,p]}let u=!0,w=0;const g=new Array(f).fill(0);for(let E=0;E<a;++E){const t=e[E*y];if(t<0)throw new Error(r.backend_util.getSparseFillEmptyRowsNegativeIndexErrorMessage(E,t));if(t>=f)throw new Error(r.backend_util.getSparseFillEmptyRowsOutOfRangeIndexErrorMessage(E,t,f));++g[t],u=u&&t>=w,w=t}let m=!0;for(let r=0;r<f;++r){const e=0===g[r];c[r]=e,m=m&&!e,g[r]=Math.max(g[r],1),r>0&&(g[r]+=g[r-1])}if(m&&u){const r=e,t=l;for(let e=0;e<a;++e)p[e]=e;return[r,[a,y],t,c,p]}{const t=g[f-1],n=r.util.getArrayFromDType(o,t*y),u=r.util.getArrayFromDType(s,t),w=new Array(f).fill(0);for(let r=0;r<a;++r){const t=e[r*y],o=w[t],s=(0===t?0:g[t-1])+o;w[t]++;for(let l=0;l<y;++l)n[s*y+l]=e[r*y+l];u[s]=l[r],p[r]=s}for(let r=0;r<f;++r){if(0===w[r]){const e=0===r?0:g[r-1];n[e*y+0]=r;for(let r=1;r<y;++r)n[e*y+r]=0;u[e]=i}}return[n,[t,y],u,c,p]}}
},{"@tensorflow/tfjs-core":"kSBl"}],"LDTS":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.sparseReshapeImpl=r;var e=require("@tensorflow/tfjs-core");function r(r,t,s,o,a){const u=e.util.sizeFromShape(o),i=t[0],p=a.length,n=[];let l=1,h=-1;for(let E=0;E<p;++E){const r=a[E];if(-1===r){if(-1!==h)throw new Error(e.backend_util.getSparseReshapeMultipleNegativeOneOutputDimErrorMessage(h,E));h=E,n.push(1)}else{if(r<0)throw new Error(e.backend_util.getSparseReshapeNegativeOutputDimErrorMessage(E,r));l*=r,n.push(r)}}if(-1!==h){if(l<=0)throw new Error(e.backend_util.getSparseReshapeEmptyTensorZeroOutputDimErrorMessage());const r=Math.trunc(u/l);if(l*r!==u)throw new Error(e.backend_util.getSparseReshapeInputOutputMultipleErrorMessage(o,n));n[h]=r}if(e.util.sizeFromShape(n)!==u)throw new Error(e.backend_util.getSparseReshapeInputOutputMismatchErrorMessage(o,n));const f=o.length,c=[];if(f>0){c[f-1]=1;for(let e=f-2;e>=0;--e)c[e]=c[e+1]*o[e+1]}const g=[];if(p>0){g[p-1]=1;for(let e=p-2;e>=0;--e)g[e]=g[e+1]*n[e+1]}const w=e.util.getArrayFromDType(s,i*p);for(let e=0;e<i;++e){let t=0;for(let s=0;s<f;++s)t+=r[e*f+s]*c[s];for(let r=0;r<p;++r)w[e*p+r]=Math.trunc(t/g[r]),t%=g[r]}return[w,[i,p],n]}
},{"@tensorflow/tfjs-core":"kSBl"}],"XhXa":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.sparseSegmentReductionImpl=r;var e=require("@tensorflow/tfjs-core");function r(r,t,n,o,i,s=!1,g=0){const a=o.length,c=[t[0],r.length/t[0]],l=c[1],f=a>0?i[a-1]+1:0;if(f<0)throw new Error(e.backend_util.getSparseSegmentReductionNegativeSegmentIdsErrorMessage());const u=t.slice();u[0]=f;const d=u.reduce((e,r)=>e*r,1),S=e.util.getArrayFromDType(n,d);if(0===a)return f>0&&S.fill(g),[S,u];if(f<=0)throw new Error(e.backend_util.getSparseSegmentReductionNegativeSegmentIdsErrorMessage());let m=0,p=1,w=0,E=i[m];for(;;){let t=0;if(p<a){if(E===(t=i[p])){++p;continue}if(E>=t)throw new Error(e.backend_util.getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage())}if(E<0||E>=f)throw new Error(e.backend_util.getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage(E,f));E>w&&S.fill(g,w*l,E*l);for(let n=m;n<p;++n){const t=o[n];if(t<0||t>=c[0])throw new Error(e.backend_util.getSparseSegmentReductionIndicesOutOfRangeErrorMessage(n,o[n],c[0]));for(let e=0;e<l;e++)S[E*l+e]+=r[t*l+e]}if(s)for(let e=0;e<l;e++)S[E*l+e]/=p-m;if(m=p,w=E+1,E=t,++p>a)break}return w<f&&S.fill(g,w*l,f*l),[S,u]}
},{"@tensorflow/tfjs-core":"kSBl"}],"YdSx":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.sqrtImpl=exports.sqrtConfig=exports.sqrt=void 0;var r=require("@tensorflow/tfjs-core"),e=require("../utils/unary_impl"),t=require("../utils/unary_utils");const s=exports.sqrtImpl=(0,e.createSimpleUnaryImpl)(r=>Math.sqrt(r)),o=exports.sqrt=(0,t.unaryKernelFunc)(r.Sqrt,r=>Math.sqrt(r)),n=exports.sqrtConfig={kernelName:r.Sqrt,backendName:"cpu",kernelFunc:o};
},{"@tensorflow/tfjs-core":"kSBl","../utils/unary_impl":"FlCa","../utils/unary_utils":"kZAs"}],"p6Qg":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.squaredDifferenceImpl=exports.squaredDifferenceConfig=exports.squaredDifference=void 0;var e=require("@tensorflow/tfjs-core"),r=require("../utils/binary_impl"),n=require("../utils/binary_utils");const i=exports.squaredDifferenceImpl=(0,r.createSimpleBinaryKernelImpl)((e,r)=>{const n=e-r;return n*n}),s=exports.squaredDifference=(0,n.binaryKernelFunc)(e.SquaredDifference,i),f=exports.squaredDifferenceConfig={kernelName:e.SquaredDifference,backendName:"cpu",kernelFunc:s};
},{"@tensorflow/tfjs-core":"kSBl","../utils/binary_impl":"v0i6","../utils/binary_utils":"FLbP"}],"ENGS":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.staticRegexReplaceImpl=exports.staticRegexReplaceConfig=void 0;var e=require("@tensorflow/tfjs-core"),r=require("../utils/unary_impl"),t=require("../utils/unary_utils");const a=exports.staticRegexReplaceImpl=(0,r.createSimpleUnaryImpl)((e,r)=>{const{pattern:t,replaceGlobal:a,rewrite:l}=r;return e.replace(new RegExp(t,a?"g":""),l)}),l=(0,t.unaryKernelFuncFromImpl)(e.StaticRegexReplace,a),c=exports.staticRegexReplaceConfig={kernelName:e.StaticRegexReplace,backendName:"cpu",kernelFunc:l};
},{"@tensorflow/tfjs-core":"kSBl","../utils/unary_impl":"FlCa","../utils/unary_utils":"kZAs"}],"Jc0Z":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.stridedSliceImpl=t;var e=require("@tensorflow/tfjs-core");function t(t,r,o,s){const n=(0,e.buffer)(t,r.dtype);for(let e=0;e<n.size;e++){const t=n.indexToLoc(e),l=new Array(t.length);for(let e=0;e<l.length;e++)l[e]=t[e]*o[e]+s[e];n.set(r.get(...l),...t)}return n}
},{"@tensorflow/tfjs-core":"kSBl"}],"CMu9":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.stringNGramsImpl=r;var t=require("@tensorflow/tfjs-core");class e{constructor(e,r,s,i,a,h){this.separator=t.util.encodeString(e),this.nGramWidths=r,this.leftPad=t.util.encodeString(s),this.rightPad=t.util.encodeString(i),this.padWidth=a,this.preserveShort=h}getPadWidth(t){return Math.min(this.padWidth<0?t-1:this.padWidth,t-1)}getNumNGrams(t,e){const r=this.getPadWidth(e);return Math.max(0,t+2*r-e+1)}createNGrams(t,e,r,s,i,a){for(let h=0;h<i;++h){const o=this.getPadWidth(a),n=Math.max(0,o-h),l=Math.max(0,o-(i-(h+1))),c=a-(n+l),d=e+(n>0?0:h-o);let f=0;f+=n*this.leftPad.length;for(let e=0;e<c;++e)f+=t[d+e].length;f+=l*this.rightPad.length,f+=(n+l+c-1)*this.separator.length,r[s+h]=new Uint8Array(f);const u=r[s+h];let g=0;const m=t=>t.forEach(t=>u[g++]=t);for(let t=0;t<n;++t)m(this.leftPad),m(this.separator);for(let e=0;e<c-1;++e)m(t[d+e]),m(this.separator);if(c>0){m(t[d+c-1]);for(let t=0;t<l;++t)m(this.separator),m(this.rightPad)}else{for(let t=0;t<l-1;++t)m(this.rightPad),m(this.separator);m(this.rightPad)}}}compute(e,r){const s=e.length,i=r.length;if(i>0){let t=r[0];if(0!==t)throw new Error(`First split value must be 0, got ${t}`);for(let e=1;e<i;++e){let i=r[e]>=t;if(!(i=i&&r[e]<=s))throw new Error(`Invalid split value ${r[e]}, must be in [${t}, ${s}]`);t=r[e]}if(t!==s)throw new Error(`Last split value must be data size. Expected ${s}, got ${t}`)}const a=i-1,h=t.util.getArrayFromDType("int32",i);if(0===s||0===i){const t=new Array(s);for(let e=0;e<=a;++e)h[e]=0;return[t,h]}h[0]=0;for(let t=1;t<=a;++t){const e=r[t]-r[t-1];let s=0;this.nGramWidths.forEach(t=>{s+=this.getNumNGrams(e,t)}),this.preserveShort&&e>0&&0===s&&(s=1),h[t]=h[t-1]+s}const o=new Array(h[a]);for(let t=0;t<a;++t){const s=r[t];let i=h[t];if(this.nGramWidths.forEach(a=>{const h=r[t+1]-r[t],n=this.getNumNGrams(h,a);this.createNGrams(e,s,o,i,n,a),i+=n}),this.preserveShort&&i===h[t]){const a=r[t+1]-r[t];if(0===a)continue;const h=a+2*this.padWidth,n=1;this.createNGrams(e,s,o,i,n,h)}}return[o,h]}}function r(t,r,s,i,a,h,o,n){return new e(s,i,a,h,o,n).compute(t,r)}
},{"@tensorflow/tfjs-core":"kSBl"}],"opA2":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.stringSplitImpl=r;var t=require("@tensorflow/tfjs-core");function e(t,e,r,n){if(!t.length)return;if(0===e.length){for(let e=0;e<t.length;++e)n.push(t.subarray(e,e+1));return}if(1===e.length){const l=e[0];let o=t.indexOf(l);for(;-1!==o;){const e=t.subarray(0,o);r&&0===e.length||n.push(e),o=(t=t.subarray(o+1)).indexOf(l)}return void(r&&0===t.length||n.push(t))}let l=0;for(let o=0;o<t.length+1;o++)if(o===t.length||-1!==e.indexOf(t[o])){const e=t.subarray(l,o);r&&0===e.length||n.push(e),l=o+1}}function r(r,n,l){const o=r.length,s=[];let u=0,f=0;const h=new Array(o);for(let t=0;t<o;++t){const o=s.length;e(r[t],n,l,s);const i=s.length-o;h[t]=i,u+=i,f=Math.max(f,i)}const i=t.util.getArrayFromDType("int32",2*u),a=new Array(u),g=[o,f];let c=0;for(let t=0;t<o;++t)for(let e=0;e<h[t];++e)i[2*c]=t,i[2*c+1]=e,a[c]=s[c],++c;return[i,a,g]}
},{"@tensorflow/tfjs-core":"kSBl"}],"KvpR":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.stringToHashBucketFastImpl=t;var e=require("@tensorflow/tfjs-core");function t(t,r){const o=e.util.getArrayFromDType("int32",t.length);for(let n=0;n<t.length;++n)o[n]=e.util.fingerPrint64(t[n]).modulo(r).getLowBitsUnsigned();return o}
},{"@tensorflow/tfjs-core":"kSBl"}],"fBFg":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.subImpl=exports.subConfig=exports.subComplexImpl=exports.sub=void 0;var e=require("@tensorflow/tfjs-core"),r=require("../utils/binary_impl"),s=require("../utils/binary_utils");const l=exports.subImpl=(0,r.createSimpleBinaryKernelImpl)((e,r)=>e-r),p=exports.subComplexImpl=(0,s.createComplexBinaryKernelImpl)((e,r,s,l)=>({real:e-s,imag:r-l})),u=exports.sub=(0,s.binaryKernelFunc)(e.Sub,l,p),o=exports.subConfig={kernelName:e.Sub,backendName:"cpu",kernelFunc:u};
},{"@tensorflow/tfjs-core":"kSBl","../utils/binary_impl":"v0i6","../utils/binary_utils":"FLbP"}],"W9Ei":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.tileImpl=r;var e=require("@tensorflow/tfjs-core");function r(r,t){const o=new Array(r.rank);for(let e=0;e<o.length;e++)o[e]=r.shape[e]*t[e];const n=(0,e.buffer)(o,r.dtype);for(let e=0;e<n.values.length;++e){const t=n.indexToLoc(e),o=new Array(r.rank);for(let e=0;e<o.length;e++)o[e]=t[e]%r.shape[e];const s=r.locToIndex(o);n.values[e]=r.values[s]}return n}
},{"@tensorflow/tfjs-core":"kSBl"}],"iXMz":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.topKImpl=o;var t=require("@tensorflow/tfjs-core");const e=(t,e)=>{const r=e.value-t.value;return 0===r?t.index-e.index:r};function r(o,n,a=0,l=o.length-1){for(;l>a;){if(l-a>600){const t=l-a+1,e=n-a+1,s=Math.log(t),u=.5*Math.exp(2*s/3),i=.5*Math.sqrt(s*u*(t-u)/t)*Math.sign(e-t/2);r(o,n,Math.max(a,Math.floor(n-e*u/t+i)),Math.min(l,Math.floor(n+(t-e)*u/t+i)))}const s=o[n];let u=a,i=l;for(t.util.swap(o,a,n),e(o[l],s)>0&&t.util.swap(o,a,l);u<i;){for(t.util.swap(o,u,i),u++,i--;e(o[u],s)<0;)u+=1;for(;e(o[i],s)>0;)i-=1}0===e(o[a],s)?t.util.swap(o,a,i):(i+=1,t.util.swap(o,i,l)),i<=n&&(a=i+1),n<=i&&(l=i-1)}}function o(o,n,a,l,s){const u=n[n.length-1],[i,f]=[o.length/u,u],c=t.util.getTypedArrayFromDType(a,i*l),h=t.util.getTypedArrayFromDType("int32",i*l);for(let t=0;t<i;t++){const n=t*f,a=o.subarray(n,n+f);let u=new Array(a.length);a.forEach((t,e)=>u[e]={value:t,index:e}),l<u.length&&(r(u,l),u=u.slice(0,l)),s&&u.sort(e);const i=t*l,p=c.subarray(i,i+l),y=h.subarray(i,i+l);for(let t=0;t<l;t++)p[t]=u[t].value,y[t]=u[t].index}const p=n.slice();return p[p.length-1]=l,[(0,t.buffer)(p,a,c),(0,t.buffer)(p,"int32",h)]}
},{"@tensorflow/tfjs-core":"kSBl"}],"hHdG":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.uniqueImpl=t;var e=require("@tensorflow/tfjs-core");function t(t,s,o,r){const n=e.util.parseAxisParam(s,o)[0],l=[1,o[0],1];for(let e=0;e<n;e++)l[0]*=o[e];l[1]=o[n];for(let e=n+1;e<o.length;e++)l[2]*=o[e];const u=new Map,f=new Int32Array(o[n]),i=new e.TensorBuffer(l,r,t),c=[],a=1===l[0]&&1===l[2];for(let e=0;e<o[n];e++){let s;if(a)s=t[e].toString();else{const t=[];for(let s=0;s<l[0];s++)for(let o=0;o<l[2];o++)t.push(i.get(s,e,o));s=t.join(",")}const o=u.get(s);if(null!=o)f[e]=o;else{const t=u.size;u.set(s,t),f[e]=t,c.push(e)}}const p=l.slice();p[1]=u.size;const g=new e.TensorBuffer(p,r);c.forEach((e,t)=>{for(let s=0;s<l[0];s++)for(let o=0;o<l[2];o++)g.set(i.get(s,e,o),s,t,o)});const h=o.slice();return h[n]=p[1],{outputValues:g.values,outputShape:h,indices:f}}
},{"@tensorflow/tfjs-core":"kSBl"}],"AxIp":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),Object.defineProperty(exports,"addImpl",{enumerable:!0,get:function(){return r.addImpl}}),Object.defineProperty(exports,"bincountImpl",{enumerable:!0,get:function(){return t.bincountImpl}}),Object.defineProperty(exports,"bincountReduceImpl",{enumerable:!0,get:function(){return t.bincountReduceImpl}}),Object.defineProperty(exports,"bitwiseAndImpl",{enumerable:!0,get:function(){return n.bitwiseAndImpl}}),Object.defineProperty(exports,"castImpl",{enumerable:!0,get:function(){return l.castImpl}}),Object.defineProperty(exports,"ceilImpl",{enumerable:!0,get:function(){return p.ceilImpl}}),Object.defineProperty(exports,"concatImpl",{enumerable:!0,get:function(){return i.concatImpl}}),Object.defineProperty(exports,"equalImpl",{enumerable:!0,get:function(){return u.equalImpl}}),Object.defineProperty(exports,"expImpl",{enumerable:!0,get:function(){return m.expImpl}}),Object.defineProperty(exports,"expm1Impl",{enumerable:!0,get:function(){return o.expm1Impl}}),Object.defineProperty(exports,"floorDivImpl",{enumerable:!0,get:function(){return a.floorDivImpl}}),Object.defineProperty(exports,"floorImpl",{enumerable:!0,get:function(){return s.floorImpl}}),Object.defineProperty(exports,"gatherNdImpl",{enumerable:!0,get:function(){return c.gatherNdImpl}}),Object.defineProperty(exports,"gatherV2Impl",{enumerable:!0,get:function(){return b.gatherV2Impl}}),Object.defineProperty(exports,"greaterEqualImpl",{enumerable:!0,get:function(){return g.greaterEqualImpl}}),Object.defineProperty(exports,"greaterImpl",{enumerable:!0,get:function(){return f.greaterImpl}}),Object.defineProperty(exports,"lessEqualImpl",{enumerable:!0,get:function(){return d.lessEqualImpl}}),Object.defineProperty(exports,"lessImpl",{enumerable:!0,get:function(){return I.lessImpl}}),Object.defineProperty(exports,"linSpaceImpl",{enumerable:!0,get:function(){return q.linSpaceImpl}}),Object.defineProperty(exports,"logImpl",{enumerable:!0,get:function(){return x.logImpl}}),Object.defineProperty(exports,"maxImpl",{enumerable:!0,get:function(){return y.maxImpl}}),Object.defineProperty(exports,"maximumImpl",{enumerable:!0,get:function(){return k.maximumImpl}}),Object.defineProperty(exports,"minimumImpl",{enumerable:!0,get:function(){return P.minimumImpl}}),Object.defineProperty(exports,"multiplyImpl",{enumerable:!0,get:function(){return j.multiplyImpl}}),Object.defineProperty(exports,"negImpl",{enumerable:!0,get:function(){return O.negImpl}}),Object.defineProperty(exports,"notEqualImpl",{enumerable:!0,get:function(){return S.notEqualImpl}}),Object.defineProperty(exports,"prodImpl",{enumerable:!0,get:function(){return R.prodImpl}}),Object.defineProperty(exports,"raggedGatherImpl",{enumerable:!0,get:function(){return _.raggedGatherImpl}}),Object.defineProperty(exports,"raggedRangeImpl",{enumerable:!0,get:function(){return h.raggedRangeImpl}}),Object.defineProperty(exports,"raggedTensorToTensorImpl",{enumerable:!0,get:function(){return E.raggedTensorToTensorImpl}}),Object.defineProperty(exports,"rangeImpl",{enumerable:!0,get:function(){return T.rangeImpl}}),Object.defineProperty(exports,"rsqrtImpl",{enumerable:!0,get:function(){return G.rsqrtImpl}}),Object.defineProperty(exports,"scatterImpl",{enumerable:!0,get:function(){return F.scatterImpl}}),Object.defineProperty(exports,"sigmoidImpl",{enumerable:!0,get:function(){return N.sigmoidImpl}}),Object.defineProperty(exports,"simpleAbsImpl",{enumerable:!0,get:function(){return e.simpleAbsImpl}}),Object.defineProperty(exports,"sliceImpl",{enumerable:!0,get:function(){return A.sliceImpl}}),Object.defineProperty(exports,"sparseFillEmptyRowsImpl",{enumerable:!0,get:function(){return w.sparseFillEmptyRowsImpl}}),Object.defineProperty(exports,"sparseReshapeImpl",{enumerable:!0,get:function(){return D.sparseReshapeImpl}}),Object.defineProperty(exports,"sparseSegmentReductionImpl",{enumerable:!0,get:function(){return v.sparseSegmentReductionImpl}}),Object.defineProperty(exports,"sqrtImpl",{enumerable:!0,get:function(){return B.sqrtImpl}}),Object.defineProperty(exports,"squaredDifferenceImpl",{enumerable:!0,get:function(){return M.squaredDifferenceImpl}}),Object.defineProperty(exports,"staticRegexReplaceImpl",{enumerable:!0,get:function(){return L.staticRegexReplaceImpl}}),Object.defineProperty(exports,"stridedSliceImpl",{enumerable:!0,get:function(){return C.stridedSliceImpl}}),Object.defineProperty(exports,"stringNGramsImpl",{enumerable:!0,get:function(){return H.stringNGramsImpl}}),Object.defineProperty(exports,"stringSplitImpl",{enumerable:!0,get:function(){return K.stringSplitImpl}}),Object.defineProperty(exports,"stringToHashBucketFastImpl",{enumerable:!0,get:function(){return V.stringToHashBucketFastImpl}}),Object.defineProperty(exports,"subImpl",{enumerable:!0,get:function(){return U.subImpl}}),Object.defineProperty(exports,"tileImpl",{enumerable:!0,get:function(){return z.tileImpl}}),Object.defineProperty(exports,"topKImpl",{enumerable:!0,get:function(){return J.topKImpl}}),Object.defineProperty(exports,"transposeImpl",{enumerable:!0,get:function(){return Q.transposeImpl}}),Object.defineProperty(exports,"uniqueImpl",{enumerable:!0,get:function(){return W.uniqueImpl}});var e=require("./kernels/Abs"),r=require("./kernels/Add"),t=require("./kernels/Bincount_impl"),n=require("./kernels/BitwiseAnd"),l=require("./kernels/Cast"),p=require("./kernels/Ceil"),i=require("./kernels/Concat_impl"),u=require("./kernels/Equal"),m=require("./kernels/Exp"),o=require("./kernels/Expm1"),s=require("./kernels/Floor"),a=require("./kernels/FloorDiv"),c=require("./kernels/GatherNd_Impl"),b=require("./kernels/GatherV2_impl"),f=require("./kernels/Greater"),g=require("./kernels/GreaterEqual"),I=require("./kernels/Less"),d=require("./kernels/LessEqual"),q=require("./kernels/LinSpace_impl"),x=require("./kernels/Log"),y=require("./kernels/Max_impl"),k=require("./kernels/Maximum"),P=require("./kernels/Minimum"),j=require("./kernels/Multiply"),O=require("./kernels/Neg"),S=require("./kernels/NotEqual"),R=require("./kernels/Prod"),_=require("./kernels/RaggedGather_impl"),h=require("./kernels/RaggedRange_impl"),E=require("./kernels/RaggedTensorToTensor_impl"),T=require("./kernels/Range_impl"),G=require("./kernels/Rsqrt"),F=require("./kernels/Scatter_impl"),N=require("./kernels/Sigmoid"),A=require("./kernels/Slice"),w=require("./kernels/SparseFillEmptyRows_impl"),D=require("./kernels/SparseReshape_impl"),v=require("./kernels/SparseSegmentReduction_impl"),B=require("./kernels/Sqrt"),M=require("./kernels/SquaredDifference"),L=require("./kernels/StaticRegexReplace"),C=require("./kernels/StridedSlice_impl"),H=require("./kernels/StringNGrams_impl"),K=require("./kernels/StringSplit_impl"),V=require("./kernels/StringToHashBucketFast_impl"),U=require("./kernels/Sub"),z=require("./kernels/Tile_impl"),J=require("./kernels/TopK_impl"),Q=require("./kernels/Transpose_impl"),W=require("./kernels/Unique_impl");
},{"./kernels/Abs":"WHC3","./kernels/Add":"ZBkJ","./kernels/Bincount_impl":"cUUF","./kernels/BitwiseAnd":"PuG8","./kernels/Cast":"Bp6G","./kernels/Ceil":"PT9Z","./kernels/Concat_impl":"axei","./kernels/Equal":"Qy3m","./kernels/Exp":"Q92g","./kernels/Expm1":"wiHC","./kernels/Floor":"KFD4","./kernels/FloorDiv":"JeKf","./kernels/GatherNd_Impl":"kXTU","./kernels/GatherV2_impl":"Ea37","./kernels/Greater":"QWdt","./kernels/GreaterEqual":"gfwn","./kernels/Less":"x95l","./kernels/LessEqual":"N5Qh","./kernels/LinSpace_impl":"BmUg","./kernels/Log":"ipxn","./kernels/Max_impl":"Db4x","./kernels/Maximum":"DbCK","./kernels/Minimum":"pZXl","./kernels/Multiply":"N9Eb","./kernels/Neg":"NnAL","./kernels/NotEqual":"VkjO","./kernels/Prod":"us0k","./kernels/RaggedGather_impl":"mwpO","./kernels/RaggedRange_impl":"Xl6V","./kernels/RaggedTensorToTensor_impl":"H940","./kernels/Range_impl":"m7wV","./kernels/Rsqrt":"eSbP","./kernels/Scatter_impl":"VFSj","./kernels/Sigmoid":"QVgs","./kernels/Slice":"i6mc","./kernels/SparseFillEmptyRows_impl":"vXdm","./kernels/SparseReshape_impl":"LDTS","./kernels/SparseSegmentReduction_impl":"XhXa","./kernels/Sqrt":"YdSx","./kernels/SquaredDifference":"p6Qg","./kernels/StaticRegexReplace":"ENGS","./kernels/StridedSlice_impl":"Jc0Z","./kernels/StringNGrams_impl":"CMu9","./kernels/StringSplit_impl":"opA2","./kernels/StringToHashBucketFast_impl":"KvpR","./kernels/Sub":"fBFg","./kernels/Tile_impl":"W9Ei","./kernels/TopK_impl":"iXMz","./kernels/Transpose_impl":"fDvd","./kernels/Unique_impl":"hHdG"}],"Y42A":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),Object.defineProperty(exports,"MathBackendCPU",{enumerable:!0,get:function(){return r.MathBackendCPU}}),exports.shared=void 0,Object.defineProperty(exports,"version_cpu",{enumerable:!0,get:function(){return n.version}});var e=require("@tensorflow/tfjs-core"),r=require("./backend_cpu"),t=o(require("./shared"));exports.shared=t;var n=require("./version");function o(e,r){if("function"==typeof WeakMap)var t=new WeakMap,n=new WeakMap;return(o=function(e,r){if(!r&&e&&e.__esModule)return e;var o,u,a={__proto__:null,default:e};if(null===e||"object"!=typeof e&&"function"!=typeof e)return a;if(o=r?n:t){if(o.has(e))return o.get(e);o.set(e,a)}for(const t in e)"default"!==t&&{}.hasOwnProperty.call(e,t)&&((u=(o=Object.defineProperty)&&Object.getOwnPropertyDescriptor(e,t))&&(u.get||u.set)?o(a,t,u):a[t]=e[t]);return a})(e,r)}(0,e.registerBackend)("cpu",()=>new r.MathBackendCPU,1);
},{"@tensorflow/tfjs-core":"kSBl","./backend_cpu":"hTsf","./shared":"AxIp","./version":"KPnh"}],"DCCw":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.eluConfig=exports.elu=void 0;var e=require("@tensorflow/tfjs-core"),r=require("../utils/unary_utils");const u=exports.elu=(0,r.unaryKernelFunc)(e.Elu,e=>e>=0?e:Math.exp(e)-1),t=exports.eluConfig={kernelName:e.Elu,backendName:"cpu",kernelFunc:u};
},{"@tensorflow/tfjs-core":"kSBl","../utils/unary_utils":"kZAs"}],"vnsb":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.leakyRelu=a,exports.leakyReluConfig=void 0;var e=require("@tensorflow/tfjs-core"),t=require("../cpu_util");function a(a){const{inputs:r,backend:o,attrs:l}=a,{x:s}=r,{alpha:u}=l;(0,t.assertNotComplex)([s],"leakyRelu");const n=e.util.sizeFromShape(s.shape),p=o.data.get(s.dataId).values,i=e.util.getTypedArrayFromDType("float32",n);for(let e=0;e<p.length;e++)i[e]=p[e]<0?u*p[e]:p[e];return o.makeTensorInfo(s.shape,"float32",i)}const r=exports.leakyReluConfig={kernelName:e.LeakyRelu,backendName:"cpu",kernelFunc:a};
},{"@tensorflow/tfjs-core":"kSBl","../cpu_util":"nVKy"}],"YsQM":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.prelu=o,exports.preluConfig=void 0;var e=require("@tensorflow/tfjs-core"),r=require("../cpu_util"),t=require("../utils/binary_impl");const a=(0,t.createSimpleBinaryKernelImpl)((e,r)=>e<0?r*e:e);function o(e){const{inputs:t,backend:o}=e,{x:l,alpha:n}=t;(0,r.assertNotComplex)([l,n],"prelu");const s=o.data.get(l.dataId).values,u=o.data.get(n.dataId).values,[p,i]=a(l.shape,n.shape,s,u,"float32");return o.makeTensorInfo(i,"float32",p)}const l=exports.preluConfig={kernelName:e.Prelu,backendName:"cpu",kernelFunc:o};
},{"@tensorflow/tfjs-core":"kSBl","../cpu_util":"nVKy","../utils/binary_impl":"v0i6"}],"MWuD":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.reluConfig=exports.relu=void 0;var e=require("@tensorflow/tfjs-core"),r=require("../utils/unary_utils");const u=exports.relu=(0,r.unaryKernelFunc)(e.Relu,e=>Math.max(0,e)),t=exports.reluConfig={kernelName:e.Relu,backendName:"cpu",kernelFunc:u};
},{"@tensorflow/tfjs-core":"kSBl","../utils/unary_utils":"kZAs"}],"rFRZ":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.relu6Config=exports.relu6=void 0;var e=require("@tensorflow/tfjs-core"),r=require("../utils/unary_utils");const u=exports.relu6=(0,r.unaryKernelFunc)(e.Relu6,e=>Math.min(Math.max(0,e),6)),t=exports.relu6Config={kernelName:e.Relu6,backendName:"cpu",kernelFunc:u};
},{"@tensorflow/tfjs-core":"kSBl","../utils/unary_utils":"kZAs"}],"x15i":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.applyActivation=a;var e=require("../kernels/Elu"),r=require("../kernels/Identity"),n=require("../kernels/LeakyRelu"),u=require("../kernels/Prelu"),i=require("../kernels/Relu"),t=require("../kernels/Relu6"),l=require("../kernels/Sigmoid");function a(a,s,k,p,d){if("linear"===k)return(0,r.identity)({inputs:{x:s},backend:a});if("relu"===k)return(0,i.relu)({inputs:{x:s},backend:a});if("elu"===k)return(0,e.elu)({inputs:{x:s},backend:a});if("relu6"===k)return(0,t.relu6)({inputs:{x:s},backend:a});if("prelu"===k)return(0,u.prelu)({inputs:{x:s,alpha:p},backend:a});if("leakyrelu"===k)return(0,n.leakyRelu)({inputs:{x:s},backend:a,attrs:{alpha:d}});if("sigmoid"===k)return(0,l.sigmoid)({inputs:{x:s},backend:a});throw new Error(`Activation ${k} has not been implemented for the CPU backend.`)}
},{"../kernels/Elu":"DCCw","../kernels/Identity":"nMAE","../kernels/LeakyRelu":"vnsb","../kernels/Prelu":"YsQM","../kernels/Relu":"MWuD","../kernels/Relu6":"rFRZ","../kernels/Sigmoid":"QVgs"}],"FjS7":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.reshape=s,exports.reshapeConfig=void 0;var e=require("@tensorflow/tfjs-core");function s(s){const{inputs:a,backend:t,attrs:n}=s,{x:o}=a,{shape:p}=n,r=e.util.sizeFromShape(o.shape),h=e.util.inferFromImplicitShape(p,r),l=e.util.sizeFromShape(h);e.util.assert(r===l,()=>`The new shape (${h}) has ${l} elements and the old `+`shape (${o.shape}) has ${r} elements. The new shape and old `+"shape must have the same number of elements."),t.incRef(o.dataId);const d=t.data.get(o.dataId);if(null!=d.complexTensorInfos){const e=d.complexTensorInfos.real,s=d.complexTensorInfos.imag;e.shape=h,s.shape=h}return{dataId:o.dataId,shape:h,dtype:o.dtype}}const a=exports.reshapeConfig={kernelName:e.Reshape,backendName:"cpu",kernelFunc:s};
},{"@tensorflow/tfjs-core":"kSBl"}],"xlhc":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.batchMatMul=t,exports.batchMatMulConfig=void 0;var e=require("@tensorflow/tfjs-core"),s=require("../cpu_util"),a=require("./Reshape");function t(t){const{inputs:r,backend:p,attrs:o}=t,{a:n,b:h}=r,{transposeA:i,transposeB:l}=o;(0,s.assertNotComplex)([n,h],"matMul");const c=n.shape.length,u=h.shape.length,d=i?n.shape[c-2]:n.shape[c-1],f=l?h.shape[u-1]:h.shape[u-2],m=i?n.shape[c-1]:n.shape[c-2],M=l?h.shape[u-2]:h.shape[u-1],b=n.shape.slice(0,-2),k=h.shape.slice(0,-2),x=e.util.sizeFromShape(b),v=e.util.sizeFromShape(k),I=e.broadcast_util.assertAndGetBroadcastShape(n.shape.slice(0,-2),h.shape.slice(0,-2)).concat([m,M]);e.util.assert(d===f,()=>`Error in matMul: inner shapes (${d}) and (`+`${f}) of Tensors with shapes ${n.shape} and `+`${h.shape} and transposeA=${i}`+` and transposeB=${l} must match.`);const g=i?[x,d,m]:[x,m,d],S=l?[v,M,f]:[v,f,M],$=(0,a.reshape)({inputs:{x:n},backend:p,attrs:{shape:g}}),B=(0,a.reshape)({inputs:{x:h},backend:p,attrs:{shape:S}}),T=i?$.shape[1]:$.shape[2],_=i?$.shape[2]:$.shape[1],q=l?B.shape[1]:B.shape[2],y=Math.max(x,v),z=p.data.get($.dataId).values,A=p.data.get(B.dataId).values,C=e.util.computeStrides($.shape),F=e.util.computeStrides(B.shape),[N,j,w]=i?[C[0],1,C[1]]:[C[0],C[1],1],[E,G,O]=l?[1,F[1],F[0]]:[F[1],1,F[0]],P=_*q,R=(0,e.buffer)([y,_,q],$.dtype),D=R.values,H=p.blockSize;for(let e=0;e<y;e++){const s=e%x,a=e%v;for(let t=0;t<_;t+=H){const r=Math.min(t+H,_);for(let p=0;p<q;p+=H){const o=Math.min(p+H,q);for(let n=0;n<T;n+=H){const h=Math.min(n+H,T);for(let i=t;i<r;i++)for(let t=p;t<o;t++){let r=0;for(let e=n;e<h;e++){r+=z[s*N+i*j+e*w]*A[e*E+t*G+a*O]}D[e*P+(i*q+t)]+=r}}}}}return p.disposeIntermediateTensorInfo($),p.disposeIntermediateTensorInfo(B),p.makeTensorInfo(I,R.dtype,R.values)}const r=exports.batchMatMulConfig={kernelName:e.BatchMatMul,backendName:"cpu",kernelFunc:t};
},{"@tensorflow/tfjs-core":"kSBl","../cpu_util":"nVKy","./Reshape":"FjS7"}],"scv7":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports._fusedMatMul=r,exports._fusedMatMulConfig=void 0;var e=require("@tensorflow/tfjs-core"),t=require("../utils/fused_utils"),s=require("./Add"),a=require("./BatchMatMul");function r(e){const{inputs:r,backend:n,attrs:u}=e,{a:o,b:i,bias:p,preluActivationWeights:c}=r,{transposeA:l,transposeB:d,activation:f,leakyreluAlpha:M}=u;let b,k,_;const h=[];b=(0,a.batchMatMul)({inputs:{a:o,b:i},attrs:{transposeA:l,transposeB:d},backend:n}),p&&(k=(0,s.add)({inputs:{a:b,b:p},backend:n}),h.push(b),b=k),f&&(_=(0,t.applyActivation)(n,b,f,c,M),h.push(b),b=_);for(const t of h)n.disposeIntermediateTensorInfo(t);return b}const n=exports._fusedMatMulConfig={kernelName:e._FusedMatMul,backendName:"cpu",kernelFunc:r};
},{"@tensorflow/tfjs-core":"kSBl","../utils/fused_utils":"x15i","./Add":"ZBkJ","./BatchMatMul":"xlhc"}],"gpS6":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.acosConfig=exports.acos=void 0;var e=require("@tensorflow/tfjs-core"),o=require("../utils/unary_utils");const r=exports.acos=(0,o.unaryKernelFunc)(e.Acos,e=>Math.acos(e)),s=exports.acosConfig={kernelName:e.Acos,backendName:"cpu",kernelFunc:r};
},{"@tensorflow/tfjs-core":"kSBl","../utils/unary_utils":"kZAs"}],"evAw":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.acoshConfig=exports.acosh=void 0;var e=require("@tensorflow/tfjs-core"),o=require("../utils/unary_utils");const r=exports.acosh=(0,o.unaryKernelFunc)(e.Acosh,e=>Math.acosh(e)),s=exports.acoshConfig={kernelName:e.Acosh,backendName:"cpu",kernelFunc:r};
},{"@tensorflow/tfjs-core":"kSBl","../utils/unary_utils":"kZAs"}],"caIF":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.addN=o,exports.addNConfig=void 0;var e=require("@tensorflow/tfjs-core"),t=require("../cpu_util");function o(o){const{inputs:r,backend:a}=o,s=r;(0,t.assertNotComplex)(r,"addN");const n=s.map(e=>a.data.get(e.dataId).values),d=(0,e.buffer)(s[0].shape,s[0].dtype),u=d.values;for(let e=0;e<s.length;e++){const t=n[e];for(let e=0;e<u.length;e++)u[e]+=t[e]}return a.makeTensorInfo(d.shape,d.dtype,d.values)}const r=exports.addNConfig={kernelName:e.AddN,backendName:"cpu",kernelFunc:o};
},{"@tensorflow/tfjs-core":"kSBl","../cpu_util":"nVKy"}],"wcw0":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.all=a,exports.allConfig=void 0;var e=require("@tensorflow/tfjs-core"),t=require("../cpu_util"),s=require("./Reshape"),n=require("./Transpose");function a(a){const{inputs:r,backend:o,attrs:l}=a,{x:i}=r,{axis:p,keepDims:u}=l;(0,t.assertNotComplex)(i,"all");const c=e.util.parseAxisParam(p,i.shape);let d=c;const h=e.backend_util.getAxesPermutation(d,i.shape.length);let m=i;null!=h&&(m=(0,n.transpose)({inputs:{x:i},backend:o,attrs:{perm:h}}),d=e.backend_util.getInnerMostAxes(d.length,i.shape.length)),e.backend_util.assertAxesAreInnerMostDims("all",d,m.shape.length);const[k,x]=e.backend_util.computeOutAndReduceShapes(m.shape,d),f=e.util.sizeFromShape(x),b=e.util.makeZerosTypedArray(e.util.sizeFromShape(k),m.dtype),g=o.data.get(m.dataId).values;for(let e=0;e<b.length;++e){const t=e*f;let s=g[t];for(let e=0;e<f;++e){const n=g[t+e];s=s&&n}b[e]=s}null!=h&&o.disposeIntermediateTensorInfo(m);const A=o.makeTensorInfo(k,m.dtype,b);if(u){const t=e.backend_util.expandShapeToKeepDim(k,c),n=(0,s.reshape)({inputs:{x:A},backend:o,attrs:{shape:t}});return o.disposeIntermediateTensorInfo(A),n}return A}const r=exports.allConfig={kernelName:e.All,backendName:"cpu",kernelFunc:a};
},{"@tensorflow/tfjs-core":"kSBl","../cpu_util":"nVKy","./Reshape":"FjS7","./Transpose":"zFLV"}],"idgX":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.any=a,exports.anyConfig=void 0;var e=require("@tensorflow/tfjs-core"),t=require("../cpu_util"),n=require("./Reshape"),s=require("./Transpose");function a(a){const{inputs:r,backend:o,attrs:i}=a,{x:p}=r,{axis:u,keepDims:l}=i;(0,t.assertNotComplex)(p,"any");const c=e.util.parseAxisParam(u,p.shape);let d=c;const h=e.backend_util.getAxesPermutation(d,p.shape.length);let m=p;null!=h&&(m=(0,s.transpose)({inputs:{x:p},backend:o,attrs:{perm:h}}),d=e.backend_util.getInnerMostAxes(d.length,p.shape.length)),e.backend_util.assertAxesAreInnerMostDims("any",d,m.shape.length);const[k,x]=e.backend_util.computeOutAndReduceShapes(m.shape,d),f=e.util.sizeFromShape(x),y=e.util.makeZerosTypedArray(e.util.sizeFromShape(k),m.dtype),b=o.data.get(m.dataId).values;for(let e=0;e<y.length;++e){const t=e*f;let n=b[t];for(let e=0;e<f;++e){const s=b[t+e];n=n||s}y[e]=n}null!=h&&o.disposeIntermediateTensorInfo(m);const g=o.makeTensorInfo(k,m.dtype,y);if(l){const t=e.backend_util.expandShapeToKeepDim(k,c),s=(0,n.reshape)({inputs:{x:g},backend:o,attrs:{shape:t}});return o.disposeIntermediateTensorInfo(g),s}return g}const r=exports.anyConfig={kernelName:e.Any,backendName:"cpu",kernelFunc:a};
},{"@tensorflow/tfjs-core":"kSBl","../cpu_util":"nVKy","./Reshape":"FjS7","./Transpose":"zFLV"}],"WhbY":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.argMax=a,exports.argMaxConfig=void 0;var e=require("@tensorflow/tfjs-core"),t=require("../cpu_util"),s=require("./Transpose");function a(a){const{inputs:r,backend:n,attrs:o}=a,{x:i}=r,{axis:u}=o;(0,t.assertNotComplex)(i,"argMax");let l=e.util.parseAxisParam(u,i.shape);const p=e.backend_util.getAxesPermutation(l,i.shape.length);let c=i;const d=[];null!=p&&(c=(0,s.transpose)({inputs:{x:i},backend:n,attrs:{perm:p}}),d.push(c),l=e.backend_util.getInnerMostAxes(l.length,c.shape.length)),l=[l[0]],e.backend_util.assertAxesAreInnerMostDims("argMax",l,c.shape.length);const[x,g]=e.backend_util.computeOutAndReduceShapes(c.shape,l),h=e.util.sizeFromShape(x),m=e.util.makeZerosTypedArray(h,"int32"),f=e.util.sizeFromShape(g),k=n.data.get(c.dataId).values;for(let e=0;e<m.length;++e){const t=e*f;let s=k[t],a=0;for(let e=0;e<f;++e){const r=k[t+e];r>s&&(s=r,a=e)}m[e]=a}return d.forEach(e=>n.disposeIntermediateTensorInfo(e)),n.makeTensorInfo(x,"int32",m)}const r=exports.argMaxConfig={kernelName:e.ArgMax,backendName:"cpu",kernelFunc:a};
},{"@tensorflow/tfjs-core":"kSBl","../cpu_util":"nVKy","./Transpose":"zFLV"}],"NFWe":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.argMin=s,exports.argMinConfig=void 0;var e=require("@tensorflow/tfjs-core"),t=require("../cpu_util"),n=require("./Transpose");function s(s){const{inputs:r,backend:a,attrs:o}=s,{x:i}=r,{axis:u}=o;(0,t.assertNotComplex)(i,"argMin");let l=e.util.parseAxisParam(u,i.shape);const p=e.backend_util.getAxesPermutation(l,i.shape.length);let c=i;const d=[];null!=p&&(c=(0,n.transpose)({inputs:{x:i},backend:a,attrs:{perm:p}}),d.push(c),l=e.backend_util.getInnerMostAxes(l.length,c.shape.length)),l=[l[0]],e.backend_util.assertAxesAreInnerMostDims("argMin",l,c.shape.length);const[g,h]=e.backend_util.computeOutAndReduceShapes(c.shape,l),m=e.util.sizeFromShape(g),x=e.util.makeZerosTypedArray(m,"int32"),f=e.util.sizeFromShape(h),k=a.data.get(c.dataId).values;for(let e=0;e<x.length;++e){const t=e*f;let n=k[t],s=0;for(let e=0;e<f;++e){const r=k[t+e];r<n&&(n=r,s=e)}x[e]=s}return d.forEach(e=>a.disposeIntermediateTensorInfo(e)),a.makeTensorInfo(g,"int32",x)}const r=exports.argMinConfig={kernelName:e.ArgMin,backendName:"cpu",kernelFunc:s};
},{"@tensorflow/tfjs-core":"kSBl","../cpu_util":"nVKy","./Transpose":"zFLV"}],"N8T3":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.asinConfig=exports.asin=void 0;var e=require("@tensorflow/tfjs-core"),n=require("../utils/unary_utils");const r=exports.asin=(0,n.unaryKernelFunc)(e.Asin,e=>Math.asin(e)),s=exports.asinConfig={kernelName:e.Asin,backendName:"cpu",kernelFunc:r};
},{"@tensorflow/tfjs-core":"kSBl","../utils/unary_utils":"kZAs"}],"xPoz":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.asinhConfig=exports.asinh=void 0;var e=require("@tensorflow/tfjs-core"),n=require("../utils/unary_utils");const r=exports.asinh=(0,n.unaryKernelFunc)(e.Asinh,e=>Math.asinh(e)),s=exports.asinhConfig={kernelName:e.Asinh,backendName:"cpu",kernelFunc:r};
},{"@tensorflow/tfjs-core":"kSBl","../utils/unary_utils":"kZAs"}],"s1ZS":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.atanConfig=exports.atan=void 0;var e=require("@tensorflow/tfjs-core"),t=require("../utils/unary_utils");const a=exports.atan=(0,t.unaryKernelFunc)(e.Atan,e=>Math.atan(e)),n=exports.atanConfig={kernelName:e.Atan,backendName:"cpu",kernelFunc:a};
},{"@tensorflow/tfjs-core":"kSBl","../utils/unary_utils":"kZAs"}],"AHcr":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.atan2Impl=exports.atan2Config=exports.atan2=void 0;var e=require("@tensorflow/tfjs-core"),r=require("../utils/binary_impl"),t=require("../utils/binary_utils");const a=exports.atan2Impl=(0,r.createSimpleBinaryKernelImpl)((e,r)=>Math.atan2(e,r)),n=exports.atan2=(0,t.binaryKernelFunc)(e.Atan2,a),i=exports.atan2Config={kernelName:e.Atan2,backendName:"cpu",kernelFunc:n};
},{"@tensorflow/tfjs-core":"kSBl","../utils/binary_impl":"v0i6","../utils/binary_utils":"FLbP"}],"JKyg":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.atanhConfig=exports.atanh=void 0;var e=require("@tensorflow/tfjs-core"),t=require("../utils/unary_utils");const a=exports.atanh=(0,t.unaryKernelFunc)(e.Atanh,e=>Math.atanh(e)),n=exports.atanhConfig={kernelName:e.Atanh,backendName:"cpu",kernelFunc:a};
},{"@tensorflow/tfjs-core":"kSBl","../utils/unary_utils":"kZAs"}],"ds2d":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.maxPool3dPositions=n,exports.maxPoolPositions=o,exports.pool=e,exports.pool3d=i;var t=require("@tensorflow/tfjs-core");function e(e,o,i,n,h,r){const f=h.strideHeight,a=h.strideWidth,l=h.dilationHeight,s=h.dilationWidth,d=h.effectiveFilterHeight,c=h.effectiveFilterWidth,u=h.padInfo.top,p=h.padInfo.left,I="max"===r?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,N=(0,t.buffer)(h.outShape,i),g=N.values,S=h.outShape[1]*h.outShape[2]*h.outShape[3],m=h.outShape[2]*h.outShape[3],W=h.outShape[3];for(let t=0;t<h.batchSize;++t){const o=t*S,i=t*n[0];for(let t=0;t<h.inChannels;++t)for(let N=0;N<h.outHeight;++N){const S=N*f-u,H=Math.max(0,S),b=Math.min(h.inHeight,d+S),v=o+N*m;for(let o=0;o<h.outWidth;++o){const f=o*a-p,d=Math.max(0,f),u=Math.min(h.inWidth,c+f);let N=I,S=0,m=0;for(let o=H;o<b;o+=l){const h=i+o*n[1];for(let o=d;o<u;o+=s){const i=e[h+o*n[2]+t];"max"===r&&i>N?N=i:"avg"===r&&(S+=i,m++)}if(isNaN(N))break}g[v+o*W+t]="avg"===r?S/m:N}}}return N}function o(e,o,i,n,h=!1,r=!1){const f=(0,t.buffer)(n.outShape,"int32"),a=n.strideHeight,l=n.strideWidth,s=n.dilationHeight,d=n.dilationWidth,c=n.effectiveFilterHeight,u=n.effectiveFilterWidth,p=n.padInfo.top,I=n.padInfo.left,N=(0,t.buffer)(o,i,e);for(let t=0;t<n.batchSize;++t)for(let e=0;e<n.inChannels;++e)for(let o=0;o<n.outHeight;++o){const i=o*a-p;let g=i;for(;g<0;)g+=s;const S=Math.min(n.inHeight,c+i);for(let a=0;a<n.outWidth;++a){const c=a*l-I;let p=c;for(;p<0;)p+=d;const m=Math.min(n.inWidth,u+c);let W=Number.NEGATIVE_INFINITY,H=-1;for(let o=g;o<S;o+=s){const f=o-i;for(let i=p;i<m;i+=d){const a=i-c,l=N.get(t,o,i,e);l>W&&(W=l,H=h?r?((t*n.inHeight+o)*n.inWidth+i)*n.inChannels+e:(o*n.inWidth+i)*n.inChannels+e:f*u+a)}}f.set(H,t,o,a,e)}}return f}function i(e,o,i,n,h,r){const f=h.strideDepth,a=h.strideHeight,l=h.strideWidth,s=h.dilationDepth,d=h.dilationHeight,c=h.dilationWidth,u=h.effectiveFilterDepth,p=h.effectiveFilterHeight,I=h.effectiveFilterWidth,N=h.padInfo.front,g=h.padInfo.top,S=h.padInfo.left,m="max"===r?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,W=(0,t.buffer)(h.outShape,i),H=W.values,b=h.outShape[1]*h.outShape[2]*h.outShape[3]*h.outShape[4],v=h.outShape[2]*h.outShape[3]*h.outShape[4],F=h.outShape[3]*h.outShape[4],x=h.outShape[4];for(let t=0;t<h.batchSize;++t){const o=t*b,i=t*n[0];for(let t=0;t<h.inChannels;++t)for(let W=0;W<h.outDepth;++W){const b=W*f-N;let M=b;for(;M<0;)M+=s;const T=Math.min(h.inDepth,u+b),D=o+W*v;for(let o=0;o<h.outHeight;++o){const f=o*a-g;let u=f;for(;u<0;)u+=d;const N=Math.min(h.inHeight,p+f),W=D+o*F;for(let o=0;o<h.outWidth;++o){const f=o*l-S;let a=f;for(;a<0;)a+=c;const p=Math.min(h.inWidth,I+f),g=W+o*x;let b=m,v=0,F=0;for(let o=M;o<T;o+=s){const h=i+o*n[1];for(let o=u;o<N;o+=d){const i=h+o*n[2];for(let o=a;o<p;o+=c){const h=e[i+o*n[3]+t];if("max"===r&&h>b?b=h:"avg"===r&&(v+=h,F++),isNaN(b))break}if(isNaN(b))break}if(isNaN(b))break}H[g+t]="avg"===r?v/Math.max(F,1):b}}}}return W}function n(e,o){const i=(0,t.buffer)(o.outShape,"int32"),n=o.strideDepth,h=o.strideHeight,r=o.strideWidth,f=o.dilationDepth,a=o.dilationHeight,l=o.dilationWidth,s=o.effectiveFilterDepth,d=o.effectiveFilterHeight,c=o.effectiveFilterWidth,u=o.padInfo.front,p=o.padInfo.top,I=o.padInfo.left;for(let t=0;t<o.batchSize;++t)for(let N=0;N<o.inChannels;++N)for(let g=0;g<o.outDepth;++g){const S=g*n-u;let m=S;for(;m<0;)m+=f;const W=Math.min(o.inDepth,s+S);for(let n=0;n<o.outHeight;++n){const s=n*h-p;let u=s;for(;u<0;)u+=a;const H=Math.min(o.inHeight,d+s);for(let h=0;h<o.outWidth;++h){const p=h*r-I;let b=p;for(;b<0;)b+=l;const v=Math.min(o.inWidth,c+p);let F=Number.NEGATIVE_INFINITY,x=-1;for(let o=m;o<W;o+=f){const i=o-S;for(let n=u;n<H;n+=a){const h=n-s;for(let r=b;r<v;r+=l){const f=r-p,a=e.get(t,o,n,r,N);a>=F&&(F=a,x=i*d*c+h*d+f)}}}i.set(x,t,g,n,h,N)}}}return i}
},{"@tensorflow/tfjs-core":"kSBl"}],"qDYU":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.avgPool=r,exports.avgPoolConfig=void 0;var e=require("@tensorflow/tfjs-core"),t=require("../cpu_util"),o=require("../utils/pool_utils"),i=require("./Identity");function r(r){const{inputs:s,backend:a,attrs:n}=r,{x:l}=s;(0,t.assertNotComplex)(l,"avgPool");const{filterSize:u,strides:d,pad:p,dimRoundingMode:c}=n;e.util.assert(e.backend_util.eitherStridesOrDilationsAreOne(d,1),()=>"Error in avgPool: Either strides or dilations must be 1. "+`Got strides ${d} and dilations '1'`);const f=e.backend_util.computePool2DInfo(l.shape,u,d,1,p,c);let g;if(1===f.filterWidth&&1===f.filterHeight&&e.util.arraysEqual(f.inShape,f.outShape))g=(0,i.identity)({inputs:{x:l},backend:a});else{const t=a.data.get(l.dataId).values,i=e.util.computeStrides(l.shape),r=(0,o.pool)(t,l.shape,l.dtype,i,f,"avg");g=a.makeTensorInfo(f.outShape,l.dtype,r.values)}return g}const s=exports.avgPoolConfig={kernelName:e.AvgPool,backendName:"cpu",kernelFunc:r};
},{"@tensorflow/tfjs-core":"kSBl","../cpu_util":"nVKy","../utils/pool_utils":"ds2d","./Identity":"nMAE"}],"RFNp":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.avgPool3D=a,exports.avgPool3DConfig=void 0;var e=require("@tensorflow/tfjs-core"),o=require("../cpu_util"),t=require("../utils/pool_utils");function a(a){const{inputs:s,backend:r,attrs:l}=a,{x:n}=s,{filterSize:u,strides:i,pad:d,dimRoundingMode:p,dataFormat:c}=l;(0,o.assertNotComplex)(n,"avgPool3d");const v=e.backend_util.computePool3DInfo(n.shape,u,i,1,d,p,c),f=r.data.get(n.dataId).values,g=(0,t.pool3d)(f,n.shape,n.dtype,e.util.computeStrides(n.shape),v,"avg");return r.makeTensorInfo(g.shape,"float32",g.values)}const s=exports.avgPool3DConfig={kernelName:e.AvgPool3D,backendName:"cpu",kernelFunc:a};
},{"@tensorflow/tfjs-core":"kSBl","../cpu_util":"nVKy","../utils/pool_utils":"ds2d"}],"UevM":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.avgPool3DGrad=o,exports.avgPool3DGradConfig=void 0;var e=require("@tensorflow/tfjs-core"),t=require("../cpu_util");function o(o){const{inputs:i,backend:r,attrs:f}=o,{dy:n,input:l}=i,{filterSize:a,strides:d,pad:s,dimRoundingMode:h}=f;(0,t.assertNotComplex)([n,l],"avgPool3DGrad");const p=e.backend_util.computePool3DInfo(l.shape,a,d,1,s,h),c=p.strideDepth,u=p.strideHeight,g=p.strideWidth,v=p.filterDepth,D=p.filterHeight,b=p.filterWidth,P=p.dilationDepth,k=p.dilationHeight,m=p.dilationWidth,H=p.effectiveFilterDepth,W=p.effectiveFilterHeight,x=p.effectiveFilterWidth,G=H-1-p.padInfo.front,I=x-1-p.padInfo.left,M=W-1-p.padInfo.top,y=(0,e.buffer)(l.shape,"float32"),C=1/(v*D*b),F=r.bufferSync(n);for(let e=0;e<p.batchSize;++e)for(let t=0;t<p.inChannels;++t)for(let o=0;o<p.inDepth;++o)for(let i=0;i<p.inHeight;++i)for(let r=0;r<p.inWidth;++r){const f=o-G,n=i-M,l=r-I;let a=0;for(let o=0;o<H;o+=P){const i=(f+o)/c;if(!(i<0||i>=p.outDepth||Math.floor(i)!==i))for(let o=0;o<W;o+=k){const r=(n+o)/u;if(!(r<0||r>=p.outHeight||Math.floor(r)!==r))for(let o=0;o<x;o+=m){const f=(l+o)/g;f<0||f>=p.outWidth||Math.floor(f)!==f||(a+=F.get(e,i,r,f,t))}}}y.set(a*C,e,o,i,r,t)}return r.makeTensorInfo(y.shape,y.dtype,y.values)}const i=exports.avgPool3DGradConfig={kernelName:e.AvgPool3DGrad,backendName:"cpu",kernelFunc:o};
},{"@tensorflow/tfjs-core":"kSBl","../cpu_util":"nVKy"}],"ZSgh":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.avgPoolGrad=o,exports.avgPoolGradConfig=void 0;var e=require("@tensorflow/tfjs-core"),t=require("../cpu_util");function o(o){const{inputs:i,backend:r,attrs:a}=o,{dy:l,input:f}=i,n=f;(0,t.assertNotComplex)([l,f],"avgPoolGrad");const{filterSize:s,strides:d,pad:u}=a,c=e.backend_util.computePool2DInfo(n.shape,s,d,1,u),h=c.strideHeight,p=c.strideWidth,g=c.filterHeight,v=c.filterWidth,b=c.dilationHeight,P=c.dilationWidth,k=c.effectiveFilterHeight,H=c.effectiveFilterWidth,W=H-1-c.padInfo.left,m=k-1-c.padInfo.top,x=(0,e.buffer)(n.shape,"float32"),G=1/(g*v),I=r.data.get(l.dataId).values,C=(0,e.buffer)(l.shape,"float32",I);for(let e=0;e<c.batchSize;++e)for(let t=0;t<c.inChannels;++t)for(let o=0;o<c.inHeight;++o)for(let i=0;i<c.inWidth;++i){const r=o-m,a=i-W;let l=0;for(let o=0;o<k;o+=b){const i=(r+o)/h;if(!(i<0||i>=c.outHeight||Math.floor(i)!==i))for(let o=0;o<H;o+=P){const r=(a+o)/p;r<0||r>=c.outWidth||Math.floor(r)!==r||(l+=C.get(e,i,r,t))}}x.set(l*G,e,o,i,t)}return r.makeTensorInfo(x.shape,x.dtype,x.values)}const i=exports.avgPoolGradConfig={kernelName:e.AvgPoolGrad,backendName:"cpu",kernelFunc:o};
},{"@tensorflow/tfjs-core":"kSBl","../cpu_util":"nVKy"}],"OtYx":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.batchNorm=t,exports.batchNormConfig=void 0;var e=require("@tensorflow/tfjs-core"),a=require("../cpu_util");function t(t){const{inputs:n,backend:r,attrs:l}=t,{x:s,scale:o,offset:h,mean:u,variance:i}=n;e.util.assert(u.shape.length===i.shape.length,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),e.util.assert(null==h||u.shape.length===h.shape.length,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),e.util.assert(null==o||u.shape.length===o.shape.length,()=>"Batch normalization gradient requires mean and scale to have equal ranks."),(0,a.assertNotComplex)([s,u,i,o,h],"batchNorm");let{varianceEpsilon:d}=l;null==d&&(d=.001);const c=r.data.get(s.dataId).values,g=r.data.get(u.dataId).values,p=r.data.get(i.dataId).values,m=o?r.data.get(o.dataId).values:new Float32Array([1]),v=h?r.data.get(h.dataId).values:new Float32Array([0]),f=new Float32Array(c.length),q=v.length,k=m.length,N=p.length,b=g.length;let x=0,I=0,y=0,F=0;for(let e=0;e<c.length;++e)f[e]=v[x++]+(c[e]-g[I++])*m[y++]/Math.sqrt(p[F++]+d),x>=q&&(x=0),I>=b&&(I=0),y>=k&&(y=0),F>=N&&(F=0);return r.makeTensorInfo(s.shape,s.dtype,f)}const n=exports.batchNormConfig={kernelName:e.FusedBatchNorm,backendName:"cpu",kernelFunc:t};
},{"@tensorflow/tfjs-core":"kSBl","../cpu_util":"nVKy"}],"xdCY":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.batchToSpaceND=r,exports.batchToSpaceNDConfig=void 0;var e=require("@tensorflow/tfjs-core"),t=require("../cpu_util"),s=require("./Reshape"),a=require("./Slice"),n=require("./Transpose");function r(r){const{inputs:c,backend:o,attrs:i}=r,{x:p}=c,{blockShape:u,crops:d}=i;(0,t.assertNotComplex)([p],"batchToSpaceND");const l=u.reduce((e,t)=>e*t),h=e.backend_util.getReshaped(p.shape,u,l),b=e.backend_util.getPermuted(h.length,u.length),k=e.backend_util.getReshapedPermuted(p.shape,u,l),g=e.backend_util.getSliceBeginCoords(d,u.length),x=e.backend_util.getSliceSize(k,d,u.length),S=(0,s.reshape)({inputs:{x:p},backend:o,attrs:{shape:h}}),f=(0,n.transpose)({inputs:{x:S},backend:o,attrs:{perm:b}}),m=(0,s.reshape)({inputs:{x:f},backend:o,attrs:{shape:k}}),T=(0,a.slice)({inputs:{x:m},backend:o,attrs:{begin:g,size:x}});return o.disposeIntermediateTensorInfo(S),o.disposeIntermediateTensorInfo(f),o.disposeIntermediateTensorInfo(m),T}const c=exports.batchToSpaceNDConfig={kernelName:e.BatchToSpaceND,backendName:"cpu",kernelFunc:r};
},{"@tensorflow/tfjs-core":"kSBl","../cpu_util":"nVKy","./Reshape":"FjS7","./Slice":"i6mc","./Transpose":"zFLV"}],"cA1l":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.bincount=n,exports.bincountConfig=void 0;var e=require("@tensorflow/tfjs-core"),t=require("./Bincount_impl");function n(e){const{inputs:n,backend:o,attrs:r}=e,{x:a,weights:s}=n,{size:i}=r,u=o.data.get(a.dataId).values,c=o.data.get(s.dataId).values,d=(0,t.bincountImpl)(u,c,s.dtype,s.shape,i);return o.makeTensorInfo([i],s.dtype,d)}const o=exports.bincountConfig={kernelName:e.Bincount,backendName:"cpu",kernelFunc:n};
},{"@tensorflow/tfjs-core":"kSBl","./Bincount_impl":"cUUF"}],"AJJk":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.broadcastArgs=r,exports.broadcastArgsConfig=void 0;var e=require("@tensorflow/tfjs-core");function r(r){const{inputs:a,backend:t}=r,{s0:s,s1:o}=a,n=t.data.get(s.dataId).values,d=t.data.get(o.dataId).values,c=e.backend_util.assertAndGetBroadcastShape(Array.from(n),Array.from(d));return t.makeTensorInfo([c.length],"int32",Int32Array.from(c))}const a=exports.broadcastArgsConfig={kernelName:e.BroadcastArgs,backendName:"cpu",kernelFunc:r};
},{"@tensorflow/tfjs-core":"kSBl"}],"LGZH":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.clipByValueConfig=exports.clipByValue=void 0;var e=require("@tensorflow/tfjs-core"),l=require("../utils/unary_utils");const u=exports.clipByValue=(0,l.unaryKernelFunc)(e.ClipByValue,(e,l)=>{const u=l;return e>u.clipValueMax?u.clipValueMax:e<u.clipValueMin?u.clipValueMin:e}),r=exports.clipByValueConfig={kernelName:e.ClipByValue,backendName:"cpu",kernelFunc:u};
},{"@tensorflow/tfjs-core":"kSBl","../utils/unary_utils":"kZAs"}],"EAkL":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.complexAbsConfig=exports.complexAbs=void 0;var e=require("@tensorflow/tfjs-core");const t=t=>{const{x:o}=t.inputs,a=t.backend,s=new Float32Array(e.util.sizeFromShape(o.shape)),r=a.data.get(o.dataId),n=r.complexTensorInfos.real,l=r.complexTensorInfos.imag,p=a.data.get(n.dataId).values,c=a.data.get(l.dataId).values;for(let e=0;e<p.length;e++){const t=p[e],o=c[e];s[e]=Math.hypot(t,o)}return a.makeOutput(s,o.shape,"float32")};exports.complexAbs=t;const o=exports.complexAbsConfig={kernelName:e.ComplexAbs,backendName:"cpu",kernelFunc:t};
},{"@tensorflow/tfjs-core":"kSBl"}],"YWMY":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.imag=t,exports.imagConfig=void 0;var e=require("@tensorflow/tfjs-core");function t(e){const{inputs:t,backend:a}=e,{input:n}=t,o=a.data.get(n.dataId).complexTensorInfos.imag,r=a.data.get(o.dataId).values;return a.makeTensorInfo(o.shape,o.dtype,r)}const a=exports.imagConfig={kernelName:e.Imag,backendName:"cpu",kernelFunc:t};
},{"@tensorflow/tfjs-core":"kSBl"}],"ZWVG":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.concat=i,exports.concatConfig=void 0;var e=require("@tensorflow/tfjs-core"),t=require("./Complex"),a=require("./Concat_impl"),n=require("./Identity"),s=require("./Imag"),r=require("./Real"),p=require("./Reshape");function i(o){const{inputs:c,backend:u,attrs:d}=o,{axis:m}=d,l=e.util.parseAxisParam(m,c[0].shape)[0],h=c.map(e=>e.shape);e.backend_util.assertParamsConsistent(h,l);let f=e.backend_util.computeOutShape(c.map(e=>e.shape),l);if(0===e.util.sizeFromShape(f))return u.makeTensorInfo(f,c[0].dtype,[]);const k=c.filter(t=>e.util.sizeFromShape(t.shape)>0);if(1===k.length)return(0,n.identity)({inputs:{x:k[0]},backend:u});if("complex64"===k[0].dtype){const e=k.map(e=>(0,r.real)({inputs:{input:e},backend:u})),a=k.map(e=>(0,s.imag)({inputs:{input:e},backend:u})),n=i({inputs:e,backend:u,attrs:{axis:l}}),p=i({inputs:a,backend:u,attrs:{axis:l}}),o=(0,t.complex)({inputs:{real:n,imag:p},backend:u});return e.forEach(e=>u.disposeIntermediateTensorInfo(e)),a.forEach(e=>u.disposeIntermediateTensorInfo(e)),u.disposeIntermediateTensorInfo(n),u.disposeIntermediateTensorInfo(p),o}const I=k.map(t=>{const a=[-1,e.util.sizeFromShape(t.shape.slice(l))];return(0,p.reshape)({inputs:{x:t},backend:u,attrs:{shape:a}})}),b=I.map(e=>({vals:u.data.get(e.dataId).values,shape:e.shape}));f=e.backend_util.computeOutShape(I.map(e=>e.shape),1);const x=1===I[0].shape[0],g=(0,a.concatImpl)(b,f,c[0].dtype,x),q=e.backend_util.computeOutShape(k.map(e=>e.shape),l),y=u.makeTensorInfo(q,c[0].dtype,g);return I.forEach(e=>u.disposeIntermediateTensorInfo(e)),y}const o=exports.concatConfig={kernelName:e.Concat,backendName:"cpu",kernelFunc:i};
},{"@tensorflow/tfjs-core":"kSBl","./Complex":"KmEe","./Concat_impl":"axei","./Identity":"nMAE","./Imag":"YWMY","./Real":"icBn","./Reshape":"FjS7"}],"E2Vg":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.conv2D=o,exports.conv2DConfig=void 0;var t=require("@tensorflow/tfjs-core"),e=require("../cpu_util");function o(o){const{inputs:n,backend:s,attrs:i}=o,{x:a,filter:r}=n,{strides:d,pad:c,dataFormat:l,dilations:u,dimRoundingMode:f}=i;(0,e.assertNotComplex)([a,r],"conv2d");const p=t.backend_util.convertConv2DDataFormat(l),h=t.backend_util.computeConv2DInfo(a.shape,r.shape,d,u,c,f,!1,p),v=h.filterHeight,m=h.filterWidth,g=h.dilationHeight,C=h.dilationWidth,k=h.padInfo.left,D=h.padInfo.top,b="channelsLast"===h.dataFormat,x=new t.TensorBuffer(h.outShape,a.dtype),I=t.util.computeStrides(a.shape),H=t.util.computeStrides(r.shape),W=I[0],_=b?I[1]:I[2],F=b?I[2]:1,S=b?1:I[1],y=x.strides[0],N=b?x.strides[1]:x.strides[2],j=b?x.strides[2]:1,q=b?1:x.strides[1],w=s.data.get(a.dataId).values,M=s.data.get(r.dataId).values,T=x.values;for(let t=0;t<h.batchSize;++t){const e=t*W,o=t*y;for(let t=0;t<h.outHeight;++t){const n=o+t*N,s=t*h.strideHeight-D;for(let t=0;t<v;++t){const o=s+t*g;if(o<0||o>=h.inHeight)continue;const i=t*H[0],a=e+o*_;for(let t=0;t<h.outWidth;++t){const e=n+t*j,o=t*h.strideWidth-k;for(let t=0;t<m;++t){const n=o+t*C;if(n<0||n>=h.inWidth)continue;const s=a+n*F;let r=i+t*H[1];for(let t=0;t<h.inChannels;++t){const o=w[s+t*S];for(let t=0;t<h.outChannels;++t)T[e+t*q]+=o*M[r+t];r+=h.outChannels}}}}}}return s.makeTensorInfo(x.shape,x.dtype,T)}const n=exports.conv2DConfig={kernelName:t.Conv2D,backendName:"cpu",kernelFunc:o};
},{"@tensorflow/tfjs-core":"kSBl","../cpu_util":"nVKy"}],"fkMN":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.conv2DBackpropFilter=o,exports.conv2DBackpropFilterConfig=void 0;var e=require("@tensorflow/tfjs-core"),t=require("../cpu_util");function o(o){const{inputs:a,backend:r,attrs:n}=o,{x:i,dy:s}=a,{strides:l,pad:c,dataFormat:d,dimRoundingMode:p,filterShape:f}=n;(0,t.assertNotComplex)([i,s],"conv2dBackpropFilter");const u=e.backend_util.convertConv2DDataFormat(d),h=e.backend_util.computeConv2DInfo(i.shape,f,l,1,c,p,!1,u),{strideHeight:v,strideWidth:g,filterHeight:m,filterWidth:k}=h,F="channelsLast"===h.dataFormat,x=new e.TensorBuffer(h.filterShape,"float32"),B=h.padInfo.left,C=h.padInfo.top,M=r.data.get(i.dataId).values,D=r.data.get(s.dataId).values,b=new e.TensorBuffer(i.shape,i.dtype,M),I=new e.TensorBuffer(s.shape,s.dtype,D);for(let e=0;e<m;++e){const t=Math.max(0,Math.ceil((C-e)/v)),o=Math.min(h.outHeight,(h.inHeight+C-e)/v);for(let a=0;a<k;++a){const r=Math.max(0,Math.ceil((B-a)/g)),n=Math.min(h.outWidth,(h.inWidth+B-a)/g);for(let i=0;i<h.inChannels;++i)for(let s=0;s<h.outChannels;++s){let l=0;for(let c=0;c<h.batchSize;++c)for(let d=t;d<o;++d){const t=e+d*v-C;for(let e=r;e<n;++e){const o=a+e*g-B;l+=F?b.get(c,t,o,i)*I.get(c,d,e,s):b.get(c,i,t,o)*I.get(c,s,d,e)}}x.set(l,e,a,i,s)}}}return r.makeTensorInfo(x.shape,x.dtype,x.values)}const a=exports.conv2DBackpropFilterConfig={kernelName:e.Conv2DBackpropFilter,backendName:"cpu",kernelFunc:o};
},{"@tensorflow/tfjs-core":"kSBl","../cpu_util":"nVKy"}],"fcKD":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.conv2DBackpropInput=o,exports.conv2DBackpropInputConfig=void 0;var t=require("@tensorflow/tfjs-core"),e=require("../cpu_util");function o(o){const{inputs:a,backend:n,attrs:r}=o,{dy:s,filter:i}=a,{inputShape:p,strides:d,pad:c,dataFormat:l,dimRoundingMode:u}=r;(0,e.assertNotComplex)([s,i],"conv2dBackpropInput");const f=t.util.computeStrides(i.shape),h=t.util.computeStrides(s.shape);let m=t.backend_util.convertConv2DDataFormat(l);const v=t.backend_util.computeConv2DInfo(p,i.shape,d,1,c,u,!1,m),k=new t.TensorBuffer(v.inShape,"float32"),I=k.values,g=n.data.get(s.dataId).values,C=n.data.get(i.dataId).values,[M,x,D]=f,{batchSize:b,filterHeight:B,filterWidth:S,inChannels:_,inHeight:F,inWidth:H,outChannels:W,outHeight:y,outWidth:N,strideHeight:j,strideWidth:q}=v;m=v.dataFormat;const w=B-1-v.padInfo.top,T=S-1-v.padInfo.left,z="channelsLast"===m,L=k.strides[0],O=z?k.strides[1]:k.strides[2],P=z?k.strides[2]:1,R=z?1:k.strides[1],A=h[0],E=z?h[1]:h[2],G=z?h[2]:1,J=z?1:h[1];for(let t=0;t<b;++t)for(let e=0;e<_;++e)for(let o=0;o<F;++o){const a=o-w,n=Math.max(0,Math.ceil(a/j)),r=Math.min(y,(B+a)/j);for(let s=0;s<H;++s){const i=s-T,p=Math.max(0,Math.ceil(i/q)),d=Math.min(N,(S+i)/q);let c=0;for(let o=n;o<r;++o){const n=o*j-a;for(let a=p;a<d;++a){const r=A*t+E*o+G*a,s=M*(B-1-n)+x*(S-1-(a*q-i))+D*e;for(let t=0;t<W;++t){c+=g[r+J*t]*C[s+t]}}}I[L*t+O*o+P*s+R*e]=c}}return n.makeTensorInfo(k.shape,k.dtype,k.values)}const a=exports.conv2DBackpropInputConfig={kernelName:t.Conv2DBackpropInput,backendName:"cpu",kernelFunc:o};
},{"@tensorflow/tfjs-core":"kSBl","../cpu_util":"nVKy"}],"a6p3":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.conv3D=o,exports.conv3DConfig=void 0;var t=require("@tensorflow/tfjs-core"),e=require("../cpu_util");function o(o){const{inputs:n,backend:s,attrs:i}=o,{x:r,filter:a}=n,{strides:l,pad:c,dilations:d}=i;(0,e.assertNotComplex)([r,a],"conv3d");const u=t.backend_util.computeConv3DInfo(r.shape,a.shape,l,d,c),{filterDepth:f,filterHeight:p,filterWidth:h,dilationDepth:v,dilationHeight:C,dilationWidth:D,padInfo:g}=u,m=g.front,k=g.left,x=g.top,b=new t.TensorBuffer(u.outShape,r.dtype),H=s.data.get(r.dataId).values,I=s.data.get(a.dataId).values,W=b.values,S=t.util.computeStrides(r.shape),_=t.util.computeStrides(a.shape);for(let t=0;t<u.batchSize;++t){const e=t*S[0],o=t*b.strides[0];for(let t=0;t<u.outDepth;++t){const n=o+t*b.strides[1],s=t*u.strideDepth-m;for(let t=0;t<f;++t){const o=s+t*v;if(o<0||o>=u.inDepth)continue;const i=t*_[0],r=e+o*S[1];for(let t=0;t<u.outHeight;++t){const e=n+t*b.strides[2],o=t*u.strideHeight-x;for(let t=0;t<p;++t){const n=o+t*C;if(n<0||n>=u.inHeight)continue;const s=i+t*_[1],a=r+n*S[2];for(let t=0;t<u.outWidth;++t){const o=e+t*u.outChannels,n=t*u.strideWidth-k;for(let t=0;t<h;++t){const e=n+t*D;if(e<0||e>=u.inWidth)continue;const i=s+t*_[2],r=a+e*u.inChannels;let l=i;for(let t=0;t<u.inChannels;++t){const e=H[r+t];for(let t=0;t<u.outChannels;++t)W[o+t]+=e*I[l+t];l+=u.outChannels}}}}}}}}return s.makeTensorInfo(b.shape,b.dtype,b.values)}const n=exports.conv3DConfig={kernelName:t.Conv3D,backendName:"cpu",kernelFunc:o};
},{"@tensorflow/tfjs-core":"kSBl","../cpu_util":"nVKy"}],"DRlm":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.conv3DBackpropFilterV2=o,exports.conv3DBackpropFilterV2Config=void 0;var t=require("@tensorflow/tfjs-core"),e=require("../cpu_util");function o(o){const{inputs:r,backend:a,attrs:n}=o,{x:i,dy:s}=r,{strides:l,pad:p,filterShape:c}=n;(0,e.assertNotComplex)([i,s],"conv3dBackpropFilterV2");const d=t.util.computeStrides(i.shape),f=t.util.computeStrides(s.shape),h=t.backend_util.computeConv3DInfo(i.shape,c,l,1,p),u=h.strideDepth,m=h.strideHeight,v=h.strideWidth,k=h.filterDepth,M=h.filterHeight,x=h.filterWidth,D=new t.TensorBuffer(h.filterShape,"float32"),g=D.values,[C,I,B,F]=D.strides,b=a.data.get(s.dataId).values,[S,V,H,W]=f,_=a.data.get(i.dataId).values,[y,N,j,q]=d,w=h.padInfo.front,T=h.padInfo.left,z=h.padInfo.top;for(let t=0;t<k;++t){const e=Math.max(0,Math.ceil((w-t)/u)),o=Math.min(h.outDepth,(h.inDepth+w-t)/u),r=t*C;for(let a=0;a<M;++a){const n=Math.max(0,Math.ceil((z-a)/m)),i=Math.min(h.outHeight,(h.inHeight+z-a)/m),s=a*I+r;for(let r=0;r<x;++r){const l=Math.max(0,Math.ceil((T-r)/v)),p=Math.min(h.outWidth,(h.inWidth+T-r)/v),c=r*B+s;for(let s=0;s<h.inChannels;++s){const d=s*F+c;for(let c=0;c<h.outChannels;++c){let f=0;for(let d=0;d<h.batchSize;++d){const h=d*y,k=d*S;for(let d=e;d<o;++d){const e=(t+d*u-w)*N+h,o=d*V+k;for(let t=n;t<i;++t){const n=(a+t*m-z)*j+e,i=t*H+o;for(let t=l;t<p;++t){const e=t*W+i;f+=_[(r+t*v-T)*q+n+s]*b[e+c]}}}}g[d+c]=f}}}}}return a.makeTensorInfo(D.shape,D.dtype,D.values)}const r=exports.conv3DBackpropFilterV2Config={kernelName:t.Conv3DBackpropFilterV2,backendName:"cpu",kernelFunc:o};
},{"@tensorflow/tfjs-core":"kSBl","../cpu_util":"nVKy"}],"DCpn":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.conv3DBackpropInputV2=o,exports.conv3DBackpropInputV2Config=void 0;var t=require("@tensorflow/tfjs-core"),e=require("../cpu_util");function o(o){const{inputs:n,backend:a,attrs:r}=o,{dy:i,filter:p}=n,{pad:s,strides:c,inputShape:l}=r;(0,e.assertNotComplex)([i],"conv3dBackpropInputV2");const u=t.util.computeStrides(i.shape),d=t.util.computeStrides(p.shape),h=t.backend_util.computeConv3DInfo(l,p.shape,c,1,s),f=new t.TensorBuffer(h.inShape,"float32"),m=f.values,[v,I,k,M]=f.strides,D=a.data.get(i.dataId).values,[g,x,C,B]=u,b=a.data.get(p.dataId).values,[S,V,H,W]=d,{batchSize:_,filterDepth:y,filterHeight:N,filterWidth:j,inChannels:q,inDepth:w,inHeight:T,inWidth:z,outChannels:F,outDepth:O,outHeight:P,outWidth:A,strideDepth:E,strideHeight:G,strideWidth:J}=h,K=y-1-h.padInfo.front,L=N-1-h.padInfo.top,Q=j-1-h.padInfo.left;for(let t=0;t<_;++t)for(let e=0;e<q;++e)for(let o=0;o<w;++o){const n=o-K,a=Math.max(0,Math.ceil(n/E)),r=Math.min(O,(y+n)/E);for(let i=0;i<T;++i){const p=i-L,s=Math.max(0,Math.ceil(p/G)),c=Math.min(P,(N+p)/G);for(let l=0;l<z;++l){const u=l-Q,d=Math.max(0,Math.ceil(u/J)),h=Math.min(A,(j+u)/J);let f=0;for(let o=a;o<r;++o){const a=o*E-n;for(let n=s;n<c;++n){const r=n*G-p;for(let i=d;i<h;++i){const p=g*t+x*o+C*n+B*i,s=S*(y-1-a)+V*(N-1-r)+H*(j-1-(i*J-u))+W*e;for(let t=0;t<F;++t){f+=D[p+t]*b[s+t]}}}}m[v*t+I*o+k*i+M*l+e]=f}}}return a.makeTensorInfo(f.shape,f.dtype,f.values)}const n=exports.conv3DBackpropInputV2Config={kernelName:t.Conv3DBackpropInputV2,backendName:"cpu",kernelFunc:o};
},{"@tensorflow/tfjs-core":"kSBl","../cpu_util":"nVKy"}],"diTV":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.cosConfig=exports.cos=void 0;var e=require("@tensorflow/tfjs-core"),o=require("../utils/unary_utils");const r=exports.cos=(0,o.unaryKernelFunc)(e.Cos,e=>Math.cos(e)),s=exports.cosConfig={kernelName:e.Cos,backendName:"cpu",kernelFunc:r};
},{"@tensorflow/tfjs-core":"kSBl","../utils/unary_utils":"kZAs"}],"YBxL":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.coshConfig=exports.cosh=void 0;var e=require("@tensorflow/tfjs-core"),o=require("../utils/unary_utils");const r=exports.cosh=(0,o.unaryKernelFunc)(e.Cosh,e=>Math.cosh(e)),s=exports.coshConfig={kernelName:e.Cosh,backendName:"cpu",kernelFunc:r};
},{"@tensorflow/tfjs-core":"kSBl","../utils/unary_utils":"kZAs"}],"wxMi":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.cropAndResize=t,exports.cropAndResizeConfig=void 0;var e=require("@tensorflow/tfjs-core");function t(t){const{inputs:o,backend:s,attrs:a}=t,{image:n,boxes:r,boxInd:l}=o,{cropSize:c,method:i,extrapolationValue:u}=a,[f,d,p,h]=n.shape,v=r.shape[0],[b,m]=c,x=(0,e.buffer)([v,b,m,h],"float32"),M=s.data.get(r.dataId).values,g=s.data.get(l.dataId).values,k=s.data.get(n.dataId).values,z=e.util.computeStrides(n.shape),I=e.util.computeStrides(x.shape);for(let e=0;e<v;e++){const t=4*e,o=M[t],s=M[t+1],a=M[t+2],n=M[t+3],r=g[e];if(r>=f)continue;const l=b>1?(a-o)*(d-1)/(b-1):0,c=m>1?(n-s)*(p-1)/(m-1):0;for(let f=0;f<b;f++){const t=b>1?o*(d-1)+f*l:.5*(o+a)*(d-1);if(t<0||t>d-1)for(let o=0;o<m;o++)for(let t=0;t<h;t++){const s=t+o*I[2]+f*I[1]+e*I[0];x.values[s]=u}else if("bilinear"===i){const o=Math.floor(t),a=Math.ceil(t),l=t-o;for(let t=0;t<m;t++){const i=m>1?s*(p-1)+t*c:.5*(s+n)*(p-1);if(i<0||i>p-1){for(let o=0;o<h;o++){const s=o+t*I[2]+f*I[1]+e*I[0];x.values[s]=u}continue}const d=Math.floor(i),v=Math.ceil(i),b=i-d;for(let s=0;s<h;s++){let n=s+d*z[2]+o*z[1]+r*z[0];const c=k[n],i=k[n=s+v*z[2]+o*z[1]+r*z[0]],u=k[n=s+d*z[2]+a*z[1]+r*z[0]],p=c+(i-c)*b,h=u+(k[n=s+v*z[2]+a*z[1]+r*z[0]]-u)*b;n=s+t*I[2]+f*I[1]+e*I[0],x.values[n]=p+(h-p)*l}}}else for(let o=0;o<m;++o){const a=m>1?s*(p-1)+o*c:.5*(s+n)*(p-1);if(a<0||a>p-1){for(let t=0;t<h;t++){const s=t+o*I[2]+f*I[1]+e*I[0];x.values[s]=u}continue}const l=Math.round(a),i=Math.round(t);for(let t=0;t<h;t++){const s=t+l*z[2]+i*z[1]+r*z[0],a=t+o*I[2]+f*I[1]+e*I[0];x.values[a]=k[s]}}}}return s.makeTensorInfo(x.shape,x.dtype,x.values)}const o=exports.cropAndResizeConfig={kernelName:e.CropAndResize,backendName:"cpu",kernelFunc:t};
},{"@tensorflow/tfjs-core":"kSBl"}],"O5hk":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.cumprod=n,exports.cumprodConfig=void 0;var e=require("@tensorflow/tfjs-core"),t=require("../cpu_util"),s=require("./Transpose");function n(n){const{inputs:r,backend:o,attrs:a}=n,{x:p}=r,{axis:i,exclusive:u,reverse:c}=a;(0,t.assertNotComplex)(p,"cumprod");const l=e.backend_util.getAxesPermutation([i],p.shape.length);let d=p;null!=l&&(d=(0,s.transpose)({inputs:{x:p},backend:o,attrs:{perm:l}}));const m=e.backend_util.getInnerMostAxes(1,p.shape.length)[0];if(m!==d.shape.length-1)throw new Error("backend.cumprod in CPU expects an inner-most "+`axis=${d.shape.length-1} but got axis=${m}`);const h=(0,e.upcastType)(d.dtype,"int32"),x=e.util.makeOnesTypedArray(e.util.sizeFromShape(d.shape),h),f=o.data.get(d.dataId).values,g=d.shape[d.shape.length-1],k=c?(e,t)=>e+g-t-1:(e,t)=>e+t;for(let e=0;e<f.length;e+=g)for(let t=0;t<g;t++){const s=k(e,t);if(0===t)x[s]=u?1:f[s];else{const n=k(e,t-1);x[s]=u?f[n]*x[n]:f[s]*x[n]}}const b=o.makeTensorInfo(d.shape,h,x);if(null!=l){const t=e.backend_util.getUndoAxesPermutation(l),n=(0,s.transpose)({inputs:{x:b},backend:o,attrs:{perm:t}});return o.disposeIntermediateTensorInfo(b),o.disposeIntermediateTensorInfo(d),n}return b}const r=exports.cumprodConfig={kernelName:e.Cumprod,backendName:"cpu",kernelFunc:n};
},{"@tensorflow/tfjs-core":"kSBl","../cpu_util":"nVKy","./Transpose":"zFLV"}],"DpoM":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.cumsum=n,exports.cumsumConfig=void 0;var e=require("@tensorflow/tfjs-core"),t=require("../cpu_util"),s=require("./Transpose");function n(n){const{inputs:r,backend:o,attrs:a}=n,{x:u}=r,{axis:i,exclusive:c,reverse:p}=a;(0,t.assertNotComplex)(u,"cumsum");const l=e.backend_util.getAxesPermutation([i],u.shape.length);let m=u;null!=l&&(m=(0,s.transpose)({inputs:{x:u},backend:o,attrs:{perm:l}}));const d=e.backend_util.getInnerMostAxes(1,u.shape.length)[0];if(d!==m.shape.length-1)throw new Error("backend.cumsum in CPU expects an inner-most "+`axis=${m.shape.length-1} but got axis=${d}`);const h=(0,e.upcastType)(m.dtype,"int32"),x=e.util.makeZerosTypedArray(e.util.sizeFromShape(m.shape),h),f=o.data.get(m.dataId).values,g=m.shape[m.shape.length-1],k=p?(e,t)=>e+g-t-1:(e,t)=>e+t;for(let e=0;e<f.length;e+=g)for(let t=0;t<g;t++){const s=k(e,t);if(0===t)x[s]=c?0:f[s];else{const n=k(e,t-1);x[s]=c?f[n]+x[n]:f[s]+x[n]}}const b=o.makeTensorInfo(m.shape,h,x);if(null!=l){const t=e.backend_util.getUndoAxesPermutation(l),n=(0,s.transpose)({inputs:{x:b},backend:o,attrs:{perm:t}});return o.disposeIntermediateTensorInfo(b),o.disposeIntermediateTensorInfo(m),n}return b}const r=exports.cumsumConfig={kernelName:e.Cumsum,backendName:"cpu",kernelFunc:n};
},{"@tensorflow/tfjs-core":"kSBl","../cpu_util":"nVKy","./Transpose":"zFLV"}],"mHH1":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.denseBincount=t,exports.denseBincountConfig=void 0;var e=require("@tensorflow/tfjs-core"),n=require("./Bincount_impl");function t(e){const{inputs:t,backend:r,attrs:o}=e,{x:s,weights:u}=t,{size:a,binaryOutput:i}=o;if(1===s.shape.length){const e=r.data.get(s.dataId).values,t=r.data.get(u.dataId).values,o=(0,n.bincountImpl)(e,t,u.dtype,u.shape,a);return r.makeTensorInfo([a],u.dtype,o)}if(2===s.shape.length){const e=r.bufferSync(s),t=r.bufferSync(u),o=(0,n.bincountReduceImpl)(e,t,a,i);return r.makeTensorInfo(o.shape,u.dtype,o.values)}throw new Error("Error in denseBincount: input must be at most rank 2, but got rank"+`${s.shape.length}.`)}const r=exports.denseBincountConfig={kernelName:e.DenseBincount,backendName:"cpu",kernelFunc:t};
},{"@tensorflow/tfjs-core":"kSBl","./Bincount_impl":"cUUF"}],"O7Jf":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.depthToSpace=t,exports.depthToSpaceConfig=void 0;var e=require("@tensorflow/tfjs-core");function t(t){const{inputs:o,backend:a,attrs:r}=t,{x:s}=o,{blockSize:n,dataFormat:p}=r;e.util.assert("NHWC"===p,()=>`Only NHWC dataFormat supported on CPU for depthToSpace. Got ${p}`);const c=s.shape[0],l=s.shape[1],d=s.shape[2],f=s.shape[3],u=l*n,h=d*n,i=f/(n*n),k=a.data.get(s.dataId).values,S=new Float32Array(c*u*h*i);let T=0;for(let e=0;e<c;++e)for(let t=0;t<u;++t){const o=Math.floor(t/n),a=t%n;for(let t=0;t<h;++t){const r=Math.floor(t/n),s=(a*n+t%n)*i;for(let t=0;t<i;++t){const a=t+s+f*(r+d*(o+l*e));S[T++]=k[a]}}}return a.makeTensorInfo([c,u,h,i],s.dtype,S)}const o=exports.depthToSpaceConfig={kernelName:e.DepthToSpace,backendName:"cpu",kernelFunc:t};
},{"@tensorflow/tfjs-core":"kSBl"}],"nTCB":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.depthwiseConv2dNative=i,exports.depthwiseConv2dNativeConfig=void 0;var e=require("@tensorflow/tfjs-core"),t=require("../cpu_util");function i(i){const{inputs:s,backend:n,attrs:o}=i,{x:r,filter:d}=s,{strides:a,pad:l,dilations:u,dimRoundingMode:c}=o;(0,t.assertNotComplex)([r,d],"depthwiseConv2DNative");const h=e.util.computeStrides(r.shape),p=e.util.computeStrides(d.shape);let f=u;null==f&&(f=[1,1]),e.util.assert(e.backend_util.eitherStridesOrDilationsAreOne(a,f),()=>"Error in depthwiseConv2d: Either strides or dilations must be "+`1. Got strides ${a} and dilations '${f}'`);const v=e.backend_util.computeConv2DInfo(r.shape,d.shape,a,f,l,c,!0),{filterHeight:C,filterWidth:g,dilationHeight:m,dilationWidth:w,padInfo:N}=v,b=N.left,k=N.top,x=v.outChannels/v.inChannels,H=new e.TensorBuffer(v.outShape,r.dtype),I=n.data.get(r.dataId).values,S=n.data.get(d.dataId).values,W=H.values;for(let e=0;e<v.batchSize;++e){const t=e*h[0],i=e*H.strides[0];for(let e=0;e<v.outHeight;++e){const s=i+e*H.strides[1],n=e*v.strideHeight-k;for(let e=0;e<C;++e){const i=n+e*m;if(i<0||i>=v.inHeight)continue;const o=e*p[0],r=t+i*h[1];for(let e=0;e<v.outWidth;++e){const t=s+e*H.strides[2],i=e*v.strideWidth-b;for(let e=0;e<g;++e){const s=i+e*w;if(s<0||s>=v.inWidth)continue;const n=o+e*p[1],d=r+s*v.inChannels;let a=t,l=n;for(let e=0;e<v.inChannels;++e){const t=I[d+e];for(let e=0;e<x;++e)W[a+e]+=t*S[l+e];a+=x,l+=x}}}}}}return n.makeTensorInfo(H.shape,H.dtype,H.values)}const s=exports.depthwiseConv2dNativeConfig={kernelName:e.DepthwiseConv2dNative,backendName:"cpu",kernelFunc:i};
},{"@tensorflow/tfjs-core":"kSBl","../cpu_util":"nVKy"}],"KAed":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.depthwiseConv2dNativeBackpropFilter=o,exports.depthwiseConv2dNativeBackpropFilterConfig=void 0;var e=require("@tensorflow/tfjs-core"),t=require("../cpu_util");function o(o){const{inputs:a,backend:n,attrs:i}=o,{x:r,dy:s}=a,{strides:d,dilations:p,pad:l,dimRoundingMode:h,filterShape:c}=i;(0,t.assertNotComplex)([r,s],"depthwiseConv2dNativeBackpropFilter");const f=e.backend_util.computeConv2DInfo(r.shape,c,d,p,l,h,!0),{strideHeight:u,strideWidth:v,filterHeight:C,filterWidth:g}=f,k=new e.TensorBuffer(f.filterShape,"float32"),m=f.padInfo.left,w=f.padInfo.top,M=f.outChannels/f.inChannels,x=n.data.get(r.dataId).values,B=new e.TensorBuffer(r.shape,r.dtype,x),N=n.data.get(s.dataId).values,F=new e.TensorBuffer(s.shape,s.dtype,N);for(let e=0;e<C;++e){const t=Math.max(0,Math.ceil((w-e)/u)),o=Math.min(f.outHeight,(f.inHeight+w-e)/u);for(let a=0;a<g;++a){const n=Math.max(0,Math.ceil((m-a)/v)),i=Math.min(f.outWidth,(f.inWidth+m-a)/v);for(let r=0;r<f.outChannels;++r){const s=Math.trunc(r/M),d=r%M;let p=0;for(let l=0;l<f.batchSize;++l)for(let d=t;d<o;++d){const t=e+d*u-w;for(let e=n;e<i;++e){const o=a+e*v-m;p+=B.get(l,t,o,s)*F.get(l,d,e,r)}}k.set(p,e,a,s,d)}}}return n.makeTensorInfo(k.shape,k.dtype,k.values)}const a=exports.depthwiseConv2dNativeBackpropFilterConfig={kernelName:e.DepthwiseConv2dNativeBackpropFilter,backendName:"cpu",kernelFunc:o};
},{"@tensorflow/tfjs-core":"kSBl","../cpu_util":"nVKy"}],"O5E9":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.depthwiseConv2dNativeBackpropInput=o,exports.depthwiseConv2dNativeBackpropInputConfig=void 0;var e=require("@tensorflow/tfjs-core"),t=require("../cpu_util");function o(o){const{inputs:a,backend:i,attrs:n}=o,{dy:s,filter:p}=a,{strides:r,dilations:d,pad:u,dimRoundingMode:l,inputShape:c}=n;(0,t.assertNotComplex)([s,p],"depthwiseConv2DNativeBackpropInput");const h=e.util.computeStrides(s.shape),f=e.util.computeStrides(p.shape),v=e.backend_util.computeConv2DInfo(c,p.shape,r,d,u,l,!0),m=new e.TensorBuffer(v.inShape,"float32"),k=m.values,[C,I,g]=m.strides,M=i.data.get(s.dataId).values,[N,w,x]=h,B=i.data.get(p.dataId).values,[b,S,H]=f,{batchSize:W,filterHeight:_,filterWidth:y,inChannels:D,inHeight:j,inWidth:q,outChannels:T,outHeight:z,outWidth:F,strideHeight:O,strideWidth:P}=v,R=_-1-v.padInfo.top,A=y-1-v.padInfo.left,E=T/D;for(let e=0;e<W;++e)for(let t=0;t<D;++t)for(let o=0;o<j;++o){const a=o-R,i=Math.max(0,Math.ceil(a/O)),n=Math.min(z,(_+a)/O);for(let s=0;s<q;++s){const p=s-A,r=Math.max(0,Math.ceil(p/P)),d=Math.min(F,(y+p)/P);let u=0;for(let o=i;o<n;++o){const i=o*O-a;for(let a=r;a<d;++a){const n=N*e+w*o+x*a,s=b*(_-1-i)+S*(y-1-(a*P-p))+H*t;for(let e=0;e<E;++e){u+=M[n+(t*E+e)]*B[s+e]}}}k[C*e+I*o+g*s+t]=u}}return i.makeTensorInfo(m.shape,m.dtype,m.values)}const a=exports.depthwiseConv2dNativeBackpropInputConfig={kernelName:e.DepthwiseConv2dNativeBackpropInput,backendName:"cpu",kernelFunc:o};
},{"@tensorflow/tfjs-core":"kSBl","../cpu_util":"nVKy"}],"KIC9":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.diag=t,exports.diagConfig=void 0;var e=require("@tensorflow/tfjs-core");function t(t){const{inputs:a,backend:s}=t,{x:o}=a,r=e.util.sizeFromShape(o.shape),n=s.data.get(o.dataId).values,i=(0,e.buffer)([r,r],o.dtype),u=i.values;for(let e=0;e<n.length;e++)u[e*r+e]=n[e];const d=[...o.shape,...o.shape];return s.makeTensorInfo(d,i.dtype,i.values)}const a=exports.diagConfig={kernelName:e.Diag,backendName:"cpu",kernelFunc:t};
},{"@tensorflow/tfjs-core":"kSBl"}],"RutC":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.dilation2DConfig=void 0;var t=require("@tensorflow/tfjs-core");const e=exports.dilation2DConfig={kernelName:t.Dilation2D,backendName:"cpu",kernelFunc:({inputs:e,backend:i,attrs:o})=>{const{x:a,filter:l}=e,{strides:d,pad:n,dilations:r}=o,s=i,p=s.data.get(a.dataId).values,u=a.shape.length,h=s.data.get(l.dataId).values,c=l.shape.length,{batchSize:f,inHeight:g,inWidth:y,inChannels:I,outHeight:m,outWidth:x,padInfo:D,strideHeight:S,strideWidth:b,filterHeight:H,filterWidth:N,dilationHeight:T,dilationWidth:W,outShape:k}=t.backend_util.computeDilation2DInfo(a.shape,l.shape,d,n,"NHWC",r),v=t.util.sizeFromShape(k),_=k.length,C=t.util.getArrayFromDType(a.dtype,v);for(let F=0;F<f;++F)for(let e=0;e<m;++e){const i=e*S-D.top;for(let o=0;o<x;++o){const d=o*b-D.left;for(let n=0;n<I;++n){let r=Number.MIN_SAFE_INTEGER;for(let e=0;e<H;++e){const o=i+e*T;if(o>=0&&o<g)for(let i=0;i<N;++i){const s=d+i*W;if(s>=0&&s<y){const d=t.util.locToIndex([F,o,s,n],u,t.util.computeStrides(a.shape)),f=t.util.locToIndex([e,i,n],c,t.util.computeStrides(l.shape)),g=p[d]+h[f];g>r&&(r=g)}}}C[t.util.locToIndex([F,e,o,n],_,t.util.computeStrides(k))]=r}}}return{dataId:s.write(t.util.toTypedArray(C,a.dtype),k,a.dtype),shape:k,dtype:a.dtype}}};
},{"@tensorflow/tfjs-core":"kSBl"}],"SdQk":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.dilation2DBackpropFilterConfig=void 0;var t=require("@tensorflow/tfjs-core");const e=exports.dilation2DBackpropFilterConfig={kernelName:t.Dilation2DBackpropFilter,backendName:"cpu",kernelFunc:({inputs:e,backend:a,attrs:i})=>{const{x:r,filter:o,dy:d}=e,{strides:s,pad:l,dilations:n}=i,p=a,u=t.util.toNestedArray(r.shape,p.data.get(r.dataId).values),h=t.util.toNestedArray(o.shape,p.data.get(o.dataId).values),{batchSize:c,inHeight:f,inWidth:y,inChannels:g,outHeight:k,outWidth:N,padInfo:D,strideHeight:I,strideWidth:b,filterHeight:m,filterWidth:v,dilationHeight:A,dilationWidth:F,outShape:H}=t.backend_util.computeDilation2DInfo(r.shape,o.shape,s,l,"NHWC",n);t.util.assert(d.rank===H.length,()=>`Error in ${t.Dilation2DBackpropFilter}, dy `+`must have the same rank as output ${H.length}, but got `+`${d.rank}`);const W=t.util.toNestedArray(H,p.data.get(d.dataId).values),_=t.util.makeZerosNestedTypedArray(o.shape,o.dtype);for(let t=0;t<c;++t)for(let e=0;e<k;++e){const a=e*I-D.top;for(let i=0;i<N;++i){const r=i*b-D.left;for(let o=0;o<g;++o){let d=Number.MIN_SAFE_INTEGER,s=0,l=0;for(let e=0;e<m;++e){const i=a+e*A;if(i>=0&&i<f)for(let a=0;a<v;++a){const n=r+a*F;if(n>=0&&n<y){const r=u[t][i][n][o]+h[e][a][o];r>d&&(d=r,s=e,l=a)}}}_[s][l][o]+=W[t][e][i][o]}}}return{dataId:p.write(t.util.toTypedArray(_,r.dtype),o.shape,o.dtype),shape:o.shape,dtype:o.dtype}}};
},{"@tensorflow/tfjs-core":"kSBl"}],"Tml6":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.dilation2DBackpropInputConfig=void 0;var t=require("@tensorflow/tfjs-core");const e=exports.dilation2DBackpropInputConfig={kernelName:t.Dilation2DBackpropInput,backendName:"cpu",kernelFunc:({inputs:e,backend:a,attrs:i})=>{const{x:o,filter:r,dy:d}=e,{strides:n,pad:s,dilations:p}=i,l=a,u=t.util.toNestedArray(o.shape,l.data.get(o.dataId).values),h=t.util.toNestedArray(r.shape,l.data.get(r.dataId).values),{batchSize:c,inHeight:f,inWidth:y,inChannels:g,outHeight:k,outWidth:I,padInfo:N,strideHeight:D,strideWidth:b,filterHeight:m,filterWidth:v,dilationHeight:A,dilationWidth:H,outShape:W}=t.backend_util.computeDilation2DInfo(o.shape,r.shape,n,s,"NHWC",p);t.util.assert(d.rank===W.length,()=>`Error in ${t.Dilation2DBackpropInput}, dy `+`must have the same rank as output ${W.length}, but got `+`${d.rank}`);const _=t.util.toNestedArray(W,l.data.get(d.dataId).values),x=t.util.makeZerosNestedTypedArray(o.shape,o.dtype);for(let t=0;t<c;++t)for(let e=0;e<k;++e){const a=e*D-N.top;for(let i=0;i<I;++i){const o=i*b-N.left;for(let r=0;r<g;++r){let d=Number.MIN_SAFE_INTEGER,n=a<0?0:a,s=o<0?0:o;for(let e=0;e<m;++e){const i=a+e*A;if(i>=0&&i<f)for(let a=0;a<v;++a){const p=o+a*H;if(p>=0&&p<y){const o=u[t][i][p][r]+h[e][a][r];o>d&&(d=o,n=i,s=p)}}}x[t][n][s][r]+=_[t][e][i][r]}}}return{dataId:l.write(t.util.toTypedArray(x,o.dtype),o.shape,o.dtype),shape:o.shape,dtype:o.dtype}}};
},{"@tensorflow/tfjs-core":"kSBl"}],"umZe":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.draw=e,exports.drawConfig=void 0;var t=require("@tensorflow/tfjs-core");function e(t){const{inputs:e,backend:n,attrs:o}=t,{image:r}=e,{canvas:a,options:s}=o,{contextOptions:i,imageOptions:d}=s||{},u=(null==d?void 0:d.alpha)||1,l=(null==i?void 0:i.contextType)||"2d";if("2d"!==l)throw new Error(`Context type ${i.contextType} is not supported by the CPU backend.`);const c=a.getContext(l,(null==i?void 0:i.contextAttributes)||{});if(null==c)throw new Error(`Could not get the context with ${l} type.`);const[p,h]=r.shape.slice(0,2),f=2===r.shape.length?1:r.shape[2],w=n.data.get(r.dataId).values,g="float32"===r.dtype?255:1,x=new Uint8ClampedArray(h*p*4);for(let v=0;v<p*h;++v){const t=[0,0,0,255*u];for(let n=0;n<f;n++){const e=w[v*f+n];if("float32"===r.dtype){if(e<0||e>1)throw new Error("Tensor values for a float32 Tensor must be in the "+`range [0 - 1] but encountered ${e}.`)}else if("int32"===r.dtype&&(e<0||e>255))throw new Error("Tensor values for a int32 Tensor must be in the "+`range [0 - 255] but encountered ${e}.`);1===f?(t[0]=e*g,t[1]=e*g,t[2]=e*g):t[n]=e*g}const e=4*v;x[e+0]=Math.round(t[0]),x[e+1]=Math.round(t[1]),x[e+2]=Math.round(t[2]),x[e+3]=Math.round(t[3])}a.width=h,a.height=p;const b=new ImageData(x,h,p);return c.putImageData(b,0,0),r}const n=exports.drawConfig={kernelName:t.Draw,backendName:"cpu",kernelFunc:e};
},{"@tensorflow/tfjs-core":"kSBl"}],"EH1U":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.sum=o,exports.sumConfig=void 0;var e=require("@tensorflow/tfjs-core"),t=require("../cpu_util"),s=require("../utils/zeros_impl"),n=require("./Cast"),a=require("./Identity"),r=require("./Reshape"),i=require("./Transpose");function o(o){const{inputs:u,backend:p,attrs:d}=o,{x:l}=u,{axis:c,keepDims:m}=d;let x;(0,t.assertNotComplex)(l,"sum");const h=(x="bool"===l.dtype?(0,n.cast)({inputs:{x:l},backend:p,attrs:{dtype:"int32"}}):(0,a.identity)({inputs:{x:l},backend:p})).shape.length,k=e.util.parseAxisParam(c,x.shape),b=e.backend_util.getAxesPermutation(k,h);let f=k,I=x;null!=b&&(I=(0,i.transpose)({inputs:{x:x},backend:p,attrs:{perm:b}}),f=e.backend_util.getInnerMostAxes(f.length,h)),e.backend_util.assertAxesAreInnerMostDims("sum",f,I.shape.length);const[g,_]=e.backend_util.computeOutAndReduceShapes(I.shape,f),q=e.backend_util.upcastType(I.dtype,"int32");let y=(0,s.zeros)(p,g,q);const A=e.util.sizeFromShape(_),T=p.data.get(y.dataId).values,v=p.data.get(I.dataId).values;for(let e=0;e<T.length;++e){const t=e*A;let s=0;for(let e=0;e<A;++e)s+=v[t+e];T[e]=s}if(m){const t=e.backend_util.expandShapeToKeepDim(y.shape,k),s=y;y=(0,r.reshape)({inputs:{x:y},backend:p,attrs:{shape:t}}),p.disposeIntermediateTensorInfo(s)}return p.disposeIntermediateTensorInfo(x),null!=b&&p.disposeIntermediateTensorInfo(I),y}const u=exports.sumConfig={kernelName:e.Sum,backendName:"cpu",kernelFunc:o};
},{"@tensorflow/tfjs-core":"kSBl","../cpu_util":"nVKy","../utils/zeros_impl":"QgwK","./Cast":"Bp6G","./Identity":"nMAE","./Reshape":"FjS7","./Transpose":"zFLV"}],"MGE7":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.einsum=u,exports.einsumConfig=void 0;var e=require("@tensorflow/tfjs-core"),t=require("./Multiply"),s=require("./Reshape"),n=require("./Sum"),i=require("./Transpose");function u(u){const{inputs:r,backend:a,attrs:o}=u,{equation:l}=o,p=r,{allDims:c,summedDims:m,idDims:d}=e.backend_util.decodeEinsumEquation(l,p.length);e.backend_util.checkEinsumDimSizes(c.length,d,p);const{path:h,steps:k}=e.backend_util.getEinsumComputePath(m,d),b=k.length;let f=null,g=c.length;const x=[];for(let q=0;q<b;++q){for(const n of k[q]){const{permutationIndices:u,expandDims:r}=e.backend_util.getEinsumPermutation(g,d[n]);let o;e.backend_util.isIdentityPermutation(u)?o=p[n]:(o=(0,i.transpose)({inputs:{x:p[n]},backend:a,attrs:{perm:u}}),x.push(o));const l=o.shape.slice();for(let e=0;e<r.length;++e)l.splice(r[e],0,1);e.util.arraysEqual(o.shape,l)||(o=(0,s.reshape)({inputs:{x:o},backend:a,attrs:{shape:l}}),x.push(o)),null===f?f=o:(f=(0,t.multiply)({inputs:{a:o,b:f},backend:a}),x.push(f))}q<b-1&&(h[q]>=0&&(f=(0,n.sum)({inputs:{x:f},backend:a,attrs:{axis:h[q]-(c.length-g),keepDims:!1}}),x.push(f)),g--)}for(const e of x)e!==f&&a.disposeIntermediateTensorInfo(e);return f}const r=exports.einsumConfig={kernelName:e.Einsum,backendName:"cpu",kernelFunc:u};
},{"@tensorflow/tfjs-core":"kSBl","./Multiply":"N9Eb","./Reshape":"FjS7","./Sum":"EH1U","./Transpose":"zFLV"}],"sOra":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.eluGrad=a,exports.eluGradConfig=void 0;var e=require("@tensorflow/tfjs-core"),t=require("../cpu_util");function a(a){const{inputs:r,backend:o}=a,{dy:s,y:n}=r;(0,t.assertNotComplex)([s,n],"eluGrad");const u=new Float32Array(e.util.sizeFromShape(n.shape)),l=o.data.get(n.dataId).values,d=o.data.get(s.dataId).values;for(let e=0;e<l.length;++e){const t=l[e];u[e]=t>=0?d[e]:d[e]*(t+1)}return o.makeTensorInfo(n.shape,"float32",u)}const r=exports.eluGradConfig={kernelName:e.EluGrad,backendName:"cpu",kernelFunc:a};
},{"@tensorflow/tfjs-core":"kSBl","../cpu_util":"nVKy"}],"SuF1":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.erfConfig=exports.erf=void 0;var e=require("@tensorflow/tfjs-core"),r=require("../utils/unary_utils");const t=e.backend_util.ERF_P,n=e.backend_util.ERF_A1,u=e.backend_util.ERF_A2,a=e.backend_util.ERF_A3,i=e.backend_util.ERF_A4,s=e.backend_util.ERF_A5,c=exports.erf=(0,r.unaryKernelFunc)(e.Erf,e=>{const r=Math.sign(e),c=Math.abs(e),o=1/(1+t*c);return r*(1-((((s*o+i)*o+a)*o+u)*o+n)*o*Math.exp(-c*c))}),o=exports.erfConfig={kernelName:e.Erf,backendName:"cpu",kernelFunc:c};
},{"@tensorflow/tfjs-core":"kSBl","../utils/unary_utils":"kZAs"}],"B1EV":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.expandDims=t,exports.expandDimsConfig=void 0;var e=require("@tensorflow/tfjs-core"),s=require("./Reshape");function t(t){const{inputs:n,backend:r,attrs:i}=t,{input:a}=n,{dim:p}=i,o=a.shape.length,u=a.shape.slice();let c=p;return p<0&&(e.util.assert(-(o+1)<=p,()=>`Axis must be in the interval [${-(o+1)}, ${o}]`),c=o+p+1),u.splice(c,0,1),(0,s.reshape)({inputs:{x:a},backend:r,attrs:{shape:u}})}const n=exports.expandDimsConfig={kernelName:e.ExpandDims,backendName:"cpu",kernelFunc:t};
},{"@tensorflow/tfjs-core":"kSBl","./Reshape":"FjS7"}],"jPQU":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.realDivImpl=exports.realDivConfig=exports.div=void 0;var e=require("@tensorflow/tfjs-core"),r=require("../utils/binary_impl"),i=require("../utils/binary_utils");const l=exports.realDivImpl=(0,r.createSimpleBinaryKernelImpl)((e,r)=>e/r),t=exports.div=(0,i.binaryKernelFunc)(e.RealDiv,l),a=exports.realDivConfig={kernelName:e.RealDiv,backendName:"cpu",kernelFunc:t};
},{"@tensorflow/tfjs-core":"kSBl","../utils/binary_impl":"v0i6","../utils/binary_utils":"FLbP"}],"i85q":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.fftBatch=m,exports.fftImpl=p;var e=require("@tensorflow/tfjs-core"),n=require("../kernels/Add"),a=require("../kernels/Complex"),t=require("../kernels/Concat"),o=require("../kernels/Identity"),r=require("../kernels/Imag"),s=require("../kernels/Multiply"),i=require("../kernels/Real"),d=require("../kernels/RealDiv"),l=require("../kernels/Slice"),I=require("../kernels/Sub");function m(n,t,o){const r=n.shape,s=r[0],i=r[1],d=o.data.get(n.dataId),I=d.complexTensorInfos.real,m=d.complexTensorInfos.imag,f=[s,i],u=e.util.sizeFromShape(f),c=e.util.getTypedArrayFromDType("float32",u),T=e.util.getTypedArrayFromDType("float32",u);for(let x=0;x<s;x++){const n=(0,l.slice)({inputs:{x:I},backend:o,attrs:{begin:[x,0],size:[1,i]}}),r=(0,l.slice)({inputs:{x:m},backend:o,attrs:{begin:[x,0],size:[1,i]}}),s=(0,a.complex)({inputs:{real:n,imag:r},backend:o}),{real:d,imag:f}=p(s,t,o),u=e.backend_util.mergeRealAndImagArrays(d,f);for(let a=0;a<i;a++){const n=e.backend_util.getComplexWithIndex(u,a);c[x*i+a]=n.real,T[x*i+a]=n.imag}o.disposeIntermediateTensorInfo(n),o.disposeIntermediateTensorInfo(r),o.disposeIntermediateTensorInfo(s)}const k=o.makeTensorInfo(f,"float32",c),g=o.makeTensorInfo(f,"float32",T),b=(0,a.complex)({inputs:{real:k,imag:g},backend:o});return o.disposeIntermediateTensorInfo(k),o.disposeIntermediateTensorInfo(g),b}function p(n,a,t){const r=e.util.sizeFromShape(n.shape),s=t.data.get(n.dataId),i=t.data.get(s.complexTensorInfos.real.dataId).values,l=t.data.get(s.complexTensorInfos.imag.dataId).values;if(f(r)){const s=u(i,l,r,a,t),I=[n.shape[0],n.shape[1]];if(a){const n=t.makeTensorInfo(I,"float32",s.real),a=t.makeTensorInfo(I,"float32",s.imag),i=t.makeTensorInfo([],"float32",e.util.createScalarValue(r,"float32")),l=(0,o.identity)({inputs:{x:i},backend:t}),m=d.realDivConfig.kernelFunc({inputs:{a:n,b:i},backend:t}),p=d.realDivConfig.kernelFunc({inputs:{a:a,b:l},backend:t}),f=t.data.get(m.dataId).values,u=t.data.get(p.dataId).values;return t.disposeIntermediateTensorInfo(n),t.disposeIntermediateTensorInfo(a),t.disposeIntermediateTensorInfo(i),t.disposeIntermediateTensorInfo(l),t.disposeIntermediateTensorInfo(m),t.disposeIntermediateTensorInfo(p),{real:f,imag:u}}return s}{const n=c(e.backend_util.mergeRealAndImagArrays(i,l),r,a);return e.backend_util.splitRealAndImagArrays(n)}}function f(e){return 0==(e&e-1)}function u(o,d,l,m,p){if(1===l)return{real:o,imag:d};const f=e.backend_util.mergeRealAndImagArrays(o,d),c=l/2,T=e.backend_util.complexWithEvenIndex(f),k=T.real,g=T.imag,b=[k.length],x=p.makeTensorInfo(b,"float32",k),y=p.makeTensorInfo(b,"float32",g),h=(0,a.complex)({inputs:{real:x,imag:y},backend:p}),A=e.backend_util.complexWithOddIndex(f),_=A.real,v=A.imag,q=[_.length],F=p.makeTensorInfo(q,"float32",_),C=p.makeTensorInfo(q,"float32",v),R=(0,a.complex)({inputs:{real:F,imag:C},backend:p}),D=u(k,g,c,m,p),S=D.real,z=D.imag,W=[S.length],j=p.makeTensorInfo(W,"float32",S),w=p.makeTensorInfo(W,"float32",z),M=(0,a.complex)({inputs:{real:j,imag:w},backend:p}),O=u(_,v,c,m,p),B=O.real,E=O.imag,P=[B.length],V=p.makeTensorInfo(P,"float32",B),G=p.makeTensorInfo(P,"float32",E),H=(0,a.complex)({inputs:{real:V,imag:G},backend:p}),J=e.backend_util.exponents(l,m),K=[J.real.length],L=p.makeTensorInfo(K,"float32",J.real),N=p.makeTensorInfo(K,"float32",J.imag),Q=(0,a.complex)({inputs:{real:L,imag:N},backend:p}),U=(0,s.multiply)({inputs:{a:Q,b:H},backend:p}),X=(0,n.add)({inputs:{a:M,b:U},backend:p}),Y=(0,I.sub)({inputs:{a:M,b:U},backend:p}),Z=(0,i.real)({inputs:{input:X},backend:p}),$=(0,i.real)({inputs:{input:Y},backend:p}),ee=(0,r.imag)({inputs:{input:X},backend:p}),ne=(0,r.imag)({inputs:{input:Y},backend:p}),ae=(0,t.concat)({inputs:[Z,$],backend:p,attrs:{axis:0}}),te=(0,t.concat)({inputs:[ee,ne],backend:p,attrs:{axis:0}}),oe=p.data.get(ae.dataId).values,re=p.data.get(te.dataId).values;return p.disposeIntermediateTensorInfo(x),p.disposeIntermediateTensorInfo(y),p.disposeIntermediateTensorInfo(h),p.disposeIntermediateTensorInfo(F),p.disposeIntermediateTensorInfo(C),p.disposeIntermediateTensorInfo(R),p.disposeIntermediateTensorInfo(j),p.disposeIntermediateTensorInfo(w),p.disposeIntermediateTensorInfo(M),p.disposeIntermediateTensorInfo(V),p.disposeIntermediateTensorInfo(G),p.disposeIntermediateTensorInfo(H),p.disposeIntermediateTensorInfo(L),p.disposeIntermediateTensorInfo(N),p.disposeIntermediateTensorInfo(Q),p.disposeIntermediateTensorInfo(U),p.disposeIntermediateTensorInfo(X),p.disposeIntermediateTensorInfo(Y),p.disposeIntermediateTensorInfo(Z),p.disposeIntermediateTensorInfo(ee),p.disposeIntermediateTensorInfo($),p.disposeIntermediateTensorInfo(ne),p.disposeIntermediateTensorInfo(ae),p.disposeIntermediateTensorInfo(te),{real:oe,imag:re}}function c(n,a,t){const o=new Float32Array(2*a);for(let r=0;r<a;r++){let s=0,i=0;for(let o=0;o<a;o++){const d=e.backend_util.exponent(r*o,a,t),l=e.backend_util.getComplexWithIndex(n,o);s+=l.real*d.real-l.imag*d.imag,i+=l.real*d.imag+l.imag*d.real}t&&(s/=a,i/=a),e.backend_util.assignToTypedArray(o,s,i,r)}return o}
},{"@tensorflow/tfjs-core":"kSBl","../kernels/Add":"ZBkJ","../kernels/Complex":"KmEe","../kernels/Concat":"ZWVG","../kernels/Identity":"nMAE","../kernels/Imag":"YWMY","../kernels/Multiply":"N9Eb","../kernels/Real":"icBn","../kernels/RealDiv":"jPQU","../kernels/Slice":"i6mc","../kernels/Sub":"fBFg"}],"km8M":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.fft=r,exports.fftConfig=void 0;var e=require("@tensorflow/tfjs-core"),t=require("../utils/fft_utils"),s=require("./Reshape");function r(r){const{inputs:n,backend:a}=r,{input:o}=n,p=e.util.sizeFromShape(o.shape),i=o.shape[o.shape.length-1],f=p/i,u=(0,s.reshape)({inputs:{x:o},backend:a,attrs:{shape:[f,i]}}),c=(0,t.fftBatch)(u,!1,a),h=(0,s.reshape)({inputs:{x:c},backend:a,attrs:{shape:o.shape}});return a.disposeIntermediateTensorInfo(u),a.disposeIntermediateTensorInfo(c),h}const n=exports.fftConfig={kernelName:e.FFT,backendName:"cpu",kernelFunc:r};
},{"@tensorflow/tfjs-core":"kSBl","../utils/fft_utils":"i85q","./Reshape":"FjS7"}],"Iz4a":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.fill=r,exports.fillConfig=void 0;var e=require("@tensorflow/tfjs-core");function r(r){const{backend:t,attrs:l}=r,{shape:n,value:i,dtype:s}=l,f=s||e.util.inferDtype(i),u=e.util.getArrayFromDType(f,e.util.sizeFromShape(n));return o(u,i,f),t.makeTensorInfo(n,f,u)}const t=exports.fillConfig={kernelName:e.Fill,backendName:"cpu",kernelFunc:r};function o(e,r,t){e.fill(r)}
},{"@tensorflow/tfjs-core":"kSBl"}],"jKep":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.flipLeftRightConfig=void 0;var e=require("@tensorflow/tfjs-core");const t=exports.flipLeftRightConfig={kernelName:e.FlipLeftRight,backendName:"cpu",kernelFunc:({inputs:t,attrs:r,backend:o})=>{const{image:a}=t,s=o,p=e.util.getTypedArrayFromDType(a.dtype,e.util.sizeFromShape(a.shape)),[i,n,d,l]=a.shape,f=s.data.get(a.dataId).values;for(let e=0;e<i;e++){const t=e*d*n*l;for(let e=0;e<n;e++){const r=e*(d*l);for(let e=0;e<d;e++){const o=e*l;for(let a=0;a<l;a++){const s=Math.round(d-e-1),i=t+r+o+a;let n=f[i];if(s>=0&&s<d){n=f[t+r+s*l+a]}p[i]=n}}}}return{dataId:s.write(p,a.shape,a.dtype),shape:a.shape,dtype:a.dtype}}};
},{"@tensorflow/tfjs-core":"kSBl"}],"zTKt":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.fusedConv2D=i,exports.fusedConv2DConfig=void 0;var e=require("@tensorflow/tfjs-core"),s=require("../utils/fused_utils"),t=require("./Add"),n=require("./Conv2D"),a=require("./Reshape");function i(e){const{inputs:i,backend:o,attrs:r}=e,{x:d,filter:p,bias:u,preluActivationWeights:c}=i,{strides:l,pad:f,dataFormat:h,dilations:v,dimRoundingMode:b,activation:k,leakyreluAlpha:m}=r;let C=(0,n.conv2D)({inputs:{x:d,filter:p},backend:o,attrs:{strides:l,pad:f,dataFormat:h,dilations:v,dimRoundingMode:b}});if(u){const e=C;if("NCHW"===h&&1===u.shape.length&&1!==u.shape[0]){const e=(0,a.reshape)({inputs:{x:u},backend:o,attrs:{shape:[u.shape[0],1,1]}});C=(0,t.add)({inputs:{a:C,b:e},backend:o}),o.disposeIntermediateTensorInfo(e)}else C=(0,t.add)({inputs:{a:C,b:u},backend:o});o.disposeIntermediateTensorInfo(e)}if(k){const e=C;if("NCHW"===h&&"prelu"===k&&1===c.shape.length&&1!==c.shape[0]){const e=(0,a.reshape)({inputs:{x:c},backend:o,attrs:{shape:[c.shape[0],1,1]}});C=(0,s.applyActivation)(o,C,k,e,m),o.disposeIntermediateTensorInfo(e)}else C=(0,s.applyActivation)(o,C,k,c,m);o.disposeIntermediateTensorInfo(e)}return C}const o=exports.fusedConv2DConfig={kernelName:e.FusedConv2D,backendName:"cpu",kernelFunc:i};
},{"@tensorflow/tfjs-core":"kSBl","../utils/fused_utils":"x15i","./Add":"ZBkJ","./Conv2D":"E2Vg","./Reshape":"FjS7"}],"zu78":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.fusedDepthwiseConv2D=n,exports.fusedDepthwiseConv2DConfig=void 0;var e=require("@tensorflow/tfjs-core"),t=require("../utils/fused_utils"),i=require("./Add"),s=require("./DepthwiseConv2dNative");function n(e){const{inputs:n,backend:o,attrs:d}=e,{x:r,filter:a,bias:u,preluActivationWeights:p}=n,{strides:c,pad:l,dataFormat:f,dilations:v,dimRoundingMode:D,activation:h,leakyreluAlpha:m}=d;let C=(0,s.depthwiseConv2dNative)({inputs:{x:r,filter:a},backend:o,attrs:{strides:c,pad:l,dataFormat:f,dilations:v,dimRoundingMode:D}});if(u){const e=C;C=(0,i.add)({inputs:{a:C,b:u},backend:o}),o.disposeIntermediateTensorInfo(e)}if(h){const e=C;C=(0,t.applyActivation)(o,C,h,p,m),o.disposeIntermediateTensorInfo(e)}return C}const o=exports.fusedDepthwiseConv2DConfig={kernelName:e.FusedDepthwiseConv2D,backendName:"cpu",kernelFunc:n};
},{"@tensorflow/tfjs-core":"kSBl","../utils/fused_utils":"x15i","./Add":"ZBkJ","./DepthwiseConv2dNative":"nTCB"}],"eygj":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.gatherNd=t,exports.gatherNdConfig=void 0;var e=require("@tensorflow/tfjs-core"),r=require("./GatherNd_Impl");function t(t){const{inputs:a,backend:n}=t,{params:s,indices:d}=a,o=e.util.sizeFromShape(s.shape),p=d.shape,i=p[p.length-1],[u,c,l,f]=e.backend_util.prepareAndValidate(s,d);if(0===c)return n.makeTensorInfo(u,s.dtype,[]);const h=n.data.get(d.dataId).values,g=n.bufferSync(s),m=(0,r.gatherNdImpl)(h,g,s.dtype,c,i,l,f,s.shape,o);return n.makeTensorInfo(u,s.dtype,m.values)}const a=exports.gatherNdConfig={kernelName:e.GatherNd,backendName:"cpu",kernelFunc:t};
},{"@tensorflow/tfjs-core":"kSBl","./GatherNd_Impl":"kXTU"}],"ZMn5":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.gatherV2=s,exports.gatherV2Config=void 0;var e=require("@tensorflow/tfjs-core"),t=require("../cpu_util"),a=require("./GatherV2_impl"),r=require("./Reshape");function s(s){const{inputs:i,backend:n,attrs:o}=s,{x:u,indices:c}=i,{axis:p,batchDims:h}=o;(0,t.assertNotComplex)([u,c],"gatherV2");const l=e.util.parseAxisParam(p,u.shape)[0],d=n.data.get(c.dataId).values,f=u.shape[l];for(let t=0;t<d.length;++t){const a=d[t];e.util.assert(a<=f-1&&a>=0,()=>`GatherV2: the index value ${a} is not in [0, ${f-1}]`)}let S=h;null==h&&(S=0);const b=e.util.sizeFromShape(c.shape),m=e.backend_util.segment_util.collectGatherOpShapeInfo(u,c,l,S),x=(0,r.reshape)({inputs:{x:u},backend:n,attrs:{shape:[m.batchSize,m.outerSize,m.dimSize,m.sliceSize]}}),z=(0,r.reshape)({inputs:{x:c},backend:n,attrs:{shape:[m.batchSize,b/m.batchSize]}}),g=[m.batchSize,m.outerSize,b/m.batchSize,m.sliceSize],k=n.bufferSync(z),I=n.bufferSync(x),V=(0,a.gatherV2Impl)(I,k,g);return n.disposeIntermediateTensorInfo(x),n.disposeIntermediateTensorInfo(z),n.makeTensorInfo(m.outputShape,V.dtype,V.values)}const i=exports.gatherV2Config={kernelName:e.GatherV2,backendName:"cpu",kernelFunc:s};
},{"@tensorflow/tfjs-core":"kSBl","../cpu_util":"nVKy","./GatherV2_impl":"Ea37","./Reshape":"FjS7"}],"NGLg":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.ifft=r,exports.ifftConfig=void 0;var e=require("@tensorflow/tfjs-core"),t=require("../utils/fft_utils"),s=require("./Reshape");function r(r){const{inputs:n,backend:i}=r,{input:a}=n,o=e.util.sizeFromShape(a.shape),p=a.shape[a.shape.length-1],f=o/p,u=(0,s.reshape)({inputs:{x:a},backend:i,attrs:{shape:[f,p]}}),c=(0,t.fftBatch)(u,!0,i),h=(0,s.reshape)({inputs:{x:c},backend:i,attrs:{shape:a.shape}});return i.disposeIntermediateTensorInfo(u),i.disposeIntermediateTensorInfo(c),h}const n=exports.ifftConfig={kernelName:e.IFFT,backendName:"cpu",kernelFunc:r};
},{"@tensorflow/tfjs-core":"kSBl","../utils/fft_utils":"i85q","./Reshape":"FjS7"}],"dRYN":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.isFiniteConfig=exports.isFinite=void 0;var e=require("@tensorflow/tfjs-core"),i=require("../utils/unary_utils");const r=exports.isFinite=(0,i.unaryKernelFunc)(e.IsFinite,e=>Number.isFinite(e)?1:0,"bool"),t=exports.isFiniteConfig={kernelName:e.IsFinite,backendName:"cpu",kernelFunc:r};
},{"@tensorflow/tfjs-core":"kSBl","../utils/unary_utils":"kZAs"}],"mqmg":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.isInfConfig=exports.isInf=void 0;var e=require("@tensorflow/tfjs-core"),r=require("../utils/unary_utils");const s=exports.isInf=(0,r.unaryKernelFunc)(e.IsInf,e=>Math.abs(e)===1/0?1:0,"bool"),n=exports.isInfConfig={kernelName:e.IsInf,backendName:"cpu",kernelFunc:s};
},{"@tensorflow/tfjs-core":"kSBl","../utils/unary_utils":"kZAs"}],"aZ2V":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.isNaNConfig=exports.isNaN=void 0;var e=require("@tensorflow/tfjs-core"),r=require("../utils/unary_utils");const s=exports.isNaN=(0,r.unaryKernelFunc)(e.IsNan,e=>Number.isNaN(e)?1:0,"bool"),o=exports.isNaNConfig={kernelName:e.IsNan,backendName:"cpu",kernelFunc:s};
},{"@tensorflow/tfjs-core":"kSBl","../utils/unary_utils":"kZAs"}],"MgCL":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.linSpace=r,exports.linSpaceConfig=void 0;var e=require("@tensorflow/tfjs-core"),n=require("./LinSpace_impl");function r(e){const{backend:r,attrs:t}=e,{start:o,stop:a,num:c}=t,i=(0,n.linSpaceImpl)(o,a,c);return r.makeTensorInfo([i.length],"float32",i)}const t=exports.linSpaceConfig={kernelName:e.LinSpace,backendName:"cpu",kernelFunc:r};
},{"@tensorflow/tfjs-core":"kSBl","./LinSpace_impl":"BmUg"}],"ZPXk":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.log1pConfig=exports.log1p=void 0;var e=require("@tensorflow/tfjs-core"),o=require("../utils/unary_utils");const r=exports.log1p=(0,o.unaryKernelFunc)(e.Log1p,e=>Math.log1p(e)),t=exports.log1pConfig={kernelName:e.Log1p,backendName:"cpu",kernelFunc:r};
},{"@tensorflow/tfjs-core":"kSBl","../utils/unary_utils":"kZAs"}],"Jrk0":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.logicalAndImpl=exports.logicalAndConfig=exports.logicalAnd=void 0;var e=require("@tensorflow/tfjs-core"),l=require("../utils/binary_impl"),r=require("../utils/binary_utils");const o=exports.logicalAndImpl=(0,l.createSimpleBinaryKernelImpl)((e,l)=>e&&l),i=exports.logicalAnd=(0,r.binaryKernelFunc)(e.LogicalAnd,o,null,"bool"),n=exports.logicalAndConfig={kernelName:e.LogicalAnd,backendName:"cpu",kernelFunc:i};
},{"@tensorflow/tfjs-core":"kSBl","../utils/binary_impl":"v0i6","../utils/binary_utils":"FLbP"}],"c1HV":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.logicalNotConfig=exports.logicalNot=void 0;var e=require("@tensorflow/tfjs-core"),o=require("../utils/unary_utils");const r=exports.logicalNot=(0,o.unaryKernelFunc)(e.LogicalNot,e=>e?0:1,"bool"),t=exports.logicalNotConfig={kernelName:e.LogicalNot,backendName:"cpu",kernelFunc:r};
},{"@tensorflow/tfjs-core":"kSBl","../utils/unary_utils":"kZAs"}],"CEVP":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.logicalOrImpl=exports.logicalOrConfig=exports.logicalOr=void 0;var e=require("@tensorflow/tfjs-core"),r=require("../utils/binary_impl"),l=require("../utils/binary_utils");const o=exports.logicalOrImpl=(0,r.createSimpleBinaryKernelImpl)((e,r)=>e||r),i=exports.logicalOr=(0,l.binaryKernelFunc)(e.LogicalOr,o,null,"bool"),a=exports.logicalOrConfig={kernelName:e.LogicalOr,backendName:"cpu",kernelFunc:i};
},{"@tensorflow/tfjs-core":"kSBl","../utils/binary_impl":"v0i6","../utils/binary_utils":"FLbP"}],"tpLL":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.LRNConfig=void 0,exports.lRN=o;var e=require("@tensorflow/tfjs-core"),t=require("../cpu_util");function o(o){const{inputs:a,backend:r,attrs:s}=o,{x:n}=a,{depthRadius:c,bias:p,alpha:u,beta:i}=s;(0,t.assertNotComplex)(n,"LRN");const l=n.shape[3],d=l-1,f=r.data.get(n.dataId).values,h=e.util.sizeFromShape(n.shape),N=new Float32Array(h);function m(e){const t=e%l;let o=e-t+Math.max(0,t-c);const a=e-t+Math.min(t+c,d);let r=0;for(;o<=a;o++){const e=f[o];r+=e*e}return r}for(let e=0;e<h;e++){const t=m(e),o=f[e]*Math.pow(p+u*t,-i);N[e]=o}return r.makeTensorInfo(n.shape,n.dtype,N)}const a=exports.LRNConfig={kernelName:e.LRN,backendName:"cpu",kernelFunc:o};
},{"@tensorflow/tfjs-core":"kSBl","../cpu_util":"nVKy"}],"AaA7":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.LRNGradConfig=void 0,exports.lRNGrad=t;var e=require("@tensorflow/tfjs-core"),a=require("../cpu_util");function t(t){const{inputs:r,backend:o,attrs:s}=t,{x:d,y:n,dy:l}=r,{depthRadius:p,bias:u,alpha:i,beta:c}=s;(0,a.assertNotComplex)(l,"LRNGrad");const f=e.util.sizeFromShape(l.shape),h=l.shape[3],N=o.data.get(l.dataId).values,m=o.data.get(d.dataId).values,x=o.data.get(n.dataId).values,v=new Float32Array(f),R=f;for(let e=0;e<R;e++){const a=e%h,t=e-a+Math.max(0,a-p),r=e-a+Math.min(h,a+p+1);let o=0;for(let e=t;e<r;e++)o+=Math.pow(m[e],2);o=i*o+u;for(let s=t;s<r;s++){let a=-2*i*c*m[s]*x[e]/o;e===s&&(a+=Math.pow(o,-c)),a*=N[e],v[s]+=a}}return o.makeTensorInfo(l.shape,d.dtype,v)}const r=exports.LRNGradConfig={kernelName:e.LRNGrad,backendName:"cpu",kernelFunc:t};
},{"@tensorflow/tfjs-core":"kSBl","../cpu_util":"nVKy"}],"MqGL":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.max=s,exports.maxConfig=void 0;var e=require("@tensorflow/tfjs-core"),t=require("../cpu_util"),a=require("./Max_impl"),n=require("./Transpose_impl");function s(s){const{inputs:r,backend:i,attrs:o}=s,{x:p}=r,{reductionIndices:l,keepDims:u}=o,d=i;let c=p.shape;const m=c.length,x=e.util.parseAxisParam(l,c);let k=x;const _=e.backend_util.getAxesPermutation(k,m);let f=d.data.get(p.dataId).values;if(null!=_){const t=new Array(m);for(let e=0;e<t.length;e++)t[e]=c[_[e]];f=(0,n.transposeImpl)(f,c,p.dtype,_,t),k=e.backend_util.getInnerMostAxes(k.length,m),c=t}(0,t.assertNotComplex)(p,"max"),e.backend_util.assertAxesAreInnerMostDims("max",k,m);const[b,g]=e.backend_util.computeOutAndReduceShapes(c,k),h=e.util.sizeFromShape(g),y=(0,a.maxImpl)(f,h,b,p.dtype),A=d.write(y,b,p.dtype);let I=b;if(u){I=e.backend_util.expandShapeToKeepDim(b,x)}return{dataId:A,shape:I,dtype:p.dtype}}const r=exports.maxConfig={kernelName:e.Max,backendName:"cpu",kernelFunc:s};
},{"@tensorflow/tfjs-core":"kSBl","../cpu_util":"nVKy","./Max_impl":"Db4x","./Transpose_impl":"fDvd"}],"lCs9":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.maxPool=r,exports.maxPoolConfig=void 0;var e=require("@tensorflow/tfjs-core"),t=require("../cpu_util"),o=require("../utils/pool_utils"),i=require("./Identity");function r(r){const{inputs:s,backend:a,attrs:n}=r,{x:l}=s;(0,t.assertNotComplex)(l,"maxPool");const{filterSize:u,strides:d,pad:p,dimRoundingMode:c}=n;e.util.assert(e.backend_util.eitherStridesOrDilationsAreOne(d,1),()=>"Error in maxPool: Either strides or dilations must be 1. "+`Got strides ${d} and dilations '1'`);const m=e.backend_util.computePool2DInfo(l.shape,u,d,1,p,c);let x;if(1===m.filterWidth&&1===m.filterHeight&&e.util.arraysEqual(m.inShape,m.outShape))x=(0,i.identity)({inputs:{x:l},backend:a});else{const t=a.data.get(l.dataId).values,i=e.util.computeStrides(l.shape),r=(0,o.pool)(t,l.shape,l.dtype,i,m,"max");x=a.makeTensorInfo(m.outShape,l.dtype,r.values)}return x}const s=exports.maxPoolConfig={kernelName:e.MaxPool,backendName:"cpu",kernelFunc:r};
},{"@tensorflow/tfjs-core":"kSBl","../cpu_util":"nVKy","../utils/pool_utils":"ds2d","./Identity":"nMAE"}],"o8AC":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.maxPool3D=a,exports.maxPool3DConfig=void 0;var e=require("@tensorflow/tfjs-core"),o=require("../cpu_util"),t=require("../utils/pool_utils");function a(a){const{inputs:s,backend:r,attrs:l}=a,{x:n}=s,{filterSize:u,strides:i,pad:d,dimRoundingMode:p,dataFormat:c}=l;(0,o.assertNotComplex)(n,"maxPool3d");const m=e.backend_util.computePool3DInfo(n.shape,u,i,1,d,p,c),x=r.data.get(n.dataId).values,f=(0,t.pool3d)(x,n.shape,n.dtype,e.util.computeStrides(n.shape),m,"max");return r.makeTensorInfo(f.shape,"float32",f.values)}const s=exports.maxPool3DConfig={kernelName:e.MaxPool3D,backendName:"cpu",kernelFunc:a};
},{"@tensorflow/tfjs-core":"kSBl","../cpu_util":"nVKy","../utils/pool_utils":"ds2d"}],"zcv3":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.maxPool3DGrad=i,exports.maxPool3DGradConfig=void 0;var e=require("@tensorflow/tfjs-core"),t=require("../cpu_util"),o=require("../utils/pool_utils");function i(i){const{inputs:r,backend:n,attrs:f}=i,{dy:l,input:a}=r,{filterSize:s,strides:d,pad:u,dimRoundingMode:c}=f;(0,t.assertNotComplex)([l,a],"maxPool3DGrad");const p=e.backend_util.computePool3DInfo(a.shape,s,d,1,u,c),h=n.bufferSync(a),m=(0,o.maxPool3dPositions)(h,p),x=p.strideDepth,D=p.strideHeight,g=p.strideWidth,P=p.dilationDepth,b=p.dilationHeight,v=p.dilationWidth,k=p.effectiveFilterDepth,M=p.effectiveFilterHeight,y=p.effectiveFilterWidth,G=k-1-p.padInfo.front,H=y-1-p.padInfo.left,I=M-1-p.padInfo.top,W=(0,e.buffer)(a.shape,"float32"),_=n.bufferSync(l);for(let e=0;e<p.batchSize;++e)for(let t=0;t<p.inChannels;++t)for(let o=0;o<p.inDepth;++o)for(let i=0;i<p.inHeight;++i)for(let r=0;r<p.inWidth;++r){const n=o-G,f=i-I,l=r-H;let a=0;for(let o=0;o<k;o+=P){const i=(n+o)/x;if(!(i<0||i>=p.outDepth||Math.floor(i)!==i))for(let r=0;r<M;r+=b){const n=(f+r)/D;if(!(n<0||n>=p.outHeight||Math.floor(n)!==n))for(let f=0;f<y;f+=v){const s=(l+f)/g;if(s<0||s>=p.outWidth||Math.floor(s)!==s)continue;const d=k*M*y-1-m.get(e,i,n,s,t)===o*M*y+r*y+f?1:0;0!==d&&(a+=_.get(e,i,n,s,t)*d)}}}W.set(a,e,o,i,r,t)}return n.makeTensorInfo(W.shape,W.dtype,W.values)}const r=exports.maxPool3DGradConfig={kernelName:e.MaxPool3DGrad,backendName:"cpu",kernelFunc:i};
},{"@tensorflow/tfjs-core":"kSBl","../cpu_util":"nVKy","../utils/pool_utils":"ds2d"}],"vVVK":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.maxPoolGrad=a,exports.maxPoolGradConfig=void 0;var e=require("@tensorflow/tfjs-core"),t=require("../cpu_util"),o=require("../utils/pool_utils");function a(a){const{inputs:i,backend:r,attrs:l}=a,{dy:s,input:n,output:d}=i,f=n;(0,t.assertNotComplex)([n,d],"maxPoolGrad");const{filterSize:u,strides:p,pad:c,dimRoundingMode:h}=l,g=e.backend_util.computePool2DInfo(f.shape,u,p,1,c,h),m=r.data.get(f.dataId).values,x=(0,e.buffer)(g.outShape,f.dtype,(0,o.maxPoolPositions)(m,f.shape,f.dtype,g).values),v=g.strideHeight,P=g.strideWidth,b=g.dilationHeight,k=g.dilationWidth,I=g.effectiveFilterHeight,y=g.effectiveFilterWidth,G=y-1-g.padInfo.left,H=I-1-g.padInfo.top,M=(0,e.buffer)(f.shape,"float32"),W=r.data.get(s.dataId).values,_=(0,e.buffer)(s.shape,"float32",W);for(let e=0;e<g.batchSize;++e)for(let t=0;t<g.inChannels;++t)for(let o=0;o<g.inHeight;++o)for(let a=0;a<g.inWidth;++a){const i=o-H,r=a-G;let l=0;for(let o=0;o<I;o+=b){const a=(i+o)/v;if(!(a<0||a>=g.outHeight||Math.floor(a)!==a))for(let i=0;i<y;i+=k){const s=(r+i)/P;if(s<0||s>=g.outWidth||Math.floor(s)!==s)continue;const n=I*y-1-x.get(e,a,s,t)===o*y+i?1:0;0!==n&&(l+=_.get(e,a,s,t)*n)}}M.set(l,e,o,a,t)}return r.makeTensorInfo(M.shape,M.dtype,M.values)}const i=exports.maxPoolGradConfig={kernelName:e.MaxPoolGrad,backendName:"cpu",kernelFunc:a};
},{"@tensorflow/tfjs-core":"kSBl","../cpu_util":"nVKy","../utils/pool_utils":"ds2d"}],"zztO":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.maxPoolWithArgmaxImpl=t;var e=require("@tensorflow/tfjs-core"),o=require("../utils/pool_utils");function t(t,r,s,l,u){const i=e.util.computeStrides(r),a=(0,o.pool)(t,r,s,i,u,"max"),n=(0,o.maxPoolPositions)(t,r,s,u,!0,l);return[a.values,n.values]}
},{"@tensorflow/tfjs-core":"kSBl","../utils/pool_utils":"ds2d"}],"jYjX":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.maxPoolWithArgmaxConfig=void 0;var e=require("@tensorflow/tfjs-core"),t=require("../cpu_util"),a=require("./MaxPoolWithArgmax_impl");const o=exports.maxPoolWithArgmaxConfig={kernelName:e.MaxPoolWithArgmax,backendName:"cpu",kernelFunc:({inputs:o,attrs:r,backend:p})=>{const{x:i}=o,{filterSize:d,strides:s,pad:l,includeBatchInIndex:n}=r,u=p;(0,t.assertNotComplex)(i,"MaxPoolWithArgmax");const x=u.data.get(i.dataId).values,c=e.backend_util.computePool2DInfo(i.shape,d,s,[1,1],l),[h,m]=(0,a.maxPoolWithArgmaxImpl)(x,i.shape,i.dtype,n,c),g=u.write(h,c.outShape,i.dtype),P=u.write(m,c.outShape,i.dtype);return[{dataId:g,shape:c.outShape,dtype:i.dtype},{dataId:P,shape:c.outShape,dtype:"int32"}]}};
},{"@tensorflow/tfjs-core":"kSBl","../cpu_util":"nVKy","./MaxPoolWithArgmax_impl":"zztO"}],"Imwc":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.mean=n,exports.meanConfig=void 0;var e=require("@tensorflow/tfjs-core"),s=require("./Cast"),t=require("./RealDiv"),a=require("./Sum");function n(n){const{inputs:r,backend:o,attrs:i}=n,{x:u}=r,{axis:p,keepDims:c}=i,d=e.util.parseAxisParam(p,u.shape),m=e.backend_util.computeOutAndReduceShapes(u.shape,d)[1],l=e.util.sizeFromShape(m),f=[],k=o.makeTensorInfo([],"float32",new Float32Array([l]));f.push(k);const x=(0,s.cast)({inputs:{x:u},backend:o,attrs:{dtype:"float32"}});f.push(x);const b=(0,t.div)({inputs:{a:x,b:k},backend:o});f.push(b);const h=(0,a.sum)({inputs:{x:b},backend:o,attrs:{axis:p,keepDims:c}});return f.forEach(e=>o.disposeIntermediateTensorInfo(e)),h}const r=exports.meanConfig={kernelName:e.Mean,backendName:"cpu",kernelFunc:n};
},{"@tensorflow/tfjs-core":"kSBl","./Cast":"Bp6G","./RealDiv":"jPQU","./Sum":"EH1U"}],"VXYe":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.min=r,exports.minConfig=void 0;var e=require("@tensorflow/tfjs-core"),t=require("../cpu_util"),s=require("./Reshape"),n=require("./Transpose");function r(r){const{inputs:a,backend:o,attrs:i}=r,{x:p}=a,{axis:u,keepDims:l}=i;(0,t.assertNotComplex)(p,"min");const c=e.util.parseAxisParam(u,p.shape);let d=c;const m=e.backend_util.getAxesPermutation(d,p.shape.length);let h=p;null!=m&&(h=(0,n.transpose)({inputs:{x:p},backend:o,attrs:{perm:m}}),d=e.backend_util.getInnerMostAxes(d.length,p.shape.length)),e.backend_util.assertAxesAreInnerMostDims("min",d,h.shape.length);const[k,x]=e.backend_util.computeOutAndReduceShapes(h.shape,d),f=e.util.sizeFromShape(x),b=e.util.makeZerosTypedArray(e.util.sizeFromShape(k),h.dtype),g=o.data.get(h.dataId).values;for(let e=0;e<b.length;++e){const t=e*f;let s=g[t];for(let e=0;e<f;++e){const n=g[t+e];(Number.isNaN(n)||n<s)&&(s=n)}b[e]=s}null!=m&&o.disposeIntermediateTensorInfo(h);const I=o.makeTensorInfo(k,h.dtype,b);if(l){const t=e.backend_util.expandShapeToKeepDim(k,c),n=(0,s.reshape)({inputs:{x:I},backend:o,attrs:{shape:t}});return o.disposeIntermediateTensorInfo(I),n}return I}const a=exports.minConfig={kernelName:e.Min,backendName:"cpu",kernelFunc:r};
},{"@tensorflow/tfjs-core":"kSBl","../cpu_util":"nVKy","./Reshape":"FjS7","./Transpose":"zFLV"}],"WAgk":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.mirrorPad=r,exports.mirrorPadConfig=void 0;var e=require("@tensorflow/tfjs-core"),t=require("../cpu_util");function r(r){const{inputs:o,backend:a,attrs:p}=r,{x:d}=o,{paddings:i,mode:s}=p;(0,t.assertNotComplex)(d,"mirrorPad");const n=i.map((e,t)=>e[0]+d.shape[t]+e[1]),l=i.map(e=>e[0]),u=i.map((e,t)=>e[0]+d.shape[t]),c="reflect"===s?0:1,m=a.data.get(d.dataId).values,f=d.shape.length,h=e.util.computeStrides(d.shape),x=e.util.sizeFromShape(n),y=n.length,g=e.util.computeStrides(n),P=e.util.getTypedArrayFromDType(d.dtype,x);for(let t=0;t<x;t++){let r=e.util.indexToLoc(t,y,g);for(let e=0;e<y;e++)r[e]<l[e]?r[e]=2*l[e]-r[e]-c:r[e]>=u[e]&&(r[e]=2*(u[e]-1)-r[e]+c);r=r.map((e,t)=>e-l[t]);const o=e.util.locToIndex(r,f,h);P[t]=m[o]}return{dataId:a.write(P,n,d.dtype),shape:n,dtype:d.dtype}}const o=exports.mirrorPadConfig={kernelName:e.MirrorPad,backendName:"cpu",kernelFunc:r};
},{"@tensorflow/tfjs-core":"kSBl","../cpu_util":"nVKy"}],"ZmsI":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.modImpl=exports.modConfig=exports.mod=void 0;var e=require("@tensorflow/tfjs-core"),r=require("../utils/binary_impl"),o=require("../utils/binary_utils");const t=exports.modImpl=(0,r.createSimpleBinaryKernelImpl)((e,r)=>{const o=e%r;return e<0&&r<0||e>=0&&r>=0?o:(o+r)%r}),n=exports.mod=(0,o.binaryKernelFunc)(e.Mod,t),i=exports.modConfig={kernelName:e.Mod,backendName:"cpu",kernelFunc:n};
},{"@tensorflow/tfjs-core":"kSBl","../utils/binary_impl":"v0i6","../utils/binary_utils":"FLbP"}],"xTcN":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.softmax=o,exports.softmaxConfig=void 0;var e=require("@tensorflow/tfjs-core"),s=require("./Exp"),t=require("./Max"),n=require("./RealDiv"),a=require("./Reshape"),r=require("./Sub"),i=require("./Sum");function o(o){const{inputs:p,backend:d,attrs:u}=o,{logits:m}=p,{dim:c}=u,x=m.shape.length;let f=c;if(-1===f&&(f=x-1),f!==x-1)throw Error("Softmax along a non-last dimension is not yet supported. "+`Logits was rank ${x} and dim was ${f}`);const b=e.util.parseAxisParam([f],m.shape),k=(0,t.max)({inputs:{x:m},backend:d,attrs:{reductionIndices:b,keepDims:!1}}),l=e.backend_util.expandShapeToKeepDim(k.shape,b),I=(0,a.reshape)({inputs:{x:k},backend:d,attrs:{shape:l}}),h=(0,r.sub)({inputs:{a:m,b:I},backend:d}),q=(0,s.exp)({inputs:{x:h},backend:d}),T=(0,i.sum)({inputs:{x:q},backend:d,attrs:{axis:b,keepDims:!1}}),g=(0,a.reshape)({inputs:{x:T},backend:d,attrs:{shape:l}}),v=(0,n.div)({inputs:{a:q,b:g},backend:d});return d.disposeIntermediateTensorInfo(k),d.disposeIntermediateTensorInfo(I),d.disposeIntermediateTensorInfo(h),d.disposeIntermediateTensorInfo(q),d.disposeIntermediateTensorInfo(T),d.disposeIntermediateTensorInfo(g),v}const p=exports.softmaxConfig={kernelName:e.Softmax,backendName:"cpu",kernelFunc:o};
},{"@tensorflow/tfjs-core":"kSBl","./Exp":"Q92g","./Max":"MqGL","./RealDiv":"jPQU","./Reshape":"FjS7","./Sub":"fBFg","./Sum":"EH1U"}],"kAjy":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.multinomial=a,exports.multinomialConfig=void 0;var e=require("@tensorflow/tfjs-core"),t=o(require("seedrandom")),r=require("../cpu_util"),n=require("./Softmax");function o(e,t){if("function"==typeof WeakMap)var r=new WeakMap,n=new WeakMap;return(o=function(e,t){if(!t&&e&&e.__esModule)return e;var o,a,i={__proto__:null,default:e};if(null===e||"object"!=typeof e&&"function"!=typeof e)return i;if(o=t?n:r){if(o.has(e))return o.get(e);o.set(e,i)}for(const r in e)"default"!==r&&{}.hasOwnProperty.call(e,r)&&((a=(o=Object.defineProperty)&&Object.getOwnPropertyDescriptor(e,r))&&(a.get||a.set)?o(i,r,a):i[r]=e[r]);return i})(e,t)}function a(o){const{inputs:a,backend:i,attrs:s}=o,{logits:l}=a,{numSamples:u,seed:f,normalized:p}=s;(0,r.assertNotComplex)(l,"multinomial");const c=p?l:(0,n.softmax)({inputs:{logits:l},backend:i,attrs:{dim:-1}}),m=c.shape[0],d=c.shape[1],g=i.data.get(c.dataId).values,k=[m,u],y=e.util.makeZerosTypedArray(e.util.sizeFromShape(k),"int32");for(let e=0;e<m;++e){const r=e*d,n=new Float32Array(d-1);n[0]=g[r];for(let e=1;e<n.length;++e)n[e]=n[e-1]+g[r+e];const o=t.alea(f.toString()),a=e*u;for(let e=0;e<u;++e){const t=o();y[a+e]=n.length;for(let r=0;r<n.length;r++)if(t<n[r]){y[a+e]=r;break}}}return p||i.disposeIntermediateTensorInfo(c),i.makeTensorInfo(k,"int32",y)}const i=exports.multinomialConfig={kernelName:e.Multinomial,backendName:"cpu",kernelFunc:a};
},{"@tensorflow/tfjs-core":"kSBl","seedrandom":"xt2p","../cpu_util":"nVKy","./Softmax":"xTcN"}],"FriM":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.nonMaxSuppressionV3=o,exports.nonMaxSuppressionV3Config=void 0;var e=require("@tensorflow/tfjs-core"),n=require("../cpu_util");const s=e.kernel_impls.nonMaxSuppressionV3Impl;function o(e){const{inputs:o,backend:r,attrs:t}=e,{boxes:a,scores:p}=o,{maxOutputSize:u,iouThreshold:i,scoreThreshold:c}=t;(0,n.assertNotComplex)(a,"NonMaxSuppression");const l=r.data.get(a.dataId).values,d=r.data.get(p.dataId).values,{selectedIndices:x}=s(l,d,u,i,c);return r.makeTensorInfo([x.length],"int32",new Int32Array(x))}const r=exports.nonMaxSuppressionV3Config={kernelName:e.NonMaxSuppressionV3,backendName:"cpu",kernelFunc:o};
},{"@tensorflow/tfjs-core":"kSBl","../cpu_util":"nVKy"}],"WzMy":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.nonMaxSuppressionV4=o,exports.nonMaxSuppressionV4Config=void 0;var e=require("@tensorflow/tfjs-core"),n=require("../cpu_util");const s=e.kernel_impls.nonMaxSuppressionV4Impl;function o(e){const{inputs:o,backend:t,attrs:r}=e,{boxes:a,scores:p}=o,{maxOutputSize:u,iouThreshold:i,scoreThreshold:d,padToMaxOutputSize:c}=r;(0,n.assertNotComplex)(a,"NonMaxSuppressionPadded");const l=t.data.get(a.dataId).values,x=t.data.get(p.dataId).values,{selectedIndices:f,validOutputs:m}=s(l,x,u,i,d,c);return[t.makeTensorInfo([f.length],"int32",new Int32Array(f)),t.makeTensorInfo([],"int32",new Int32Array([m]))]}const t=exports.nonMaxSuppressionV4Config={kernelName:e.NonMaxSuppressionV4,backendName:"cpu",kernelFunc:o};
},{"@tensorflow/tfjs-core":"kSBl","../cpu_util":"nVKy"}],"Wtm2":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.nonMaxSuppressionV5=n,exports.nonMaxSuppressionV5Config=void 0;var e=require("@tensorflow/tfjs-core"),o=require("../cpu_util");const s=e.kernel_impls.nonMaxSuppressionV5Impl;function n(e){const{inputs:n,backend:t,attrs:r}=e,{boxes:a,scores:p}=n,{maxOutputSize:i,iouThreshold:u,scoreThreshold:c,softNmsSigma:l}=r;(0,o.assertNotComplex)(a,"NonMaxSuppressionWithScore");const d=t.data.get(a.dataId).values,x=t.data.get(p.dataId).values,f=i,m=u,S=c,g=l,{selectedIndices:h,selectedScores:k}=s(d,x,f,m,S,g);return[t.makeTensorInfo([h.length],"int32",new Int32Array(h)),t.makeTensorInfo([k.length],"float32",new Float32Array(k))]}const t=exports.nonMaxSuppressionV5Config={kernelName:e.NonMaxSuppressionV5,backendName:"cpu",kernelFunc:n};
},{"@tensorflow/tfjs-core":"kSBl","../cpu_util":"nVKy"}],"Jaj4":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.oneHot=t,exports.oneHotConfig=void 0;var e=require("@tensorflow/tfjs-core"),o=require("../cpu_util");function t(t){const{inputs:n,backend:r,attrs:s}=t,{indices:a}=n,{dtype:u,depth:i,onValue:l,offValue:c}=s;(0,o.assertNotComplex)(a,"oneHot");const p=e.util.sizeFromShape(a.shape),d=new Float32Array(p*i);d.fill(c);const f=r.data.get(a.dataId).values;for(let e=0;e<p;++e)f[e]>=0&&f[e]<i&&(d[e*i+f[e]]=l);return r.makeTensorInfo([...a.shape,i],u,d)}const n=exports.oneHotConfig={kernelName:e.OneHot,backendName:"cpu",kernelFunc:t};
},{"@tensorflow/tfjs-core":"kSBl","../cpu_util":"nVKy"}],"vJtB":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.zerosLike=o,exports.zerosLikeConfig=void 0;var e=require("@tensorflow/tfjs-core"),r=require("./Complex"),n=require("./Fill"),s=require("./Imag"),t=require("./Real");function o(e){const{inputs:i,backend:p}=e,{x:a}=i;if("string"===a.dtype)throw new Error("zerosLike is not supported for string tensors");if("complex64"===a.dtype){const e=(0,t.real)({inputs:{input:a},backend:p}),n=o({inputs:{x:e},backend:p}),i=(0,s.imag)({inputs:{input:a},backend:p}),d=o({inputs:{x:i},backend:p}),u=(0,r.complex)({inputs:{real:n,imag:d},backend:p});return p.disposeIntermediateTensorInfo(e),p.disposeIntermediateTensorInfo(n),p.disposeIntermediateTensorInfo(i),p.disposeIntermediateTensorInfo(d),u}return(0,n.fill)({backend:p,attrs:{shape:a.shape,value:0,dtype:a.dtype}})}const i=exports.zerosLikeConfig={kernelName:e.ZerosLike,backendName:"cpu",kernelFunc:o};
},{"@tensorflow/tfjs-core":"kSBl","./Complex":"KmEe","./Fill":"Iz4a","./Imag":"YWMY","./Real":"icBn"}],"pdze":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.onesLike=o,exports.onesLikeConfig=void 0;var e=require("@tensorflow/tfjs-core"),n=require("./Complex"),r=require("./Fill"),s=require("./Imag"),i=require("./Real"),t=require("./ZerosLike");function o(e){const{inputs:p,backend:a}=e,{x:d}=p;if("string"===d.dtype)throw new Error("onesLike is not supported for string tensors");if("complex64"===d.dtype){const e=(0,i.real)({inputs:{input:d},backend:a}),r=o({inputs:{x:e},backend:a}),p=(0,s.imag)({inputs:{input:d},backend:a}),u=(0,t.zerosLike)({inputs:{x:p},backend:a}),c=(0,n.complex)({inputs:{real:r,imag:u},backend:a});return a.disposeIntermediateTensorInfo(e),a.disposeIntermediateTensorInfo(r),a.disposeIntermediateTensorInfo(p),a.disposeIntermediateTensorInfo(u),c}return(0,r.fill)({backend:a,attrs:{shape:d.shape,value:1,dtype:d.dtype}})}const p=exports.onesLikeConfig={kernelName:e.OnesLike,backendName:"cpu",kernelFunc:o};
},{"@tensorflow/tfjs-core":"kSBl","./Complex":"KmEe","./Fill":"Iz4a","./Imag":"YWMY","./Real":"icBn","./ZerosLike":"vJtB"}],"CPkC":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.pack=a,exports.packConfig=void 0;var e=require("@tensorflow/tfjs-core"),t=require("./Concat"),s=require("./ExpandDims");function a(a){const{inputs:n,backend:r,attrs:c}=a,{axis:p}=c;if(1===n.length)return(0,s.expandDims)({inputs:{input:n[0]},backend:r,attrs:{dim:p}});const i=n[0].shape,o=n[0].dtype;n.forEach(t=>{e.util.assertShapesMatch(i,t.shape,"All tensors passed to stack must have matching shapes"),e.util.assert(o===t.dtype,()=>"All tensors passed to stack must have matching dtypes")});const u=[],d=n.map(e=>{const t=(0,s.expandDims)({inputs:{input:e},backend:r,attrs:{dim:p}});return u.push(t),t}),h=(0,t.concat)({inputs:d,backend:r,attrs:{axis:p}});return u.forEach(e=>r.disposeIntermediateTensorInfo(e)),h}const n=exports.packConfig={kernelName:e.Pack,backendName:"cpu",kernelFunc:a};
},{"@tensorflow/tfjs-core":"kSBl","./Concat":"ZWVG","./ExpandDims":"B1EV"}],"Ylc8":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.padV2=a,exports.padV2Config=void 0;var e=require("@tensorflow/tfjs-core"),t=require("../cpu_util");function a(a){const{inputs:p,backend:o,attrs:r}=a,{x:s}=p,{paddings:d,constantValue:i}=r;(0,t.assertNotComplex)(s,"pad");const n=d.map((e,t)=>e[0]+s.shape[t]+e[1]),u=d.map(e=>e[0]),l=o.data.get(s.dataId).values,c=e.util.sizeFromShape(s.shape),m=s.shape.length,h=e.util.computeStrides(s.shape),f=e.util.sizeFromShape(n),x=n.length,y=e.util.computeStrides(n),g=e.util.getTypedArrayFromDType(s.dtype,f);0!==i&&g.fill(i);for(let t=0;t<c;t++){const a=e.util.indexToLoc(t,m,h).map((e,t)=>e+u[t]);g[e.util.locToIndex(a,x,y)]=l[t]}return{dataId:o.write(g,n,s.dtype),shape:n,dtype:s.dtype}}const p=exports.padV2Config={kernelName:e.PadV2,backendName:"cpu",kernelFunc:a};
},{"@tensorflow/tfjs-core":"kSBl","../cpu_util":"nVKy"}],"YQ3v":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.powImpl=exports.powConfig=exports.pow=void 0;var e=require("@tensorflow/tfjs-core"),r=require("../utils/binary_impl"),o=require("../utils/binary_utils");const p=exports.powImpl=(0,r.createSimpleBinaryKernelImpl)((e,r)=>Math.pow(e,r)),t=exports.pow=(0,o.binaryKernelFunc)(e.Pow,p),i=exports.powConfig={kernelName:e.Pow,backendName:"cpu",kernelFunc:t};
},{"@tensorflow/tfjs-core":"kSBl","../utils/binary_impl":"v0i6","../utils/binary_utils":"FLbP"}],"XAjk":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.raggedGather=t,exports.raggedGatherConfig=void 0;var e=require("@tensorflow/tfjs-core"),a=require("./RaggedGather_impl");function t(e){const{inputs:t,backend:r,attrs:s}=e,{paramsNestedSplits:d,paramsDenseValues:n,indices:o}=t,{outputRaggedRank:p}=s,g=d.map(e=>r.data.get(e.dataId).values),u=d.map(e=>e.shape),i=r.data.get(n.dataId).values,c=r.data.get(o.dataId).values,[l,m,h]=(0,a.raggedGatherImpl)(g,u,i,n.shape,n.dtype,c,o.shape,p),f=l.map(e=>r.makeTensorInfo([e.length],"int32",e)),k=r.makeTensorInfo(h,n.dtype,m);return f.concat([k])}const r=exports.raggedGatherConfig={kernelName:e.RaggedGather,backendName:"cpu",kernelFunc:t};
},{"@tensorflow/tfjs-core":"kSBl","./RaggedGather_impl":"mwpO"}],"RjlN":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.raggedRange=t,exports.raggedRangeConfig=void 0;var e=require("@tensorflow/tfjs-core"),a=require("./RaggedRange_impl");function t(e){const{inputs:t,backend:n}=e,{starts:g,limits:r,deltas:s}=t,d=n.data.get(g.dataId).values,o=n.data.get(r.dataId).values,l=n.data.get(s.dataId).values,[p,i]=(0,a.raggedRangeImpl)(d,g.shape,g.dtype,o,r.shape,l,s.shape);return[n.makeTensorInfo([p.length],"int32",p),n.makeTensorInfo([i.length],g.dtype,i)]}const n=exports.raggedRangeConfig={kernelName:e.RaggedRange,backendName:"cpu",kernelFunc:t};
},{"@tensorflow/tfjs-core":"kSBl","./RaggedRange_impl":"Xl6V"}],"UQ6n":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.raggedTensorToTensor=r,exports.raggedTensorToTensorConfig=void 0;var e=require("@tensorflow/tfjs-core"),a=require("./RaggedTensorToTensor_impl");function r(e){const{inputs:r,backend:o,attrs:s}=e,{shape:t,values:n,defaultValue:d,rowPartitionTensors:T}=r,{rowPartitionTypes:p}=s,g=o.data.get(t.dataId).values,u=o.data.get(n.dataId).values,i=o.data.get(d.dataId).values,l=T.map(e=>o.data.get(e.dataId).values),c=T.map(e=>e.shape),[f,v]=(0,a.raggedTensorToTensorImpl)(g,t.shape,u,n.shape,n.dtype,i,d.shape,l,c,p);return o.makeTensorInfo(f,n.dtype,v)}const o=exports.raggedTensorToTensorConfig={kernelName:e.RaggedTensorToTensor,backendName:"cpu",kernelFunc:r};
},{"@tensorflow/tfjs-core":"kSBl","./RaggedTensorToTensor_impl":"H940"}],"dRlj":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.range=n,exports.rangeConfig=void 0;var e=require("@tensorflow/tfjs-core"),r=require("./Range_impl");function n(e){const{backend:n,attrs:t}=e,{start:o,stop:s,dtype:a,step:p}=t,c=(0,r.rangeImpl)(o,s,p,a);return n.makeTensorInfo([c.length],a,c)}const t=exports.rangeConfig={kernelName:e.Range,backendName:"cpu",kernelFunc:n};
},{"@tensorflow/tfjs-core":"kSBl","./Range_impl":"m7wV"}],"PhB2":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.reciprocalConfig=exports.reciprocal=void 0;var e=require("@tensorflow/tfjs-core"),r=require("../utils/unary_utils");const c=exports.reciprocal=(0,r.unaryKernelFunc)(e.Reciprocal,e=>1/e),o=exports.reciprocalConfig={kernelName:e.Reciprocal,backendName:"cpu",kernelFunc:c};
},{"@tensorflow/tfjs-core":"kSBl","../utils/unary_utils":"kZAs"}],"f8vQ":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.resizeBilinear=r,exports.resizeBilinearConfig=void 0;var e=require("@tensorflow/tfjs-core"),t=require("../cpu_util");function r(r){const{inputs:a,backend:i,attrs:o}=r,{images:s}=a,{alignCorners:n,halfPixelCenters:l,size:c}=o;(0,t.assertNotComplex)(s,"resizeBilinear");const u=e.util.computeStrides(s.shape),[f,p]=c,[h,m,d,M]=s.shape,x=i.data.get(s.dataId).values,z=new Float32Array(e.util.sizeFromShape([h,f,p,M])),g=[n&&f>1?m-1:m,n&&p>1?d-1:d],k=[n&&f>1?f-1:f,n&&p>1?p-1:p];let B=0;const C=g[0]/k[0],v=g[1]/k[1];for(let e=0;e<h;e++)for(let t=0;t<f;t++){let r;r=l?C*(t+.5)-.5:C*t;const a=Math.max(0,Math.floor(r)),i=r-a,o=Math.min(m-1,Math.ceil(r)),s=e*u[0]+a*u[1],n=e*u[0]+o*u[1];for(let e=0;e<p;e++){let t;t=l?v*(e+.5)-.5:v*e;const r=Math.max(0,Math.floor(t)),a=t-r,o=Math.min(d-1,Math.ceil(t)),c=s+r*u[2],f=n+r*u[2],p=s+o*u[2],h=n+o*u[2];for(let e=0;e<M;e++){const t=x[c+e],r=x[f+e],o=t+(x[p+e]-t)*a,s=o+(r+(x[h+e]-r)*a-o)*i;z[B++]=s}}}return i.makeTensorInfo([h,f,p,M],"float32",z)}const a=exports.resizeBilinearConfig={kernelName:e.ResizeBilinear,backendName:"cpu",kernelFunc:r};
},{"@tensorflow/tfjs-core":"kSBl","../cpu_util":"nVKy"}],"niMu":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.resizeBilinearGrad=t,exports.resizeBilinearGradConfig=void 0;var e=require("@tensorflow/tfjs-core"),r=require("../cpu_util");function t(t){const{inputs:a,backend:o,attrs:i}=t,{images:s,dy:n}=a,{alignCorners:l}=i;(0,r.assertNotComplex)([n,s],"resizeBilinearGrad");const c=e.util.computeStrides(s.shape),[d,u,f,p]=s.shape,[,h,m]=n.shape,M=new Float32Array(d*u*f*p),g=[l&&h>1?u-1:u,l&&m>1?f-1:f],k=[l&&h>1?h-1:h,l&&m>1?m-1:m],x=g[0]/k[0],z=g[1]/k[1],B=o.data.get(n.dataId).values;let G=0;for(let e=0;e<d;e++){const r=e*c[0];for(let e=0;e<h;e++){const t=e*x,a=Math.floor(t),o=Math.min(Math.ceil(t),u-1),i=r+a*c[1],s=r+o*c[1],n=t-a,l=1-n;for(let e=0;e<m;e++){const r=e*z,t=Math.floor(r),a=Math.min(Math.ceil(r),f-1),o=r-t,d=1-o,u=i+t*c[2],h=i+a*c[2],m=s+t*c[2],g=s+a*c[2],k=l*d,x=l*o,v=n*d,C=n*o;for(let e=0;e<p;e++){const r=B[G++];M[u+e]+=r*k,M[h+e]+=r*x,M[m+e]+=r*v,M[g+e]+=r*C}}}}return o.makeTensorInfo([d,f,u,p],"float32",M)}const a=exports.resizeBilinearGradConfig={kernelName:e.ResizeBilinearGrad,backendName:"cpu",kernelFunc:t};
},{"@tensorflow/tfjs-core":"kSBl","../cpu_util":"nVKy"}],"F9yl":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.resizeNearestNeighbor=r,exports.resizeNearestNeighborConfig=void 0;var e=require("@tensorflow/tfjs-core"),t=require("../cpu_util");function r(r){const{inputs:o,backend:s,attrs:a}=r,{images:n}=o,{alignCorners:i,halfPixelCenters:l,size:c}=a;(0,t.assertNotComplex)(n,"resizeNearestNeighbor");const u=e.util.computeStrides(n.shape),[h,f]=c,[p,N,d,g]=n.shape,m=s.data.get(n.dataId).values,M=new Float32Array(p*h*f*g),b=[i&&h>1?N-1:N,i&&f>1?d-1:d],x=[i&&h>1?h-1:h,i&&f>1?f-1:f],z=b[0]/x[0],k=b[1]/x[1];let C=0;for(let e=0;e<p;e++){const t=e*u[0];for(let e=0;e<h;e++){const r=l?z*(e+.5):z*e;let o=Math.min(N-1,i?Math.round(r):Math.floor(r));l&&(o=Math.max(0,o));const s=t+o*u[1];for(let e=0;e<f;e++){const t=l?k*(e+.5):k*e;let r=Math.min(d-1,i?Math.round(t):Math.floor(t));l&&(r=Math.max(0,r));const o=s+r*u[2];for(let e=0;e<g;e++){const t=m[o+e];M[C++]=t}}}}return s.makeTensorInfo([p,h,f,g],n.dtype,M)}const o=exports.resizeNearestNeighborConfig={kernelName:e.ResizeNearestNeighbor,backendName:"cpu",kernelFunc:r};
},{"@tensorflow/tfjs-core":"kSBl","../cpu_util":"nVKy"}],"VbVm":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.resizeNearestNeighborGrad=r,exports.resizeNearestNeighborGradConfig=void 0;var e=require("@tensorflow/tfjs-core"),t=require("../cpu_util");function r(r){const{inputs:o,backend:a,attrs:s}=r,{images:n,dy:i}=o,{alignCorners:l}=s;(0,t.assertNotComplex)([i,n],"resizeNearestNeighborGrad");const c=e.util.computeStrides(n.shape),f=e.util.computeStrides(i.shape),[h,u,d,p]=n.shape,[,M,N]=i.shape,g=new Float32Array(h*u*d*p),m=a.data.get(i.dataId).values,b=[l&&M>1?u-1:u,l&&N>1?d-1:d],k=[l&&M>1?M-1:M,l&&N>1?N-1:N],x=b[0]/k[0],z=b[1]/k[1],G=1/x,v=1/z,y=2*Math.ceil(G)+2,C=2*Math.ceil(v)+2;for(let e=0;e<h;e++){const t=e*c[0];for(let e=0;e<u;e++){const r=t+e*c[1],o=Math.floor(e*G),a=Math.floor(o-y/2);for(let s=0;s<d;s++){const o=r+s*c[2],n=Math.floor(s*v),i=Math.floor(n-C/2);for(let r=0;r<p;r++){let n=0;for(let o=0;o<y;o++){const c=o+a;if(c<0||c>=M)continue;const h=t+c*f[1],p=c*x;if(e===Math.min(u-1,l?Math.round(p):Math.floor(p)))for(let e=0;e<C;e++){const t=e+i;if(t<0||t>=N)continue;const o=h+t*f[2],a=t*z;s===Math.min(d-1,l?Math.round(a):Math.floor(a))&&(n+=m[o+r])}}g[o+r]=n}}}}return a.makeTensorInfo(n.shape,n.dtype,g)}const o=exports.resizeNearestNeighborGradConfig={kernelName:e.ResizeNearestNeighborGrad,backendName:"cpu",kernelFunc:r};
},{"@tensorflow/tfjs-core":"kSBl","../cpu_util":"nVKy"}],"UHhn":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.reverse=t,exports.reverseConfig=void 0;var e=require("@tensorflow/tfjs-core"),r=require("../cpu_util"),s=require("./Identity");function t(t){const{inputs:n,backend:o,attrs:i}=t,{x:a}=n,{dims:c}=i;(0,r.assertNotComplex)(a,"reverse");const u=a.shape.length,p=e.util.parseAxisParam(c,a.shape);if(0===u)return(0,s.identity)({inputs:{x:a},backend:o});const f=new e.TensorBuffer(a.shape,a.dtype),d=o.bufferSync(a);for(let e=0;e<f.size;e++){const r=f.indexToLoc(e),s=r.slice();p.forEach(e=>s[e]=a.shape[e]-1-s[e]),f.set(d.get(...s),...r)}return o.makeTensorInfo(f.shape,f.dtype,f.values)}const n=exports.reverseConfig={kernelName:e.Reverse,backendName:"cpu",kernelFunc:t};
},{"@tensorflow/tfjs-core":"kSBl","../cpu_util":"nVKy","./Identity":"nMAE"}],"FpFQ":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.rotateWithOffsetConfig=void 0;var e=require("@tensorflow/tfjs-core");const t=exports.rotateWithOffsetConfig={kernelName:e.RotateWithOffset,backendName:"cpu",kernelFunc:({inputs:t,attrs:a,backend:r})=>{const{image:o}=t,{radians:s,fillValue:n,center:i}=a,d=r,p=e.util.getTypedArrayFromDType(o.dtype,e.util.sizeFromShape(o.shape)),[f,l,c,u]=o.shape,[h,y]=e.backend_util.getImageCenter(i,l,c),g=Math.sin(s),m=Math.cos(s),b=d.data.get(o.dataId).values;for(let e=0;e<f;e++){const t=e*c*l*u;for(let e=0;e<l;e++){const a=e*(c*u);for(let r=0;r<c;r++){const o=r*u;for(let s=0;s<u;s++){const i=[f,e,r,s],d=i[2],k=i[1];let M=(d-h)*m-(k-y)*g,v=(d-h)*g+(k-y)*m;M=Math.round(M+h),v=Math.round(v+y);let O=n;if("number"!=typeof n&&(O=3===s?255:n[s]),M>=0&&M<c&&v>=0&&v<l){O=b[t+v*(c*u)+M*u+s]}p[t+a+o+s]=O}}}}return{dataId:d.write(p,o.shape,o.dtype),shape:o.shape,dtype:o.dtype}}};
},{"@tensorflow/tfjs-core":"kSBl"}],"W307":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.roundConfig=exports.round=void 0;var e=require("@tensorflow/tfjs-core"),r=require("../utils/unary_utils");const o=exports.round=(0,r.unaryKernelFunc)(e.Round,e=>{const r=Math.floor(e);return e-r<.5?Math.floor(e):e-r>.5?Math.ceil(e):r%2==0?r:r+1}),n=exports.roundConfig={kernelName:e.Round,backendName:"cpu",kernelFunc:o};
},{"@tensorflow/tfjs-core":"kSBl","../utils/unary_utils":"kZAs"}],"Wt5A":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.scatterNd=r,exports.scatterNdConfig=void 0;var e=require("@tensorflow/tfjs-core"),t=require("./Scatter_impl");function r(r){const{inputs:s,backend:c,attrs:a}=r,{indices:n,updates:u}=s,{shape:i}=a,{sliceRank:o,numUpdates:d,sliceSize:p,strides:l,outputSize:f}=e.backend_util.calculateShapes(u,n,i),k=c.bufferSync(n),S=c.bufferSync(u),b=(0,t.scatterImpl)(k,S,i,f,p,d,o,l,0,!0);return c.makeTensorInfo(i,b.dtype,b.values)}const s=exports.scatterNdConfig={kernelName:e.ScatterNd,backendName:"cpu",kernelFunc:r};
},{"@tensorflow/tfjs-core":"kSBl","./Scatter_impl":"VFSj"}],"ESIi":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.searchSortedImpl=o;var e=require("@tensorflow/tfjs-core");function t(e,t){let r=0,o=e.length,n=0;for(;r<o;)e[n=Math.floor((r+o)/2)]<t?r=n+1:o=n;return o}function r(e,t){let r=0,o=e.length,n=0;for(;r<o;)e[n=Math.floor((r+o)/2)]<=t?r=n+1:o=n;return o}function o(o,n,l,f,s,u){const c=e.util.getArrayFromDType("int32",l*s);for(let e=0;e<l;++e){const l=o.slice(e*f,(e+1)*f),i=e*s;for(let e=0;e<s;++e)c[i+e]="left"===u?t(l,n[e+i]):r(l,n[e+i])}return c}
},{"@tensorflow/tfjs-core":"kSBl"}],"obrK":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.searchSorted=t,exports.searchSortedConfig=void 0;var e=require("@tensorflow/tfjs-core"),r=require("./SearchSorted_impl");function t(e){const{inputs:t,backend:a,attrs:s}=e,{sortedSequence:o,values:d}=t,{side:n}=s,c=a.data.get(o.dataId).values,u=a.data.get(d.dataId).values,p=(0,r.searchSortedImpl)(c,u,o.shape[0],o.shape[1],d.shape[1],n);return a.makeTensorInfo(d.shape,"int32",p)}const a=exports.searchSortedConfig={kernelName:e.SearchSorted,backendName:"cpu",kernelFunc:t};
},{"@tensorflow/tfjs-core":"kSBl","./SearchSorted_impl":"ESIi"}],"ZOwV":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.select=s,exports.selectConfig=void 0;var e=require("@tensorflow/tfjs-core"),t=require("../cpu_util");function s(s){const{inputs:a,backend:o}=s,{condition:r,t:l,e:n}=a;(0,t.assertNotComplex)([r,l,n],"select");const c=r.shape.length,p=o.data.get(r.dataId).values,u=o.data.get(l.dataId).values,d=o.data.get(n.dataId).values,i=(0,e.upcastType)(l.dtype,n.dtype),h=e.util.makeZerosTypedArray(e.util.sizeFromShape(l.shape),i);let f=0;const g=0===c||c>1||1===l.shape.length?1:e.util.sizeFromShape(l.shape.slice(1));for(let e=0;e<p.length;e++)for(let t=0;t<g;t++)1===p[e]?h[f++]=u[e]:h[f++]=d[e];return o.makeTensorInfo(l.shape,i,h)}const a=exports.selectConfig={kernelName:e.Select,backendName:"cpu",kernelFunc:s};
},{"@tensorflow/tfjs-core":"kSBl","../cpu_util":"nVKy"}],"qgMT":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.seluConfig=exports.selu=void 0;var e=require("@tensorflow/tfjs-core"),r=require("../utils/unary_utils");const u=e.backend_util.SELU_SCALEALPHA,s=e.backend_util.SELU_SCALE,t=exports.selu=(0,r.unaryKernelFunc)(e.Selu,e=>e>=0?s*e:u*(Math.exp(e)-1)),l=exports.seluConfig={kernelName:e.Selu,backendName:"cpu",kernelFunc:t};
},{"@tensorflow/tfjs-core":"kSBl","../utils/unary_utils":"kZAs"}],"AMoq":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.signConfig=exports.sign=void 0;var e=require("@tensorflow/tfjs-core"),r=require("../utils/unary_utils");const n=exports.sign=(0,r.unaryKernelFunc)(e.Sign,e=>e<0?-1:e>0?1:0),s=exports.signConfig={kernelName:e.Sign,backendName:"cpu",kernelFunc:n};
},{"@tensorflow/tfjs-core":"kSBl","../utils/unary_utils":"kZAs"}],"ot3i":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.sinConfig=exports.sin=void 0;var e=require("@tensorflow/tfjs-core"),n=require("../utils/unary_utils");const r=exports.sin=(0,n.unaryKernelFunc)(e.Sin,e=>Math.sin(e)),s=exports.sinConfig={kernelName:e.Sin,backendName:"cpu",kernelFunc:r};
},{"@tensorflow/tfjs-core":"kSBl","../utils/unary_utils":"kZAs"}],"UUxh":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.sinhConfig=exports.sinh=void 0;var e=require("@tensorflow/tfjs-core"),n=require("../utils/unary_utils");const r=exports.sinh=(0,n.unaryKernelFunc)(e.Sinh,e=>Math.sinh(e)),s=exports.sinhConfig={kernelName:e.Sinh,backendName:"cpu",kernelFunc:r};
},{"@tensorflow/tfjs-core":"kSBl","../utils/unary_utils":"kZAs"}],"NecI":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.softplusConfig=exports.softplus=void 0;var e=require("@tensorflow/tfjs-core"),t=require("../utils/unary_utils");const s=1.1920928955078125e-7,o=Math.log(s)+2,r=exports.softplus=(0,t.unaryKernelFunc)(e.Softplus,e=>{const t=e>-o,s=e<o,r=Math.exp(e);let u;return u=s?r:t?e:Math.log(1+r)}),u=exports.softplusConfig={kernelName:e.Softplus,backendName:"cpu",kernelFunc:r};
},{"@tensorflow/tfjs-core":"kSBl","../utils/unary_utils":"kZAs"}],"kHRr":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.spaceToBatchND=r,exports.spaceToBatchNDConfig=void 0;var e=require("@tensorflow/tfjs-core"),t=require("../cpu_util"),s=require("./PadV2"),a=require("./Reshape"),n=require("./Transpose");function r(r){const{inputs:p,backend:o,attrs:c}=r,{x:i}=p,{blockShape:u,paddings:d}=c;(0,t.assertNotComplex)([i],"spaceToBatchND");const h=e.util.sizeFromShape(u),l=[[0,0]];l.push(...d);for(let e=1+u.length;e<i.shape.length;++e)l.push([0,0]);const k=s.padV2Config.kernelFunc({inputs:{x:i},backend:o,attrs:{paddings:l,constantValue:0}}),g=e.backend_util.getReshaped(k.shape,u,h,!1),b=e.backend_util.getPermuted(g.length,u.length,!1),f=e.backend_util.getReshapedPermuted(k.shape,u,h,!1),m={x:k},x={shape:g},T=(0,a.reshape)({inputs:m,backend:o,attrs:x}),N={x:T},I={perm:b},_=(0,n.transpose)({inputs:N,backend:o,attrs:I}),q={x:_},B={shape:f},D=(0,a.reshape)({inputs:q,backend:o,attrs:B});return o.disposeIntermediateTensorInfo(k),o.disposeIntermediateTensorInfo(T),o.disposeIntermediateTensorInfo(_),D}const p=exports.spaceToBatchNDConfig={kernelName:e.SpaceToBatchND,backendName:"cpu",kernelFunc:r};
},{"@tensorflow/tfjs-core":"kSBl","../cpu_util":"nVKy","./PadV2":"Ylc8","./Reshape":"FjS7","./Transpose":"zFLV"}],"ptlO":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.sparseFillEmptyRows=s,exports.sparseFillEmptyRowsConfig=void 0;var e=require("@tensorflow/tfjs-core"),a=require("./SparseFillEmptyRows_impl");function s(e){const{inputs:s,backend:t}=e,{indices:r,values:n,denseShape:o,defaultValue:p}=s;if(1!==o.shape.length)throw new Error(`Dense shape must be a vector, saw:\n        ${o.shape}`);if(2!==r.shape.length)throw new Error(`Indices must be a matrix, saw:\n        ${r.shape}`);if(1!==n.shape.length)throw new Error(`Values must be a vector, saw:\n        ${n.shape}`);if(0!==p.shape.length)throw new Error(`Default value must be a scalar, saw:\n        ${p.shape}`);const l=t.data.get(r.dataId).values,d=t.data.get(n.dataId).values,i=t.data.get(o.dataId).values,u=t.data.get(p.dataId).values[0],[h,m,w,c,f]=(0,a.sparseFillEmptyRowsImpl)(l,r.shape,r.dtype,d,n.dtype,i,u);return[t.makeTensorInfo(m,r.dtype,h),t.makeTensorInfo([m[0]],n.dtype,w),t.makeTensorInfo([c.length],"bool",new Uint8Array(c.map(e=>Number(e)))),t.makeTensorInfo([f.length],r.dtype,new Int32Array(f))]}const t=exports.sparseFillEmptyRowsConfig={kernelName:e.SparseFillEmptyRows,backendName:"cpu",kernelFunc:s};
},{"@tensorflow/tfjs-core":"kSBl","./SparseFillEmptyRows_impl":"vXdm"}],"XRS0":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.sparseReshape=r,exports.sparseReshapeConfig=void 0;var e=require("@tensorflow/tfjs-core"),a=require("./SparseReshape_impl");function r(e){const{inputs:r,backend:s}=e,{inputIndices:t,inputShape:p,newShape:n}=r;if(2!==t.shape.length)throw new Error(`Input indices should be a matrix but received shape\n        ${t.shape}`);if(1!==p.shape.length)throw new Error(`Input shape should be a vector but received shape\n        ${p.shape}`);if(1!==n.shape.length)throw new Error(`Target shape should be a vector but received shape ${n.shape}`);const o=Array.from(s.data.get(p.dataId).values),h=s.data.get(t.dataId).values,d=Array.from(s.data.get(n.dataId).values),[u,i,c]=(0,a.sparseReshapeImpl)(h,t.shape,t.dtype,o,d);return[s.makeTensorInfo(i,t.dtype,u),s.makeTensorInfo([c.length],n.dtype,new Int32Array(c))]}const s=exports.sparseReshapeConfig={kernelName:e.SparseReshape,backendName:"cpu",kernelFunc:r};
},{"@tensorflow/tfjs-core":"kSBl","./SparseReshape_impl":"LDTS"}],"MRym":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.sparseSegmentMean=s,exports.sparseSegmentMeanConfig=void 0;var e=require("@tensorflow/tfjs-core"),a=require("./SparseSegmentReduction_impl");function s(e){const{inputs:s,backend:t}=e,{data:n,indices:r,segmentIds:o}=s;if(n.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==r.shape.length)throw new Error(`Indices should be a vector but received shape\n          ${r.shape}`);if(1!==o.shape.length)throw new Error(`Segment ids should be a vector but received shape\n          ${o.shape}`);if(r.shape[0]!==o.shape[0])throw new Error("segmentIds and indices should have same size.");const d=t.data.get(n.dataId).values,i=t.data.get(r.dataId).values,p=t.data.get(o.dataId).values,[c,h]=(0,a.sparseSegmentReductionImpl)(d,n.shape,n.dtype,i,p,!0);return t.makeTensorInfo(h,n.dtype,c)}const t=exports.sparseSegmentMeanConfig={kernelName:e.SparseSegmentMean,backendName:"cpu",kernelFunc:s};
},{"@tensorflow/tfjs-core":"kSBl","./SparseSegmentReduction_impl":"XhXa"}],"OuxZ":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.sparseSegmentSum=t,exports.sparseSegmentSumConfig=void 0;var e=require("@tensorflow/tfjs-core"),s=require("./SparseSegmentReduction_impl");function t(e){const{inputs:t,backend:a}=e,{data:r,indices:n,segmentIds:o}=t;if(r.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==n.shape.length)throw new Error(`Indices should be a vector but received shape\n         ${n.shape}`);if(1!==o.shape.length)throw new Error(`Segment ids should be a vector but received shape\n         ${o.shape}`);if(n.shape[0]!==o.shape[0])throw new Error("segmentIds and indices should have same size.");const d=a.data.get(r.dataId).values,i=a.data.get(n.dataId).values,p=a.data.get(o.dataId).values,[u,c]=(0,s.sparseSegmentReductionImpl)(d,r.shape,r.dtype,i,p);return a.makeTensorInfo(c,r.dtype,u)}const a=exports.sparseSegmentSumConfig={kernelName:e.SparseSegmentSum,backendName:"cpu",kernelFunc:t};
},{"@tensorflow/tfjs-core":"kSBl","./SparseSegmentReduction_impl":"XhXa"}],"ZLxi":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.sparseToDense=a,exports.sparseToDenseConfig=void 0;var e=require("@tensorflow/tfjs-core"),t=require("./Scatter_impl");function a(a){const{inputs:s,backend:r,attrs:n}=a,{sparseIndices:o,sparseValues:c,defaultValue:u}=s,{outputShape:p}=n,{sliceRank:l,numUpdates:d,sliceSize:i,strides:f,outputSize:b}=e.backend_util.calculateShapes(c,o,p),S=r.bufferSync(o);let k;switch(c.dtype){case"bool":{const e=r.bufferSync(c),a=Boolean(r.data.get(u.dataId).values[0]);k=(0,t.scatterImpl)(S,e,p,b,i,d,l,f,a,!1);break}case"float32":case"int32":{const e=r.bufferSync(c),a=r.data.get(u.dataId).values[0];k=(0,t.scatterImpl)(S,e,p,b,i,d,l,f,a,!1);break}case"string":{const a=r.bufferSync(c),s=e.util.decodeString(r.data.get(u.dataId).values[0]);k=(0,t.scatterImpl)(S,a,p,b,i,d,l,f,s,!1);break}default:throw new Error(`Unsupported type ${c.dtype}`)}return r.makeTensorInfo(p,k.dtype,k.values)}const s=exports.sparseToDenseConfig={kernelName:e.SparseToDense,backendName:"cpu",kernelFunc:a};
},{"@tensorflow/tfjs-core":"kSBl","./Scatter_impl":"VFSj"}],"BUH5":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.splitV=s,exports.splitVConfig=void 0;var e=require("@tensorflow/tfjs-core"),t=require("./Slice");function s(s){const{inputs:r,backend:i,attrs:n}=s,{x:p}=r,{numOrSizeSplits:a,axis:l}=n,c=e.util.parseAxisParam(l,p.shape)[0],o=e.backend_util.prepareSplitSize(p,a,c),u=new Array(p.shape.length).fill(0),x=p.shape.slice();return o.map(e=>{const s=[...x];s[c]=e;const r=(0,t.slice)({inputs:{x:p},backend:i,attrs:{begin:u,size:s}});return u[c]+=e,r})}const r=exports.splitVConfig={kernelName:e.SplitV,backendName:"cpu",kernelFunc:s};
},{"@tensorflow/tfjs-core":"kSBl","./Slice":"i6mc"}],"onVE":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.squareConfig=void 0;var e=require("@tensorflow/tfjs-core"),t=require("../cpu_util");const r=exports.squareConfig={kernelName:e.Square,backendName:"cpu",kernelFunc:({inputs:e,backend:r})=>{const{x:a}=e,s=r;(0,t.assertNotComplex)(a,"square");const o=s.data.get(a.dataId).values,n=new Float32Array(o.length);for(let t=0;t<o.length;++t){const e=o[t];n[t]=e*e}return{dataId:s.write(n,a.shape,a.dtype),shape:a.shape,dtype:a.dtype}}};
},{"@tensorflow/tfjs-core":"kSBl","../cpu_util":"nVKy"}],"euKg":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.stepConfig=exports.step=void 0;var e=require("@tensorflow/tfjs-core"),r=require("../utils/unary_utils");const t=exports.step=(0,r.unaryKernelFunc)(e.Step,(e,r)=>{const t=r;return isNaN(e)?NaN:e>0?1:t.alpha}),s=exports.stepConfig={kernelName:e.Step,backendName:"cpu",kernelFunc:t};
},{"@tensorflow/tfjs-core":"kSBl","../utils/unary_utils":"kZAs"}],"IocJ":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.stridedSlice=n,exports.stridedSliceConfig=void 0;var e=require("@tensorflow/tfjs-core"),s=require("../cpu_util"),i=require("./Reshape"),t=require("./Slice"),r=require("./StridedSlice_impl");function n(n){const{inputs:a,backend:l,attrs:c}=n,{x:p}=a,{begin:d,end:o,strides:u,beginMask:S,endMask:f,ellipsisMask:h,newAxisMask:k,shrinkAxisMask:b}=c;(0,s.assertNotComplex)(p,"stridedSlice");const{finalShapeSparse:m,finalShape:x,isIdentity:g,sliceDim0:I,isSimpleSlice:M,begin:_,end:q,strides:v}=e.slice_util.sliceInfo(p.shape,d,o,u,S,f,h,k,b);let y;if(g)y=(0,i.reshape)({inputs:{x:p},backend:l,attrs:{shape:x}});else if(I||M){e.util.assert(p.shape.length>=1,()=>`Input must have rank at least 1, got: ${p.shape.length}`);const s=e.slice_util.computeOutShape(_,q,v),r=(0,t.slice)({inputs:{x:p},backend:l,attrs:{begin:_,size:s}});y=(0,i.reshape)({inputs:{x:r},backend:l,attrs:{shape:x}}),l.disposeIntermediateTensorInfo(r)}else{const e=l.bufferSync(p),s=(0,r.stridedSliceImpl)(m,e,v,_);y=l.makeTensorInfo(x,s.dtype,s.values)}return y}const a=exports.stridedSliceConfig={kernelName:e.StridedSlice,backendName:"cpu",kernelFunc:n};
},{"@tensorflow/tfjs-core":"kSBl","../cpu_util":"nVKy","./Reshape":"FjS7","./Slice":"i6mc","./StridedSlice_impl":"Jc0Z"}],"Ds6w":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.stringNGrams=t,exports.stringNGramsConfig=void 0;var e=require("@tensorflow/tfjs-core"),r=require("./StringNGrams_impl");function t(e){const{inputs:t,backend:a,attrs:s}=e,{separator:n,nGramWidths:i,leftPad:o,rightPad:d,padWidth:p,preserveShortSequences:g}=s,{data:m,dataSplits:u}=t,l=a.data.get(m.dataId).values,c=a.data.get(u.dataId).values,[f,N]=(0,r.stringNGramsImpl)(l,c,n,i,o,d,p,g);return[a.makeTensorInfo([f.length],"string",f),a.makeTensorInfo(u.shape,"int32",N)]}const a=exports.stringNGramsConfig={kernelName:e.StringNGrams,backendName:"cpu",kernelFunc:t};
},{"@tensorflow/tfjs-core":"kSBl","./StringNGrams_impl":"CMu9"}],"dykI":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.stringSplit=r,exports.stringSplitConfig=void 0;var t=require("@tensorflow/tfjs-core"),e=require("./StringSplit_impl");function r(t){const{inputs:r,backend:n,attrs:s}=t,{skipEmpty:i}=s,{input:a,delimiter:o}=r;if("string"!==a.dtype)throw new Error("Input must be of datatype string");if(1!==a.shape.length)throw new Error(`Input must be a vector, got shape: ${a.shape}`);if(0!==o.shape.length)throw new Error(`Delimiter must be a scalar, got shape: ${o.shape}`);const p=n.data.get(a.dataId).values,l=n.data.get(o.dataId).values[0],[g,u,d]=(0,e.stringSplitImpl)(p,l,i),c=u.length;return[n.makeTensorInfo([c,2],"int32",g),n.makeTensorInfo([c],"string",u),n.makeTensorInfo([2],"int32",new Int32Array(d))]}const n=exports.stringSplitConfig={kernelName:t.StringSplit,backendName:"cpu",kernelFunc:r};
},{"@tensorflow/tfjs-core":"kSBl","./StringSplit_impl":"opA2"}],"DxUa":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.stringToHashBucketFast=s,exports.stringToHashBucketFastConfig=void 0;var t=require("@tensorflow/tfjs-core"),e=require("./StringToHashBucketFast_impl");function s(t){const{inputs:s,backend:r,attrs:n}=t,{numBuckets:a}=n,{input:o}=s;if("string"!==o.dtype)throw new Error("Input must be of datatype string");if(a<=0)throw new Error("Number of buckets must be at least 1");const u=r.data.get(o.dataId).values,i=(0,e.stringToHashBucketFastImpl)(u,a);return r.makeTensorInfo(o.shape,"int32",i)}const r=exports.stringToHashBucketFastConfig={kernelName:t.StringToHashBucketFast,backendName:"cpu",kernelFunc:s};
},{"@tensorflow/tfjs-core":"kSBl","./StringToHashBucketFast_impl":"KvpR"}],"L3BY":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.tanConfig=exports.tan=void 0;var e=require("@tensorflow/tfjs-core"),n=require("../utils/unary_utils");const r=exports.tan=(0,n.unaryKernelFunc)(e.Tan,e=>Math.tan(e)),t=exports.tanConfig={kernelName:e.Tan,backendName:"cpu",kernelFunc:r};
},{"@tensorflow/tfjs-core":"kSBl","../utils/unary_utils":"kZAs"}],"DseU":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.tanhConfig=exports.tanh=void 0;var e=require("@tensorflow/tfjs-core"),n=require("../utils/unary_utils");const r=exports.tanh=(0,n.unaryKernelFunc)(e.Tanh,e=>Math.tanh(e)),t=exports.tanhConfig={kernelName:e.Tanh,backendName:"cpu",kernelFunc:r};
},{"@tensorflow/tfjs-core":"kSBl","../utils/unary_utils":"kZAs"}],"SoME":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.tensorScatterUpdate=r,exports.tensorScatterUpdateConfig=void 0;var e=require("@tensorflow/tfjs-core"),t=require("./Scatter_impl");function r(r){const{inputs:s,backend:n}=r,{tensor:a,indices:c,updates:o}=s,{sliceRank:p,numUpdates:u,sliceSize:i,strides:d,outputSize:f}=e.backend_util.calculateShapes(o,c,a.shape),l=n.bufferSync(c),S=n.bufferSync(o),b=n.bufferSync(a),k=(0,t.scatterImpl)(l,S,a.shape,f,i,u,p,d,b,!1);return n.makeTensorInfo(a.shape,k.dtype,k.values)}const s=exports.tensorScatterUpdateConfig={kernelName:e.TensorScatterUpdate,backendName:"cpu",kernelFunc:r};
},{"@tensorflow/tfjs-core":"kSBl","./Scatter_impl":"VFSj"}],"Miyd":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.tile=o,exports.tileConfig=void 0;var e=require("@tensorflow/tfjs-core"),t=require("../cpu_util"),r=require("./Tile_impl");function o(e){const{inputs:o,backend:s,attrs:i}=e,{x:n}=o,{reps:l}=i;(0,t.assertNotComplex)(n,"tile");const u=(0,r.tileImpl)(s.bufferSync(n),l);return s.makeTensorInfo(u.shape,u.dtype,u.values)}const s=exports.tileConfig={kernelName:e.Tile,backendName:"cpu",kernelFunc:o};
},{"@tensorflow/tfjs-core":"kSBl","../cpu_util":"nVKy","./Tile_impl":"W9Ei"}],"WBag":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.topK=r,exports.topKConfig=void 0;var e=require("@tensorflow/tfjs-core"),t=require("../cpu_util"),o=require("./TopK_impl");function r(e){const{inputs:r,backend:s,attrs:p}=e,{x:a}=r,{k:n,sorted:u}=p;(0,t.assertNotComplex)(a,"topk");const c=s.data.get(a.dataId).values,[d,i]=(0,o.topKImpl)(c,a.shape,a.dtype,n,u);return[s.makeTensorInfo(d.shape,d.dtype,d.values),s.makeTensorInfo(i.shape,i.dtype,i.values)]}const s=exports.topKConfig={kernelName:e.TopK,backendName:"cpu",kernelFunc:r};
},{"@tensorflow/tfjs-core":"kSBl","../cpu_util":"nVKy","./TopK_impl":"iXMz"}],"aHoY":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.transform=e,exports.transformConfig=void 0;var t=require("@tensorflow/tfjs-core");function e(e){const{inputs:r,attrs:a,backend:o}=e,{image:s,transforms:u}=r,{interpolation:i,fillMode:f,fillValue:p,outputShape:d}=a,[h,m,y,M]=s.shape,[b,g]=null!=d?d:[m,y],k=[h,b,g,M],w=t.util.computeStrides(s.shape),v=w[0],x=w[1],T=w[2],I=t.util.computeStrides(k),S=I[0],E=I[1],F=I[2],j=t.util.getTypedArrayFromDType(s.dtype,t.util.sizeFromShape(k));j.fill(p);const C=o.data.get(s.dataId).values,N=o.data.get(u.dataId).values;for(let t=0;t<h;++t){const e=1===u.shape[0]?N:N.subarray(8*t,8*t+8);for(let r=0;r<b;++r)for(let a=0;a<g;++a)for(let o=0;o<M;++o){let s;const u=e[6]*a+e[7]*r+1;if(0===u)continue;const d=(e[0]*a+e[1]*r+e[2])/u,h=(e[3]*a+e[4]*r+e[5])/u,M=n(d,y,f),b=n(h,m,f);switch(i){case"nearest":s=c(C,m,y,v,x,T,t,b,M,o,p);break;case"bilinear":s=l(C,m,y,v,x,T,t,b,M,o,p);break;default:throw new Error("Error in Transform: Expect 'nearest' or "+`'bilinear', but got ${i}`)}j[t*S+r*E+a*F+o]=s}return o.makeTensorInfo(k,s.dtype,j)}return{dataId:o.write(j,k,s.dtype),shape:s.shape,dtype:s.dtype}}const r=exports.transformConfig={kernelName:t.Transform,backendName:"cpu",kernelFunc:e};function n(t,e,r){switch(r){case"reflect":return a(t,e);case"wrap":return o(t,e);case"nearest":return u(t,e);case"constant":default:return s(t,e)}}function a(e,r){let n=e;if(n<0)if(r<=1)n=0;else{const t=2*r;n<t&&(n=t*Math.trunc(-n/t)+n),n=n<-r?n+t:-n-1}else if(n>r-1)if(r<=1)n=0;else{const t=2*r;(n-=t*Math.trunc(n/t))>=r&&(n=t-n-1)}return t.util.clamp(0,n,r-1)}function o(e,r){let n=e;if(n<0)if(r<=1)n=0;else{const t=r-1;n+=r*(Math.trunc(-n/t)+1)}else if(n>r-1)if(r<=1)n=0;else{const t=r-1;n-=r*Math.trunc(n/t)}return t.util.clamp(0,n,r-1)}function s(t,e){return t}function u(e,r){return t.util.clamp(0,e,r-1)}function i(t,e,r,n,a,o,s,u,i,c,l){return 0<=u&&u<e&&0<=i&&i<r?t[s*n+u*a+i*o+c]:l}function c(t,e,r,n,a,o,s,u,c,l,f){return i(t,e,r,n,a,o,s,Math.round(u),Math.round(c),l,f)}function l(t,e,r,n,a,o,s,u,c,l,f){const p=Math.floor(u),d=Math.floor(c),h=p+1,m=d+1;return(h-u)*((m-c)*i(t,e,r,n,a,o,s,p,d,l,f)+(c-d)*i(t,e,r,n,a,o,s,p,m,l,f))+(u-p)*((m-c)*i(t,e,r,n,a,o,s,h,d,l,f)+(c-d)*i(t,e,r,n,a,o,s,h,m,l,f))}
},{"@tensorflow/tfjs-core":"kSBl"}],"xqHf":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.unique=n,exports.uniqueConfig=void 0;var e=require("@tensorflow/tfjs-core"),t=require("../cpu_util"),u=require("./Unique_impl");function n(e){const{inputs:n,attrs:o,backend:r}=e,{axis:i}=o,{x:s}=n;(0,t.assertNotComplex)(s,"unique");const a=r.data.get(s.dataId).values,{outputValues:p,outputShape:c,indices:l}=(0,u.uniqueImpl)(a,i,s.shape,s.dtype);return[r.makeTensorInfo(c,s.dtype,p),r.makeTensorInfo([l.length],"int32",l)]}const o=exports.uniqueConfig={kernelName:e.Unique,backendName:"cpu",kernelFunc:n};
},{"@tensorflow/tfjs-core":"kSBl","../cpu_util":"nVKy","./Unique_impl":"hHdG"}],"PIOQ":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.unpack=t,exports.unpackConfig=void 0;var e=require("@tensorflow/tfjs-core"),n=require("./Reshape"),s=require("./Slice");function t(e){const{inputs:t,backend:r,attrs:a}=e,{value:o}=t;let{axis:c}=a;c<0&&(c+=o.shape.length);const p=o.shape.length,i=o.shape[c],l=new Array(p-1);let u=0;for(let n=0;n<p;n++)n!==c&&(l[u++]=o.shape[n]);const h=new Array(p).fill(0),f=o.shape.slice();f[c]=1;const k=new Array(i);for(let d=0;d<k.length;d++){h[c]=d;const e=(0,s.slice)({inputs:{x:o},backend:r,attrs:{begin:h,size:f}});k[d]=(0,n.reshape)({inputs:{x:e},backend:r,attrs:{shape:l}}),r.disposeIntermediateTensorInfo(e)}return k}const r=exports.unpackConfig={kernelName:e.Unpack,backendName:"cpu",kernelFunc:t};
},{"@tensorflow/tfjs-core":"kSBl","./Reshape":"FjS7","./Slice":"i6mc"}],"IFWn":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.unsortedSegmentSum=o,exports.unsortedSegmentSumConfig=void 0;var e=require("@tensorflow/tfjs-core"),t=require("../cpu_util"),s=require("./Cast"),n=require("./Equal"),u=require("./ExpandDims"),r=require("./Multiply"),a=require("./Pack"),i=require("./Sum");function o(o){const{inputs:p,backend:c,attrs:m}=o,{x:d,segmentIds:l}=p,{numSegments:k}=m;(0,t.assertNotComplex)(d,"unsortedSegmentSum");const S=[],f=[],h=d.shape.length-l.shape.length;let x=l;for(let e=0;e<h;++e){const t=(0,u.expandDims)({inputs:{input:x},backend:c,attrs:{dim:e+1}});x=t,f.push(t)}for(let t=0;t<k;++t){const u=e.util.createScalarValue(t,"int32"),a=c.makeTensorInfo([],"int32",u),o=(0,n.equal)({inputs:{a:a,b:x},backend:c}),p=(0,s.cast)({inputs:{x:o},backend:c,attrs:{dtype:"float32"}}),m=(0,r.multiply)({inputs:{a:p,b:d},backend:c}),l=(0,i.sum)({inputs:{x:m},backend:c,attrs:{axis:0,keepDims:!1}});S.push(l),f.push(a),f.push(o),f.push(p),f.push(m),f.push(l)}const b=(0,a.pack)({inputs:S,backend:c,attrs:{axis:0}});return f.forEach(e=>c.disposeIntermediateTensorInfo(e)),b}const p=exports.unsortedSegmentSumConfig={kernelName:e.UnsortedSegmentSum,backendName:"cpu",kernelFunc:o};
},{"@tensorflow/tfjs-core":"kSBl","../cpu_util":"nVKy","./Cast":"Bp6G","./Equal":"Qy3m","./ExpandDims":"B1EV","./Multiply":"N9Eb","./Pack":"CPkC","./Sum":"EH1U"}],"zh3A":[function(require,module,exports) {
"use strict";var e=require("@tensorflow/tfjs-core"),r=require("./kernels/_FusedMatMul"),i=require("./kernels/Abs"),n=require("./kernels/Acos"),o=require("./kernels/Acosh"),s=require("./kernels/Add"),l=require("./kernels/AddN"),u=require("./kernels/All"),g=require("./kernels/Any"),a=require("./kernels/ArgMax"),f=require("./kernels/ArgMin"),k=require("./kernels/Asin"),C=require("./kernels/Asinh"),q=require("./kernels/Atan"),t=require("./kernels/Atan2"),p=require("./kernels/Atanh"),c=require("./kernels/AvgPool"),d=require("./kernels/AvgPool3D"),m=require("./kernels/AvgPool3DGrad"),S=require("./kernels/AvgPoolGrad"),D=require("./kernels/BatchMatMul"),h=require("./kernels/BatchNorm"),v=require("./kernels/BatchToSpaceND"),N=require("./kernels/Bincount"),x=require("./kernels/BitwiseAnd"),R=require("./kernels/BroadcastArgs"),B=require("./kernels/Cast"),M=require("./kernels/Ceil"),A=require("./kernels/ClipByValue"),F=require("./kernels/Complex"),P=require("./kernels/ComplexAbs"),T=require("./kernels/Concat"),G=require("./kernels/Conv2D"),L=require("./kernels/Conv2DBackpropFilter"),V=require("./kernels/Conv2DBackpropInput"),w=require("./kernels/Conv3D"),b=require("./kernels/Conv3DBackpropFilterV2"),E=require("./kernels/Conv3DBackpropInputV2"),I=require("./kernels/Cos"),y=require("./kernels/Cosh"),z=require("./kernels/CropAndResize"),O=require("./kernels/Cumprod"),U=require("./kernels/Cumsum"),H=require("./kernels/DenseBincount"),W=require("./kernels/DepthToSpace"),K=require("./kernels/DepthwiseConv2dNative"),_=require("./kernels/DepthwiseConv2dNativeBackpropFilter"),j=require("./kernels/DepthwiseConv2dNativeBackpropInput"),Z=require("./kernels/Diag"),J=require("./kernels/Dilation2D"),Q=require("./kernels/Dilation2DBackpropFilter"),X=require("./kernels/Dilation2DBackpropInput"),Y=require("./kernels/Draw"),$=require("./kernels/Einsum"),ee=require("./kernels/Elu"),re=require("./kernels/EluGrad"),ie=require("./kernels/Equal"),ne=require("./kernels/Erf"),oe=require("./kernels/Exp"),se=require("./kernels/ExpandDims"),le=require("./kernels/Expm1"),ue=require("./kernels/FFT"),ge=require("./kernels/Fill"),ae=require("./kernels/FlipLeftRight"),fe=require("./kernels/Floor"),ke=require("./kernels/FloorDiv"),Ce=require("./kernels/FusedConv2D"),qe=require("./kernels/FusedDepthwiseConv2D"),te=require("./kernels/GatherNd"),pe=require("./kernels/GatherV2"),ce=require("./kernels/Greater"),de=require("./kernels/GreaterEqual"),me=require("./kernels/Identity"),Se=require("./kernels/IFFT"),De=require("./kernels/Imag"),he=require("./kernels/IsFinite"),ve=require("./kernels/IsInf"),Ne=require("./kernels/IsNaN"),xe=require("./kernels/LeakyRelu"),Re=require("./kernels/Less"),Be=require("./kernels/LessEqual"),Me=require("./kernels/LinSpace"),Ae=require("./kernels/Log"),Fe=require("./kernels/Log1p"),Pe=require("./kernels/LogicalAnd"),Te=require("./kernels/LogicalNot"),Ge=require("./kernels/LogicalOr"),Le=require("./kernels/LRN"),Ve=require("./kernels/LRNGrad"),we=require("./kernels/Max"),be=require("./kernels/Maximum"),Ee=require("./kernels/MaxPool"),Ie=require("./kernels/MaxPool3D"),ye=require("./kernels/MaxPool3DGrad"),ze=require("./kernels/MaxPoolGrad"),Oe=require("./kernels/MaxPoolWithArgmax"),Ue=require("./kernels/Mean"),He=require("./kernels/Min"),We=require("./kernels/Minimum"),Ke=require("./kernels/MirrorPad"),_e=require("./kernels/Mod"),je=require("./kernels/Multinomial"),Ze=require("./kernels/Multiply"),Je=require("./kernels/Neg"),Qe=require("./kernels/NonMaxSuppressionV3"),Xe=require("./kernels/NonMaxSuppressionV4"),Ye=require("./kernels/NonMaxSuppressionV5"),$e=require("./kernels/NotEqual"),er=require("./kernels/OneHot"),rr=require("./kernels/OnesLike"),ir=require("./kernels/Pack"),nr=require("./kernels/PadV2"),or=require("./kernels/Pow"),sr=require("./kernels/Prelu"),lr=require("./kernels/Prod"),ur=require("./kernels/RaggedGather"),gr=require("./kernels/RaggedRange"),ar=require("./kernels/RaggedTensorToTensor"),fr=require("./kernels/Range"),kr=require("./kernels/Real"),Cr=require("./kernels/RealDiv"),qr=require("./kernels/Reciprocal"),tr=require("./kernels/Relu"),pr=require("./kernels/Relu6"),cr=require("./kernels/Reshape"),dr=require("./kernels/ResizeBilinear"),mr=require("./kernels/ResizeBilinearGrad"),Sr=require("./kernels/ResizeNearestNeighbor"),Dr=require("./kernels/ResizeNearestNeighborGrad"),hr=require("./kernels/Reverse"),vr=require("./kernels/RotateWithOffset"),Nr=require("./kernels/Round"),xr=require("./kernels/Rsqrt"),Rr=require("./kernels/ScatterNd"),Br=require("./kernels/SearchSorted"),Mr=require("./kernels/Select"),Ar=require("./kernels/Selu"),Fr=require("./kernels/Sigmoid"),Pr=require("./kernels/Sign"),Tr=require("./kernels/Sin"),Gr=require("./kernels/Sinh"),Lr=require("./kernels/Slice"),Vr=require("./kernels/Softmax"),wr=require("./kernels/Softplus"),br=require("./kernels/SpaceToBatchND"),Er=require("./kernels/SparseFillEmptyRows"),Ir=require("./kernels/SparseReshape"),yr=require("./kernels/SparseSegmentMean"),zr=require("./kernels/SparseSegmentSum"),Or=require("./kernels/SparseToDense"),Ur=require("./kernels/SplitV"),Hr=require("./kernels/Sqrt"),Wr=require("./kernels/Square"),Kr=require("./kernels/SquaredDifference"),_r=require("./kernels/StaticRegexReplace"),jr=require("./kernels/Step"),Zr=require("./kernels/StridedSlice"),Jr=require("./kernels/StringNGrams"),Qr=require("./kernels/StringSplit"),Xr=require("./kernels/StringToHashBucketFast"),Yr=require("./kernels/Sub"),$r=require("./kernels/Sum"),ei=require("./kernels/Tan"),ri=require("./kernels/Tanh"),ii=require("./kernels/TensorScatterUpdate"),ni=require("./kernels/Tile"),oi=require("./kernels/TopK"),si=require("./kernels/Transform"),li=require("./kernels/Transpose"),ui=require("./kernels/Unique"),gi=require("./kernels/Unpack"),ai=require("./kernels/UnsortedSegmentSum"),fi=require("./kernels/ZerosLike");const ki=[r._fusedMatMulConfig,i.absConfig,n.acosConfig,o.acoshConfig,s.addConfig,l.addNConfig,u.allConfig,g.anyConfig,a.argMaxConfig,f.argMinConfig,k.asinConfig,C.asinhConfig,q.atanConfig,t.atan2Config,p.atanhConfig,c.avgPoolConfig,d.avgPool3DConfig,m.avgPool3DGradConfig,S.avgPoolGradConfig,D.batchMatMulConfig,h.batchNormConfig,v.batchToSpaceNDConfig,N.bincountConfig,x.bitwiseAndConfig,R.broadcastArgsConfig,B.castConfig,M.ceilConfig,A.clipByValueConfig,F.complexConfig,P.complexAbsConfig,T.concatConfig,G.conv2DConfig,L.conv2DBackpropFilterConfig,V.conv2DBackpropInputConfig,w.conv3DConfig,b.conv3DBackpropFilterV2Config,E.conv3DBackpropInputV2Config,I.cosConfig,y.coshConfig,z.cropAndResizeConfig,O.cumprodConfig,U.cumsumConfig,H.denseBincountConfig,W.depthToSpaceConfig,K.depthwiseConv2dNativeConfig,_.depthwiseConv2dNativeBackpropFilterConfig,j.depthwiseConv2dNativeBackpropInputConfig,Z.diagConfig,J.dilation2DConfig,Q.dilation2DBackpropFilterConfig,X.dilation2DBackpropInputConfig,Y.drawConfig,$.einsumConfig,ee.eluConfig,re.eluGradConfig,ie.equalConfig,ne.erfConfig,oe.expConfig,se.expandDimsConfig,le.expm1Config,ue.fftConfig,ge.fillConfig,ae.flipLeftRightConfig,fe.floorConfig,ke.floorDivConfig,Ce.fusedConv2DConfig,qe.fusedDepthwiseConv2DConfig,te.gatherNdConfig,pe.gatherV2Config,ce.greaterConfig,de.greaterEqualConfig,me.identityConfig,Se.ifftConfig,De.imagConfig,he.isFiniteConfig,ve.isInfConfig,Ne.isNaNConfig,xe.leakyReluConfig,Re.lessConfig,Be.lessEqualConfig,Me.linSpaceConfig,Ae.logConfig,Fe.log1pConfig,Pe.logicalAndConfig,Te.logicalNotConfig,Ge.logicalOrConfig,Le.LRNConfig,Ve.LRNGradConfig,we.maxConfig,be.maximumConfig,Ee.maxPoolConfig,Ie.maxPool3DConfig,ye.maxPool3DGradConfig,ze.maxPoolGradConfig,Oe.maxPoolWithArgmaxConfig,Ue.meanConfig,He.minConfig,We.minimumConfig,Ke.mirrorPadConfig,_e.modConfig,je.multinomialConfig,Ze.multiplyConfig,Je.negConfig,Qe.nonMaxSuppressionV3Config,Xe.nonMaxSuppressionV4Config,Ye.nonMaxSuppressionV5Config,$e.notEqualConfig,er.oneHotConfig,rr.onesLikeConfig,ir.packConfig,nr.padV2Config,or.powConfig,sr.preluConfig,lr.prodConfig,ur.raggedGatherConfig,gr.raggedRangeConfig,ar.raggedTensorToTensorConfig,fr.rangeConfig,kr.realConfig,Cr.realDivConfig,qr.reciprocalConfig,tr.reluConfig,pr.relu6Config,cr.reshapeConfig,dr.resizeBilinearConfig,mr.resizeBilinearGradConfig,Sr.resizeNearestNeighborConfig,Dr.resizeNearestNeighborGradConfig,hr.reverseConfig,vr.rotateWithOffsetConfig,Nr.roundConfig,xr.rsqrtConfig,Rr.scatterNdConfig,Br.searchSortedConfig,Mr.selectConfig,Ar.seluConfig,Fr.sigmoidConfig,Pr.signConfig,Tr.sinConfig,Gr.sinhConfig,Lr.sliceConfig,Vr.softmaxConfig,wr.softplusConfig,br.spaceToBatchNDConfig,Er.sparseFillEmptyRowsConfig,Ir.sparseReshapeConfig,yr.sparseSegmentMeanConfig,zr.sparseSegmentSumConfig,Or.sparseToDenseConfig,Ur.splitVConfig,Hr.sqrtConfig,Wr.squareConfig,Kr.squaredDifferenceConfig,_r.staticRegexReplaceConfig,jr.stepConfig,Zr.stridedSliceConfig,Jr.stringNGramsConfig,Qr.stringSplitConfig,Xr.stringToHashBucketFastConfig,Yr.subConfig,$r.sumConfig,ei.tanConfig,ri.tanhConfig,ii.tensorScatterUpdateConfig,ni.tileConfig,oi.topKConfig,si.transformConfig,li.transposeConfig,ui.uniqueConfig,gi.unpackConfig,ai.unsortedSegmentSumConfig,fi.zerosLikeConfig];for(const Ci of ki)(0,e.registerKernel)(Ci);
},{"@tensorflow/tfjs-core":"kSBl","./kernels/_FusedMatMul":"scv7","./kernels/Abs":"WHC3","./kernels/Acos":"gpS6","./kernels/Acosh":"evAw","./kernels/Add":"ZBkJ","./kernels/AddN":"caIF","./kernels/All":"wcw0","./kernels/Any":"idgX","./kernels/ArgMax":"WhbY","./kernels/ArgMin":"NFWe","./kernels/Asin":"N8T3","./kernels/Asinh":"xPoz","./kernels/Atan":"s1ZS","./kernels/Atan2":"AHcr","./kernels/Atanh":"JKyg","./kernels/AvgPool":"qDYU","./kernels/AvgPool3D":"RFNp","./kernels/AvgPool3DGrad":"UevM","./kernels/AvgPoolGrad":"ZSgh","./kernels/BatchMatMul":"xlhc","./kernels/BatchNorm":"OtYx","./kernels/BatchToSpaceND":"xdCY","./kernels/Bincount":"cA1l","./kernels/BitwiseAnd":"PuG8","./kernels/BroadcastArgs":"AJJk","./kernels/Cast":"Bp6G","./kernels/Ceil":"PT9Z","./kernels/ClipByValue":"LGZH","./kernels/Complex":"KmEe","./kernels/ComplexAbs":"EAkL","./kernels/Concat":"ZWVG","./kernels/Conv2D":"E2Vg","./kernels/Conv2DBackpropFilter":"fkMN","./kernels/Conv2DBackpropInput":"fcKD","./kernels/Conv3D":"a6p3","./kernels/Conv3DBackpropFilterV2":"DRlm","./kernels/Conv3DBackpropInputV2":"DCpn","./kernels/Cos":"diTV","./kernels/Cosh":"YBxL","./kernels/CropAndResize":"wxMi","./kernels/Cumprod":"O5hk","./kernels/Cumsum":"DpoM","./kernels/DenseBincount":"mHH1","./kernels/DepthToSpace":"O7Jf","./kernels/DepthwiseConv2dNative":"nTCB","./kernels/DepthwiseConv2dNativeBackpropFilter":"KAed","./kernels/DepthwiseConv2dNativeBackpropInput":"O5E9","./kernels/Diag":"KIC9","./kernels/Dilation2D":"RutC","./kernels/Dilation2DBackpropFilter":"SdQk","./kernels/Dilation2DBackpropInput":"Tml6","./kernels/Draw":"umZe","./kernels/Einsum":"MGE7","./kernels/Elu":"DCCw","./kernels/EluGrad":"sOra","./kernels/Equal":"Qy3m","./kernels/Erf":"SuF1","./kernels/Exp":"Q92g","./kernels/ExpandDims":"B1EV","./kernels/Expm1":"wiHC","./kernels/FFT":"km8M","./kernels/Fill":"Iz4a","./kernels/FlipLeftRight":"jKep","./kernels/Floor":"KFD4","./kernels/FloorDiv":"JeKf","./kernels/FusedConv2D":"zTKt","./kernels/FusedDepthwiseConv2D":"zu78","./kernels/GatherNd":"eygj","./kernels/GatherV2":"ZMn5","./kernels/Greater":"QWdt","./kernels/GreaterEqual":"gfwn","./kernels/Identity":"nMAE","./kernels/IFFT":"NGLg","./kernels/Imag":"YWMY","./kernels/IsFinite":"dRYN","./kernels/IsInf":"mqmg","./kernels/IsNaN":"aZ2V","./kernels/LeakyRelu":"vnsb","./kernels/Less":"x95l","./kernels/LessEqual":"N5Qh","./kernels/LinSpace":"MgCL","./kernels/Log":"ipxn","./kernels/Log1p":"ZPXk","./kernels/LogicalAnd":"Jrk0","./kernels/LogicalNot":"c1HV","./kernels/LogicalOr":"CEVP","./kernels/LRN":"tpLL","./kernels/LRNGrad":"AaA7","./kernels/Max":"MqGL","./kernels/Maximum":"DbCK","./kernels/MaxPool":"lCs9","./kernels/MaxPool3D":"o8AC","./kernels/MaxPool3DGrad":"zcv3","./kernels/MaxPoolGrad":"vVVK","./kernels/MaxPoolWithArgmax":"jYjX","./kernels/Mean":"Imwc","./kernels/Min":"VXYe","./kernels/Minimum":"pZXl","./kernels/MirrorPad":"WAgk","./kernels/Mod":"ZmsI","./kernels/Multinomial":"kAjy","./kernels/Multiply":"N9Eb","./kernels/Neg":"NnAL","./kernels/NonMaxSuppressionV3":"FriM","./kernels/NonMaxSuppressionV4":"WzMy","./kernels/NonMaxSuppressionV5":"Wtm2","./kernels/NotEqual":"VkjO","./kernels/OneHot":"Jaj4","./kernels/OnesLike":"pdze","./kernels/Pack":"CPkC","./kernels/PadV2":"Ylc8","./kernels/Pow":"YQ3v","./kernels/Prelu":"YsQM","./kernels/Prod":"us0k","./kernels/RaggedGather":"XAjk","./kernels/RaggedRange":"RjlN","./kernels/RaggedTensorToTensor":"UQ6n","./kernels/Range":"dRlj","./kernels/Real":"icBn","./kernels/RealDiv":"jPQU","./kernels/Reciprocal":"PhB2","./kernels/Relu":"MWuD","./kernels/Relu6":"rFRZ","./kernels/Reshape":"FjS7","./kernels/ResizeBilinear":"f8vQ","./kernels/ResizeBilinearGrad":"niMu","./kernels/ResizeNearestNeighbor":"F9yl","./kernels/ResizeNearestNeighborGrad":"VbVm","./kernels/Reverse":"UHhn","./kernels/RotateWithOffset":"FpFQ","./kernels/Round":"W307","./kernels/Rsqrt":"eSbP","./kernels/ScatterNd":"Wt5A","./kernels/SearchSorted":"obrK","./kernels/Select":"ZOwV","./kernels/Selu":"qgMT","./kernels/Sigmoid":"QVgs","./kernels/Sign":"AMoq","./kernels/Sin":"ot3i","./kernels/Sinh":"UUxh","./kernels/Slice":"i6mc","./kernels/Softmax":"xTcN","./kernels/Softplus":"NecI","./kernels/SpaceToBatchND":"kHRr","./kernels/SparseFillEmptyRows":"ptlO","./kernels/SparseReshape":"XRS0","./kernels/SparseSegmentMean":"MRym","./kernels/SparseSegmentSum":"OuxZ","./kernels/SparseToDense":"ZLxi","./kernels/SplitV":"BUH5","./kernels/Sqrt":"YdSx","./kernels/Square":"onVE","./kernels/SquaredDifference":"p6Qg","./kernels/StaticRegexReplace":"ENGS","./kernels/Step":"euKg","./kernels/StridedSlice":"IocJ","./kernels/StringNGrams":"Ds6w","./kernels/StringSplit":"dykI","./kernels/StringToHashBucketFast":"DxUa","./kernels/Sub":"fBFg","./kernels/Sum":"EH1U","./kernels/Tan":"L3BY","./kernels/Tanh":"DseU","./kernels/TensorScatterUpdate":"SoME","./kernels/Tile":"Miyd","./kernels/TopK":"WBag","./kernels/Transform":"aHoY","./kernels/Transpose":"zFLV","./kernels/Unique":"xqHf","./kernels/Unpack":"PIOQ","./kernels/UnsortedSegmentSum":"IFWn","./kernels/ZerosLike":"vJtB"}],"sqr6":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0});var e=require("./base");Object.keys(e).forEach(function(r){"default"!==r&&"__esModule"!==r&&(r in exports&&exports[r]===e[r]||Object.defineProperty(exports,r,{enumerable:!0,get:function(){return e[r]}}))}),require("./register_all_kernels");
},{"./base":"Y42A","./register_all_kernels":"zh3A"}],"xuCv":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.clearWebGLContext=o,exports.getWebGLContext=l,exports.setWebGLContext=r;var e=require("@tensorflow/tfjs-core");const t={},n={alpha:!1,antialias:!1,premultipliedAlpha:!1,preserveDrawingBuffer:!1,depth:!1,stencil:!1,failIfMajorPerformanceCaveat:!0};function o(e){delete t[e]}function r(e,n){t[e]=n}function l(e,n){if(!(e in t)||null!=n){const o=i(e,n);if(null===o)return console.log("Could not get context for WebGL version",e),null;t[e]=o}const o=t[e];return null==o||o.isContextLost()?(delete t[e],l(e)):(o.disable(o.DEPTH_TEST),o.disable(o.STENCIL_TEST),o.disable(o.BLEND),o.disable(o.DITHER),o.disable(o.POLYGON_OFFSET_FILL),o.disable(o.SAMPLE_COVERAGE),o.enable(o.SCISSOR_TEST),o.enable(o.CULL_FACE),o.cullFace(o.BACK),t[e])}function a(t){if((0,e.env)().getBool("IS_SAFARI")||"undefined"==typeof OffscreenCanvas||2!==t){if("undefined"!=typeof document)return document.createElement("canvas");throw new Error("Cannot create a canvas in this context")}return new OffscreenCanvas(300,150)}function i(o,r){if(1!==o&&2!==o)throw new Error("Cannot get WebGL rendering context, WebGL is disabled.");const l=null==r?a(o):r;return l.addEventListener("webglcontextlost",e=>{e.preventDefault(),delete t[o]},!1),(0,e.env)().getBool("SOFTWARE_WEBGL_ENABLED")&&(n.failIfMajorPerformanceCaveat=!1),1===o?l.getContext("webgl",n)||l.getContext("experimental-webgl",n):l.getContext("webgl2",n)}
},{"@tensorflow/tfjs-core":"kSBl"}],"jAWT":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.TextureUsage=exports.PhysicalTextureType=exports.PackingScheme=void 0,exports.decodeMatrixFromUnpackedColorRGBAArray=l,exports.getColorMatrixTextureShapeWidthHeight=i,exports.getDenseTexShape=u,exports.getMatrixSizeFromUnpackedArraySize=A,exports.getPackedMatrixTextureShapeWidthHeight=c,exports.getPackedRGBAArraySizeFromMatrixShape=x,exports.getTextureConfig=s,exports.getUnpackedArraySizeFromMatrixSize=a,exports.getUnpackedMatrixTextureShapeWidthHeight=n;var e,t,r,o=require("@tensorflow/tfjs-core");function n(e,t){return[t,e]}function a(e,t){return e*t}function i(e,t){return[4*t,e]}function u(e){const t=o.util.sizeFromShape(e),r=Math.ceil(t/4);return o.util.sizeToSquarishShape(r)}function A(e,t){if(e%t!=0)throw new Error(`unpackedSize (${e}) must be a multiple of `+`${t}`);return e/t}function l(e,t,r){const o=e.length*r/4;if(t.length<o)throw new Error(`matrix length (${t.length}) must be >= ${o}`);let n=0;for(let a=0;a<e.length;a+=4)for(let o=0;o<r;o++)t[n++]=e[a+o]}function c(e,t){return[Math.max(1,Math.ceil(t/2)),Math.max(1,Math.ceil(e/2))]}function x(e,t){const[r,o]=c(e,t);return r*o*4}function s(e,t){const r=e;let n,a,i,u,A,l,c,x,s,F;return 2===(0,o.env)().getNumber("WEBGL_VERSION")?(n=r.R32F,a=r.R16F,i=r.RGBA16F,u=r.RGBA32F,A=r.RED,c=4,x=1,s=r.HALF_FLOAT,F=r.FLOAT,l=r.RGBA8):(n=e.RGBA,a=e.RGBA,i=e.RGBA,u=r.RGBA,A=e.RGBA,c=4,x=4,s=null!=t?t.HALF_FLOAT_OES:null,F=e.FLOAT,l=e.RGBA),{internalFormatFloat:n,internalFormatHalfFloat:a,internalFormatPackedHalfFloat:i,internalFormatPackedFloat:u,textureFormatFloat:A,downloadTextureFormat:l,downloadUnpackNumChannels:c,defaultNumChannels:x,textureTypeHalfFloat:s,textureTypeFloat:F}}!function(e){e[e.DENSE=0]="DENSE",e[e.SHARED_BATCH=1]="SHARED_BATCH"}(e||(exports.PackingScheme=e={})),function(e){e[e.RENDER=0]="RENDER",e[e.UPLOAD=1]="UPLOAD",e[e.PIXELS=2]="PIXELS",e[e.DOWNLOAD=3]="DOWNLOAD"}(t||(exports.TextureUsage=t={})),function(e){e[e.UNPACKED_FLOAT16=0]="UNPACKED_FLOAT16",e[e.UNPACKED_FLOAT32=1]="UNPACKED_FLOAT32",e[e.PACKED_4X1_UNSIGNED_BYTE=2]="PACKED_4X1_UNSIGNED_BYTE",e[e.PACKED_2X2_FLOAT32=3]="PACKED_2X2_FLOAT32",e[e.PACKED_2X2_FLOAT16=4]="PACKED_2X2_FLOAT16"}(r||(exports.PhysicalTextureType=r={}));
},{"@tensorflow/tfjs-core":"kSBl"}],"u1ML":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.assertNotComplex=te,exports.bindCanvasToFramebuffer=O,exports.bindColorTextureToFramebuffer=I,exports.bindTextureToProgramUniformSampler=S,exports.bindTextureUnit=U,exports.bindVertexBufferToProgramAttribute=d,exports.callAndCheck=n,exports.canBeRepresented=i,exports.createFragmentShader=s,exports.createFramebuffer=m,exports.createProgram=F,exports.createStaticIndexBuffer=x,exports.createStaticVertexBuffer=_,exports.createTexture=h,exports.createVertexShader=l,exports.getBatchDim=G,exports.getExtensionOrThrow=f,exports.getFramebufferErrorMessage=C,exports.getMaxTexturesInShader=z,exports.getNumChannels=b,exports.getProgramUniformLocation=L,exports.getProgramUniformLocationOrThrow=M,exports.getRowsCols=w,exports.getShapeAs3D=X,exports.getTextureShapeFromLogicalShape=W,exports.getWebGLDisjointQueryTimerVersion=Y,exports.getWebGLErrorMessage=E,exports.getWebGLMaxTextureSize=$,exports.hasExtension=j,exports.isCapableOfRenderingToFloatTexture=Q,exports.isDownloadFloatTextureEnabled=K,exports.isReshapeFree=V,exports.isWebGLFenceEnabled=re,exports.isWebGLVersionEnabled=Z,exports.linkProgram=R,exports.logShaderSourceAndInfoLog=T,exports.resetMaxTextureSize=k,exports.resetMaxTexturesInShader=q,exports.unbindColorTextureFromFramebuffer=N,exports.unbindTextureUnit=p,exports.validateFramebuffer=B,exports.validateProgram=g,exports.validateTextureSize=A;var e=require("@tensorflow/tfjs-core"),r=require("./canvas_util"),t=require("./tex_util");function n(r,t){const n=t();return(0,e.env)().getBool("DEBUG")&&o(r),n}function o(e){const r=e.getError();if(r!==e.NO_ERROR)throw new Error("WebGL Error: "+E(e,r))}const u=5.96e-8,a=65504;function i(r){return!!((0,e.env)().getBool("WEBGL_RENDER_FLOAT32_ENABLED")||0===r||u<Math.abs(r)&&Math.abs(r)<a)}function E(e,r){switch(r){case e.NO_ERROR:return"NO_ERROR";case e.INVALID_ENUM:return"INVALID_ENUM";case e.INVALID_VALUE:return"INVALID_VALUE";case e.INVALID_OPERATION:return"INVALID_OPERATION";case e.INVALID_FRAMEBUFFER_OPERATION:return"INVALID_FRAMEBUFFER_OPERATION";case e.OUT_OF_MEMORY:return"OUT_OF_MEMORY";case e.CONTEXT_LOST_WEBGL:return"CONTEXT_LOST_WEBGL";default:return`Unknown error code ${r}`}}function f(e,r){return P(e,()=>e.getExtension(r),'Extension "'+r+'" not supported on this browser.')}function l(e,r){const t=P(e,()=>e.createShader(e.VERTEX_SHADER),"Unable to create vertex WebGLShader.");if(n(e,()=>e.shaderSource(t,r)),n(e,()=>e.compileShader(t)),!1===e.getShaderParameter(t,e.COMPILE_STATUS))throw console.log(e.getShaderInfoLog(t)),new Error("Failed to compile vertex shader.");return t}function s(r,t){const o=P(r,()=>r.createShader(r.FRAGMENT_SHADER),"Unable to create fragment WebGLShader.");if(n(r,()=>r.shaderSource(o,t)),n(r,()=>r.compileShader(o)),(0,e.env)().get("ENGINE_COMPILE_ONLY"))return o;if(!1===r.getShaderParameter(o,r.COMPILE_STATUS))throw T(t,r.getShaderInfoLog(o)),new Error("Failed to compile fragment shader.");return o}const c=/ERROR: [0-9]+:([0-9]+):/g;function T(r,t){const n=c.exec(t);if(null==n)return console.log(`Couldn't parse line number in error: ${t}`),void console.log(r);const o=+n[1],u=r.split("\n"),a=u.length.toString().length+2,i=u.map((r,t)=>e.util.rightPad((t+1).toString(),a)+r);let E=0;for(let e=0;e<i.length;e++)E=Math.max(i[e].length,E);const f=i.slice(0,o-1),l=i.slice(o-1,o),s=i.slice(o);console.log(f.join("\n")),console.log(t.split("\n")[0]),console.log(`%c ${e.util.rightPad(l[0],E)}`,"border:1px solid red; background-color:#e3d2d2; color:#a61717"),console.log(s.join("\n"))}function F(e){return P(e,()=>e.createProgram(),"Unable to create WebGLProgram.")}function R(r,t){if(n(r,()=>r.linkProgram(t)),!(0,e.env)().get("ENGINE_COMPILE_ONLY")&&!1===r.getProgramParameter(t,r.LINK_STATUS))throw console.log(r.getProgramInfoLog(t)),new Error("Failed to link vertex and fragment shaders.")}function g(e,r){if(n(e,()=>e.validateProgram(r)),!1===e.getProgramParameter(r,e.VALIDATE_STATUS))throw console.log(e.getProgramInfoLog(r)),new Error("Shader program validation failed.")}function _(e,r){const t=P(e,()=>e.createBuffer(),"Unable to create WebGLBuffer");return n(e,()=>e.bindBuffer(e.ARRAY_BUFFER,t)),n(e,()=>e.bufferData(e.ARRAY_BUFFER,r,e.STATIC_DRAW)),t}function x(e,r){const t=P(e,()=>e.createBuffer(),"Unable to create WebGLBuffer");return n(e,()=>e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,t)),n(e,()=>e.bufferData(e.ELEMENT_ARRAY_BUFFER,r,e.STATIC_DRAW)),t}function b(){return 2===(0,e.env)().getNumber("WEBGL_VERSION")?1:4}function h(e){return P(e,()=>e.createTexture(),"Unable to create WebGLTexture.")}function A(r,t){const n=(0,e.env)().getNumber("WEBGL_MAX_TEXTURE_SIZE");if(r<=0||t<=0){throw new Error("Requested texture size "+`[${r}x${t}]`+" is invalid.")}if(r>n||t>n){throw new Error("Requested texture size "+`[${r}x${t}]`+" greater than WebGL maximum on this browser / GPU "+`[${n}x${n}]`+".")}}function m(e){return P(e,()=>e.createFramebuffer(),"Unable to create WebGLFramebuffer.")}function d(e,r,t,o,u,a,i){const E=e.getAttribLocation(r,t);return-1!==E&&(n(e,()=>e.bindBuffer(e.ARRAY_BUFFER,o)),n(e,()=>e.vertexAttribPointer(E,u,e.FLOAT,!1,a,i)),n(e,()=>e.enableVertexAttribArray(E)),!0)}function U(e,r,t){D(e,t),n(e,()=>e.activeTexture(e.TEXTURE0+t)),n(e,()=>e.bindTexture(e.TEXTURE_2D,r))}function p(e,r){D(e,r),n(e,()=>e.activeTexture(e.TEXTURE0+r)),n(e,()=>e.bindTexture(e.TEXTURE_2D,null))}function M(e,r,t){return P(e,()=>e.getUniformLocation(r,t),'uniform "'+t+'" not present in program.')}function L(e,r,t){return e.getUniformLocation(r,t)}function S(e,r,t,o){n(e,()=>U(e,r,o)),n(e,()=>e.uniform1i(t,o))}function O(e){n(e,()=>e.bindFramebuffer(e.FRAMEBUFFER,null)),n(e,()=>e.viewport(0,0,e.canvas.width,e.canvas.height)),n(e,()=>e.scissor(0,0,e.canvas.width,e.canvas.height))}function I(e,r,t){n(e,()=>e.bindFramebuffer(e.FRAMEBUFFER,t)),n(e,()=>e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,r,0))}function N(e,r){n(e,()=>e.bindFramebuffer(e.FRAMEBUFFER,r)),n(e,()=>e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,null,0))}function B(e){const r=e.checkFramebufferStatus(e.FRAMEBUFFER);if(r!==e.FRAMEBUFFER_COMPLETE)throw new Error("Error binding framebuffer: "+C(e,r))}function C(e,r){switch(r){case e.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_ATTACHMENT";case e.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT";case e.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:return"FRAMEBUFFER_INCOMPLETE_DIMENSIONS";case e.FRAMEBUFFER_UNSUPPORTED:return"FRAMEBUFFER_UNSUPPORTED";default:return`unknown error ${r}`}}function P(e,r,t){const o=n(e,()=>r());if(null==o)throw new Error(t);return o}function D(e,r){const t=e.MAX_COMBINED_TEXTURE_IMAGE_UNITS-1,n=r+e.TEXTURE0;if(n<e.TEXTURE0||n>t){throw new Error(`textureUnit must be in ${`[gl.TEXTURE0, gl.TEXTURE${t}]`}.`)}}function G(r,t=2){return e.util.sizeFromShape(r.slice(0,r.length-t))}function w(e){if(0===e.length)throw Error("Cannot get rows and columns of an empty shape array.");return[e.length>1?e[e.length-2]:1,e[e.length-1]]}function X(e){let r=[1,1,1];return 0===e.length||1===e.length&&1===e[0]||(r=[G(e),...w(e)]),r}function W(r,t=!1){let n=(0,e.env)().getNumber("WEBGL_MAX_TEXTURE_SIZE"),o=(0,e.env)().getNumber("WEBGL_MAX_SIZE_FOR_NARROW_TEXTURE");if(o===1/0&&(0,e.env)().getBool("WEBGL_AUTO_SQUARIFY_NARROW_TEXTURE_SHAPE")&&(o=n/2),t&&(n*=2,o*=2,1===(r=r.map((t,n)=>n>=r.length-2?e.util.nearestLargerEven(r[n]):r[n])).length&&(r=[2,r[0]])),2!==r.length){const t=e.util.squeezeShape(r);r=t.newShape}let u=e.util.sizeFromShape(r),a=null;r.length<=1&&u<=n?a=[1,u]:2===r.length&&r[0]<=n&&r[1]<=n?a=r:3===r.length&&r[0]*r[1]<=n&&r[2]<=n?a=[r[0]*r[1],r[2]]:3===r.length&&r[0]<=n&&r[1]*r[2]<=n?a=[r[0],r[1]*r[2]]:4===r.length&&r[0]*r[1]*r[2]<=n&&r[3]<=n?a=[r[0]*r[1]*r[2],r[3]]:4===r.length&&r[0]<=n&&r[1]*r[2]*r[3]<=n&&(a=[r[0],r[1]*r[2]*r[3]]);const i=null!=a&&Math.max(...a)>o&&Math.min(...a)<=(t?2:1)&&Math.min(...a)>0;if(null==a||i)if(t){const t=G(r);let n=2,o=2;r.length&&([n,o]=w(r)),u=t*(n/2)*(o/2),a=e.util.sizeToSquarishShape(u).map(e=>2*e)}else a=e.util.sizeToSquarishShape(u);return a}function v(e){return e%2==0}function V(r,t){if(r=r.slice(-2),t=t.slice(-2),e.util.arraysEqual(r,t))return!0;if(!r.length||!t.length)return!0;if(0===r[0]||0===r[1]||0===t[0]||0===t[1])return!0;if(r.length!==t.length){const e=r[r.length-1],n=t[t.length-1];if(e===n)return!0;if(v(e)&&v(n)&&(1===r[0]||1===t[0]))return!0}return r[1]===t[1]&&v(r[0])&&v(t[0])}let y,H;function $(e){if(null==y){const t=(0,r.getWebGLContext)(e);y=t.getParameter(t.MAX_TEXTURE_SIZE)}return y}function k(){y=null}function q(){H=null}function z(e){if(null==H){const t=(0,r.getWebGLContext)(e);H=t.getParameter(t.MAX_TEXTURE_IMAGE_UNITS)}return Math.min(16,H)}function Y(e){if(0===e)return 0;let t;const n=(0,r.getWebGLContext)(e);return t=j(n,"EXT_disjoint_timer_query_webgl2")&&2===e?2:j(n,"EXT_disjoint_timer_query")?1:0}function j(e,r){return null!=e.getExtension(r)}function Z(e){try{if(null!=(0,r.getWebGLContext)(e))return!0}catch(t){return console.log("Error when getting WebGL context: ",t),!1}return!1}function Q(e){if(0===e)return!1;const t=(0,r.getWebGLContext)(e);if(1===e){if(!j(t,"OES_texture_float"))return!1}else if(!j(t,"EXT_color_buffer_float"))return!1;return J(t)}function K(e){if(0===e)return!1;const t=(0,r.getWebGLContext)(e);if(1!==e){if(j(t,"EXT_color_buffer_float"))return J(t);const e="EXT_color_buffer_half_float";if(j(t,e)){const r=t.getExtension(e);return ee(t,r)}return!1}return!!j(t,"OES_texture_float")&&(!!j(t,"WEBGL_color_buffer_float")&&J(t))}function J(e){const r=(0,t.getTextureConfig)(e),n=e.createTexture();e.bindTexture(e.TEXTURE_2D,n);e.texImage2D(e.TEXTURE_2D,0,r.internalFormatFloat,1,1,0,r.textureFormatFloat,r.textureTypeFloat,null);const o=e.createFramebuffer();e.bindFramebuffer(e.FRAMEBUFFER,o),e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,n,0);const u=e.checkFramebufferStatus(e.FRAMEBUFFER)===e.FRAMEBUFFER_COMPLETE;return e.bindTexture(e.TEXTURE_2D,null),e.bindFramebuffer(e.FRAMEBUFFER,null),e.deleteTexture(n),e.deleteFramebuffer(o),u}function ee(e,r){const n=(0,t.getTextureConfig)(e,r),o=e.createTexture();e.bindTexture(e.TEXTURE_2D,o);e.texImage2D(e.TEXTURE_2D,0,n.internalFormatHalfFloat,1,1,0,n.textureFormatFloat,n.textureTypeHalfFloat,null);const u=e.createFramebuffer();e.bindFramebuffer(e.FRAMEBUFFER,u),e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,o,0);const a=e.checkFramebufferStatus(e.FRAMEBUFFER)===e.FRAMEBUFFER_COMPLETE;return e.bindTexture(e.TEXTURE_2D,null),e.bindFramebuffer(e.FRAMEBUFFER,null),e.deleteTexture(o),e.deleteFramebuffer(u),a}function re(e){if(2!==e)return!1;return null!=(0,r.getWebGLContext)(e).fenceSync}function te(r,t){Array.isArray(r)||(r=[r]),r.forEach(r=>{null!=r&&e.util.assert("complex64"!==r.dtype,()=>`${t} does not support complex64 tensors `+"in the WebGL backend.")})}
},{"@tensorflow/tfjs-core":"kSBl","./canvas_util":"xuCv","./tex_util":"jAWT"}],"K5Ex":[function(require,module,exports) {
"use strict";var E=require("@tensorflow/tfjs-core"),e=require("./webgl_util");const _=(0,E.env)();_.registerFlag("HAS_WEBGL",()=>_.getNumber("WEBGL_VERSION")>0),_.registerFlag("WEBGL_VERSION",()=>(0,e.isWebGLVersionEnabled)(2)?2:(0,e.isWebGLVersionEnabled)(1)?1:0),_.registerFlag("WEBGL_CHECK_NUMERICAL_PROBLEMS",()=>!1),_.registerFlag("WEBGL_BUFFER_SUPPORTED",()=>2===_.get("WEBGL_VERSION")),_.registerFlag("WEBGL_CPU_FORWARD",()=>!0),_.registerFlag("WEBGL_FORCE_F16_TEXTURES",()=>!1),_.registerFlag("WEBGL_PACK",()=>_.getBool("HAS_WEBGL")),_.registerFlag("WEBGL_PACK_NORMALIZATION",()=>_.getBool("WEBGL_PACK")),_.registerFlag("WEBGL_PACK_CLIP",()=>_.getBool("WEBGL_PACK")),_.registerFlag("WEBGL_PACK_DEPTHWISECONV",()=>_.getBool("WEBGL_PACK")),_.registerFlag("WEBGL_PACK_BINARY_OPERATIONS",()=>_.getBool("WEBGL_PACK")),_.registerFlag("WEBGL_PACK_UNARY_OPERATIONS",()=>_.getBool("WEBGL_PACK")),_.registerFlag("WEBGL_PACK_ARRAY_OPERATIONS",()=>_.getBool("WEBGL_PACK")),_.registerFlag("WEBGL_PACK_IMAGE_OPERATIONS",()=>_.getBool("WEBGL_PACK")),_.registerFlag("WEBGL_PACK_REDUCE",()=>_.getBool("WEBGL_PACK")),_.registerFlag("WEBGL_LAZILY_UNPACK",()=>_.getBool("WEBGL_PACK")),_.registerFlag("WEBGL_CONV_IM2COL",()=>_.getBool("WEBGL_PACK")),_.registerFlag("WEBGL_PACK_CONV2DTRANSPOSE",()=>_.getBool("WEBGL_PACK")),_.registerFlag("WEBGL_MAX_TEXTURE_SIZE",()=>(0,e.getWebGLMaxTextureSize)(_.getNumber("WEBGL_VERSION"))),_.registerFlag("WEBGL_MAX_TEXTURES_IN_SHADER",()=>(0,e.getMaxTexturesInShader)(_.getNumber("WEBGL_VERSION"))),_.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION",()=>{const E=_.getNumber("WEBGL_VERSION");return 0===E?0:(0,e.getWebGLDisjointQueryTimerVersion)(E)}),_.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE",()=>_.getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0&&!E.device_util.isMobile()),_.registerFlag("WEBGL_RENDER_FLOAT32_CAPABLE",()=>(0,e.isCapableOfRenderingToFloatTexture)(_.getNumber("WEBGL_VERSION"))),_.registerFlag("WEBGL_RENDER_FLOAT32_ENABLED",()=>!_.getBool("WEBGL_FORCE_F16_TEXTURES")&&_.getBool("WEBGL_RENDER_FLOAT32_CAPABLE")),_.registerFlag("WEBGL_DOWNLOAD_FLOAT_ENABLED",()=>(0,e.isDownloadFloatTextureEnabled)(_.getNumber("WEBGL_VERSION"))),_.registerFlag("WEBGL_FENCE_API_ENABLED",()=>(0,e.isWebGLFenceEnabled)(_.getNumber("WEBGL_VERSION"))),_.registerFlag("WEBGL_SIZE_UPLOAD_UNIFORM",()=>{return _.getBool("WEBGL_RENDER_FLOAT32_ENABLED")?4:0}),_.registerFlag("WEBGL_DELETE_TEXTURE_THRESHOLD",()=>-1,E=>{if("number"!=typeof E)throw new Error("WEBGL_DELETE_TEXTURE_THRESHOLD must be a number but "+`got ${E}.`);if(E<0&&-1!==E)throw new Error("WEBGL_DELETE_TEXTURE_THRESHOLD must be -1 (indicating never "+`delete) or at least 0, but got ${E}.`)}),_.registerFlag("WEBGL_FLUSH_THRESHOLD",()=>E.device_util.isMobile()?1:-1,E=>{if("number"!=typeof E)throw new Error("WEBGL_FLUSH_THRESHOLD must be a number but got "+`${E}.`);if(E<0&&-1!==E)throw new Error("WEBGL_FLUSH_THRESHOLD must be -1 (indicating never "+`manual flush) or at least 0, but got ${E}.`)}),_.registerFlag("CPU_HANDOFF_SIZE_THRESHOLD",()=>128),_.registerFlag("WEBGL_USE_SHAPES_UNIFORMS",()=>!1),_.registerFlag("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD",()=>1e5),_.registerFlag("TOPK_K_CPU_HANDOFF_THRESHOLD",()=>128),_.registerFlag("WEBGL_EXP_CONV",()=>!1),_.registerFlag("SOFTWARE_WEBGL_ENABLED",()=>_.getBool("IS_TEST")),_.registerFlag("WEBGL_MAX_SIZE_FOR_NARROW_TEXTURE",()=>1/0),_.registerFlag("WEBGL_AUTO_SQUARIFY_NARROW_TEXTURE_SHAPE",()=>!1),_.registerFlag("WEBGL2_ISNAN_CUSTOM",()=>!1),_.registerFlag("ENGINE_COMPILE_ONLY",()=>!1);
},{"@tensorflow/tfjs-core":"kSBl","./webgl_util":"u1ML"}],"fXvw":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.getGlslDifferences=e;var n=require("@tensorflow/tfjs-core");function e(){let e,a,t,u,o,l,v,i,r,s;return 2===(0,n.env)().getNumber("WEBGL_VERSION")?(e="#version 300 es",a="in",t="out",u="in",o="texture",l="outputColor",v="out vec4 outputColor;",i=(0,n.env)().getBool("WEBGL2_ISNAN_CUSTOM")?"\n      bool isnan_custom(float val) {\n        uint floatToUint = floatBitsToUint(val);\n        return (floatToUint & 0x7fffffffu) > 0x7f800000u;\n      }\n\n      bvec4 isnan_custom(vec4 val) {\n        return bvec4(isnan_custom(val.x),\n          isnan_custom(val.y), isnan_custom(val.z), isnan_custom(val.w));\n      }\n\n      #define isnan(value) isnan_custom(value)\n    ":"",r="",s="\n      #define round(value) newRound(value)\n      int newRound(float value) {\n        return int(floor(value + 0.5));\n      }\n\n      ivec4 newRound(vec4 value) {\n        return ivec4(floor(value + vec4(0.5)));\n      }\n    "):(e="",a="attribute",t="varying",u="varying",o="texture2D",l="gl_FragColor",v="",i="\n      #define isnan(value) isnan_custom(value)\n      bool isnan_custom(float val) {\n        return (val > 0. || val < 1. || val == 0.) ? false : true;\n      }\n      bvec4 isnan_custom(vec4 val) {\n        return bvec4(isnan(val.x), isnan(val.y), isnan(val.z), isnan(val.w));\n      }\n    ",r="\n      uniform float INFINITY;\n\n      bool isinf(float val) {\n        return abs(val) == INFINITY;\n      }\n      bvec4 isinf(vec4 val) {\n        return equal(abs(val), vec4(INFINITY));\n      }\n    ",s="\n      int round(float value) {\n        return int(floor(value + 0.5));\n      }\n\n      ivec4 round(vec4 value) {\n        return ivec4(floor(value + vec4(0.5)));\n      }\n    "),{version:e,attribute:a,varyingVs:t,varyingFs:u,texture2D:o,output:l,defineOutput:v,defineSpecialNaN:i,defineSpecialInf:r,defineRound:s}}
},{"@tensorflow/tfjs-core":"kSBl"}],"tjqy":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.ENCODE_FLOAT_SNIPPET=void 0,exports.dotify=c,exports.getFlatIndexFrom3D=s,exports.getFlatIndexFrom3DOutput=l,exports.getLogicalCoordinatesFromFlatIndex=t,exports.getLogicalCoordinatesFromFlatIndexByUniform=r,exports.getOutputLogicalCoordinatesFromFlatIndexByUniform=e;var n=require("@tensorflow/tfjs-core");function t(t,e,o="index"){const r=n.util.computeStrides(e);return r.map((n,e)=>{return`${`int ${t[e]} = ${o} / ${n}`}; ${e===r.length-1?`int ${t[e+1]} = ${o} - ${t[e]} * ${n}`:`index -= ${t[e]} * ${n}`};`}).join("")}function e(t,e,o="index"){const r=n.util.computeStrides(e);return r.map((n,e)=>{return`${`int ${t[e]} = ${o} / outShapeStrides[${e}]`}; ${e===r.length-1?`int ${t[e+1]} = ${o} - ${t[e]} * outShapeStrides[${e}]`:`index -= ${t[e]} * outShapeStrides[${e}]`};`}).join("")}function o(n,t){const e=n.length,o=n.map(n=>`${t}[${n}]`),r=new Array(e-1);r[e-2]=o[e-1];for(let i=e-3;i>=0;--i)r[i]=`(${r[i+1]} * ${o[i+1]})`;return r}function r(n,t,e="index"){const r=o(n.map((n,t)=>t),t);return r.map((t,o)=>{return`${`int ${n[o]} = ${e} / ${r[o]}`}; ${o===r.length-1?`int ${n[o+1]} = ${e} - ${n[o]} * ${r[o]}`:`index -= ${n[o]} * ${r[o]}`};`}).join("")}function i(n){return 1===n.length?`${n[0]}`:`vec${n.length}(${n.join(",")})`}function c(n,t){if(n.length!==t.length)throw new Error("Vectors to be dotted must be of the same length -"+`got ${n.length} and ${t.length}`);const e=[],o=Math.floor(n.length/4),r=n.length%4;for(let c=0;c<o;c++){const o=n.slice(4*c,4*c+4),r=t.slice(4*c,4*c+4);e.push(`${i(o)}, ${i(r)}`)}if(0!==r){let r=n.slice(4*o),c=t.slice(4*o);1===r.length&&(r=r.map(n=>`float(${n})`),c=c.map(n=>`float(${n})`)),e.push(`${i(r)}, ${i(c)}`)}return e.map((n,t)=>`dot(${n})`).join("+")}function s(t){const e=n.util.computeStrides(t).map(n=>n.toString());return`\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * ${e[0]} + coords.y * ${e[1]} + coords.z;\n  }\n`}function l(){return"\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;\n  }\n"}const a=exports.ENCODE_FLOAT_SNIPPET="\n  const float FLOAT_MAX = 1.70141184e38;\n  const float FLOAT_MIN = 1.17549435e-38;\n\n  lowp vec4 encode_float(highp float v) {\n    if (isnan(v)) {\n      return vec4(255, 255, 255, 255);\n    }\n\n    highp float av = abs(v);\n\n    if(av < FLOAT_MIN) {\n      return vec4(0.0, 0.0, 0.0, 0.0);\n    } else if(v > FLOAT_MAX) {\n      return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;\n    } else if(v < -FLOAT_MAX) {\n      return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;\n    }\n\n    highp vec4 c = vec4(0,0,0,0);\n\n    highp float e = floor(log2(av));\n    highp float m = exp2(fract(log2(av))) - 1.0;\n\n    c[2] = floor(128.0 * m);\n    m -= c[2] / 128.0;\n    c[1] = floor(32768.0 * m);\n    m -= c[1] / 32768.0;\n    c[0] = floor(8388608.0 * m);\n\n    highp float ebias = e + 127.0;\n    c[3] = floor(ebias / 2.0);\n    ebias -= c[3] * 2.0;\n    c[2] += floor(ebias) * 128.0;\n\n    c[3] += 128.0 * step(0.0, -v);\n\n    return c / 255.0;\n  }\n";
},{"@tensorflow/tfjs-core":"kSBl"}],"xhhc":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.getCoordsDataType=H,exports.getUniformInfoFromShape=W,exports.makeShader=o,exports.squeezeInputInfo=J;var e=require("@tensorflow/tfjs-core"),n=require("./glsl_version"),t=r(require("./shader_compiler_util"));function r(e,n){if("function"==typeof WeakMap)var t=new WeakMap,i=new WeakMap;return(r=function(e,n){if(!n&&e&&e.__esModule)return e;var r,o,a={__proto__:null,default:e};if(null===e||"object"!=typeof e&&"function"!=typeof e)return a;if(r=n?i:t){if(r.has(e))return r.get(e);r.set(e,a)}for(const t in e)"default"!==t&&{}.hasOwnProperty.call(e,t)&&((o=(r=Object.defineProperty)&&Object.getOwnPropertyDescriptor(e,t))&&(o.get||o.set)?r(a,t,o):a[t]=e[t]);return a})(e,n)}const{getBroadcastDims:i}=e.backend_util;function o(t,r,i){const o=[];if(t.forEach(n=>{const t=e.util.sizeFromShape(n.shapeInfo.logicalShape);if(n.shapeInfo.isUniform?o.push(`uniform float ${n.name}${t>1?`[${t}]`:""};`):(o.push(`uniform sampler2D ${n.name};`),o.push(`uniform int offset${n.name};`)),i.enableShapeUniforms){const{uniformShape:e}=W(i.packedInputs,n.shapeInfo.logicalShape,n.shapeInfo.texShape);switch(e.length){case 1:o.push(`uniform int ${n.name}Shape;`);break;case 2:o.push(`uniform ivec2 ${n.name}Shape;`);break;case 3:o.push(`uniform ivec3 ${n.name}Shape;`);break;case 4:o.push(`uniform ivec4 ${n.name}Shape;`)}o.push(`uniform ivec2 ${n.name}TexShape;`)}}),i.enableShapeUniforms){switch(r.logicalShape.length){case 1:o.push("uniform int outShape;");break;case 2:o.push("uniform ivec2 outShape;"),o.push("uniform int outShapeStrides;");break;case 3:o.push("uniform ivec3 outShape;"),o.push("uniform ivec2 outShapeStrides;");break;case 4:o.push("uniform ivec4 outShape;"),o.push("uniform ivec3 outShapeStrides;")}o.push("uniform ivec2 outTexShape;")}i.customUniforms&&i.customUniforms.forEach(e=>{o.push(`uniform ${e.type} ${e.name}${e.arrayIndex?`[${e.arrayIndex}]`:""};`)});const a=o.join("\n"),c=t.map(e=>u(e,r,i.packedInputs,i.enableShapeUniforms)).join("\n"),v=r.texShape,$=(0,n.getGlslDifferences)(),f=s($);let C,T,m=d($);return r.isPacked?(C=l(r.logicalShape,v,i.enableShapeUniforms),T=h($)):(C=p(r.logicalShape,v,i.enableShapeUniforms),T=x($)),i.packedInputs&&(m+=S),[m,f,T,a,C,c,i.userCode].join("\n")}function a(e,n=!1){const t=e.shapeInfo.logicalShape;switch(t.length){case 0:return D(e,n);case 1:return N(e,n);case 2:return L(e,n);case 3:return A(e,n);case 4:return z(e,n);case 5:return q(e);case 6:return j(e);default:throw new Error(`${t.length}-D input sampling`+" is not yet supported")}}function c(e,n){switch(e.shapeInfo.logicalShape.length){case 0:return b(e);case 1:return F(e,n);case 2:return M(e,n);case 3:return B(e,n);default:return E(e,n)}}function u(e,n,t=!1,r){let i="";i+=t?c(e,r):a(e,r);const o=e.shapeInfo.logicalShape,u=n.logicalShape;return o.length<=u.length&&(i+=t?_(e,n):G(e,n)),i}function l(e,n,t){switch(e.length){case 0:return C();case 1:return T(e,n,t);case 2:return k(e,n,t);case 3:return g(e,n,t);default:return w(e,n,t)}}function p(e,n,t){switch(e.length){case 0:return C();case 1:return m(e,n,t);case 2:return O(e,n,t);case 3:return R(e,n,t);case 4:return y(e,n,t);case 5:return I(e,n);case 6:return U(e,n);default:throw new Error(`${e.length}-D output sampling is not yet supported`)}}function s(e){return`\n    float sampleTexture(sampler2D textureSampler, vec2 uv) {\n      return ${e.texture2D}(textureSampler, uv).r;\n    }\n  `}function x(e){return`\n    void setOutput(float val) {\n      ${e.output} = vec4(val, 0, 0, 0);\n    }\n  `}function h(e){return`\n    void setOutput(vec4 val) {\n      ${e.output} = val;\n    }\n  `}function d(e){return`${e.version}\n    precision highp float;\n    precision highp int;\n    precision highp sampler2D;\n    ${e.varyingFs} vec2 resultUV;\n    ${e.defineOutput}\n    const vec2 halfCR = vec2(0.5, 0.5);\n\n    struct ivec5\n    {\n      int x;\n      int y;\n      int z;\n      int w;\n      int u;\n    };\n\n    struct ivec6\n    {\n      int x;\n      int y;\n      int z;\n      int w;\n      int u;\n      int v;\n    };\n\n    uniform float NAN;\n    ${e.defineSpecialNaN}\n    ${e.defineSpecialInf}\n    ${e.defineRound}\n\n    int imod(int x, int y) {\n      return x - y * (x / y);\n    }\n\n    int idiv(int a, int b, float sign) {\n      int res = a / b;\n      int mod = imod(a, b);\n      if (sign < 0. && mod != 0) {\n        res -= 1;\n      }\n      return res;\n    }\n\n    //Based on the work of Dave Hoskins\n    //https://www.shadertoy.com/view/4djSRW\n    #define HASHSCALE1 443.8975\n    float random(float seed){\n      vec2 p = resultUV * seed;\n      vec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);\n      p3 += dot(p3, p3.yzx + 19.19);\n      return fract((p3.x + p3.y) * p3.z);\n    }\n\n    ${v}\n    ${$}\n    ${f}\n  `}const v="\nvec2 uvFromFlat(int texNumR, int texNumC, int index) {\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\nvec2 packedUVfrom1D(int texNumR, int texNumC, int index) {\n  int texelIndex = index / 2;\n  int texR = texelIndex / texNumC;\n  int texC = texelIndex - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",$="\nvec2 packedUVfrom2D(int texelsInLogicalRow, int texNumR,\n  int texNumC, int row, int col) {\n  int texelIndex = (row / 2) * texelsInLogicalRow + (col / 2);\n  int texR = texelIndex / texNumC;\n  int texC = texelIndex - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",f="\nvec2 packedUVfrom3D(int texNumR, int texNumC,\n    int texelsInBatch, int texelsInLogicalRow, int b,\n    int row, int col) {\n  int index = b * texelsInBatch + (row / 2) * texelsInLogicalRow + (col / 2);\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",S="\n  float getChannel(vec4 frag, vec2 innerDims) {\n    vec2 modCoord = mod(innerDims, 2.);\n    return modCoord.x == 0. ?\n      (modCoord.y == 0. ? frag.r : frag.g) :\n      (modCoord.y == 0. ? frag.b : frag.a);\n  }\n  float getChannel(vec4 frag, int dim) {\n    float modCoord = mod(float(dim), 2.);\n    return modCoord == 0. ? frag.r : frag.g;\n  }\n";function C(){return"\n    int getOutputCoords() {\n      return 0;\n    }\n  "}function T(e,n,t){const r=[Math.ceil(n[0]/2),Math.ceil(n[1]/2)];return 1===r[0]?t?"\n      int getOutputCoords() {\n        return 2 * int(resultUV.x * ceil(float(outTexShape[1]) / 2.0));\n      }\n    ":`\n      int getOutputCoords() {\n        return 2 * int(resultUV.x * ${r[1]}.0);\n      }\n    `:1===r[1]?t?"\n      int getOutputCoords() {\n        return 2 * int(resultUV.y * ceil(float(outTexShape[0]) / 2.0));\n      }\n    ":`\n      int getOutputCoords() {\n        return 2 * int(resultUV.y * ${r[0]}.0);\n      }\n    `:t?"\n    int getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n      return 2 * (resTexRC.x * packedTexShape[1] + resTexRC.y);\n    }\n  ":`\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${r[0]}, ${r[1]}));\n      return 2 * (resTexRC.x * ${r[1]} + resTexRC.y);\n    }\n  `}function m(e,n,t){return 1===n[0]?t?"\n      int getOutputCoords() {\n        return int(resultUV.x * float(outTexShape[1]));\n      }\n    ":`\n      int getOutputCoords() {\n        return int(resultUV.x * ${n[1]}.0);\n      }\n    `:1===n[1]?t?"\n      int getOutputCoords() {\n        return int(resultUV.y * float(outTexShape[0]));\n      }\n    ":`\n      int getOutputCoords() {\n        return int(resultUV.y * ${n[0]}.0);\n      }\n    `:t?"\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(outTexShape[0], outTexShape[1]));\n      return resTexRC.x * outTexShape[1] + resTexRC.y;\n    }\n  ":`\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${n[0]}, ${n[1]}));\n      return resTexRC.x * ${n[1]} + resTexRC.y;\n    }\n  `}function g(e,n,t){if(t)return"\n    ivec3 getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      int texelsInLogicalRow = int(ceil(float(outShape[2]) / 2.0));\n      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;\n\n      int b = index / texelsInBatch;\n      index -= b * texelsInBatch;\n\n      int r = 2 * (index / texelsInLogicalRow);\n      int c = imod(index, texelsInLogicalRow) * 2;\n\n      return ivec3(b, r, c);\n    }\n  ";const r=[Math.ceil(n[0]/2),Math.ceil(n[1]/2)],i=Math.ceil(e[2]/2),o=i*Math.ceil(e[1]/2);return`\n    ivec3 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${r[0]}, ${r[1]}));\n      int index = resTexRC.x * ${r[1]} + resTexRC.y;\n\n      int b = index / ${o};\n      index -= b * ${o};\n\n      int r = 2 * (index / ${i});\n      int c = imod(index, ${i}) * 2;\n\n      return ivec3(b, r, c);\n    }\n  `}function R(e,n,r){if(r){return`\n  ivec3 getOutputCoords() {\n    ivec2 resTexRC = ivec2(resultUV.yx *\n                           vec2(outTexShape[0], outTexShape[1]));\n    int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n    ${t.getOutputLogicalCoordinatesFromFlatIndexByUniform(["r","c","d"],e)}\n    return ivec3(r, c, d);\n  }\n`}const i=t.getLogicalCoordinatesFromFlatIndex(["r","c","d"],e);return`\n    ivec3 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${n[0]}, ${n[1]}));\n      int index = resTexRC.x * ${n[1]} + resTexRC.y;\n      ${i}\n      return ivec3(r, c, d);\n    }\n  `}function w(e,n,t){if(t)return"\n    ivec4 getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;\n\n      int texelsInLogicalRow = int(ceil(float(outShape[3]) / 2.0));\n      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[2]) / 2.0));\n      int texelsInBatchN = texelsInBatch * outShape[1];\n\n      int b2 = index / texelsInBatchN;\n      index -= b2 * texelsInBatchN;\n\n      int b = index / texelsInBatch;\n      index -= b * texelsInBatch;\n\n      int r = 2 * (index / texelsInLogicalRow);\n      int c = imod(index, texelsInLogicalRow) * 2;\n\n      return ivec4(b2, b, r, c);\n    }\n  ";const r=[Math.ceil(n[0]/2),Math.ceil(n[1]/2)],i=Math.ceil(e[e.length-1]/2),o=i*Math.ceil(e[e.length-2]/2);let a=o,c="",u="b, r, c";for(let l=2;l<e.length-1;l++)c=`\n      int b${l} = index / ${a*=e[e.length-l-1]};\n      index -= b${l} * ${a};\n    `+c,u=`b${l}, `+u;return`\n    ivec${e.length} getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${r[0]}, ${r[1]}));\n      int index = resTexRC.x * ${r[1]} + resTexRC.y;\n\n      ${c}\n\n      int b = index / ${o};\n      index -= b * ${o};\n\n      int r = 2 * (index / ${i});\n      int c = imod(index, ${i}) * 2;\n\n      return ivec${e.length}(${u});\n    }\n  `}function y(e,n,r){if(r){return`\n    ivec4 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(outTexShape[0], outTexShape[1]));\n      int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n      ${t.getOutputLogicalCoordinatesFromFlatIndexByUniform(["r","c","d","d2"],e)}\n      return ivec4(r, c, d, d2);\n    }\n  `}const i=t.getLogicalCoordinatesFromFlatIndex(["r","c","d","d2"],e);return`\n    ivec4 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(${n[0]}, ${n[1]}));\n      int index = resTexRC.x * ${n[1]} + resTexRC.y;\n      ${i}\n      return ivec4(r, c, d, d2);\n    }\n  `}function I(e,n){const r=t.getLogicalCoordinatesFromFlatIndex(["r","c","d","d2","d3"],e);return`\n    ivec5 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx * vec2(${n[0]},\n                             ${n[1]}));\n\n      int index = resTexRC.x * ${n[1]} + resTexRC.y;\n\n      ${r}\n\n      ivec5 outShape = ivec5(r, c, d, d2, d3);\n      return outShape;\n    }\n  `}function U(e,n){const r=t.getLogicalCoordinatesFromFlatIndex(["r","c","d","d2","d3","d4"],e);return`\n    ivec6 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(${n[0]}, ${n[1]}));\n      int index = resTexRC.x * ${n[1]} + resTexRC.y;\n\n      ${r}\n\n      ivec6 result = ivec6(r, c, d, d2, d3, d4);\n      return result;\n    }\n  `}function k(n,t,r){const i=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)];if(e.util.arraysEqual(n,t))return r?"\n      ivec2 getOutputCoords() {\n        ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n        return 2 * ivec2(resultUV.yx * vec2(packedTexShape[0], packedTexShape[1]));\n      }\n    ":`\n      ivec2 getOutputCoords() {\n        return 2 * ivec2(resultUV.yx * vec2(${i[0]}, ${i[1]}));\n      }\n    `;const o=Math.ceil(n[1]/2);return r?"\n    ivec2 getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      int texelsInLogicalRow = int(ceil(float(outShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n\n      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;\n      int r = 2 * (index / texelsInLogicalRow);\n      int c = imod(index, texelsInLogicalRow) * 2;\n\n      return ivec2(r, c);\n    }\n  ":`\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${i[0]}, ${i[1]}));\n\n      int index = resTexRC.x * ${i[1]} + resTexRC.y;\n      int r = 2 * (index / ${o});\n      int c = imod(index, ${o}) * 2;\n\n      return ivec2(r, c);\n    }\n  `}function O(n,t,r){return e.util.arraysEqual(n,t)?r?"\n      ivec2 getOutputCoords() {\n        return ivec2(resultUV.yx * vec2(outTexShape[0], outTexShape[1]));\n      }\n    ":`\n      ivec2 getOutputCoords() {\n        return ivec2(resultUV.yx * vec2(${t[0]}, ${t[1]}));\n      }\n    `:1===n[1]?r?"\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(outTexShape[0], outTexShape[1]));\n        int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n        return ivec2(index, 0);\n      }\n    ":`\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(${t[0]}, ${t[1]}));\n        int index = resTexRC.x * ${t[1]} + resTexRC.y;\n        return ivec2(index, 0);\n      }\n    `:1===n[0]?r?"\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(outTexShape[0], outTexShape[1]));\n        int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n        return ivec2(0, index);\n      }\n    ":`\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(${t[0]}, ${t[1]}));\n        int index = resTexRC.x * ${t[1]} + resTexRC.y;\n        return ivec2(0, index);\n      }\n    `:r?"\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(outTexShape[0], outTexShape[1]));\n      int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n      int r = index / outShape[1];\n      int c = index - r * outShape[1];\n      return ivec2(r, c);\n    }\n  ":`\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${t[0]}, ${t[1]}));\n      int index = resTexRC.x * ${t[1]} + resTexRC.y;\n      int r = index / ${n[1]};\n      int c = index - r * ${n[1]};\n      return ivec2(r, c);\n    }\n  `}function V(e){return`offset${e}`}function b(e){const t=e.name;return`\n    vec4 ${"get"+t.charAt(0).toUpperCase()+t.slice(1)}() {\n      return ${(0,n.getGlslDifferences)().texture2D}(${t}, halfCR);\n    }\n  `}function D(e,n){const t=e.name,r="get"+t.charAt(0).toUpperCase()+t.slice(1);if(e.shapeInfo.isUniform)return`float ${r}() {return ${t};}`;const[i,o]=e.shapeInfo.texShape;if(1===i&&1===o)return`\n      float ${r}() {\n        return sampleTexture(${t}, halfCR);\n      }\n    `;const a=V(t);if(n)return`\n    float ${r}() {\n      vec2 uv = uvFromFlat(${t}TexShape[0], ${t}TexShape[1], ${a});\n      return sampleTexture(${t}, uv);\n    }\n  `;const[c,u]=e.shapeInfo.texShape;return`\n    float ${r}() {\n      vec2 uv = uvFromFlat(${c}, ${u}, ${a});\n      return sampleTexture(${t}, uv);\n    }\n  `}function F(e,t){const r=e.name,i="get"+r.charAt(0).toUpperCase()+r.slice(1),o=e.shapeInfo.texShape,a=(0,n.getGlslDifferences)();if(t)return`\n    vec4 ${i}(int index) {\n      ivec2 packedTexShape = ivec2(ceil(float(${r}TexShape[0]) / 2.0), ceil(float(${r}TexShape[1]) / 2.0));\n      vec2 uv = packedUVfrom1D(\n        packedTexShape[0], packedTexShape[1], index);\n      return ${a.texture2D}(${r}, uv);\n    }\n  `;const c=[Math.ceil(o[0]/2),Math.ceil(o[1]/2)];return`\n    vec4 ${i}(int index) {\n      vec2 uv = packedUVfrom1D(\n        ${c[0]}, ${c[1]}, index);\n      return ${a.texture2D}(${r}, uv);\n    }\n  `}function N(e,n){const t=e.name,r="get"+t.charAt(0).toUpperCase()+t.slice(1);if(e.shapeInfo.isUniform)return`\n      float ${r}(int index) {\n        ${P(e)}\n      }\n    `;const i=e.shapeInfo.texShape,o=i[0],a=i[1];if(1===a&&1===o)return`\n      float ${r}(int index) {\n        return sampleTexture(${t}, halfCR);\n      }\n    `;const c=V(t);return 1===a?n?`\n      float ${r}(int index) {\n        vec2 uv = vec2(0.5, (float(index + ${c}) + 0.5) / float(${t}TexShape[0]));\n        return sampleTexture(${t}, uv);\n      }\n    `:`\n      float ${r}(int index) {\n        vec2 uv = vec2(0.5, (float(index + ${c}) + 0.5) / ${o}.0);\n        return sampleTexture(${t}, uv);\n      }\n    `:1===o?n?`\n      float ${r}(int index) {\n        vec2 uv = vec2((float(index + ${c}) + 0.5) / float(${t}TexShape[1]), 0.5);\n        return sampleTexture(${t}, uv);\n      }\n    `:`\n      float ${r}(int index) {\n        vec2 uv = vec2((float(index + ${c}) + 0.5) / ${a}.0, 0.5);\n        return sampleTexture(${t}, uv);\n      }\n    `:n?`\n    float ${r}(int index) {\n      vec2 uv = uvFromFlat(${t}TexShape[0], ${t}TexShape[1], index + ${c});\n      return sampleTexture(${t}, uv);\n    }\n  `:`\n    float ${r}(int index) {\n      vec2 uv = uvFromFlat(${o}, ${a}, index + ${c});\n      return sampleTexture(${t}, uv);\n    }\n  `}function M(t,r){const i=t.shapeInfo.logicalShape,o=t.name,a="get"+o.charAt(0).toUpperCase()+o.slice(1),c=t.shapeInfo.texShape,u=c[0],l=c[1],p=(0,n.getGlslDifferences)();if(null!=c&&e.util.arraysEqual(i,c))return r?`\n      vec4 ${a}(int row, int col) {\n        vec2 uv = (vec2(col, row) + halfCR) / vec2(${o}TexShape[1], ${o}TexShape[0]);\n\n        return ${p.texture2D}(${o}, uv);\n      }\n    `:`\n      vec4 ${a}(int row, int col) {\n        vec2 uv = (vec2(col, row) + halfCR) / vec2(${l}.0, ${u}.0);\n\n        return ${p.texture2D}(${o}, uv);\n      }\n    `;if(r)return`\n    vec4 ${a}(int row, int col) {\n      ivec2 packedTexShape = ivec2(ceil(float(${o}TexShape[0]) / 2.0), ceil(float(${o}TexShape[1]) / 2.0));\n      int valuesPerRow = int(ceil(float(${o}Shape[1]) / 2.0));\n      vec2 uv = packedUVfrom2D(valuesPerRow, packedTexShape[0], packedTexShape[1], row, col);\n      return ${p.texture2D}(${o}, uv);\n    }\n  `;const s=[Math.ceil(c[0]/2),Math.ceil(c[1]/2)];return`\n    vec4 ${a}(int row, int col) {\n      vec2 uv = packedUVfrom2D(${Math.ceil(i[1]/2)}, ${s[0]}, ${s[1]}, row, col);\n      return ${p.texture2D}(${o}, uv);\n    }\n  `}function L(n,t){const r=n.shapeInfo.logicalShape,i=n.name,o="get"+i.charAt(0).toUpperCase()+i.slice(1),c=n.shapeInfo.texShape;if(null!=c&&e.util.arraysEqual(r,c)){if(t)return`\n      float ${o}(int row, int col) {\n        vec2 uv = (vec2(col, row) + halfCR) / vec2(${i}TexShape[1], ${i}TexShape[0]);\n        return sampleTexture(${i}, uv);\n      }\n    `;const e=c[0];return`\n    float ${o}(int row, int col) {\n      vec2 uv = (vec2(col, row) + halfCR) / vec2(${c[1]}.0, ${e}.0);\n      return sampleTexture(${i}, uv);\n    }\n  `}const{newShape:u,keptDims:l}=e.util.squeezeShape(r),p=u;if(p.length<r.length){const e=["row","col"];return`\n      ${a(J(n,p),t)}\n      float ${o}(int row, int col) {\n        return ${o}(${K(e,l)});\n      }\n    `}if(n.shapeInfo.isUniform)return`\n      float ${o}(int row, int col) {\n        int index = round(dot(vec2(row, col), vec2(${r[1]}, 1)));\n        ${P(n)}\n      }\n    `;const s=c[0],x=c[1],h=V(i);return 1===x?t?`\n      float ${o}(int row, int col) {\n        float index = dot(vec3(row, col, ${h}), vec3(${i}Shape[1], 1, 1));\n        vec2 uv = vec2(0.5, (index + 0.5) / float(${i}TexShape[0]));\n        return sampleTexture(${i}, uv);\n      }\n    `:`\n    float ${o}(int row, int col) {\n      float index = dot(vec3(row, col, ${h}), vec3(${r[1]}, 1, 1));\n      vec2 uv = vec2(0.5, (index + 0.5) / ${s}.0);\n      return sampleTexture(${i}, uv);\n    }\n  `:1===s?t?`\n      float ${o}(int row, int col) {\n        float index = dot(vec3(row, col, ${h}), vec3(${i}Shape[1], 1, 1));\n        vec2 uv = vec2((index + 0.5) / float(${i}TexShape[1]), 0.5);\n        return sampleTexture(${i}, uv);\n      }\n    `:`\n    float ${o}(int row, int col) {\n      float index = dot(vec3(row, col, ${h}), vec3(${r[1]}, 1, 1));\n      vec2 uv = vec2((index + 0.5) / ${x}.0, 0.5);\n      return sampleTexture(${i}, uv);\n    }\n  `:t?`\n      float ${o}(int row, int col) {\n        // Explicitly use integer operations as dot() only works on floats.\n        int index = row * ${i}Shape[1] + col + ${h};\n        vec2 uv = uvFromFlat(${i}TexShape[0], ${i}TexShape[1], index);\n        return sampleTexture(${i}, uv);\n      }\n    `:`\n  float ${o}(int row, int col) {\n    // Explicitly use integer operations as dot() only works on floats.\n    int index = row * ${r[1]} + col + ${h};\n    vec2 uv = uvFromFlat(${s}, ${x}, index);\n    return sampleTexture(${i}, uv);\n  }\n`}function B(e,t){const r=e.shapeInfo.logicalShape,i=e.name,o="get"+i.charAt(0).toUpperCase()+i.slice(1),a=e.shapeInfo.texShape,u=[Math.ceil(a[0]/2),Math.ceil(a[1]/2)];if(1===r[0]){const n=[1,2],i=["b","row","col"];return`\n        ${c(J(e,r.slice(1)),t)}\n        vec4 ${o}(int b, int row, int col) {\n          return ${o}(${K(i,n)});\n        }\n      `}const l=(0,n.getGlslDifferences)();if(t)return`\n    vec4 ${o}(int b, int row, int col) {\n      ivec2 packedTexShape = ivec2(ceil(float(${i}TexShape[0]) / 2.0), ceil(float(${i}TexShape[1]) / 2.0));\n      int valuesPerRow = int(ceil(float(${i}Shape[2]) / 2.0));\n      int texelsInBatch = valuesPerRow * int(ceil(float(${i}Shape[1]) / 2.0));\n      vec2 uv = packedUVfrom3D(\n        packedTexShape[0], packedTexShape[1], texelsInBatch, valuesPerRow, b, row, col);\n      return ${l.texture2D}(${i}, uv);\n    }\n  `;const p=u[0],s=u[1],x=Math.ceil(r[2]/2);return`\n    vec4 ${o}(int b, int row, int col) {\n      vec2 uv = packedUVfrom3D(\n        ${p}, ${s}, ${x*Math.ceil(r[1]/2)}, ${x}, b, row, col);\n      return ${l.texture2D}(${i}, uv);\n    }\n  `}function A(n,t){const r=n.shapeInfo.logicalShape,i=n.name,o="get"+i.charAt(0).toUpperCase()+i.slice(1),c=r[1]*r[2],u=r[2],{newShape:l,keptDims:p}=e.util.squeezeShape(r),s=l;if(s.length<r.length){const e=["row","col","depth"];return`\n        ${a(J(n,s),t)}\n        float ${o}(int row, int col, int depth) {\n          return ${o}(${K(e,p)});\n        }\n      `}if(n.shapeInfo.isUniform)return`\n      float ${o}(int row, int col, int depth) {\n        int index = round(dot(vec3(row, col, depth),\n                          vec3(${c}, ${u}, 1)));\n        ${P(n)}\n      }\n    `;const x=n.shapeInfo.texShape,h=x[0],d=x[1],v=n.shapeInfo.flatOffset;if(d===c&&null==v)return t?`\n      float ${o}(int row, int col, int depth) {\n        int stride1 = ${i}Shape[2];\n        float texR = float(row);\n        float texC = dot(vec2(col, depth), vec2(stride1, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${i}TexShape[1], ${i}TexShape[0]);\n        return sampleTexture(${i}, uv);\n      }\n    `:`\n        float ${o}(int row, int col, int depth) {\n          float texR = float(row);\n          float texC = dot(vec2(col, depth), vec2(${u}, 1));\n          vec2 uv = (vec2(texC, texR) + halfCR) /\n                     vec2(${d}.0, ${h}.0);\n          return sampleTexture(${i}, uv);\n        }\n      `;if(d===u&&null==v)return t?`\n      float ${o}(int row, int col, int depth) {\n        float texR = dot(vec2(row, col), vec2(${i}Shape[1], 1));\n        float texC = float(depth);\n        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${i}TexShape[1], ${i}TexShape[0]);\n        return sampleTexture(${i}, uv);\n      }\n    `:`\n    float ${o}(int row, int col, int depth) {\n      float texR = dot(vec2(row, col), vec2(${r[1]}, 1));\n      float texC = float(depth);\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${d}.0, ${h}.0);\n      return sampleTexture(${i}, uv);\n    }\n  `;const $=V(i);return t?`\n    float ${o}(int row, int col, int depth) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int stride0 = ${i}Shape[1] * ${i}Shape[2];\n      int stride1 = ${i}Shape[2];\n      int index = row * stride0 + col * stride1 + depth + ${$};\n      vec2 uv = uvFromFlat(${i}TexShape[0], ${i}TexShape[1], index);\n      return sampleTexture(${i}, uv);\n    }\n    `:`\n      float ${o}(int row, int col, int depth) {\n        // Explicitly use integer operations as dot() only works on floats.\n        int index = row * ${c} + col * ${u} + depth + ${$};\n        vec2 uv = uvFromFlat(${h}, ${d}, index);\n        return sampleTexture(${i}, uv);\n      }\n  `}function E(e,t){const r=e.name,i="get"+r.charAt(0).toUpperCase()+r.slice(1),o=(0,n.getGlslDifferences)();if(t)return`\n    vec4 ${i}(int b2, int b, int row, int col) {\n      int valuesPerRow = int(ceil(float(${r}Shape[3]) / 2.0));\n      int texelsInBatch = valuesPerRow * int(ceil(float(${r}Shape[2]) / 2.0));\n      int index = b * texelsInBatch + (row / 2) * valuesPerRow + (col / 2);\n      texelsInBatch *= ${r}Shape[1];\n      index = b2 * texelsInBatch + index;\n      ivec2 packedTexShape = ivec2(ceil(float(${r}TexShape[0]) / 2.0), ceil(float(${r}TexShape[1]) / 2.0));\n      int texR = index / packedTexShape[1];\n      int texC = index - texR * packedTexShape[1];\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(packedTexShape[1], packedTexShape[0]); return ${o.texture2D}(${r}, uv);\n    }\n  `;const a=e.shapeInfo.logicalShape,c=a.length,u=e.shapeInfo.texShape,l=[Math.ceil(u[0]/2),Math.ceil(u[1]/2)],p=l[0],s=l[1],x=Math.ceil(a[c-1]/2);let h=x*Math.ceil(a[c-2]/2),d="int b, int row, int col",v=`b * ${h} + (row / 2) * ${x} + (col / 2)`;for(let n=2;n<c-1;n++)d=`int b${n}, `+d,v=`b${n} * ${h*=a[c-n-1]} + `+v;return`\n    vec4 ${i}(${d}) {\n      int index = ${v};\n      int texR = index / ${s};\n      int texC = index - texR * ${s};\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${s}, ${p});\n      return ${o.texture2D}(${r}, uv);\n    }\n  `}function z(n,t){const r=n.shapeInfo.logicalShape,i=n.name,o="get"+i.charAt(0).toUpperCase()+i.slice(1),c=r[3],u=r[2]*c,l=r[1]*u,{newShape:p,keptDims:s}=e.util.squeezeShape(r);if(p.length<r.length){const e=["row","col","depth","depth2"];return`\n      ${a(J(n,p),t)}\n      float ${o}(int row, int col, int depth, int depth2) {\n        return ${o}(${K(e,s)});\n      }\n    `}if(n.shapeInfo.isUniform)return`\n      float ${o}(int row, int col, int depth, int depth2) {\n        int index = round(dot(vec4(row, col, depth, depth2),\n                          vec4(${l}, ${u}, ${c}, 1)));\n        ${P(n)}\n      }\n    `;const x=n.shapeInfo.flatOffset,h=n.shapeInfo.texShape,d=h[0],v=h[1],$=`int stride2 = ${i}Shape[3];`,f=`int stride1 = ${i}Shape[2] * stride2;`,S=`int stride0 = ${i}Shape[1] * stride1;`;if(v===l&&null==x)return t?`\n      float ${o}(int row, int col, int depth, int depth2) {\n        ${$}\n        ${f}\n        float texR = float(row);\n        float texC =\n            dot(vec3(col, depth, depth2),\n                vec3(stride1, stride2, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${i}TexShape[1], ${i}TexShape[0]);\n        return sampleTexture(${i}, uv);\n      }\n    `:`\n      float ${o}(int row, int col, int depth, int depth2) {\n        float texR = float(row);\n        float texC =\n            dot(vec3(col, depth, depth2),\n                vec3(${u}, ${c}, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${v}.0, ${d}.0);\n        return sampleTexture(${i}, uv);\n      }\n    `;if(v===c&&null==x)return t?`\n      float ${o}(int row, int col, int depth, int depth2) {\n        float texR = dot(vec3(row, col, depth),\n                         vec3(${i}Shape[1] * ${i}Shape[2], ${i}Shape[2], 1));\n        float texC = float(depth2);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${i}TexShape[1], ${i}TexShape[0]);\n        return sampleTexture(${i}, uv);\n      }\n    `:`\n      float ${o}(int row, int col, int depth, int depth2) {\n        float texR = dot(vec3(row, col, depth),\n                         vec3(${r[1]*r[2]}, ${r[2]}, 1));\n        float texC = float(depth2);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${v}.0, ${d}.0);\n        return sampleTexture(${i}, uv);\n      }\n    `;const C=V(i);return t?`\n    float ${o}(int row, int col, int depth, int depth2) {\n      // Explicitly use integer operations as dot() only works on floats.\n      ${$}\n      ${f}\n      ${S}\n      int index = row * stride0 + col * stride1 +\n          depth * stride2 + depth2;\n      vec2 uv = uvFromFlat(${i}TexShape[0], ${i}TexShape[1], index + ${C});\n      return sampleTexture(${i}, uv);\n    }\n  `:`\n    float ${o}(int row, int col, int depth, int depth2) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ${l} + col * ${u} +\n          depth * ${c} + depth2;\n      vec2 uv = uvFromFlat(${d}, ${v}, index + ${C});\n      return sampleTexture(${i}, uv);\n    }\n  `}function q(n){const t=n.shapeInfo.logicalShape,r=n.name,i="get"+r.charAt(0).toUpperCase()+r.slice(1),o=t[4],c=t[3]*o,u=t[2]*c,l=t[1]*u,{newShape:p,keptDims:s}=e.util.squeezeShape(t);if(p.length<t.length){const e=["row","col","depth","depth2","depth3"];return`\n      ${a(J(n,p))}\n      float ${i}(int row, int col, int depth, int depth2, int depth3) {\n        return ${i}(${K(e,s)});\n      }\n    `}if(n.shapeInfo.isUniform)return`\n      float ${i}(int row, int col, int depth, int depth2, int depth3) {\n        float index = dot(\n          vec4(row, col, depth, depth2),\n          vec4(${l}, ${u}, ${c}, ${o})) +\n          depth3;\n        ${P(n)}\n      }\n    `;const x=n.shapeInfo.flatOffset,h=n.shapeInfo.texShape,d=h[0],v=h[1];return v===l&&null==x?`\n      float ${i}(int row, int col, int depth, int depth2, int depth3) {\n        int texR = row;\n        float texC = dot(vec4(col, depth, depth2, depth3),\n                         vec4(${u}, ${c}, ${o}, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${v}.0, ${d}.0);\n        return sampleTexture(${r}, uv);\n      }\n    `:v===o&&null==x?`\n      float ${i}(int row, int col, int depth, int depth2, int depth3) {\n        float texR = dot(\n          vec4(row, col, depth, depth2),\n          vec4(${t[1]*t[2]*t[3]},\n               ${t[2]*t[3]}, ${t[3]}, 1));\n        int texC = depth3;\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${v}.0, ${d}.0);\n        return sampleTexture(${r}, uv);\n      }\n    `:`\n    float ${i}(int row, int col, int depth, int depth2, int depth3) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ${l} + col * ${u} + depth * ${c} +\n          depth2 * ${o} + depth3 + ${V(r)};\n      vec2 uv = uvFromFlat(${d}, ${v}, index);\n      return sampleTexture(${r}, uv);\n    }\n  `}function j(n){const t=n.shapeInfo.logicalShape,r=n.name,i="get"+r.charAt(0).toUpperCase()+r.slice(1),{newShape:o,keptDims:c}=e.util.squeezeShape(t);if(o.length<t.length){const e=["row","col","depth","depth2","depth3","depth4"];return`\n      ${a(J(n,o))}\n      float ${i}(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        return ${i}(${K(e,c)});\n      }\n    `}const u=t[5],l=t[4]*u,p=t[3]*l,s=t[2]*p,x=t[1]*s;if(n.shapeInfo.isUniform)return`\n      float ${i}(int row, int col, int depth,\n                  int depth2, int depth3, int depth4) {\n        int index = round(dot(\n          vec4(row, col, depth, depth2),\n          vec4(${x}, ${s}, ${p}, ${l})) +\n          dot(\n            vec2(depth3, depth4),\n            vec2(${u}, 1)));\n        ${P(n)}\n      }\n    `;const h=n.shapeInfo.flatOffset,d=n.shapeInfo.texShape,v=d[0],$=d[1];return $===x&&null==h?`\n      float ${i}(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        int texR = row;\n        float texC = dot(vec4(col, depth, depth2, depth3),\n          vec4(${s}, ${p}, ${l}, ${u})) +\n               float(depth4);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${$}.0, ${v}.0);\n        return sampleTexture(${r}, uv);\n      }\n    `:$===u&&null==h?`\n      float ${i}(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        float texR = dot(vec4(row, col, depth, depth2),\n          vec4(${t[1]*t[2]*t[3]*t[4]},\n               ${t[2]*t[3]*t[4]},\n               ${t[3]*t[4]},\n               ${t[4]})) + float(depth3);\n        int texC = depth4;\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${$}.0, ${v}.0);\n        return sampleTexture(${r}, uv);\n      }\n    `:`\n    float ${i}(int row, int col, int depth,\n                  int depth2, int depth3, int depth4) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ${x} + col * ${s} + depth * ${p} +\n          depth2 * ${l} + depth3 * ${u} + depth4 + ${V(r)};\n      vec2 uv = uvFromFlat(${v}, ${$}, index);\n      return sampleTexture(${r}, uv);\n    }\n  `}function P(n){const t=n.name,r=e.util.sizeFromShape(n.shapeInfo.logicalShape);return r<2?`return ${t};`:`\n    for (int i = 0; i < ${r}; i++) {\n      if (i == index) {\n        return ${t}[i];\n      }\n    }\n  `}function _(n,t){const r=n.name,o=r.charAt(0).toUpperCase()+r.slice(1),a="get"+o+"AtOutCoords",c=n.shapeInfo.logicalShape.length,u=t.logicalShape.length,l=i(n.shapeInfo.logicalShape,t.logicalShape),p=H(u),s=u-c;let x;const h=["x","y","z","w","u","v"];x=0===c?"":u<2&&l.length>=1?"coords = 0;":l.map(e=>`coords.${h[e+s]} = 0;`).join("\n");let d="";d=u<2&&c>0?"coords":n.shapeInfo.logicalShape.map((e,n)=>`coords.${h[n+s]}`).join(", ");let v="return outputValue;";const $=1===e.util.sizeFromShape(n.shapeInfo.logicalShape),f=1===e.util.sizeFromShape(t.logicalShape);if(1!==c||$||f){if($&&!f)v=1===u?"\n        return vec4(outputValue.x, outputValue.x, 0., 0.);\n      ":"\n        return vec4(outputValue.x);\n      ";else if(l.length){const e=c-2,n=c-1;l.indexOf(e)>-1&&l.indexOf(n)>-1?v="return vec4(outputValue.x);":l.indexOf(e)>-1?v="return vec4(outputValue.x, outputValue.y, outputValue.x, outputValue.y);":l.indexOf(n)>-1&&(v="return vec4(outputValue.xx, outputValue.zz);")}}else v="\n      return vec4(outputValue.xy, outputValue.xy);\n    ";return`\n    vec4 ${a}() {\n      ${p} coords = getOutputCoords();\n      ${x}\n      vec4 outputValue = get${o}(${d});\n      ${v}\n    }\n  `}function G(n,t){const r=n.name,o=r.charAt(0).toUpperCase()+r.slice(1),a="get"+o+"AtOutCoords",c=t.texShape,u=n.shapeInfo.texShape,l=n.shapeInfo.logicalShape.length,p=t.logicalShape.length;if(!n.shapeInfo.isUniform&&l===p&&null==n.shapeInfo.flatOffset&&e.util.arraysEqual(u,c))return`\n      float ${a}() {\n        return sampleTexture(${r}, resultUV);\n      }\n    `;const s=H(p),x=i(n.shapeInfo.logicalShape,t.logicalShape),h=p-l;let d;const v=["x","y","z","w","u","v"];let $="";return`\n    float ${a}() {\n      ${s} coords = getOutputCoords();\n      ${d=0===l?"":p<2&&x.length>=1?"coords = 0;":x.map(e=>`coords.${v[e+h]} = 0;`).join("\n")}\n      return get${o}(${$=p<2&&l>0?"coords":n.shapeInfo.logicalShape.map((e,n)=>`coords.${v[n+h]}`).join(", ")});\n    }\n  `}function H(e){if(e<=1)return"int";if(2===e)return"ivec2";if(3===e)return"ivec3";if(4===e)return"ivec4";if(5===e)return"ivec5";if(6===e)return"ivec6";throw Error(`GPU for rank ${e} is not yet supported`)}function W(n,t,r){const{newShape:i,keptDims:o}=e.util.squeezeShape(t),a=t.length,c=n&&3===a&&1===t[0],u=c?t.slice(1):i,l=!n&&a>1&&!e.util.arraysEqual(t,r)&&i.length<a||c;return{useSqueezeShape:l,uniformShape:l?u:t,keptDims:o}}function J(e,n){const t=JSON.parse(JSON.stringify(e));return t.shapeInfo.logicalShape=n,t}function K(e,n){return n.map(n=>e[n]).join(", ")}
},{"@tensorflow/tfjs-core":"kSBl","./glsl_version":"fXvw","./shader_compiler_util":"tjqy"}],"eeKH":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.compileProgram=o,exports.getUniformLocations=r,exports.makeShaderKey=f,exports.runProgram=s,exports.useShapeUniforms=l;var e=require("@tensorflow/tfjs-core"),t=n(require("./shader_compiler")),a=require("./webgl_util");function n(e,t){if("function"==typeof WeakMap)var a=new WeakMap,o=new WeakMap;return(n=function(e,t){if(!t&&e&&e.__esModule)return e;var n,r,i={__proto__:null,default:e};if(null===e||"object"!=typeof e&&"function"!=typeof e)return i;if(n=t?o:a){if(n.has(e))return n.get(e);n.set(e,i)}for(const a in e)"default"!==a&&{}.hasOwnProperty.call(e,a)&&((r=(n=Object.defineProperty)&&Object.getOwnPropertyDescriptor(e,a))&&(r.get||r.set)?n(i,a,r):i[a]=e[a]);return i})(e,t)}function o(n,o,i,s){const f=i.map((e,t)=>{const a={logicalShape:e.shape,texShape:e.isUniform?null:e.texData.texShape,isUniform:e.isUniform,isPacked:!e.isUniform&&e.texData.isPacked,flatOffset:null};return null!=e.texData&&null!=e.texData.slice&&e.texData.slice.flatOffset>0&&(a.flatOffset=e.texData.slice.flatOffset),{name:o.variableNames[t],shapeInfo:a}}),l=f.map(e=>e.shapeInfo),u={logicalShape:s.shape,texShape:s.texData.texShape,isUniform:!1,isPacked:s.texData.isPacked,flatOffset:null},c=t.makeShader(f,u,o),p=(0,a.createFragmentShader)(n.gl,c),h=n.createProgram(p);return(0,e.env)().get("ENGINE_COMPILE_ONLY")?{program:o,fragmentShader:p,source:c,webGLProgram:h,inShapeInfos:l,outShapeInfo:u,variablesLocations:null,customUniformLocations:null,infLoc:null,nanLoc:null,outShapeLocation:null,outShapeStridesLocation:null,outTexShapeLocation:null}:(n.buildVao(h),Object.assign({program:o,fragmentShader:p,source:c,webGLProgram:h,inShapeInfos:l,outShapeInfo:u},r(n,o,h)))}function r(t,a,n){const o=[],r=[];let i,s,f,l=null,u=null;u=t.getUniformLocation(n,"NAN",!1),1===(0,e.env)().getNumber("WEBGL_VERSION")&&(l=t.getUniformLocation(n,"INFINITY",!1));for(const e of a.variableNames){const r={name:e,uniform:t.getUniformLocation(n,e,!1),offset:t.getUniformLocation(n,`offset${e}`,!1)};a.enableShapeUniforms&&(r.shape=t.getUniformLocation(n,`${e}Shape`,!1),r.texShape=t.getUniformLocation(n,`${e}TexShape`,!1)),o.push(r)}if(a.enableShapeUniforms&&(i=t.getUniformLocation(n,"outShape",!1),f=t.getUniformLocation(n,"outShapeStrides",!1),s=t.getUniformLocation(n,"outTexShape",!1)),a.customUniforms)for(const e of a.customUniforms)r.push(t.getUniformLocation(n,e.name,!1));return{variablesLocations:o,customUniformLocations:r,infLoc:l,nanLoc:u,outShapeLocation:i,outShapeStridesLocation:f,outTexShapeLocation:s}}function i(t,a){if(t.length!==a.length)throw Error(`Binary was compiled with ${t.length} inputs, but `+`was executed with ${a.length} inputs`);t.forEach((t,n)=>{const o=t.logicalShape,r=a[n],i=r.shape;if(!e.util.arraysEqual(o,i))throw Error("Binary was compiled with different shapes than "+`the current args. Shapes ${o} and ${i} must match`);if(t.isUniform&&r.isUniform)return;const s=t.texShape,f=r.isUniform?null:r.texData.texShape;if(!e.util.arraysEqual(s,f))throw Error("Binary was compiled with different texture shapes than the"+` current args. Shape ${s} and ${f} must match`)})}function s(a,n,o,r,s){n.program.enableShapeUniforms||(i(n.inShapeInfos,o),i([n.outShapeInfo],[r]));const f=r.texData.texture,l=r.texData.texShape;r.texData.isPacked?a.setOutputPackedMatrixTexture(f.texture,l[0],l[1]):a.setOutputMatrixTexture(f.texture,l[0],l[1]),a.setProgram(n.webGLProgram),a.bindVertexArray(n.webGLProgram.vao),1===(0,e.env)().getNumber("WEBGL_VERSION")&&null!==n.infLoc&&a.gl.uniform1f(n.infLoc,1/0),null!==n.nanLoc&&a.gl.uniform1f(n.nanLoc,NaN);for(let i=0;i<o.length;++i){const r=o[i],{uniform:s,offset:f,shape:l,texShape:u}=n.variablesLocations[i];if(l){const{uniformShape:e}=t.getUniformInfoFromShape(n.program.packedInputs,r.shape,r.texData.texShape);switch(e.length){case 1:a.gl.uniform1iv(l,new Int32Array(e));break;case 2:a.gl.uniform2iv(l,new Int32Array(e));break;case 3:a.gl.uniform3iv(l,new Int32Array(e));break;case 4:a.gl.uniform4iv(l,new Int32Array(e))}}if(u&&a.gl.uniform2i(u,r.texData.texShape[0],r.texData.texShape[1]),null!=s)if(r.isUniform)if(e.util.sizeFromShape(r.shape)<2)a.gl.uniform1f(s,r.uniformValues[0]);else{let e=r.uniformValues;e instanceof Float32Array||(e=new Float32Array(e)),a.gl.uniform1fv(s,e)}else null!=r.texData.slice&&null!=f&&a.gl.uniform1i(f,r.texData.slice.flatOffset),a.setInputMatrixTexture(r.texData.texture.texture,s,i)}const u=n.outShapeLocation;if(u)switch(r.shape.length){case 1:a.gl.uniform1iv(u,new Int32Array(r.shape));break;case 2:a.gl.uniform2iv(u,new Int32Array(r.shape));break;case 3:a.gl.uniform3iv(u,new Int32Array(r.shape));break;case 4:a.gl.uniform4iv(u,new Int32Array(r.shape))}if(n.outShapeStridesLocation){const t=e.util.computeStrides(r.shape);switch(r.shape.length){case 2:a.gl.uniform1iv(n.outShapeStridesLocation,new Int32Array(t));break;case 3:a.gl.uniform2iv(n.outShapeStridesLocation,new Int32Array(t));break;case 4:a.gl.uniform3iv(n.outShapeStridesLocation,new Int32Array(t))}}if(n.outTexShapeLocation&&a.gl.uniform2i(n.outTexShapeLocation,r.texData.texShape[0],r.texData.texShape[1]),n.program.customUniforms&&s)for(let e=0;e<n.program.customUniforms.length;++e){const t=n.program.customUniforms[e],o=n.customUniformLocations[e],r=s[e];if("float"===t.type)a.gl.uniform1fv(o,r);else if("vec2"===t.type)a.gl.uniform2fv(o,r);else if("vec3"===t.type)a.gl.uniform3fv(o,r);else if("vec4"===t.type)a.gl.uniform4fv(o,r);else if("int"===t.type)a.gl.uniform1iv(o,r);else if("ivec2"===t.type)a.gl.uniform2iv(o,r);else if("ivec3"===t.type)a.gl.uniform3iv(o,r);else{if("ivec4"!==t.type)throw Error(`uniform type ${t.type} is not supported yet.`);a.gl.uniform4iv(o,r)}}a.executeProgram()}function f(a,n,o){let r="";n.concat(o).forEach(n=>{const i=null!=n.texData&&null!=n.texData.slice&&n.texData.slice.flatOffset>0;if(a.enableShapeUniforms&&!n.isUniform){const s=n.texData.texShape,{useSqueezeShape:f,uniformShape:l,keptDims:u}=t.getUniformInfoFromShape(a.packedInputs,n.shape,s);let c="",p="",h="";if(1===l.length&&a.packedInputs){const e=[Math.ceil(s[0]/2),Math.ceil(s[1]/2)];c=`${e[0]>1}_${e[1]>1}`}else if(2!==l.length||a.packedInputs){if(l.length>2&&!a.packedInputs){const t=e.util.computeStrides(l);h=`${t[0]===s[1]}_${t[t.length-1]===s[1]}`}}else p=`${l[0]>1}_${l[1]>1}`;const m=n.shape.length,g=2===l.length&&e.util.arraysEqual(n.shape,s),S=1===e.util.sizeFromShape(n.shape),x=e.backend_util.getBroadcastDims(n.shape,o.shape),d=!a.packedInputs&&m===o.shape.length&&e.util.arraysEqual(s,o.texData.texShape),L=a.packedInputs||l.length>2?"":`${s[0]>1}_${s[1]>1}`;r+=`${m}_${d}_${f?u:""}_${l.length}_${S}_${x}_${g}_${c}_${p}_${h}_${L}_${i}`}else{const e=n.isUniform?"uniform":n.texData.texShape;r+=`${n.shape}_${e}_${i}`}});const i=a.userCode;let s=a.constructor.name;return s+="_"+r+"_"+i+`${(0,e.env)().getNumber("WEBGL_VERSION")}`}function l(t){return(0,e.env)().getBool("WEBGL_USE_SHAPES_UNIFORMS")&&t<=4}
},{"@tensorflow/tfjs-core":"kSBl","./shader_compiler":"xhhc","./webgl_util":"u1ML"}],"JMCa":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.DecodeMatrixProgram=void 0;var e=require("./glsl_version"),t=require("./gpgpu_math"),r=i(require("./shader_compiler_util")),n=require("./tex_util");function i(e,t){if("function"==typeof WeakMap)var r=new WeakMap,n=new WeakMap;return(i=function(e,t){if(!t&&e&&e.__esModule)return e;var i,o,a={__proto__:null,default:e};if(null===e||"object"!=typeof e&&"function"!=typeof e)return a;if(i=t?n:r){if(i.has(e))return i.get(e);i.set(e,a)}for(const r in e)"default"!==r&&{}.hasOwnProperty.call(e,r)&&((o=(i=Object.defineProperty)&&Object.getOwnPropertyDescriptor(e,r))&&(o.get||o.set)?i(a,r,o):a[r]=e[r]);return a})(e,t)}class o{constructor(i){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outPackingScheme=n.PackingScheme.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];const o=(0,e.getGlslDifferences)();this.outputShape=i,this.enableShapeUniforms=(0,t.useShapeUniforms)(this.outputShape.length),this.userCode=`\n      ivec3 outCoordsFromFlatIndex(int index) {\n        ${this.enableShapeUniforms?r.getOutputLogicalCoordinatesFromFlatIndexByUniform(["r","c","d"],i):r.getLogicalCoordinatesFromFlatIndex(["r","c","d"],i)}\n        return ivec3(r, c, d);\n      }\n\n      void main() {\n        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));\n        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);\n\n        vec4 result = vec4(0.);\n\n        for (int i=0; i<4; i++) {\n          int flatIndex = index + i;\n          ivec3 rc = outCoordsFromFlatIndex(flatIndex);\n          result[i] = getA(rc.x, rc.y, rc.z);\n        }\n\n        ${o.output} = result;\n      }\n    `}}exports.DecodeMatrixProgram=o;
},{"./glsl_version":"fXvw","./gpgpu_math":"eeKH","./shader_compiler_util":"tjqy","./tex_util":"jAWT"}],"RChy":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.DecodeMatrixPackedProgram=void 0;var e=require("./glsl_version"),t=require("./gpgpu_math"),r=i(require("./shader_compiler_util")),n=require("./tex_util");function i(e,t){if("function"==typeof WeakMap)var r=new WeakMap,n=new WeakMap;return(i=function(e,t){if(!t&&e&&e.__esModule)return e;var i,o,a={__proto__:null,default:e};if(null===e||"object"!=typeof e&&"function"!=typeof e)return a;if(i=t?n:r){if(i.has(e))return i.get(e);i.set(e,a)}for(const r in e)"default"!==r&&{}.hasOwnProperty.call(e,r)&&((o=(i=Object.defineProperty)&&Object.getOwnPropertyDescriptor(e,r))&&(o.get||o.set)?i(a,r,o):a[r]=e[r]);return a})(e,t)}class o{constructor(i){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outPackingScheme=n.PackingScheme.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];const o=(0,e.getGlslDifferences)();this.outputShape=i,this.enableShapeUniforms=(0,t.useShapeUniforms)(this.outputShape.length),this.userCode=`\n      ivec3 outCoordsFromFlatIndex(int index) {\n        ${this.enableShapeUniforms?r.getOutputLogicalCoordinatesFromFlatIndexByUniform(["r","c","d"],i):r.getLogicalCoordinatesFromFlatIndex(["r","c","d"],i)}\n        return ivec3(r, c, d);\n      }\n\n      void main() {\n        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));\n        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);\n\n        vec4 result = vec4(0.);\n\n        for (int i=0; i<4; i++) {\n          int flatIndex = index + i;\n          ivec3 rc = outCoordsFromFlatIndex(flatIndex);\n          result[i] = getChannel(getA(rc.x, rc.y, rc.z), vec2(rc.y, rc.z));\n        }\n\n        ${o.output} = result;\n      }\n    `}}exports.DecodeMatrixPackedProgram=o;
},{"./glsl_version":"fXvw","./gpgpu_math":"eeKH","./shader_compiler_util":"tjqy","./tex_util":"jAWT"}],"oHaq":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.EncodeFloatProgram=void 0;var e=require("./glsl_version"),t=require("./shader_compiler_util"),o=require("./tex_util");class r{constructor(r){this.variableNames=["A"],this.outTexUsage=o.TextureUsage.DOWNLOAD;const s=(0,e.getGlslDifferences)();this.outputShape=r,this.userCode=`\n      ${t.ENCODE_FLOAT_SNIPPET}\n\n      void main() {\n        float x = getAAtOutCoords();\n        ${s.output} = encode_float(x);\n      }\n    `}}exports.EncodeFloatProgram=r;
},{"./glsl_version":"fXvw","./shader_compiler_util":"tjqy","./tex_util":"jAWT"}],"r0NW":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.EncodeFloatPackedProgram=void 0;var e=require("./glsl_version"),t=require("./shader_compiler_util"),o=require("./tex_util");class r{constructor(r){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outTexUsage=o.TextureUsage.DOWNLOAD;const s=(0,e.getGlslDifferences)();this.outputShape=r,this.userCode=`\n      ${t.ENCODE_FLOAT_SNIPPET}\n\n      void main() {\n        ivec3 coords = getOutputCoords();\n        float x = getChannel(getAAtOutCoords(), vec2(coords.y, coords.z));\n        ${s.output} = encode_float(x);\n      }\n    `}}exports.EncodeFloatPackedProgram=r;
},{"./glsl_version":"fXvw","./shader_compiler_util":"tjqy","./tex_util":"jAWT"}],"o0jj":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.EncodeMatrixProgram=void 0;var e=require("./glsl_version"),t=require("./gpgpu_math"),n=r(require("./shader_compiler_util"));function r(e,t){if("function"==typeof WeakMap)var n=new WeakMap,o=new WeakMap;return(r=function(e,t){if(!t&&e&&e.__esModule)return e;var r,a,i={__proto__:null,default:e};if(null===e||"object"!=typeof e&&"function"!=typeof e)return i;if(r=t?o:n){if(r.has(e))return r.get(e);r.set(e,i)}for(const n in e)"default"!==n&&{}.hasOwnProperty.call(e,n)&&((a=(r=Object.defineProperty)&&Object.getOwnPropertyDescriptor(e,n))&&(a.get||a.set)?r(i,n,a):i[n]=e[n]);return i})(e,t)}const o={R:0,G:1,B:2,A:3};class a{constructor(r,a=!1,i="RGBA"){this.variableNames=["A"],this.customUniforms=[{name:"texShape",type:"ivec2"}];const s=(0,e.getGlslDifferences)();this.outputShape=r,this.enableShapeUniforms=(0,t.useShapeUniforms)(this.outputShape.length);let l="result";a&&(l="floor(result * 255. + 0.5)");let u="";for(let e=0;e<i.length;e++){const t=i[e];u+=`\n          if(offset == ${e}) {\n            result = values[${o[t]}];\n          }`}this.userCode=`\n      ${this.enableShapeUniforms?n.getFlatIndexFrom3DOutput():n.getFlatIndexFrom3D(r)}\n\n      void main() {\n        ivec3 coords = getOutputCoords();\n        int flatIndex = getFlatIndex(coords);\n        float result = 0.;\n        int offset = imod(flatIndex, ${i.length});\n\n        flatIndex = idiv(flatIndex, ${i.length}, 1.);\n\n        int r = flatIndex / texShape[1];\n        if (r < texShape[0]) {\n          int c = imod(flatIndex, texShape[1]);\n          vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);\n          vec4 values = ${s.texture2D}(A, uv);\n          ${u}\n        }\n        ${s.output} = vec4(${l}, 0., 0., 0.);\n      }\n    `}}exports.EncodeMatrixProgram=a;
},{"./glsl_version":"fXvw","./gpgpu_math":"eeKH","./shader_compiler_util":"tjqy"}],"UZCK":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.EncodeMatrixPackedProgram=void 0;var e=require("./glsl_version"),t=require("./gpgpu_math"),n=o(require("./shader_compiler_util"));function o(e,t){if("function"==typeof WeakMap)var n=new WeakMap,r=new WeakMap;return(o=function(e,t){if(!t&&e&&e.__esModule)return e;var o,s,a={__proto__:null,default:e};if(null===e||"object"!=typeof e&&"function"!=typeof e)return a;if(o=t?r:n){if(o.has(e))return o.get(e);o.set(e,a)}for(const n in e)"default"!==n&&{}.hasOwnProperty.call(e,n)&&((s=(o=Object.defineProperty)&&Object.getOwnPropertyDescriptor(e,n))&&(s.get||s.set)?o(a,n,s):a[n]=e[n]);return a})(e,t)}class r{constructor(o,r=!1){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.customUniforms=[{name:"texShape",type:"ivec2"}];const s=(0,e.getGlslDifferences)();this.outputShape=o,this.enableShapeUniforms=(0,t.useShapeUniforms)(this.outputShape.length);let a="",l="result";r&&(l="floor(result * 255. + 0.5)");for(let e=0;e<=1;e++)for(let t=0;t<=1;t++){const n=2*e+t;a+=`\n          localCoords = coords;\n          if(localCoords[2] + ${t} < ${this.enableShapeUniforms?"outShape[2]":`${o[2]}`}) {\n          localCoords[2] += ${t};\n          if (localCoords[1] + ${e} < ${this.enableShapeUniforms?"outShape[1]":`${o[1]}`}) {\n            localCoords[1] += ${e};\n\n            flatIndex = getFlatIndex(localCoords);\n            offset = imod(flatIndex, 4);\n\n            flatIndex = idiv(flatIndex, 4, 1.);\n\n            int r = flatIndex / texShape[1];\n            int c = imod(flatIndex, texShape[1]);\n            vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);\n            values = ${s.texture2D}(A, uv);\n\n            if (offset == 0) {\n              result[${n}] = values[0];\n            } else if (offset == 1) {\n              result[${n}] = values[1];\n            } else if (offset == 2) {\n              result[${n}] = values[2];\n            } else {\n              result[${n}] = values[3];\n            }\n          }\n        }\n        `}this.userCode=`\n        ${this.enableShapeUniforms?n.getFlatIndexFrom3DOutput():n.getFlatIndexFrom3D(o)}\n\n        void main() {\n          ivec3 coords = getOutputCoords();\n\n          vec4 result = vec4(0.);\n          int flatIndex, r, c, offset;\n          ivec3 localCoords;\n          vec2 uv;\n          vec4 values;\n\n          ${a}\n\n          ${s.output} = ${l};\n        }\n    `}}exports.EncodeMatrixPackedProgram=r;
},{"./glsl_version":"fXvw","./gpgpu_math":"eeKH","./shader_compiler_util":"tjqy"}],"jgbg":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.bindVertexProgramAttributeStreams=p,exports.createBufferFromOutputTexture=R,exports.createFloat16MatrixTexture=f,exports.createFloat16PackedMatrixTexture=_,exports.createFloat32MatrixTexture=x,exports.createIndexBuffer=c,exports.createPackedMatrixTexture=F,exports.createUnsignedBytesMatrixTexture=E,exports.createVertexBuffer=u,exports.createVertexShader=o,exports.downloadByteEncodedFloatMatrixFromOutputTexture=g,exports.downloadFloat32MatrixFromBuffer=P,exports.downloadMatrixFromPackedOutputTexture=k,exports.downloadPackedMatrixFromBuffer=U,exports.getInternalFormatForFloat16MatrixTexture=d,exports.getInternalFormatForFloat16PackedMatrixTexture=s,exports.getInternalFormatForFloat32MatrixTexture=l,exports.getInternalFormatForPackedMatrixTexture=A,exports.getInternalFormatForUnsignedBytesMatrixTexture=T,exports.uploadDenseMatrixToTexture=B,exports.uploadPixelDataToTexture=h;var e=require("@tensorflow/tfjs-core"),t=require("./glsl_version"),r=a(require("./tex_util")),n=a(require("./webgl_util"));function a(e,t){if("function"==typeof WeakMap)var r=new WeakMap,n=new WeakMap;return(a=function(e,t){if(!t&&e&&e.__esModule)return e;var a,o,u={__proto__:null,default:e};if(null===e||"object"!=typeof e&&"function"!=typeof e)return u;if(a=t?n:r){if(a.has(e))return a.get(e);a.set(e,u)}for(const r in e)"default"!==r&&{}.hasOwnProperty.call(e,r)&&((o=(a=Object.defineProperty)&&Object.getOwnPropertyDescriptor(e,r))&&(o.get||o.set)?a(u,r,o):u[r]=e[r]);return u})(e,t)}function o(e){const r=(0,t.getGlslDifferences)(),a=`${r.version}\n    precision highp float;\n    ${r.attribute} vec3 clipSpacePos;\n    ${r.attribute} vec2 uv;\n    ${r.varyingVs} vec2 resultUV;\n\n    void main() {\n      gl_Position = vec4(clipSpacePos, 1);\n      resultUV = uv;\n    }`;return n.createVertexShader(e,a)}function u(e){const t=new Float32Array([-1,1,0,0,1,-1,-1,0,0,0,1,1,0,1,1,1,-1,0,1,0]);return n.createStaticVertexBuffer(e,t)}function c(e){const t=new Uint16Array([0,1,2,2,1,3]);return n.createStaticIndexBuffer(e,t)}function i(t,r,a,o,u,c){n.validateTextureSize(r,a);const i=n.createTexture(t),l=t.TEXTURE_2D;return n.callAndCheck(t,()=>t.bindTexture(l,i)),n.callAndCheck(t,()=>t.texParameteri(l,t.TEXTURE_WRAP_S,t.CLAMP_TO_EDGE)),n.callAndCheck(t,()=>t.texParameteri(l,t.TEXTURE_WRAP_T,t.CLAMP_TO_EDGE)),n.callAndCheck(t,()=>t.texParameteri(l,t.TEXTURE_MIN_FILTER,t.NEAREST)),n.callAndCheck(t,()=>t.texParameteri(l,t.TEXTURE_MAG_FILTER,t.NEAREST)),1===(0,e.env)().getNumber("WEBGL_VERSION")?n.callAndCheck(t,()=>t.texImage2D(l,0,o,r,a,0,u,c,null)):n.callAndCheck(t,()=>t.texStorage2D(l,1,o,r,a)),n.callAndCheck(t,()=>t.bindTexture(t.TEXTURE_2D,null)),{texture:i,texShape:[a,r]}}function l(e){return e.internalFormatFloat}function x(e,t,n,a){const[o,u]=r.getUnpackedMatrixTextureShapeWidthHeight(t,n);return i(e,o,u,l(a),a.textureFormatFloat,e.FLOAT)}function d(e){return e.internalFormatHalfFloat}function f(e,t,n,a){const[o,u]=r.getUnpackedMatrixTextureShapeWidthHeight(t,n);return i(e,o,u,d(a),a.textureFormatFloat,a.textureTypeHalfFloat)}function T(e){return e.downloadTextureFormat}function E(e,t,n,a){const[o,u]=r.getUnpackedMatrixTextureShapeWidthHeight(t,n);return i(e,o,u,T(a),e.RGBA,e.UNSIGNED_BYTE)}function A(e){return e.internalFormatPackedFloat}function F(e,t,n,a){const[o,u]=r.getPackedMatrixTextureShapeWidthHeight(t,n);return i(e,o,u,A(a),e.RGBA,e.FLOAT)}function s(e){return e.internalFormatPackedHalfFloat}function _(e,t,n,a){const[o,u]=r.getPackedMatrixTextureShapeWidthHeight(t,n);return i(e,o,u,s(a),e.RGBA,a.textureTypeHalfFloat)}function p(e,t,r){return n.callAndCheck(e,()=>e.bindBuffer(e.ARRAY_BUFFER,r)),n.bindVertexBufferToProgramAttribute(e,t,"clipSpacePos",r,3,20,0)&&n.bindVertexBufferToProgramAttribute(e,t,"uv",r,2,20,12)}function B(t,r,a,o,u,c){let i,l,x;n.callAndCheck(t,()=>t.bindTexture(t.TEXTURE_2D,r)),u instanceof Uint8Array?(i=new Uint8Array(a*o*4),l=t.UNSIGNED_BYTE,x=t.RGBA):(i=new Float32Array(a*o*4),l=t.FLOAT,x=c.internalFormatPackedFloat),i.set(u),2===(0,e.env)().getNumber("WEBGL_VERSION")?n.callAndCheck(t,()=>t.texSubImage2D(t.TEXTURE_2D,0,0,0,a,o,t.RGBA,l,i)):n.callAndCheck(t,()=>t.texImage2D(t.TEXTURE_2D,0,x,a,o,0,t.RGBA,l,i)),n.callAndCheck(t,()=>t.bindTexture(t.TEXTURE_2D,null))}function h(t,r,a){n.callAndCheck(t,()=>t.bindTexture(t.TEXTURE_2D,r)),a.data instanceof Uint8Array?2===(0,e.env)().getNumber("WEBGL_VERSION")?n.callAndCheck(t,()=>t.texSubImage2D(t.TEXTURE_2D,0,0,0,a.width,a.height,t.RGBA,t.UNSIGNED_BYTE,a.data)):n.callAndCheck(t,()=>t.texImage2D(t.TEXTURE_2D,0,t.RGBA,a.width,a.height,0,t.RGBA,t.UNSIGNED_BYTE,a.data)):2===(0,e.env)().getNumber("WEBGL_VERSION")?n.callAndCheck(t,()=>t.texSubImage2D(t.TEXTURE_2D,0,0,0,t.RGBA,t.UNSIGNED_BYTE,a)):n.callAndCheck(t,()=>t.texImage2D(t.TEXTURE_2D,0,t.RGBA,t.RGBA,t.UNSIGNED_BYTE,a)),n.callAndCheck(t,()=>t.bindTexture(t.TEXTURE_2D,null))}function R(e,t,r,a){const o=e.createBuffer();n.callAndCheck(e,()=>e.bindBuffer(e.PIXEL_PACK_BUFFER,o));const u=16*t*r;return n.callAndCheck(e,()=>e.bufferData(e.PIXEL_PACK_BUFFER,u,e.STREAM_READ)),n.callAndCheck(e,()=>e.readPixels(0,0,r,t,e.RGBA,e.FLOAT,0)),n.callAndCheck(e,()=>e.bindBuffer(e.PIXEL_PACK_BUFFER,null)),o}function P(e,t,r){const n=e,a=new Float32Array(r);return n.bindBuffer(n.PIXEL_PACK_BUFFER,t),n.getBufferSubData(n.PIXEL_PACK_BUFFER,0,a),n.bindBuffer(n.PIXEL_PACK_BUFFER,null),a}function g(e,t,a,o){const[u,c]=r.getUnpackedMatrixTextureShapeWidthHeight(t,a),i=new Uint8Array(r.getUnpackedArraySizeFromMatrixSize(t*a,4));return n.callAndCheck(e,()=>e.readPixels(0,0,u,c,o.downloadTextureFormat,e.UNSIGNED_BYTE,i)),new Float32Array(i.buffer)}function U(e,t,n,a,o,u,c,i){const l=e,x=new Float32Array(r.getPackedRGBAArraySizeFromMatrixShape(u,c));return l.bindBuffer(l.PIXEL_PACK_BUFFER,t),l.getBufferSubData(l.PIXEL_PACK_BUFFER,0,x),l.bindBuffer(l.PIXEL_PACK_BUFFER,null),x}function k(e,t,r){const a=new Float32Array(t*r*4);return n.callAndCheck(e,()=>e.readPixels(0,0,r,t,e.RGBA,e.FLOAT,a)),a}
},{"@tensorflow/tfjs-core":"kSBl","./glsl_version":"fXvw","./tex_util":"jAWT","./webgl_util":"u1ML"}],"GZkx":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.GPGPUContext=void 0,exports.linearSearchLastTrue=a;var e=require("@tensorflow/tfjs-core"),t=require("./canvas_util"),r=s(require("./gpgpu_util")),i=s(require("./tex_util")),o=s(require("./webgl_util"));function s(e,t){if("function"==typeof WeakMap)var r=new WeakMap,i=new WeakMap;return(s=function(e,t){if(!t&&e&&e.__esModule)return e;var o,s,n={__proto__:null,default:e};if(null===e||"object"!=typeof e&&"function"!=typeof e)return n;if(o=t?i:r){if(o.has(e))return o.get(e);o.set(e,n)}for(const r in e)"default"!==r&&{}.hasOwnProperty.call(e,r)&&((s=(o=Object.defineProperty)&&Object.getOwnPropertyDescriptor(e,r))&&(s.get||s.set)?o(n,r,s):n[r]=e[r]);return n})(e,t)}class n{constructor(s){this.outputTexture=null,this.program=null,this.disposed=!1,this.itemsToPoll=[];const n=(0,e.env)().getNumber("WEBGL_VERSION");if(null!=s?(this.gl=s,(0,t.setWebGLContext)(n,s)):this.gl=(0,t.getWebGLContext)(n),s=this.gl,2===(0,e.env)().getNumber("WEBGL_VERSION")){const e=s;this.createVertexArray=(()=>o.callAndCheck(e,()=>e.createVertexArray())),this.bindVertexArray=(t=>o.callAndCheck(e,()=>e.bindVertexArray(t))),this.deleteVertexArray=(t=>o.callAndCheck(e,()=>e.deleteVertexArray(t))),this.getVertexArray=(()=>o.callAndCheck(e,()=>e.getParameter(e.VERTEX_ARRAY_BINDING)))}else if(null!=s){const e=s.getExtension("OES_vertex_array_object");if(null==e)throw new Error("All WebGL1 implementations are expected to offer OES_vertex_array_object.");this.createVertexArray=(()=>o.callAndCheck(s,()=>e.createVertexArrayOES())),this.bindVertexArray=(t=>o.callAndCheck(s,()=>e.bindVertexArrayOES(t))),this.deleteVertexArray=(t=>o.callAndCheck(s,()=>e.deleteVertexArrayOES(t))),this.getVertexArray=(()=>o.callAndCheck(s,()=>s.getParameter(e.VERTEX_ARRAY_BINDING_OES)))}let a="WEBGL_color_buffer_float";if(this.parallelCompilationExtension=this.gl.getExtension("KHR_parallel_shader_compile"),1===(0,e.env)().getNumber("WEBGL_VERSION")){const t="OES_texture_float",r="OES_texture_half_float";if(this.textureFloatExtension=o.getExtensionOrThrow(this.gl,t),o.hasExtension(this.gl,r))this.textureHalfFloatExtension=o.getExtensionOrThrow(this.gl,r);else if((0,e.env)().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support half float textures, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.");if(this.colorBufferFloatExtension=this.gl.getExtension(a),o.hasExtension(this.gl,"EXT_color_buffer_half_float"))this.colorBufferHalfFloatExtension=o.getExtensionOrThrow(this.gl,"EXT_color_buffer_half_float");else if((0,e.env)().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support color renderable half floats, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.")}else if(a="EXT_color_buffer_float",o.hasExtension(this.gl,a))this.colorBufferFloatExtension=this.gl.getExtension(a);else{if(!o.hasExtension(this.gl,"EXT_color_buffer_half_float"))throw new Error("GL context does not support color renderable floats");this.colorBufferHalfFloatExtension=this.gl.getExtension("EXT_color_buffer_half_float")}this.vertexBuffer=r.createVertexBuffer(this.gl),this.indexBuffer=r.createIndexBuffer(this.gl),this.framebuffer=o.createFramebuffer(this.gl),this.textureConfig=i.getTextureConfig(this.gl,this.textureHalfFloatExtension)}get debug(){return(0,e.env)().getBool("DEBUG")}dispose(){if(this.disposed)return;null!=this.program&&console.warn("Disposing a GPGPUContext that still has a bound WebGLProgram. This is probably a resource leak, delete the program with GPGPUContext.deleteProgram before disposing."),null!=this.outputTexture&&console.warn("Disposing a GPGPUContext that still has a bound output matrix texture.  This is probably a resource leak, delete the output matrix texture with GPGPUContext.deleteMatrixTexture before disposing.");const e=this.gl;o.callAndCheck(e,()=>e.finish()),o.callAndCheck(e,()=>e.bindFramebuffer(e.FRAMEBUFFER,null)),o.callAndCheck(e,()=>e.deleteFramebuffer(this.framebuffer)),o.callAndCheck(e,()=>e.bindBuffer(e.ARRAY_BUFFER,null)),o.callAndCheck(e,()=>e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,null)),o.callAndCheck(e,()=>e.deleteBuffer(this.indexBuffer)),this.disposed=!0}createFloat32MatrixTexture(e,t){return this.throwIfDisposed(),r.createFloat32MatrixTexture(this.gl,e,t,this.textureConfig)}createFloat16MatrixTexture(e,t){return this.throwIfDisposed(),r.createFloat16MatrixTexture(this.gl,e,t,this.textureConfig)}createUnsignedBytesMatrixTexture(e,t){return this.throwIfDisposed(),r.createUnsignedBytesMatrixTexture(this.gl,e,t,this.textureConfig)}uploadPixelDataToTexture(e,t){this.throwIfDisposed(),r.uploadPixelDataToTexture(this.gl,e,t)}uploadDenseMatrixToTexture(e,t,i,o){this.throwIfDisposed(),r.uploadDenseMatrixToTexture(this.gl,e,t,i,o,this.textureConfig)}createFloat16PackedMatrixTexture(e,t){return this.throwIfDisposed(),r.createFloat16PackedMatrixTexture(this.gl,e,t,this.textureConfig)}createPackedMatrixTexture(e,t){return this.throwIfDisposed(),r.createPackedMatrixTexture(this.gl,e,t,this.textureConfig)}deleteMatrixTexture(e){this.throwIfDisposed(),this.outputTexture===e&&(o.unbindColorTextureFromFramebuffer(this.gl,this.framebuffer),this.outputTexture=null),o.callAndCheck(this.gl,()=>this.gl.deleteTexture(e))}downloadByteEncodedFloatMatrixFromOutputTexture(e,t,i){return this.downloadMatrixDriver(e,()=>r.downloadByteEncodedFloatMatrixFromOutputTexture(this.gl,t,i,this.textureConfig))}downloadPackedMatrixFromBuffer(e,t,i,o,s,n){return r.downloadPackedMatrixFromBuffer(this.gl,e,t,i,o,s,n,this.textureConfig)}downloadFloat32MatrixFromBuffer(e,t){return r.downloadFloat32MatrixFromBuffer(this.gl,e,t)}createBufferFromTexture(e,t,i){this.bindTextureToFrameBuffer(e);const o=r.createBufferFromOutputTexture(this.gl,t,i,this.textureConfig);return this.unbindTextureToFrameBuffer(),o}createAndWaitForFence(){const e=this.createFence(this.gl);return this.pollFence(e)}createFence(t){let r,i;if((0,e.env)().getBool("WEBGL_FENCE_API_ENABLED")){const e=t,o=e.fenceSync(e.SYNC_GPU_COMMANDS_COMPLETE,0);t.flush(),i=(()=>{const t=e.clientWaitSync(o,0,0);return t===e.ALREADY_SIGNALED||t===e.CONDITION_SATISFIED}),r=o}else(0,e.env)().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0?(r=this.beginQuery(),this.endQuery(),i=(()=>this.isQueryAvailable(r,(0,e.env)().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")))):i=(()=>!0);return{query:r,isFencePassed:i}}downloadMatrixFromPackedTexture(e,t,i){return this.downloadMatrixDriver(e,()=>r.downloadMatrixFromPackedOutputTexture(this.gl,t,i))}createProgram(e){this.throwIfDisposed();const t=this.gl;null==this.vertexShader&&(this.vertexShader=r.createVertexShader(t));const i=o.createProgram(t);o.callAndCheck(t,()=>t.attachShader(i,this.vertexShader)),o.callAndCheck(t,()=>t.attachShader(i,e)),o.linkProgram(t,i);const s=Object.assign(i,{vao:this.createVertexArray()});return this.debug&&o.validateProgram(t,s),s}buildVao(e){this.setProgram(e),this.bindVertexArray(e.vao);const t=this.gl;o.callAndCheck(t,()=>t.bindBuffer(t.ELEMENT_ARRAY_BUFFER,this.indexBuffer)),r.bindVertexProgramAttributeStreams(t,e,this.vertexBuffer)}deleteProgram(e){this.throwIfDisposed(),e===this.program&&(this.program=null),null!=e&&(o.callAndCheck(this.gl,()=>this.gl.deleteProgram(e)),this.deleteVertexArray(e.vao))}setProgram(e){this.throwIfDisposed(),this.program=e,null!=this.program&&this.debug&&o.validateProgram(this.gl,this.program),o.callAndCheck(this.gl,()=>this.gl.useProgram(e))}getUniformLocation(e,t,r=!0){return this.throwIfDisposed(),r?o.getProgramUniformLocationOrThrow(this.gl,e,t):o.getProgramUniformLocation(this.gl,e,t)}getAttributeLocation(e,t){return this.throwIfDisposed(),o.callAndCheck(this.gl,()=>this.gl.getAttribLocation(e,t))}getUniformLocationNoThrow(e,t){return this.throwIfDisposed(),this.gl.getUniformLocation(e,t)}setInputMatrixTexture(e,t,r){this.throwIfDisposed(),this.throwIfNoProgram(),o.bindTextureToProgramUniformSampler(this.gl,e,t,r)}setOutputMatrixTexture(e,t,r){this.setOutputMatrixTextureDriver(e,r,t)}setOutputPackedMatrixTexture(e,t,r){this.throwIfDisposed();const[o,s]=i.getPackedMatrixTextureShapeWidthHeight(t,r);this.setOutputMatrixTextureDriver(e,o,s)}setOutputMatrixWriteRegion(e,t,r,i){this.setOutputMatrixWriteRegionDriver(r,e,i,t)}setOutputPackedMatrixWriteRegion(e,t,r,i){throw new Error("setOutputPackedMatrixWriteRegion not implemented.")}debugValidate(){null!=this.program&&o.validateProgram(this.gl,this.program),o.validateFramebuffer(this.gl)}executeProgram(){this.throwIfDisposed(),this.throwIfNoProgram();const e=this.gl;if(this.debug){const e=this.getVertexArray();console.assert(e===this.program.vao,"VAO changed between setProgram and executeProgram!"),this.debugValidate()}o.callAndCheck(e,()=>e.drawElements(e.TRIANGLES,6,e.UNSIGNED_SHORT,0))}blockUntilAllProgramsCompleted(){this.throwIfDisposed(),o.callAndCheck(this.gl,()=>this.gl.finish())}getQueryTimerExtension(){return null==this.disjointQueryTimerExtension&&(this.disjointQueryTimerExtension=o.getExtensionOrThrow(this.gl,2===(0,e.env)().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")?"EXT_disjoint_timer_query_webgl2":"EXT_disjoint_timer_query")),this.disjointQueryTimerExtension}getQueryTimerExtensionWebGL2(){return this.getQueryTimerExtension()}getQueryTimerExtensionWebGL1(){return this.getQueryTimerExtension()}beginQuery(){if(2===(0,e.env)().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")){const e=this.gl,t=this.getQueryTimerExtensionWebGL2(),r=e.createQuery();return e.beginQuery(t.TIME_ELAPSED_EXT,r),r}const t=this.getQueryTimerExtensionWebGL1(),r=t.createQueryEXT();return t.beginQueryEXT(t.TIME_ELAPSED_EXT,r),r}endQuery(){if(2===(0,e.env)().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")){const e=this.gl,t=this.getQueryTimerExtensionWebGL2();return void e.endQuery(t.TIME_ELAPSED_EXT)}const t=this.getQueryTimerExtensionWebGL1();t.endQueryEXT(t.TIME_ELAPSED_EXT)}async waitForQueryAndGetTime(t){return await e.util.repeatedTry(()=>this.disposed||this.isQueryAvailable(t,(0,e.env)().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))),this.getQueryTime(t,(0,e.env)().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))}getQueryTime(e,t){if(0===t)return null;if(2===t){const t=this.gl;return t.getQueryParameter(e,t.QUERY_RESULT)/1e6}{const t=this.getQueryTimerExtensionWebGL1();return t.getQueryObjectEXT(e,t.QUERY_RESULT_EXT)/1e6}}isQueryAvailable(e,t){if(0===t)return!0;if(2===t){const t=this.gl,r=this.getQueryTimerExtensionWebGL2(),i=t.getQueryParameter(e,t.QUERY_RESULT_AVAILABLE);return null==this.disjoint&&(this.disjoint=this.gl.getParameter(r.GPU_DISJOINT_EXT)),i&&!this.disjoint}{const t=this.getQueryTimerExtensionWebGL1(),r=t.getQueryObjectEXT(e,t.QUERY_RESULT_AVAILABLE_EXT);return null==this.disjoint&&(this.disjoint=this.gl.getParameter(t.GPU_DISJOINT_EXT)),r&&!this.disjoint}}pollFence(e){return new Promise(t=>{this.addItemToPoll(()=>e.isFencePassed(),()=>t())})}pollItems(){const e=a(this.itemsToPoll.map(e=>e.isDoneFn));for(let t=0;t<=e;++t){const{resolveFn:e}=this.itemsToPoll[t];e()}this.itemsToPoll=this.itemsToPoll.slice(e+1)}addItemToPoll(t,r){if(this.itemsToPoll.push({isDoneFn:t,resolveFn:r}),this.itemsToPoll.length>1)return;let i=void 0;"setTimeoutCustom"in(0,e.env)().platform&&(i=(0,e.env)().platform.setTimeoutCustom.bind((0,e.env)().platform)),e.util.repeatedTry(()=>(this.pollItems(),0===this.itemsToPoll.length),()=>0,null,i)}bindTextureToFrameBuffer(e){this.throwIfDisposed(),o.bindColorTextureToFramebuffer(this.gl,e,this.framebuffer),this.debug&&o.validateFramebuffer(this.gl)}unbindTextureToFrameBuffer(){null!=this.outputTexture?(o.bindColorTextureToFramebuffer(this.gl,this.outputTexture,this.framebuffer),this.debug&&o.validateFramebuffer(this.gl)):o.unbindColorTextureFromFramebuffer(this.gl,this.framebuffer)}downloadMatrixDriver(e,t){this.bindTextureToFrameBuffer(e);const r=t();return this.unbindTextureToFrameBuffer(),r}setOutputMatrixTextureDriver(e,t,r){this.throwIfDisposed();const i=this.gl;o.bindColorTextureToFramebuffer(i,e,this.framebuffer),this.debug&&o.validateFramebuffer(i),this.outputTexture=e,o.callAndCheck(i,()=>i.viewport(0,0,t,r)),o.callAndCheck(i,()=>i.scissor(0,0,t,r))}setOutputMatrixWriteRegionDriver(e,t,r,i){this.throwIfDisposed(),o.callAndCheck(this.gl,()=>this.gl.scissor(e,t,r,i))}throwIfDisposed(){if(this.disposed)throw new Error("Attempted to use disposed GPGPUContext.")}throwIfNoProgram(){if(null==this.program)throw new Error("No GPU program is currently set.")}}function a(e){let t=0;for(;t<e.length;++t){if(!e[t]())break}return t-1}exports.GPGPUContext=n;
},{"@tensorflow/tfjs-core":"kSBl","./canvas_util":"xuCv","./gpgpu_util":"jgbg","./tex_util":"jAWT","./webgl_util":"u1ML"}],"cNPH":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.uniqueImplCPU=exports.transposeImplCPU=exports.topKImplCPU=exports.tileImplCPU=exports.subImplCPU=exports.stringToHashBucketFastImplCPU=exports.stringSplitImplCPU=exports.stringNGramsImplCPU=exports.stridedSliceImplCPU=exports.staticRegexReplaceImplCPU=exports.sqrtImplCPU=exports.sparseSegmentReductionImplCPU=exports.sparseReshapeImplCPU=exports.sparseFillEmptyRowsImplCPU=exports.sliceImplCPU=exports.simpleAbsImplCPU=exports.sigmoidImplCPU=exports.scatterImplCPU=exports.rsqrtImplCPU=exports.rangeImplCPU=exports.raggedTensorToTensorImplCPU=exports.raggedRangeImplCPU=exports.raggedGatherImplCPU=exports.prodImplCPU=exports.notEqualImplCPU=exports.negImplCPU=exports.multiplyImplCPU=exports.minimumImplCPU=exports.maximumImplCPU=exports.maxImplCPU=exports.logImplCPU=exports.linSpaceImplCPU=exports.lessImplCPU=exports.lessEqualImplCPU=exports.greaterImplCPU=exports.greaterEqualImplCPU=exports.gatherV2ImplCPU=exports.gatherNdImplCPU=exports.floorImplCPU=exports.expm1ImplCPU=exports.expImplCPU=exports.equalImplCPU=exports.concatImplCPU=exports.ceilImplCPU=exports.castImplCPU=exports.bitwiseAndImplCPU=exports.bincountReduceImplCPU=exports.bincountImplCPU=exports.addImplCPU=void 0;var p=e(require("@tensorflow/tfjs-backend-cpu/dist/shared"));function e(p,t){if("function"==typeof WeakMap)var l=new WeakMap,s=new WeakMap;return(e=function(p,e){if(!e&&p&&p.__esModule)return p;var t,r,m={__proto__:null,default:p};if(null===p||"object"!=typeof p&&"function"!=typeof p)return m;if(t=e?s:l){if(t.has(p))return t.get(p);t.set(p,m)}for(const l in p)"default"!==l&&{}.hasOwnProperty.call(p,l)&&((r=(t=Object.defineProperty)&&Object.getOwnPropertyDescriptor(p,l))&&(r.get||r.set)?t(m,l,r):m[l]=p[l]);return m})(p,t)}const{addImpl:t,bincountImpl:l,bincountReduceImpl:s,bitwiseAndImpl:r,castImpl:m,ceilImpl:o,concatImpl:I,equalImpl:x,expImpl:a,expm1Impl:P,floorImpl:C,gatherNdImpl:U,gatherV2Impl:i,greaterImpl:n,greaterEqualImpl:u,lessImpl:g,lessEqualImpl:c,linSpaceImpl:d,logImpl:f,maxImpl:q,maximumImpl:R,minimumImpl:b,multiplyImpl:h,negImpl:y,notEqualImpl:E,prodImpl:S,raggedGatherImpl:T,raggedRangeImpl:w,raggedTensorToTensorImpl:_,rangeImpl:k,rsqrtImpl:A,scatterImpl:F,sigmoidImpl:G,simpleAbsImpl:N,sliceImpl:j,sparseFillEmptyRowsImpl:v,sparseReshapeImpl:M,sparseSegmentReductionImpl:O,sqrtImpl:B,staticRegexReplaceImpl:H,stridedSliceImpl:K,stringNGramsImpl:V,stringSplitImpl:W,stringToHashBucketFastImpl:D,subImpl:z,tileImpl:J,topKImpl:L,transposeImpl:Q,uniqueImpl:X}=p;exports.uniqueImplCPU=X,exports.transposeImplCPU=Q,exports.topKImplCPU=L,exports.tileImplCPU=J,exports.subImplCPU=z,exports.stringToHashBucketFastImplCPU=D,exports.stringSplitImplCPU=W,exports.stringNGramsImplCPU=V,exports.stridedSliceImplCPU=K,exports.staticRegexReplaceImplCPU=H,exports.sqrtImplCPU=B,exports.sparseSegmentReductionImplCPU=O,exports.sparseReshapeImplCPU=M,exports.sparseFillEmptyRowsImplCPU=v,exports.sliceImplCPU=j,exports.simpleAbsImplCPU=N,exports.sigmoidImplCPU=G,exports.scatterImplCPU=F,exports.rsqrtImplCPU=A,exports.rangeImplCPU=k,exports.raggedTensorToTensorImplCPU=_,exports.raggedRangeImplCPU=w,exports.raggedGatherImplCPU=T,exports.prodImplCPU=S,exports.notEqualImplCPU=E,exports.negImplCPU=y,exports.multiplyImplCPU=h,exports.minimumImplCPU=b,exports.maximumImplCPU=R,exports.maxImplCPU=q,exports.logImplCPU=f,exports.linSpaceImplCPU=d,exports.lessEqualImplCPU=c,exports.lessImplCPU=g,exports.greaterEqualImplCPU=u,exports.greaterImplCPU=n,exports.gatherV2ImplCPU=i,exports.gatherNdImplCPU=U,exports.floorImplCPU=C,exports.expm1ImplCPU=P,exports.expImplCPU=a,exports.equalImplCPU=x,exports.concatImplCPU=I,exports.ceilImplCPU=o,exports.castImplCPU=m,exports.bitwiseAndImplCPU=r,exports.bincountReduceImplCPU=s,exports.bincountImplCPU=l,exports.addImplCPU=t;
},{"@tensorflow/tfjs-backend-cpu/dist/shared":"AxIp"}],"BqvU":[function(require,module,exports) {
"use strict";function e(e,t){return["x","y","z","w","u","v"].slice(0,t).map(t=>`${e}.${t}`)}function t(t,r){return 1===r?[t]:e(t,r)}function r(e,t){if(1===e)return"rc";let r="";for(let n=0;n<e;n++)r+=t[n],n<e-1&&(r+=",");return r}Object.defineProperty(exports,"__esModule",{value:!0}),exports.getChannels=t,exports.getSourceCoords=r,exports.getVecChannels=e;
},{}],"tySX":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.PackProgram=void 0;var t=require("./gpgpu_math"),e=require("./packing_util"),r=require("./shader_compiler");class n{constructor(n){if(this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outputShape=n,this.rank=n.length,this.enableShapeUniforms=(0,t.useShapeUniforms)(this.outputShape.length),0===this.rank)this.userCode="\n        void main() {\n          setOutput(vec4(getA(), 0., 0., 0.));\n        }\n      ";else{const t=(0,e.getChannels)("rc",this.rank),n=(0,r.getCoordsDataType)(this.rank),s=this.getOutOfBoundsCondition(t),i=this.getSetup(t),h=this.getOutput(t);this.userCode=`\n        void main() {\n          ${n} rc = getOutputCoords();\n\n          if(${s}) {\n            setOutput(vec4(0));\n          } else {\n            ${i}\n\n            setOutput(vec4(${h}));\n          }\n        }\n      `}}getSourceCoordsArr(t){const e=[];for(let r=0;r<=1;r++)for(let n=0;n<=1;n++){let s=`${0===r?"r":"rp1"}, ${0===n?"c":"cp1"}`;for(let e=2;e<this.rank;e++)s=`${t[t.length-1-e]},`+s;e.push(s)}return e}getOutOfBoundsCondition(t){if(1===this.rank)return`rc > ${this.enableShapeUniforms?"outShape":this.outputShape[0]}`;let e="";for(let r=this.rank-2;r<this.rank;r++)e+=`${t[r]} >= ${this.enableShapeUniforms?`outShape[${r}]`:this.outputShape[r]}`,r<this.rank-1&&(e+="||");return e}getSetup(t){if(1===this.rank)return"";const e=t.slice(-2),r=this.enableShapeUniforms?`outShape[${this.rank} - 1]`:this.outputShape[this.rank-1],n=this.enableShapeUniforms?`outShape[${this.rank} - 2]`:this.outputShape[this.rank-2];return`\n      int r = ${e[0]};\n      int c = ${e[1]};\n      int rp1 = r + 1;\n      int cp1 = c + 1;\n\n      bool cEdge = cp1 >= ${r};\n      bool rEdge = rp1 >= ${n};\n    `}getOutput(t){const e=this.getSourceCoordsArr(t);if(1===this.rank){return`getA(rc), (rc + 1 >= ${this.enableShapeUniforms?"outShape":this.outputShape[0]} ? 0. : getA(rc + 1)), 0, 0`}return`getA(${e[0]}),\n            cEdge ? 0. : getA(${e[1]}),\n            rEdge ? 0. : getA(${e[2]}),\n            rEdge || cEdge ? 0. : getA(${e[3]})`}}exports.PackProgram=n;
},{"./gpgpu_math":"eeKH","./packing_util":"BqvU","./shader_compiler":"xhhc"}],"qDuX":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.ReshapePackedProgram=void 0;var e=require("./gpgpu_math"),t=n(require("./shader_compiler_util"));function n(e,t){if("function"==typeof WeakMap)var r=new WeakMap,i=new WeakMap;return(n=function(e,t){if(!t&&e&&e.__esModule)return e;var n,o,s={__proto__:null,default:e};if(null===e||"object"!=typeof e&&"function"!=typeof e)return s;if(n=t?i:r){if(n.has(e))return n.get(e);n.set(e,s)}for(const r in e)"default"!==r&&{}.hasOwnProperty.call(e,r)&&((o=(n=Object.defineProperty)&&Object.getOwnPropertyDescriptor(e,r))&&(o.get||o.set)?n(s,r,o):s[r]=e[r]);return s})(e,t)}class r{constructor(n,r){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec3"}],this.outputShape=n,this.enableShapeUniforms=(0,e.useShapeUniforms)(this.outputShape.length);let o="";for(let e=0;e<4;e++){let t="thisRC = rc;";e%2==1&&(t+="thisRC.z += 1;"),e>1&&(t+="thisRC.y += 1;"),o+=`\n        ${t}\n        ${e>0?"if(thisRC.y < rows && thisRC.z < cols){":""}\n          int flatIndex = getFlatIndex(thisRC);\n\n          ivec3 inputRC = inputCoordsFromReshapedOutCoords(flatIndex);\n          vec2 inputRCInnerDims = vec2(float(inputRC.y),float(inputRC.z));\n\n          result[${e}] =\n            getChannel(getA(inputRC.x, inputRC.y, inputRC.z), inputRCInnerDims);\n        ${e>0?"}":""}\n      `}this.userCode=`\n      ${i(r,this.enableShapeUniforms)}\n      ${this.enableShapeUniforms?t.getFlatIndexFrom3DOutput():t.getFlatIndexFrom3D(n)}\n\n      void main() {\n        ivec3 rc = getOutputCoords();\n\n        vec4 result = vec4(0.);\n\n        ivec3 thisRC;\n        int rows = ${this.enableShapeUniforms?"outShape[1]":n[1]};\n        int cols = ${this.enableShapeUniforms?"outShape[2]":n[2]};\n\n        ${o}\n\n        setOutput(result);\n      }\n    `}}function i(e,n){return`\n    ivec3 inputCoordsFromReshapedOutCoords(int index) {\n      ${n?t.getLogicalCoordinatesFromFlatIndexByUniform(["r","c","d"],"inputShape"):t.getLogicalCoordinatesFromFlatIndex(["r","c","d"],e)}\n      return ivec3(r, c, d);\n    }\n  `}exports.ReshapePackedProgram=r;
},{"./gpgpu_math":"eeKH","./shader_compiler_util":"tjqy"}],"yk4C":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.TextureManager=void 0,exports.computeBytes=i;var e=require("@tensorflow/tfjs-core"),t=require("./gpgpu_util"),r=require("./tex_util");class s{constructor(e){this.gpgpu=e,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0,this.freeTextures={},this.usedTextures={},this.logEnabled=!1}acquireTexture(e,t,s){const u=h(t,s),n=x(e,u,s);n in this.freeTextures||(this.freeTextures[n]=[]),n in this.usedTextures||(this.usedTextures[n]=[]);const T=i(e,u,this.gpgpu.gl,this.gpgpu.textureConfig,s);if(this.freeTextures[n].length>0){this.numFreeTextures--,this.numUsedTextures++,this._numBytesFree-=T,this.log();const e=this.freeTextures[n].pop();return this.usedTextures[n].push(e),e}let a;return u===r.PhysicalTextureType.PACKED_2X2_FLOAT32?a=this.gpgpu.createPackedMatrixTexture(e[0],e[1]):u===r.PhysicalTextureType.PACKED_2X2_FLOAT16?a=this.gpgpu.createFloat16PackedMatrixTexture(e[0],e[1]):u===r.PhysicalTextureType.UNPACKED_FLOAT32?a=this.gpgpu.createFloat32MatrixTexture(e[0],e[1]):u===r.PhysicalTextureType.UNPACKED_FLOAT16?a=this.gpgpu.createFloat16MatrixTexture(e[0],e[1]):u===r.PhysicalTextureType.PACKED_4X1_UNSIGNED_BYTE&&(a=this.gpgpu.createUnsignedBytesMatrixTexture(e[0],e[1])),this.usedTextures[n].push(a),this.numUsedTextures++,this._numBytesAllocated+=T,this.log(),a}releaseTexture(t,r,s,u){if(null==this.freeTextures)return;const n=h(s,u),T=x(r,n,u);T in this.freeTextures||(this.freeTextures[T]=[]);const a=i(r,n,this.gpgpu.gl,this.gpgpu.textureConfig,u),o=(0,e.env)().getNumber("WEBGL_DELETE_TEXTURE_THRESHOLD");-1!==o&&this._numBytesAllocated>o?(this.gpgpu.deleteMatrixTexture(t.texture),this._numBytesAllocated-=a):(this.freeTextures[T].push(t),this.numFreeTextures++,this._numBytesFree+=a),this.numUsedTextures--;const l=this.usedTextures[T],c=l&&l.indexOf(t);if(null==c||c<0)throw new Error("Cannot release a texture that was never provided by this texture manager");l[c]=l[l.length-1],l.pop(),this.log()}log(){if(!this.logEnabled)return;const e=this.numFreeTextures+this.numUsedTextures;console.log("Free/Used",`${this.numFreeTextures} / ${this.numUsedTextures}`,`(${e})`);const t=this._numBytesFree/this._numBytesAllocated;console.log(`Bytes allocated: ${this._numBytesAllocated}`),console.log(`Bytes unused: ${this._numBytesFree} (${Math.round(100*t)}%)`)}get numBytesAllocated(){return this._numBytesAllocated}get numBytesFree(){return this._numBytesFree}getNumUsedTextures(){return this.numUsedTextures}getNumFreeTextures(){return this.numFreeTextures}dispose(){if(null!=this.freeTextures){for(const e in this.freeTextures)this.freeTextures[e].forEach(e=>{this.gpgpu.deleteMatrixTexture(e.texture)});for(const e in this.usedTextures)this.usedTextures[e].forEach(e=>{this.gpgpu.deleteMatrixTexture(e.texture)});this.freeTextures=null,this.usedTextures=null,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0}}}function u(e,t){const r=e;if(t===r.R32F)return 4;if(t===r.R16F)return 2;if(t===r.RGBA32F)return 16;if(t===e.RGBA)return 16;if(t===r.RGBA16F)return 8;if(t===r.RGBA8)return 4;throw new Error(`Unknown internal format ${t}`)}function i(e,t,s,i,T){const h=n(t,i);let x;if(T){const[t,s]=(0,r.getPackedMatrixTextureShapeWidthHeight)(e[0],e[1]);x=t*s}else{const[t,s]=(0,r.getUnpackedMatrixTextureShapeWidthHeight)(e[0],e[1]);x=t*s}return x*u(s,h)}function n(e,s){switch(e){case r.PhysicalTextureType.PACKED_2X2_FLOAT32:return(0,t.getInternalFormatForPackedMatrixTexture)(s);case r.PhysicalTextureType.PACKED_2X2_FLOAT16:return(0,t.getInternalFormatForFloat16PackedMatrixTexture)(s);case r.PhysicalTextureType.UNPACKED_FLOAT32:return(0,t.getInternalFormatForFloat32MatrixTexture)(s);case r.PhysicalTextureType.UNPACKED_FLOAT16:return(0,t.getInternalFormatForFloat16MatrixTexture)(s);case r.PhysicalTextureType.PACKED_4X1_UNSIGNED_BYTE:return(0,t.getInternalFormatForUnsignedBytesMatrixTexture)(s);default:throw new Error(`Unknown physical texture type ${e}`)}}function T(t){return(0,e.env)().getBool("WEBGL_RENDER_FLOAT32_ENABLED")?t?r.PhysicalTextureType.PACKED_2X2_FLOAT32:r.PhysicalTextureType.UNPACKED_FLOAT32:t?r.PhysicalTextureType.PACKED_2X2_FLOAT16:r.PhysicalTextureType.UNPACKED_FLOAT16}function h(e,t){if(e===r.TextureUsage.UPLOAD)return r.PhysicalTextureType.PACKED_2X2_FLOAT32;if(e===r.TextureUsage.RENDER||null==e)return T(t);if(e===r.TextureUsage.DOWNLOAD||e===r.TextureUsage.PIXELS)return r.PhysicalTextureType.PACKED_4X1_UNSIGNED_BYTE;throw new Error(`Unknown logical texture type ${e}`)}function x(e,t,r){return`${e[0]}_${e[1]}_${t}_${r}`}exports.TextureManager=s;
},{"@tensorflow/tfjs-core":"kSBl","./gpgpu_util":"jgbg","./tex_util":"jAWT"}],"CK3x":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.SIGMOID=exports.RELU6=exports.RELU=exports.LINEAR=exports.ELU=exports.CLONE=exports.CHECK_NAN_SNIPPET=exports.ABS=void 0,exports.STEP=s,exports.UnaryOpProgram=void 0;var r=require("./gpgpu_math");class t{constructor(t,e){this.variableNames=["A"],this.outputShape=t,this.enableShapeUniforms=(0,r.useShapeUniforms)(this.outputShape.length),this.userCode=`\n      float unaryOperation(float x) {\n        ${e}\n      }\n\n      void main() {\n        float x = getAAtOutCoords();\n        float y = unaryOperation(x);\n\n        setOutput(y);\n      }\n    `}}exports.UnaryOpProgram=t;const e=exports.CHECK_NAN_SNIPPET="if (isnan(x)) return x;",n=exports.LINEAR="return x;",o=exports.ABS="return abs(x);";function s(r=0){return e+`\n    return x > 0.0 ? 1.0 : float(${r});\n  `}const x=exports.ELU="return (x >= 0.0) ? x : (exp(x) - 1.0);",p=exports.RELU=e+"\n  return (x < 0.0) ? 0.0 : x;\n",a=exports.RELU6=e+"\n  return (x < 0.0) ? 0.0 : min(6.0, x);\n",u=exports.CLONE="return x;",i=exports.SIGMOID="return 1.0 / (1.0 + exp(-1.0 * x));";
},{"./gpgpu_math":"eeKH"}],"zBLd":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.UnaryOpPackedProgram=exports.SIGMOID=exports.RELU6=exports.RELU=exports.LINEAR=exports.ELU=void 0;var e=require("./gpgpu_math");const r=exports.LINEAR="return x;",t=exports.ELU="\n  vec4 result;\n\n  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);\n  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);\n  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);\n  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);\n\n  return result;\n",s=exports.RELU="\n  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n",n=exports.RELU6="\n  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n",a=exports.SIGMOID="return 1.0 / (1.0 + exp(-1.0 * x));";class u{constructor(r,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=r,this.enableShapeUniforms=(0,e.useShapeUniforms)(this.outputShape.length),this.userCode=`\n      vec4 unaryOperation(vec4 x) {\n        ${t}\n      }\n\n      void main() {\n        vec4 x = getAAtOutCoords();\n        vec4 y = unaryOperation(x);\n\n        setOutput(y);\n      }\n    `}}exports.UnaryOpPackedProgram=u;
},{"./gpgpu_math":"eeKH"}],"boI6":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.UnpackProgram=void 0;var e=require("./gpgpu_math"),t=require("./packing_util"),r=require("./shader_compiler");class s{constructor(s){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outputShape=s,this.enableShapeUniforms=(0,e.useShapeUniforms)(this.outputShape.length);const a=s.length,n=(0,t.getChannels)("rc",a),p=(0,r.getCoordsDataType)(a),o=(0,t.getSourceCoords)(a,n),u=n.slice(-2),i=a<=1?"rc":`vec2(${u.join(",")})`;this.userCode=`\n      void main() {\n        ${p} rc = getOutputCoords();\n        vec4 packedInput = getA(${o});\n\n        setOutput(getChannel(packedInput, ${i}));\n      }\n    `}}exports.UnpackProgram=s;
},{"./gpgpu_math":"eeKH","./packing_util":"BqvU","./shader_compiler":"xhhc"}],"DXeN":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.MathBackendWebGL=exports.EPSILON_FLOAT32=exports.EPSILON_FLOAT16=void 0,exports.getBinaryCache=S,require("./flags_webgl");var e=require("@tensorflow/tfjs-core"),t=require("./canvas_util"),a=require("./decode_matrix_gpu"),r=require("./decode_matrix_packed_gpu"),n=require("./encode_float_gpu"),s=require("./encode_float_packed_gpu"),i=require("./encode_matrix_gpu"),o=require("./encode_matrix_packed_gpu"),u=require("./gpgpu_context"),h=T(require("./gpgpu_math")),l=h,p=require("./kernel_utils/shared"),d=require("./pack_gpu"),c=require("./reshape_packed_gpu"),g=T(require("./tex_util")),m=g,f=require("./texture_manager"),x=T(require("./unaryop_gpu")),P=x,I=require("./unaryop_packed_gpu"),y=require("./unpack_gpu"),E=T(require("./webgl_util"));function T(e,t){if("function"==typeof WeakMap)var a=new WeakMap,r=new WeakMap;return(T=function(e,t){if(!t&&e&&e.__esModule)return e;var n,s,i={__proto__:null,default:e};if(null===e||"object"!=typeof e&&"function"!=typeof e)return i;if(n=t?r:a){if(n.has(e))return n.get(e);n.set(e,i)}for(const a in e)"default"!==a&&{}.hasOwnProperty.call(e,a)&&((s=(n=Object.defineProperty)&&Object.getOwnPropertyDescriptor(e,a))&&(s.get||s.set)?n(i,a,s):i[a]=e[a]);return i})(e,t)}const L=e.kernel_impls.whereImpl,_=exports.EPSILON_FLOAT32=1e-7,D=exports.EPSILON_FLOAT16=1e-4,w={};function S(e){return e in w?w[e]:(w[e]={},w[e])}const k=(0,e.env)().getNumber("CPU_HANDOFF_SIZE_THRESHOLD"),b=600;function v(){return null==(0,e.env)().global.screen?1024:(0,e.env)().global.screen.height*(0,e.env)().global.screen.width*window.devicePixelRatio*b/1024/1024}class G extends e.KernelBackend{nextDataId(){return G.nextDataId++}constructor(a){if(super(),this.pendingRead=new WeakMap,this.pendingDisposal=new WeakSet,this.dataRefCount=new WeakMap,this.numBytesInGPU=0,this.uploadWaitMs=0,this.downloadWaitMs=0,this.lastGlFlushTime=0,this.warnedAboutMemory=!1,this.pendingDeletes=0,this.disposed=!1,!(0,e.env)().getBool("HAS_WEBGL"))throw new Error("WebGL is not supported on this device");let r;if(null!=a){if(a instanceof u.GPGPUContext)r=a;else{const n=(0,t.getWebGLContext)((0,e.env)().getNumber("WEBGL_VERSION"),a);r=new u.GPGPUContext(n)}this.binaryCache={},this.gpgpuCreatedLocally=!1}else{const a=(0,t.getWebGLContext)((0,e.env)().getNumber("WEBGL_VERSION"));r=new u.GPGPUContext(a),this.binaryCache=S((0,e.env)().getNumber("WEBGL_VERSION")),this.gpgpuCreatedLocally=!0}this.gpgpu=r,this.canvas=this.gpgpu.gl.canvas,this.textureManager=new f.TextureManager(this.gpgpu),this.numMBBeforeWarning=v(),this.texData=new e.DataStorage(this,(0,e.engine)())}numDataIds(){return this.texData.numDataIds()-this.pendingDeletes}writeTexture(e,t,a,r,n,s){const o=this.makeTensorInfo(t,a),u=this.texData.get(o.dataId);u.isPacked=!1,u.texture={texture:e,texShape:[r,n]},u.texShape=[r,n];const h=E.getShapeAs3D(t),l=new i.EncodeMatrixProgram(h,!1,s),p=this.runWebGLProgram(l,[o],a,[[r,n]]);return p.shape=t,u.texture=null,this.disposeIntermediateTensorInfo(o),p.dataId}write(t,a,r){if(((0,e.env)().getBool("WEBGL_CHECK_NUMERICAL_PROBLEMS")||(0,e.env)().getBool("DEBUG"))&&this.checkNumericalProblems(t),"complex64"===r&&null!=t)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");const n={id:this.nextDataId()};return this.texData.set(n,{shape:a,dtype:r,values:t,usage:g.TextureUsage.UPLOAD,refCount:1}),n}refCount(e){if(this.texData.has(e)){return this.texData.get(e).refCount}return 0}incRef(e){this.texData.get(e).refCount++}decRef(e){if(this.texData.has(e)){this.texData.get(e).refCount--}}move(t,a,r,n,s){if((0,e.env)().getBool("DEBUG")&&this.checkNumericalProblems(a),"complex64"===n)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");this.texData.set(t,{shape:r,dtype:n,values:a,usage:g.TextureUsage.UPLOAD,refCount:s})}disposeIntermediateTensorInfo(e){this.disposeData(e.dataId)}readSync(t){const a=this.texData.get(t),{values:r,dtype:n,complexTensorInfos:s,slice:i,shape:o,isPacked:u}=a;if(null!=i){let e;e=u?new I.UnaryOpPackedProgram(o,P.CLONE):new x.UnaryOpProgram(o,P.CLONE);const a=this.runWebGLProgram(e,[{dataId:t,shape:o,dtype:n}],n),r=this.readSync(a.dataId);return this.disposeIntermediateTensorInfo(a),r}if(null!=r)return this.convertAndCacheOnCPU(t);if("string"===n)return r;const h=null!=this.activeTimers;let l,p;if(h&&(l=e.util.now()),"complex64"===n){const t=this.readSync(s.real.dataId),a=this.readSync(s.imag.dataId);p=e.backend_util.mergeRealAndImagArrays(t,a)}else p=this.getValuesFromTexture(t);return h&&(this.downloadWaitMs+=e.util.now()-l),this.convertAndCacheOnCPU(t,p)}async read(t){if(this.pendingRead.has(t)){const e=this.pendingRead.get(t);return new Promise(t=>e.push(t))}const a=this.texData.get(t),{values:r,shape:n,slice:s,dtype:i,complexTensorInfos:o,isPacked:u}=a;if(null!=s){let e;e=u?new I.UnaryOpPackedProgram(n,P.CLONE):new x.UnaryOpProgram(n,P.CLONE);const a=this.runWebGLProgram(e,[{dataId:t,shape:n,dtype:i}],i),r=this.read(a.dataId);return this.disposeIntermediateTensorInfo(a),r}if(null!=r)return this.convertAndCacheOnCPU(t);if((0,e.env)().getBool("DEBUG")&&!(0,e.env)().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")&&2===(0,e.env)().getNumber("WEBGL_VERSION"))throw new Error("tensor.data() with WEBGL_DOWNLOAD_FLOAT_ENABLED=false and WEBGL_VERSION=2 not yet supported.");let h,l,p=null;if("complex64"!==i&&(0,e.env)().get("WEBGL_BUFFER_SUPPORTED")){h=this.decode(t);const e=this.texData.get(h.dataId);p=this.gpgpu.createBufferFromTexture(e.texture.texture,...m.getDenseTexShape(n))}if(this.pendingRead.set(t,[]),"complex64"!==i&&await this.gpgpu.createAndWaitForFence(),"complex64"===i){const t=await Promise.all([this.read(o.real.dataId),this.read(o.imag.dataId)]),a=t[0],r=t[1];l=e.backend_util.mergeRealAndImagArrays(a,r)}else if(null==p)l=this.getValuesFromTexture(t);else{const t=e.util.sizeFromShape(n);l=this.gpgpu.downloadFloat32MatrixFromBuffer(p,t)}if(null!=h&&this.disposeIntermediateTensorInfo(h),null!=p){const e=this.gpgpu.gl;E.callAndCheck(e,()=>e.deleteBuffer(p))}const d=this.convertAndCacheOnCPU(t,l),c=this.pendingRead.get(t);return this.pendingRead.delete(t),c.forEach(e=>e(d)),this.pendingDisposal.has(t)&&(this.pendingDisposal.delete(t),this.disposeData(t)&&(0,e.engine)().removeDataId(t,this),this.pendingDeletes--),d}readToGPU(t,a={}){const r=this.texData.get(t),{values:n,shape:s,slice:i,dtype:o,isPacked:u,texture:h}=r;if("complex64"===o)throw new Error("Does not support reading texture for complex64 dtype.");if(null!=i){let e;e=u?new I.UnaryOpPackedProgram(s,P.CLONE):new x.UnaryOpProgram(s,P.CLONE);const r=this.runWebGLProgram(e,[{dataId:t,shape:s,dtype:o}],o),n=this.readToGPU(r,a);return this.disposeIntermediateTensorInfo(r),n}if(null==h)throw null!=n?new Error("Data is not on GPU but on CPU."):new Error("There is no data on GPU or CPU.");const l=this.decode(t,a.customTexShape),p=(0,e.engine)().makeTensorFromTensorInfo(l),d=this.texData.get(l.dataId);return Object.assign({tensorRef:p},d.texture)}bufferSync(t){const a=this.readSync(t.dataId);if("string"===t.dtype)try{const n=a.map(t=>e.util.decodeString(t));return(0,e.buffer)(t.shape,t.dtype,n)}catch(r){throw new Error("Failed to decode encoded string bytes into utf-8")}return(0,e.buffer)(t.shape,t.dtype,a)}checkNumericalProblems(t){if(null!=t)for(let a=0;a<t.length;a++){const r=t[a];if(!E.canBeRepresented(r)){if((0,e.env)().getBool("WEBGL_RENDER_FLOAT32_CAPABLE"))throw Error(`The value ${r} cannot be represented with your `+"current settings. Consider enabling float32 rendering: 'tf.env().set('WEBGL_RENDER_FLOAT32_ENABLED', true);'");throw Error(`The value ${r} cannot be represented on this device.`)}}}getValuesFromTexture(t){const{shape:a,dtype:r,isPacked:i}=this.texData.get(t),o=e.util.sizeFromShape(a);if((0,e.env)().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")){const e=this.decode(t),r=this.texData.get(e.dataId),n=this.gpgpu.downloadMatrixFromPackedTexture(r.texture.texture,...m.getDenseTexShape(a)).subarray(0,o);return this.disposeIntermediateTensorInfo(e),n}const u=(0,e.env)().getBool("WEBGL_PACK")&&!0===i,h=u?E.getShapeAs3D(a):a,l=u?new s.EncodeFloatPackedProgram(h):new n.EncodeFloatProgram(h),p=this.runWebGLProgram(l,[{shape:h,dtype:r,dataId:t}],"float32"),d=this.texData.get(p.dataId),c=this.gpgpu.downloadByteEncodedFloatMatrixFromOutputTexture(d.texture.texture,d.texShape[0],d.texShape[1]).subarray(0,o);return this.disposeIntermediateTensorInfo(p),c}timerAvailable(){return(0,e.env)().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0}time(t){const a=this.activeTimers,r=[];let n=!1;null==this.programTimersStack?(this.programTimersStack=r,n=!0):this.activeTimers.push(r),this.activeTimers=r,t();const s=e.util.flatten(this.activeTimers.map(e=>e.query)).filter(e=>null!=e),i=e.util.flatten(this.activeTimers.map(e=>e.name)).filter(e=>null!=e);this.activeTimers=a,n&&(this.programTimersStack=null);const o={uploadWaitMs:this.uploadWaitMs,downloadWaitMs:this.downloadWaitMs,kernelMs:null,wallMs:null};return(async()=>{if((0,e.env)().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0){const t=await Promise.all(s);o.kernelMs=e.util.sum(t),o.getExtraProfileInfo=(()=>t.map((e,t)=>({name:i[t],ms:e})).map(e=>`${e.name}: ${e.ms}`).join(", "))}else o.kernelMs={error:"WebGL query timers are not supported in this environment."};return this.uploadWaitMs=0,this.downloadWaitMs=0,o})()}memory(){return{unreliable:!1,numBytesInGPU:this.numBytesInGPU,numBytesInGPUAllocated:this.textureManager.numBytesAllocated,numBytesInGPUFree:this.textureManager.numBytesFree}}startTimer(){return(0,e.env)().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?this.gpgpu.beginQuery():{startMs:e.util.now(),endMs:null}}endTimer(t){return(0,e.env)().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?(this.gpgpu.endQuery(),t):(t.endMs=e.util.now(),t)}async getQueryTime(t){if((0,e.env)().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0)return this.gpgpu.waitForQueryAndGetTime(t);const a=t;return a.endMs-a.startMs}disposeData(e,t=!1){if(this.pendingDisposal.has(e))return!1;if(!this.texData.has(e))return!0;if(t?this.texData.get(e).refCount=0:this.texData.get(e).refCount--,!t&&this.texData.get(e).refCount>0)return!1;if(this.pendingRead.has(e))return this.pendingDisposal.add(e),this.pendingDeletes++,!1;this.releaseGPUData(e);const{complexTensorInfos:a}=this.texData.get(e);return null!=a&&(this.disposeData(a.real.dataId,t),this.disposeData(a.imag.dataId,t)),this.texData.delete(e),!0}releaseGPUData(e){const{texture:t,dtype:a,texShape:r,usage:n,isPacked:s,slice:i}=this.texData.get(e),o=i&&i.origDataId||e,u=this.dataRefCount.get(o);u>1?this.dataRefCount.set(o,u-1):(this.dataRefCount.delete(o),null!=t&&(this.numBytesInGPU-=this.computeBytes(r,a),this.textureManager.releaseTexture(t,r,n,s)));const h=this.texData.get(e);h.texture=null,h.texShape=null,h.isPacked=!1,h.slice=null}getTexture(e){return this.uploadToGPU(e),this.texData.get(e).texture.texture}getDataInfo(e){return this.texData.get(e)}shouldExecuteOnCPU(t,a=k){return(0,e.env)().getBool("WEBGL_CPU_FORWARD")&&t.every(t=>null==this.texData.get(t.dataId).texture&&e.util.sizeFromShape(t.shape)<a)}getGPGPUContext(){return this.gpgpu}where(t){e.backend_util.warn("tf.where() in webgl locks the UI thread. Call tf.whereAsync() instead");const a=t.dataSync();return L(t.shape,a)}packedUnaryOp(t,a,r){const n=new I.UnaryOpPackedProgram(t.shape,a),s=this.compileAndRun(n,[t],r);return(0,e.engine)().makeTensorFromTensorInfo(s)}abs(t){if(this.shouldExecuteOnCPU([t])&&"complex64"!==t.dtype){const e=(0,p.simpleAbsImplCPU)(this.texData.get(t.dataId).values);return this.makeOutput(t.shape,t.dtype,e)}if((0,e.env)().getBool("WEBGL_PACK_UNARY_OPERATIONS"))return this.packedUnaryOp(t,P.ABS,t.dtype);const a=new x.UnaryOpProgram(t.shape,P.ABS),r=this.compileAndRun(a,[t]);return(0,e.engine)().makeTensorFromTensorInfo(r)}makeTensorInfo(t,a,r){let n;if("string"===a&&null!=r&&r.length>0&&e.util.isString(r[0])){const s=r.map(t=>e.util.encodeString(t));n=this.write(s,t,a)}else n=this.write(r,t,a);return this.texData.get(n).usage=null,{dataId:n,shape:t,dtype:a}}makeOutput(t,a,r){return(0,e.engine)().makeTensorFromTensorInfo(this.makeTensorInfo(t,a,r),this)}unpackTensor(e){const t=new y.UnpackProgram(e.shape);return this.runWebGLProgram(t,[e],e.dtype)}packTensor(e){const t=new d.PackProgram(e.shape);return this.runWebGLProgram(t,[e],e.dtype,null,!0)}packedReshape(e,t){const a=[E.getBatchDim(e.shape),...E.getRowsCols(e.shape)],r={dtype:e.dtype,shape:a,dataId:e.dataId},n=[E.getBatchDim(t),...E.getRowsCols(t)],s=new c.ReshapePackedProgram(n,a),i=[a],o=this.runWebGLProgram(s,[r],e.dtype,i,!0);return{dataId:o.dataId,shape:t,dtype:o.dtype}}decode(t,n){const s=this.texData.get(t),{isPacked:i,shape:o,dtype:u}=s;if(null!=n){const t=e.util.sizeFromShape(o),a=n[0]*n[1]*4;e.util.assert(t<=a,()=>"customTexShape is too small. Row * Column * 4 should be equal or larger than the size of the tensor data.")}const h=E.getShapeAs3D(o);let l;l=i?new r.DecodeMatrixPackedProgram(h):new a.DecodeMatrixProgram(h);const p=[null!=n?n:m.getDenseTexShape(h)];return{dtype:u,shape:o,dataId:this.runWebGLProgram(l,[{shape:h,dtype:u,dataId:t}],u,p,!0,n).dataId}}runWebGLProgram(t,a,r,n,s=!1,i){const o=this.makeTensorInfo(t.outputShape,r),u=this.texData.get(o.dataId);if(t.packedOutput&&(u.isPacked=!0),t.outPackingScheme===m.PackingScheme.DENSE){const e=null!=i?i:m.getDenseTexShape(t.outputShape);u.texShape=e.map(e=>2*e)}if(null!=t.outTexUsage&&(u.usage=t.outTexUsage),0===e.util.sizeFromShape(o.shape))return u.values=e.util.getTypedArrayFromDType(o.dtype,0),o;const h=[],p=a.map(a=>{if("complex64"===a.dtype)throw new Error("GPGPUProgram does not support complex64 input. For complex64 dtypes, please separate the program into real and imaginary parts.");let r=this.texData.get(a.dataId);if(null==r.texture){if(!t.packedInputs&&e.util.sizeFromShape(a.shape)<=(0,e.env)().getNumber("WEBGL_SIZE_UPLOAD_UNIFORM"))return{shape:a.shape,texData:null,isUniform:!0,uniformValues:r.values};t.packedInputs&&(r.isPacked=!0,r.shape=a.shape)}if(this.uploadToGPU(a.dataId),!!r.isPacked!=!!t.packedInputs)a=r.isPacked?this.unpackTensor(a):this.packTensor(a),h.push(a),r=this.texData.get(a.dataId);else if(r.isPacked&&!E.isReshapeFree(r.shape,a.shape)){const e=a,t=a.shape;a.shape=r.shape,a=this.packedReshape(a,t),h.push(a),r=this.texData.get(a.dataId),e.shape=t}return{shape:a.shape,texData:r,isUniform:!1}});this.uploadToGPU(o.dataId);const d={shape:o.shape,texData:u,isUniform:!1},c=l.makeShaderKey(t,p,d),g=this.getAndSaveBinary(c,()=>l.compileProgram(this.gpgpu,t,p,d)),f=null!=this.activeTimers;let x;f&&(x=this.startTimer()),(0,e.env)().get("ENGINE_COMPILE_ONLY")||l.runProgram(this.gpgpu,g,p,d,n),h.forEach(e=>this.disposeIntermediateTensorInfo(e)),f&&(x=this.endTimer(x),this.activeTimers.push({name:t.constructor.name,query:this.getQueryTime(x)}));const P=(0,e.env)().getNumber("WEBGL_FLUSH_THRESHOLD");if(P>0){const t=e.util.now();t-this.lastGlFlushTime>P&&(this.gpgpu.gl.flush(),this.lastGlFlushTime=t)}if(!(0,e.env)().getBool("WEBGL_LAZILY_UNPACK")&&u.isPacked&&!1===s){const e=this.unpackTensor(o);return this.disposeIntermediateTensorInfo(o),e}return o}compileAndRun(e,t,a,r,n=!1){return a=a||t[0].dtype,this.runWebGLProgram(e,t,a,r,n)}getAndSaveBinary(e,t){return e in this.binaryCache||(this.binaryCache[e]=t()),this.binaryCache[e]}getTextureManager(){return this.textureManager}dispose(){if(!this.disposed){if(!(0,e.env)().getBool("IS_TEST")){Object.keys(this.binaryCache).forEach(e=>{this.gpgpu.deleteProgram(this.binaryCache[e].webGLProgram),delete this.binaryCache[e]})}this.textureManager.dispose(),null!=this.canvas&&"undefined"!=typeof HTMLCanvasElement&&this.canvas instanceof HTMLCanvasElement?this.canvas.remove():this.canvas=null,this.gpgpuCreatedLocally&&(this.gpgpu.program=null,this.gpgpu.dispose()),this.disposed=!0}}floatPrecision(){return null==this.floatPrecisionValue&&(this.floatPrecisionValue=(0,e.tidy)(()=>{if(!(0,e.env)().get("WEBGL_RENDER_FLOAT32_ENABLED")){const t=(0,e.env)().getBool("DEBUG");(0,e.env)().set("DEBUG",!1);const a=this.abs((0,e.scalar)(1e-8)).dataSync()[0];if((0,e.env)().set("DEBUG",t),a>0)return 32}return 16})),this.floatPrecisionValue}epsilon(){return 32===this.floatPrecision()?_:D}uploadToGPU(t){const a=this.texData.get(t),{shape:r,dtype:n,values:s,texture:u,usage:h,isPacked:l}=a;if(null!=u)return;const p=null!=this.activeTimers;let d;p&&(d=e.util.now());let c=a.texShape;if(null==c&&(c=E.getTextureShapeFromLogicalShape(r,l),a.texShape=c),null!=s){const t=E.getShapeAs3D(r);let u,h=c[1],f=c[0];const x=s instanceof Uint8Array||s instanceof Uint8ClampedArray;!l&&x||([h,f]=m.getPackedMatrixTextureShapeWidthHeight(c[0],c[1])),u=l?new o.EncodeMatrixPackedProgram(t,x):new i.EncodeMatrixProgram(t,x);const P=x?[f,h]:c,I=this.makeTensorInfo(P,n),y=this.texData.get(I.dataId);y.usage=x?g.TextureUsage.PIXELS:g.TextureUsage.UPLOAD,y.texShape=P,this.gpgpu.uploadDenseMatrixToTexture(this.getTexture(I.dataId),h,f,s);const T=[[f,h]],L=!0,_=this.runWebGLProgram(u,[I],n,T,L),D=this.texData.get(_.dataId);a.texShape=D.texShape,a.isPacked=D.isPacked,a.usage=D.usage,(0,e.env)().get("ENGINE_COMPILE_ONLY")?this.disposeData(_.dataId):(a.texture=D.texture,a.values=null,this.texData.delete(_.dataId)),this.disposeIntermediateTensorInfo(I),p&&(this.uploadWaitMs+=e.util.now()-d)}else{const e=this.acquireTexture(c,h,n,l);a.texture=e}}convertAndCacheOnCPU(e,t){const a=this.texData.get(e),{dtype:r}=a;return null!=t&&(a.values=B(t,r)),a.values}acquireTexture(e,t,a,r){if(this.numBytesInGPU+=this.computeBytes(e,a),!this.warnedAboutMemory&&this.numBytesInGPU>1024*this.numMBBeforeWarning*1024){const e=(this.numBytesInGPU/1024/1024).toFixed(2);this.warnedAboutMemory=!0,console.warn(`High memory usage in GPU: ${e} MB, `+"most likely due to a memory leak")}return this.textureManager.acquireTexture(e,t,r)}computeBytes(t,a){return t[0]*t[1]*e.util.bytesPerElement(a)}checkCompileCompletion(){for(const[,e]of Object.entries(this.binaryCache))this.checkCompletion_(e)}async checkCompileCompletionAsync(){const e=[];if(this.gpgpu.parallelCompilationExtension){for(const[,t]of Object.entries(this.binaryCache))e.push(this.checkCompletionAsync_(t));return Promise.all(e)}for(const[,t]of Object.entries(this.binaryCache)){const a=new Promise(e=>{try{this.checkCompletion_(t),e(!0)}catch(a){throw a}});e.push(a)}return Promise.all(e)}async checkCompletionAsync_(t){return this.gpgpu.gl.getProgramParameter(t.webGLProgram,this.gpgpu.parallelCompilationExtension.COMPLETION_STATUS_KHR)?this.checkCompletion_(t):(await(0,e.nextFrame)(),this.checkCompletionAsync_(t))}checkCompletion_(e){if(!1===this.gpgpu.gl.getProgramParameter(e.webGLProgram,this.gpgpu.gl.LINK_STATUS)){if(console.log(this.gpgpu.gl.getProgramInfoLog(e.webGLProgram)),!1===this.gpgpu.gl.getShaderParameter(e.fragmentShader,this.gpgpu.gl.COMPILE_STATUS))throw E.logShaderSourceAndInfoLog(e.source,this.gpgpu.gl.getShaderInfoLog(e.fragmentShader)),new Error("Failed to compile fragment shader.");throw new Error("Failed to link vertex and fragment shaders.")}return!0}getUniformLocations(){for(const e of Object.values(this.binaryCache)){this.gpgpu.buildVao(e.webGLProgram);const{variablesLocations:t,customUniformLocations:a,infLoc:r,nanLoc:n,outShapeLocation:s,outShapeStridesLocation:i,outTexShapeLocation:o}=(0,h.getUniformLocations)(this.gpgpu,e.program,e.webGLProgram);e.variablesLocations=t,e.customUniformLocations=a,e.infLoc=r,e.nanLoc=n,e.outShapeLocation=s,e.outShapeStridesLocation=i,e.outTexShapeLocation=o}}createTensorFromGPUData(t,a,r){t.channels=t.channels||"RGBA";const{texture:n,height:s,width:i,channels:o}=t,u=(0,e.engine)().backend;if(!u.gpgpu.gl.isTexture(n))throw new Error("The texture is invalid. Also, please make sure the texture and the TFJS WebGL backend are using the same canvas. If you want to use your own custom canvas, you have to create and use the custom TFJS WebGL backend created from the canvas through 'new tf.MathBackendWebGL(customCanvas)'.");const h=u.writeTexture(n,a,r,s,i,o);return(0,e.engine)().makeTensorFromDataId(h,a,r,u)}}function B(e,t){if("float32"===t||"complex64"===t)return e;if("int32"===t||"bool"===t){const a="int32"===t?new Int32Array(e.length):new Uint8Array(e.length);for(let t=0;t<a.length;++t)a[t]=Math.round(e[t]);return a}throw new Error(`Unknown dtype ${t}`)}exports.MathBackendWebGL=G,G.nextDataId=0;
},{"./flags_webgl":"K5Ex","@tensorflow/tfjs-core":"kSBl","./canvas_util":"xuCv","./decode_matrix_gpu":"JMCa","./decode_matrix_packed_gpu":"RChy","./encode_float_gpu":"oHaq","./encode_float_packed_gpu":"r0NW","./encode_matrix_gpu":"o0jj","./encode_matrix_packed_gpu":"UZCK","./gpgpu_context":"GZkx","./gpgpu_math":"eeKH","./kernel_utils/shared":"cNPH","./pack_gpu":"tySX","./reshape_packed_gpu":"qDuX","./tex_util":"jAWT","./texture_manager":"yk4C","./unaryop_gpu":"CK3x","./unaryop_packed_gpu":"zBLd","./unpack_gpu":"boI6","./webgl_util":"u1ML"}],"RDer":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),Object.defineProperty(exports,"GPGPUContext",{enumerable:!0,get:function(){return u.GPGPUContext}}),Object.defineProperty(exports,"MathBackendWebGL",{enumerable:!0,get:function(){return n.MathBackendWebGL}}),exports.forceHalfFloat=p,exports.gpgpu_util=void 0,Object.defineProperty(exports,"setWebGLContext",{enumerable:!0,get:function(){return o.setWebGLContext}}),exports.webgl_util=void 0;var e=require("@tensorflow/tfjs-core"),t=i(require("./gpgpu_util"));exports.gpgpu_util=t;var r=i(require("./webgl_util"));exports.webgl_util=r;var n=require("./backend_webgl"),o=require("./canvas_util"),u=require("./gpgpu_context");function i(e,t){if("function"==typeof WeakMap)var r=new WeakMap,n=new WeakMap;return(i=function(e,t){if(!t&&e&&e.__esModule)return e;var o,u,i={__proto__:null,default:e};if(null===e||"object"!=typeof e&&"function"!=typeof e)return i;if(o=t?n:r){if(o.has(e))return o.get(e);o.set(e,i)}for(const r in e)"default"!==r&&{}.hasOwnProperty.call(e,r)&&((u=(o=Object.defineProperty)&&Object.getOwnPropertyDescriptor(e,r))&&(u.get||u.set)?o(i,r,u):i[r]=e[r]);return i})(e,t)}function p(){(0,e.env)().set("WEBGL_FORCE_F16_TEXTURES",!0)}
},{"@tensorflow/tfjs-core":"kSBl","./gpgpu_util":"jgbg","./webgl_util":"u1ML","./backend_webgl":"DXeN","./canvas_util":"xuCv","./gpgpu_context":"GZkx"}],"We8e":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0});var e={webgl:!0,version_webgl:!0};Object.defineProperty(exports,"version_webgl",{enumerable:!0,get:function(){return o.version}}),exports.webgl=void 0;var r=require("@tensorflow/tfjs-core"),t=require("./backend_webgl"),o=require("./version"),n=require("./webgl");Object.keys(n).forEach(function(r){"default"!==r&&"__esModule"!==r&&(Object.prototype.hasOwnProperty.call(e,r)||r in exports&&exports[r]===n[r]||Object.defineProperty(exports,r,{enumerable:!0,get:function(){return n[r]}}))}),r.device_util.isBrowser()&&(0,r.registerBackend)("webgl",()=>new t.MathBackendWebGL,2);const s=exports.webgl={forceHalfFloat:n.forceHalfFloat};
},{"@tensorflow/tfjs-core":"kSBl","./backend_webgl":"DXeN","./version":"KPnh","./webgl":"RDer"}],"wbV2":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.SQUARED_DIFFERENCE=exports.CHECK_NAN_SNIPPET=exports.BinaryOpProgram=void 0;var t=require("@tensorflow/tfjs-core"),e=require("./gpgpu_math");const r=exports.CHECK_NAN_SNIPPET="\n  if (isnan(a)) return a;\n  if (isnan(b)) return b;\n",a=exports.SQUARED_DIFFERENCE="return (a - b) * (a - b);";class n{constructor(r,a,n){this.variableNames=["A","B"],this.outputShape=t.backend_util.assertAndGetBroadcastShape(a,n),this.enableShapeUniforms=(0,e.useShapeUniforms)(this.outputShape.length),this.userCode=`\n      float binaryOperation(float a, float b) {\n        ${r}\n      }\n\n      void main() {\n        float a = getAAtOutCoords();\n        float b = getBAtOutCoords();\n        setOutput(binaryOperation(a, b));\n      }\n    `}}exports.BinaryOpProgram=n;
},{"@tensorflow/tfjs-core":"kSBl","./gpgpu_math":"eeKH"}],"mFR1":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.NOT_EQUAL=exports.ELU_DER=exports.CHECK_NAN_SNIPPET_PACKED=exports.BinaryOpPackedProgram=void 0;var e=require("@tensorflow/tfjs-core"),t=require("./gpgpu_math"),s=require("./packing_util"),n=require("./shader_compiler");const r=exports.CHECK_NAN_SNIPPET_PACKED="\n  result.r = isNaN.r ? NAN : result.r;\n  result.g = isNaN.g ? NAN : result.g;\n  result.b = isNaN.b ? NAN : result.b;\n  result.a = isNaN.a ? NAN : result.a;\n",u=exports.ELU_DER="\n  vec4 bGTEZero = vec4(greaterThanEqual(b, vec4(0.)));\n  return (bGTEZero * a) + ((vec4(1.0) - bGTEZero) * (a * (b + vec4(1.0))));\n",o=exports.NOT_EQUAL="\n  return vec4(notEqual(a, b));\n";class a{constructor(r,u,o,a=!1){this.variableNames=["A","B"],this.supportsBroadcasting=!0,this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e.backend_util.assertAndGetBroadcastShape(u,o);const l=this.outputShape.length;this.enableShapeUniforms=(0,t.useShapeUniforms)(l);let i="";if(a)if(0===l||1===e.util.sizeFromShape(this.outputShape))i="\n          result.y = 0.;\n          result.z = 0.;\n          result.w = 0.;\n        ";else{if(i=`\n          ${(0,n.getCoordsDataType)(l)} coords = getOutputCoords();\n        `,1===l)this.enableShapeUniforms?i+="\n            result.y = (coords + 1) >= outShape ? 0. : result.y;\n            result.z = 0.;\n            result.w = 0.;\n          ":i+=`\n            result.y = (coords + 1) >= ${this.outputShape[0]} ? 0. : result.y;\n            result.z = 0.;\n            result.w = 0.;\n          `;else{const e=(0,s.getChannels)("coords",l);this.enableShapeUniforms?i+=`\n            bool nextRowOutOfBounds =\n              (${e[l-2]} + 1) >= outShape[${l} - 2];\n            bool nextColOutOfBounds =\n              (${e[l-1]} + 1) >= outShape[${l} - 1];\n            result.y = nextColOutOfBounds ? 0. : result.y;\n            result.z = nextRowOutOfBounds ? 0. : result.z;\n            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;\n          `:i+=`\n            bool nextRowOutOfBounds =\n              (${e[l-2]} + 1) >= ${this.outputShape[l-2]};\n            bool nextColOutOfBounds =\n              (${e[l-1]} + 1) >= ${this.outputShape[l-1]};\n            result.y = nextColOutOfBounds ? 0. : result.y;\n            result.z = nextRowOutOfBounds ? 0. : result.z;\n            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;\n          `}}this.userCode=`\n      vec4 binaryOperation(vec4 a, vec4 b) {\n        ${r}\n      }\n\n      void main() {\n        vec4 a = getAAtOutCoords();\n        vec4 b = getBAtOutCoords();\n\n        vec4 result = binaryOperation(a, b);\n        ${i}\n\n        setOutput(result);\n      }\n    `}}exports.BinaryOpPackedProgram=a;
},{"@tensorflow/tfjs-core":"kSBl","./gpgpu_math":"eeKH","./packing_util":"BqvU","./shader_compiler":"xhhc"}],"LUQG":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.identity=t,exports.identityConfig=void 0;var e=require("@tensorflow/tfjs-core");function t(e){const{inputs:t,backend:n}=e,{x:d}=t;return n.incRef(d.dataId),{dataId:d.dataId,shape:d.shape,dtype:d.dtype}}const n=exports.identityConfig={kernelName:e.Identity,backendName:"webgl",kernelFunc:t};
},{"@tensorflow/tfjs-core":"kSBl"}],"BU0Z":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.complex=n,exports.complexConfig=void 0;var e=require("@tensorflow/tfjs-core"),t=require("./Identity");function n(e){const{inputs:n,backend:o}=e,{real:r,imag:a}=n,i=o.makeTensorInfo(r.shape,"complex64"),s=o.texData.get(i.dataId),c=(0,t.identity)({inputs:{x:r},backend:o}),p=(0,t.identity)({inputs:{x:a},backend:o});return s.complexTensorInfos={real:c,imag:p},i}const o=exports.complexConfig={kernelName:e.Complex,backendName:"webgl",kernelFunc:n};
},{"@tensorflow/tfjs-core":"kSBl","./Identity":"LUQG"}],"kZ3p":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.LEAKYRELU_PACKED=exports.LEAKYRELU=void 0,exports.leakyRelu=s,exports.leakyReluConfig=void 0;var e=require("@tensorflow/tfjs-core"),a=require("../binaryop_gpu"),r=require("../binaryop_packed_gpu");const o=exports.LEAKYRELU="return (a < 0.) ? b * a : a;",n=exports.LEAKYRELU_PACKED="\n  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));\n  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);\n";function s(s){const{inputs:t,backend:p,attrs:l}=s,{x:u}=t,{alpha:c}=l,i=p.makeTensorInfo([],"float32",e.util.createScalarValue(c,"float32")),L=(0,e.env)().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new r.BinaryOpPackedProgram(n,u.shape,i.shape):new a.BinaryOpProgram(o,u.shape,i.shape),E=p.runWebGLProgram(L,[u,i],"float32");return p.disposeIntermediateTensorInfo(i),E}const t=exports.leakyReluConfig={kernelName:e.LeakyRelu,backendName:"webgl",kernelFunc:s};
},{"@tensorflow/tfjs-core":"kSBl","../binaryop_gpu":"wbV2","../binaryop_packed_gpu":"mFR1"}],"wxXh":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.PRELU_PACKED=exports.PRELU=void 0,exports.prelu=s,exports.preluConfig=void 0;var e=require("@tensorflow/tfjs-core"),r=require("../binaryop_gpu"),a=require("../binaryop_packed_gpu");const n=exports.PRELU="return (a < 0.) ? b * a : a;",o=exports.PRELU_PACKED="\n  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));\n  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);\n";function s(s){const{inputs:p,backend:t}=s,{x:u,alpha:c}=p,i=(0,e.env)().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new a.BinaryOpPackedProgram(o,u.shape,c.shape):new r.BinaryOpProgram(n,u.shape,c.shape);return t.runWebGLProgram(i,[u,c],"float32")}const p=exports.preluConfig={kernelName:e.Prelu,backendName:"webgl",kernelFunc:s};
},{"@tensorflow/tfjs-core":"kSBl","../binaryop_gpu":"wbV2","../binaryop_packed_gpu":"mFR1"}],"ciwP":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.CHECK_NAN_SNIPPET_UNARY=void 0,exports.binaryKernelFunc=f,exports.mapActivationToShaderProgram=y,exports.unaryKernelFunc=c;var e=require("@tensorflow/tfjs-core"),r=require("../binaryop_gpu"),t=require("../binaryop_packed_gpu"),n=require("../kernels/Complex"),a=require("../kernels/LeakyRelu"),p=require("../kernels/Prelu"),o=d(require("../unaryop_gpu")),u=o,s=d(require("../unaryop_packed_gpu")),i=s;function d(e,r){if("function"==typeof WeakMap)var t=new WeakMap,n=new WeakMap;return(d=function(e,r){if(!r&&e&&e.__esModule)return e;var a,p,o={__proto__:null,default:e};if(null===e||"object"!=typeof e&&"function"!=typeof e)return o;if(a=r?n:t){if(a.has(e))return a.get(e);a.set(e,o)}for(const t in e)"default"!==t&&{}.hasOwnProperty.call(e,t)&&((p=(a=Object.defineProperty)&&Object.getOwnPropertyDescriptor(e,t))&&(p.get||p.set)?a(o,t,p):o[t]=e[t]);return o})(e,r)}const l=exports.CHECK_NAN_SNIPPET_UNARY="if (isnan(x)) return x;";function c({opSnippet:r,packedOpSnippet:t,cpuKernelImpl:n,dtype:a}){return({inputs:p,backend:u})=>{const{x:i}=p,d=u,l=a||i.dtype;if(d.shouldExecuteOnCPU([i])&&null!=n){const e=d.texData.get(i.dataId),r=n(e.values,l);return d.makeTensorInfo(i.shape,l,r)}let c;return c=(0,e.env)().getBool("WEBGL_PACK_UNARY_OPERATIONS")&&null!=t?new s.UnaryOpPackedProgram(i.shape,t):new o.UnaryOpProgram(i.shape,r),d.runWebGLProgram(c,[i],l)}}function f({opSnippet:a,packedOpSnippet:p,checkOutOfBounds:o=!1,supportsComplex:u=!1,cpuKernelImpl:s,dtype:i}){return({inputs:d,backend:l})=>{const{a:c,b:f}=d,y=l;if(u&&"complex64"===c.dtype){const t=y.texData.get(c.dataId),p=y.texData.get(f.dataId),[o,u]=[[t.complexTensorInfos.real,p.complexTensorInfos.real],[t.complexTensorInfos.imag,p.complexTensorInfos.imag]].map(t=>{const[n,p]=t,o={dataId:n.dataId,dtype:n.dtype,shape:c.shape},u={dataId:p.dataId,dtype:p.dtype,shape:f.shape},s=new r.BinaryOpProgram(a,c.shape,f.shape);return y.runWebGLProgram(s,[o,u],(0,e.upcastType)(n.dtype,p.dtype))}),s=(0,n.complex)({inputs:{real:o,imag:u},backend:y});return y.disposeIntermediateTensorInfo(o),y.disposeIntermediateTensorInfo(u),s}const g=i||(0,e.upcastType)(c.dtype,f.dtype);if(("string"===c.dtype||"string"===f.dtype||y.shouldExecuteOnCPU([c,f]))&&null!=s){const r=y.texData.get(c.dataId).values,t=y.texData.get(f.dataId).values,n="string"===c.dtype?e.backend_util.fromUint8ToStringArray(r):r,a="string"===c.dtype?e.backend_util.fromUint8ToStringArray(t):t,[p,o]=s(c.shape,f.shape,n,a,g),u=y.makeTensorInfo(o,g);return y.texData.get(u.dataId).values=p,u}let m;return m=(0,e.env)().getBool("WEBGL_PACK_BINARY_OPERATIONS")&&null!=p?new t.BinaryOpPackedProgram(p,c.shape,f.shape,o):new r.BinaryOpProgram(a,c.shape,f.shape),y.runWebGLProgram(m,[c,f],g)}}function y(e,r=!1){if("linear"===e)return r?i.LINEAR:u.LINEAR;if("relu"===e)return r?i.RELU:u.RELU;if("elu"===e)return r?i.ELU:u.ELU;if("relu6"===e)return r?i.RELU6:u.RELU6;if("prelu"===e)return r?p.PRELU_PACKED:p.PRELU;if("leakyrelu"===e)return r?a.LEAKYRELU_PACKED:a.LEAKYRELU;if("sigmoid"===e)return r?i.SIGMOID:u.SIGMOID;throw new Error(`Activation ${e} has not been implemented for the WebGL backend.`)}
},{"@tensorflow/tfjs-core":"kSBl","../binaryop_gpu":"wbV2","../binaryop_packed_gpu":"mFR1","../kernels/Complex":"BU0Z","../kernels/LeakyRelu":"kZ3p","../kernels/Prelu":"wxXh","../unaryop_gpu":"CK3x","../unaryop_packed_gpu":"zBLd"}],"QKYo":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.MatMulPackedProgram=void 0;var e=require("./gpgpu_math");class t{constructor(t,a,n,r=!1,s=!1,i=!1,o=null,c=!1,u=!1){this.variableNames=["matrixA","matrixB"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=n,this.enableShapeUniforms=(0,e.useShapeUniforms)(this.outputShape.length);const l=r?t[1]:t[2],h=Math.ceil(l/2),v=r?"i * 2, rc.y":"rc.y, i * 2",p=s?"rc.z, i * 2":"i * 2, rc.z",d=r?["a.xxyy","a.zzww"]:["a.xxzz","a.yyww"],x=s?["b.xzxz","b.ywyw"]:["b.xyxy","b.zwzw"];let b="",m="";o&&(b=c?`vec4 activation(vec4 a) {\n          vec4 b = getPreluActivationWeightsAtOutCoords();\n          ${o}\n        }`:u?`vec4 activation(vec4 a) {\n          vec4 b = getLeakyreluAlphaAtOutCoords();\n          ${o}\n        }`:`vec4 activation(vec4 x) {\n          ${o}\n        }`,m="result = activation(result);");const $=i?"result += getBiasAtOutCoords();":"";i&&this.variableNames.push("bias"),c&&this.variableNames.push("preluActivationWeights"),u&&this.variableNames.push("leakyreluAlpha");let g="rc.x",y="rc.x";t[0]<a[0]?g=`imod(rc.x, ${t[0]})`:a[0]<t[0]&&(y=`imod(rc.x, ${a[0]})`),this.userCode=`\n      ${b}\n      // Don't use uniform for sharedDimensionPacked for performance.\n      const float sharedDimension = ${h}.0;\n\n      vec4 dot2x2ARowBCol(ivec3 rc) {\n        vec4 result = vec4(0);\n        int batchA = ${g};\n        int batchB = ${y};\n        for (int i = 0; i < ${h}; i++) {\n          vec4 a = getMatrixA(batchA, ${v});\n          vec4 b = getMatrixB(batchB, ${p});\n\n          // These swizzled products need to be separately added.\n          // See: https://github.com/tensorflow/tfjs/issues/1735\n          result += (${d[0]} * ${x[0]});\n          result += (${d[1]} * ${x[1]});\n        }\n        return result;\n      }\n\n      void main() {\n        ivec3 rc = getOutputCoords();\n        vec4 result = dot2x2ARowBCol(rc);\n\n        ${$}\n\n        ${m}\n\n        setOutput(result);\n      }\n    `}}exports.MatMulPackedProgram=t;
},{"./gpgpu_math":"eeKH"}],"obKl":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.COMPLEX_MULTIPLY=exports.BinaryOpComplexProgram=void 0;var a=require("@tensorflow/tfjs-core");const e=exports.COMPLEX_MULTIPLY={REAL:"return areal * breal - aimag * bimag;",IMAG:"return areal * bimag + aimag * breal;"};class t{constructor(e,t,r){this.variableNames=["AReal","AImag","BReal","BImag"],this.outputShape=a.backend_util.assertAndGetBroadcastShape(t,r),this.userCode=`\n      float binaryOpComplex(\n          float areal, float aimag, float breal, float bimag) {\n        ${e}\n      }\n\n      void main() {\n        float areal = getARealAtOutCoords();\n        float aimag = getAImagAtOutCoords();\n        float breal = getBRealAtOutCoords();\n        float bimag = getBImagAtOutCoords();\n        setOutput(binaryOpComplex(areal, aimag, breal, bimag));\n      }\n    `}}exports.BinaryOpComplexProgram=t;
},{"@tensorflow/tfjs-core":"kSBl"}],"xWNx":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.multiply=l,exports.multiplyConfig=void 0;var e=require("@tensorflow/tfjs-core"),a=s(require("../binaryop_complex_gpu")),t=a,r=require("../binaryop_gpu"),o=require("../binaryop_packed_gpu"),n=require("../kernel_utils/shared"),p=require("./Complex");function s(e,a){if("function"==typeof WeakMap)var t=new WeakMap,r=new WeakMap;return(s=function(e,a){if(!a&&e&&e.__esModule)return e;var o,n,p={__proto__:null,default:e};if(null===e||"object"!=typeof e&&"function"!=typeof e)return p;if(o=a?r:t){if(o.has(e))return o.get(e);o.set(e,p)}for(const t in e)"default"!==t&&{}.hasOwnProperty.call(e,t)&&((n=(o=Object.defineProperty)&&Object.getOwnPropertyDescriptor(e,t))&&(n.get||n.set)?o(p,t,n):p[t]=e[t]);return p})(e,a)}const d="return a * b;";function l(s){const{inputs:l,backend:i}=s,{a:u,b:c}=l,f=e.backend_util.upcastType(u.dtype,c.dtype);if("complex64"===u.dtype){const e=i.texData.get(u.dataId),r=i.texData.get(c.dataId),o=new a.BinaryOpComplexProgram(t.COMPLEX_MULTIPLY.REAL,u.shape,c.shape),n=new a.BinaryOpComplexProgram(t.COMPLEX_MULTIPLY.IMAG,u.shape,c.shape),s=[{dataId:e.complexTensorInfos.real.dataId,dtype:e.complexTensorInfos.real.dtype,shape:u.shape},{dataId:e.complexTensorInfos.imag.dataId,dtype:e.complexTensorInfos.imag.dtype,shape:u.shape},{dataId:r.complexTensorInfos.real.dataId,dtype:r.complexTensorInfos.real.dtype,shape:c.shape},{dataId:r.complexTensorInfos.imag.dataId,dtype:r.complexTensorInfos.imag.dtype,shape:c.shape}],d=i.runWebGLProgram(o,s,"float32"),l=i.runWebGLProgram(n,s,"float32"),f=(0,p.complex)({inputs:{real:d,imag:l},backend:i});return i.disposeIntermediateTensorInfo(d),i.disposeIntermediateTensorInfo(l),f}if(i.shouldExecuteOnCPU([u,c])){const e=i.texData.get(u.dataId),a=i.texData.get(c.dataId),[t,r]=(0,n.multiplyImplCPU)(u.shape,c.shape,e.values,a.values,f),o=i.makeTensorInfo(r,f);return i.texData.get(o.dataId).values=t,o}let m;return m=(0,e.env)().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new o.BinaryOpPackedProgram(d,u.shape,c.shape):new r.BinaryOpProgram(d,u.shape,c.shape),i.runWebGLProgram(m,[u,c],f)}const i=exports.multiplyConfig={kernelName:e.Multiply,backendName:"webgl",kernelFunc:l};
},{"@tensorflow/tfjs-core":"kSBl","../binaryop_complex_gpu":"obKl","../binaryop_gpu":"wbV2","../binaryop_packed_gpu":"mFR1","../kernel_utils/shared":"cNPH","./Complex":"BU0Z"}],"ZJ8p":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.packedReshape=a;var e=require("../reshape_packed_gpu"),t=require("../webgl_util");function a(a,d,p){const r=[(0,t.getBatchDim)(a.shape),...(0,t.getRowsCols)(a.shape)],s={dtype:a.dtype,shape:r,dataId:a.dataId},o=[(0,t.getBatchDim)(d),...(0,t.getRowsCols)(d)],u=new e.ReshapePackedProgram(o,r),c=[r],h=p.runWebGLProgram(u,[s],a.dtype,c,!0);return{dataId:h.dataId,shape:d,dtype:h.dtype}}
},{"../reshape_packed_gpu":"qDuX","../webgl_util":"u1ML"}],"OCN8":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.reshape=t,exports.reshapeConfig=void 0;var e=require("@tensorflow/tfjs-core"),a=require("../kernel_utils/reshape"),s=require("../webgl_util");function t(t){const{inputs:r,backend:p,attrs:h}=t,{x:n}=r,{shape:i}=h,l=p,o=e.util.sizeFromShape(n.shape),d=e.util.inferFromImplicitShape(i,o),u=e.util.sizeFromShape(d);e.util.assert(o===u,()=>`The new shape (${d}) has ${u} elements and the old `+`shape (${n.shape}) has ${o} elements. The new shape and old `+"shape must have the same number of elements.");const c=l.texData.get(n.dataId);return!c.isPacked||(0,s.isReshapeFree)(n.shape,d)||null!==c.texture&&(0,s.isReshapeFree)(c.shape,d)?(l.incRef(n.dataId),{dataId:n.dataId,shape:d,dtype:n.dtype}):(0,a.packedReshape)(n,d,l)}const r=exports.reshapeConfig={kernelName:e.Reshape,backendName:"webgl",kernelFunc:t};
},{"@tensorflow/tfjs-core":"kSBl","../kernel_utils/reshape":"ZJ8p","../webgl_util":"u1ML"}],"ZMTc":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.MeanProgram=void 0;var n=require("@tensorflow/tfjs-core");class e{constructor(e,t){this.variableNames=["x"];const{windowSize:i,batchSize:a,inSize:s,outSize:o}=e;this.outputShape=[a,o];const u=4*Math.floor(i/4),c=i%4;let l="sumValue += dot(values, ones);";if(null!=t){const e=1/t;l=`sumValue += dot(values * ${n.util.isInt(e)?e.toPrecision(2):e}, ones);`}let d="";s%i>0&&(d=`\n        if (inIdx < 0 || inIdx >= ${s}) {\n          return 0.0;\n        }\n      `),this.userCode=`\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float getValue(int batch, int inIdx) {\n        ${d}\n        return getX(batch, inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * ${i};\n\n        float sumValue = 0.0;\n\n        for (int i = 0; i < ${u}; i += 4) {\n          int inIdx = inOffset + i;\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          ${l}\n        }\n\n        int inIdx = inOffset + ${u};\n        if (${1===c}) {\n          vec4 values = vec4(getValue(batch, inIdx), 0.0, 0.0, 0.0);\n\n          ${l}\n        } else if (${2===c}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1), 0.0, 0.0);\n\n          ${l}\n        } else if (${3===c}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2), 0.0);\n\n          ${l}\n        }\n        setOutput(sumValue);\n      }\n    `}}exports.MeanProgram=e;
},{"@tensorflow/tfjs-core":"kSBl"}],"dCKU":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.ReduceProgram=void 0;class n{constructor(n,e){this.variableNames=["x"];const{windowSize:a,batchSize:l,inSize:i,outSize:t}=n;this.outputShape=[l,t];let u="0.0",o="";"prod"===e?u="1.0":"min"===e?(u="1.0 / 1e-20",o="min"):"max"===e&&(u="-1.0 / 1e-20",o="max");let d=`${e}(${e}(${e}(`+"minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])";"sum"===e?d="sumValue":"prod"===e?d="prodValue":"all"===e?d="allValue":"any"===e&&(d="anyValue");const s=4*Math.floor(a/4),V=a%4;let c=`\n      if (${"sum"===e}) {\n        sumValue += dot(values, ones);\n      } else if (${"prod"===e}) {\n        vec2 tmp = vec2(values[0], values[1]) * vec2(values[2], values[3]);\n        prodValue *= tmp[0] * tmp[1];\n      } else {\n        minMaxValue = ${o}(values, minMaxValue);\n        if (${"min"===e} || ${"max"===e}) {\n          minMaxValue = ${o}(values, minMaxValue);\n          bvec4 isNaN = isnan(values);\n          if (isNaN.r || isNaN.g || isNaN.b || isNaN.a) {\n            minMaxValue = vec4(NAN);\n          }\n        }\n      }\n    `,r="vec4";"all"===e?(u="1.0",c="\n        bool reducedAllValue = all(values);\n        float floatedReducedAllValue = float(reducedAllValue);\n        allValue = float(allValue >= 1.0 && floatedReducedAllValue >= 1.0);\n      ",r="bvec4"):"any"===e&&(u="0.0",c="\n        bool reducedAnyValue = any(values);\n        float floatedReducedAnyValue = float(reducedAnyValue);\n        anyValue = float(anyValue >= 1.0 || floatedReducedAnyValue >= 1.0);\n      ",r="bvec4");let x="";i%a>0&&(x=`\n        if (inIdx < 0 || inIdx >= ${i}) {\n          return initializationValue;\n        }\n      `),this.userCode=`\n      const float initializationValue = ${u};\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float getValue(int batch, int inIdx) {\n        ${x}\n        return getX(batch, inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * ${a};\n\n        vec4 minMaxValue = vec4(${u});\n        float prodValue = 1.0;\n        float sumValue = 0.0;\n        float allValue = 1.0;\n        float anyValue = 0.0;\n\n        for (int i = 0; i < ${s}; i += 4) {\n          int inIdx = inOffset + i;\n          ${r} values = ${r}(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          ${c}\n        }\n\n        int inIdx = inOffset + ${s};\n        if (${1===V}) {\n          ${r} values = ${r}(\n            getValue(batch, inIdx),\n            initializationValue,\n            initializationValue,\n            initializationValue\n          );\n\n          ${c}\n        } else if (${2===V}) {\n          ${r} values = ${r}(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            initializationValue,\n            initializationValue\n          );\n\n          ${c}\n        } else if (${3===V}) {\n          ${r} values = ${r}(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            initializationValue\n          );\n\n          ${c}\n        }\n        setOutput(${d});\n      }\n    `}}exports.ReduceProgram=n;
},{}],"tZI5":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.reduce=o;var e=require("@tensorflow/tfjs-core"),i=require("../mean_gpu"),t=require("../reduce_gpu");function n(i){const t=[];for(;0===t.length||1!==t[t.length-1].outSize;){const n=t.length?t[t.length-1].outSize:i[1],o=e.backend_util.computeOptimalWindowSize(n);t.push({inSize:n,windowSize:o,outSize:Math.ceil(n/o)})}return t}function o(e,o,r,u){const a=n(e.shape);let z=e;for(let n=0;n<a.length;n++){const{inSize:S,windowSize:s,outSize:c}=a[n];let d,w;d="mean"===r?0===n?new i.MeanProgram({windowSize:s,inSize:S,batchSize:e.shape[0],outSize:c},S):new i.MeanProgram({windowSize:s,inSize:S,batchSize:e.shape[0],outSize:c}):new t.ReduceProgram({windowSize:s,inSize:S,batchSize:e.shape[0],outSize:c},r),w=z,z=u.runWebGLProgram(d,[z],o),w.dataId!==e.dataId&&u.disposeIntermediateTensorInfo(w)}return z}
},{"@tensorflow/tfjs-core":"kSBl","../mean_gpu":"ZMTc","../reduce_gpu":"dCKU"}],"zMPc":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.TransposeProgram=void 0;var r=require("./shader_compiler");class e{constructor(e,s){this.variableNames=["A"];const o=new Array(e.length);for(let r=0;r<o.length;r++)o[r]=e[s[r]];this.outputShape=o,this.rank=o.length;const n=(0,r.getCoordsDataType)(this.rank),a=t(s);this.userCode=`\n    void main() {\n      ${n} resRC = getOutputCoords();\n      setOutput(getA(${a}));\n    }\n    `}}function t(r){const e=r.length;if(e>6)throw Error(`Transpose for rank ${e} is not yet supported`);const t=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u","resRC.v"],s=new Array(e);for(let o=0;o<r.length;o++)s[r[o]]=t[o];return s.join()}exports.TransposeProgram=e;
},{"./shader_compiler":"xhhc"}],"UyJE":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.TransposePackedProgram=void 0;var t=require("./packing_util"),e=require("./shader_compiler");class r{constructor(r,n){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0;const s=new Array(r.length);for(let t=0;t<s.length;t++)s[t]=r[n[t]];if(this.outputShape=s,this.rank=s.length,this.rank>6)throw Error(`Packed transpose for rank ${this.rank} is not yet supported.`);const a=(0,e.getCoordsDataType)(this.rank),i=(0,t.getVecChannels)("rc",this.rank),o=new Array(this.rank);for(let t=0;t<n.length;t++)o[n[t]]=i[t];const h=`vec2(${o.slice(-2).join()})`,u=`++${i[this.rank-1]} < ${s[this.rank-1]}`,c=`getChannel(getA(${o.join()}), ${h})`;this.userCode=`\n    void main() {\n      ${a} rc = getOutputCoords();\n      vec4 result = vec4(0.);\n      result[0] = ${c};\n      if(${u}) {\n        result[1] = ${c};\n      }\n      --${i[this.rank-1]};\n      if(++${i[this.rank-2]} < ${s[this.rank-2]}) {\n        result[2] = ${c};\n        if(${u}) {\n          result[3] = ${c};\n        }\n      }\n      setOutput(result);\n    }\n    `}}exports.TransposePackedProgram=r;
},{"./packing_util":"BqvU","./shader_compiler":"xhhc"}],"VG4U":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.transposeImpl=o,Object.defineProperty(exports,"transposeImplCPU",{enumerable:!0,get:function(){return r.transposeImplCPU}});var e=require("@tensorflow/tfjs-core"),r=require("../kernel_utils/shared"),s=require("../transpose_gpu"),t=require("../transpose_packed_gpu");function o(r,o,n){const p=(0,e.env)().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new t.TransposePackedProgram(r.shape,o):new s.TransposeProgram(r.shape,o);return n.runWebGLProgram(p,[r],r.dtype)}
},{"@tensorflow/tfjs-core":"kSBl","../kernel_utils/shared":"cNPH","../transpose_gpu":"zMPc","../transpose_packed_gpu":"UyJE"}],"YiBb":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.sumImpl=n;var e=require("@tensorflow/tfjs-core"),s=require("../kernel_utils/reduce"),t=require("./Reshape"),r=require("./Transpose_impl");function n(n,a,p,u){const i=a,o=n.shape.length,l=e.util.parseAxisParam(i,n.shape);let d=l;const c=e.backend_util.getAxesPermutation(d,o),m=null!=c;let h=n;m&&(h=(0,r.transposeImpl)(n,c,u),d=e.backend_util.getInnerMostAxes(d.length,o)),e.backend_util.assertAxesAreInnerMostDims("sum",d,o);const[I,x]=e.backend_util.computeOutAndReduceShapes(h.shape,d);let _=I;p&&(_=e.backend_util.expandShapeToKeepDim(I,l));const b=e.util.sizeFromShape(x),k=e.util.sizeFromShape(n.shape)/b,f=(0,t.reshape)({inputs:{x:h},attrs:{shape:[k,b]},backend:u}),A=(0,e.sumOutType)(n.dtype),T=(0,s.reduce)(f,A,"sum",u),g=(0,t.reshape)({inputs:{x:T},attrs:{shape:_},backend:u});return u.disposeIntermediateTensorInfo(f),u.disposeIntermediateTensorInfo(T),m&&u.disposeIntermediateTensorInfo(h),g}
},{"@tensorflow/tfjs-core":"kSBl","../kernel_utils/reduce":"tZI5","./Reshape":"OCN8","./Transpose_impl":"VG4U"}],"FqPw":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.sum=s,exports.sumConfig=void 0;var e=require("@tensorflow/tfjs-core"),r=require("./Sum_impl");function s(e){const{inputs:s,backend:t,attrs:n}=e,{x:o}=s,{axis:u,keepDims:i}=n;return(0,r.sumImpl)(o,u,i,t)}const t=exports.sumConfig={kernelName:e.Sum,backendName:"webgl",kernelFunc:s};
},{"@tensorflow/tfjs-core":"kSBl","./Sum_impl":"YiBb"}],"ukag":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.transpose=s,exports.transposeConfig=void 0;var e=require("@tensorflow/tfjs-core"),t=require("./Transpose_impl");function s(e){const{inputs:s,backend:r,attrs:a}=e,{x:n}=s,{perm:o}=a,p=r,l=n.shape.length,u=new Array(l);for(let t=0;t<u.length;t++)u[t]=n.shape[o[t]];let d;if(p.shouldExecuteOnCPU([n])){const e=p.texData.get(n.dataId).values,s=(0,t.transposeImplCPU)(e,n.shape,n.dtype,o,u);d=p.makeTensorInfo(u,n.dtype),p.texData.get(d.dataId).values=s}else d=(0,t.transposeImpl)(n,o,p);return d}const r=exports.transposeConfig={kernelName:e.Transpose,backendName:"webgl",kernelFunc:s};
},{"@tensorflow/tfjs-core":"kSBl","./Transpose_impl":"VG4U"}],"kzNd":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.MATMUL_SHARED_DIM_THRESHOLD=void 0,exports.batchMatMulImpl=l;var e=require("@tensorflow/tfjs-core"),s=require("../kernel_utils/kernel_funcs_utils"),a=require("../mulmat_packed_gpu"),t=require("./Multiply"),p=require("./Reshape"),r=require("./Sum"),n=require("./Transpose");const u=exports.MATMUL_SHARED_DIM_THRESHOLD=1e3;function l({a:l,b:h,transposeA:i,transposeB:o,backend:c,bias:d=null,preluActivationWeights:m=null,leakyreluAlpha:k=0,activation:b=null}){const f=l.shape.length,x=h.shape.length,M=i?l.shape[f-2]:l.shape[f-1],_=o?h.shape[x-1]:h.shape[x-2],A=i?l.shape[f-1]:l.shape[f-2],S=o?h.shape[x-2]:h.shape[x-1],T=l.shape.slice(0,-2),y=h.shape.slice(0,-2),g=e.util.sizeFromShape(T),q=e.util.sizeFromShape(y),D=e.broadcast_util.assertAndGetBroadcastShape(l.shape.slice(0,-2),h.shape.slice(0,-2)).concat([A,S]);e.util.assert(M===_,()=>`Error in matMul: inner shapes (${M}) and (`+`${_}) of Tensors with shapes ${l.shape} and `+`${h.shape} and transposeA=${i}`+` and transposeB=${o} must match.`);const v=i?[g,M,A]:[g,A,M],H=o?[q,S,_]:[q,_,S],I=(0,p.reshape)({inputs:{x:l},backend:c,attrs:{shape:v}}),$=(0,p.reshape)({inputs:{x:h},backend:c,attrs:{shape:H}}),E=[I,$],L=Math.max(g,q),P=i?I.shape[1]:I.shape[2],R=null!=d,w=null!=m,B="leakyrelu"===b,O=null!=b?(0,s.mapActivationToShaderProgram)(b,!0):null;let j;if((1===A||1===S)&&P>u&&!1===(R||w||B||null!=O)){let e=I,s=$;i&&(e=(0,n.transpose)({inputs:{x:I},backend:c,attrs:{perm:[0,2,1]}}),E.push(e)),o&&(s=(0,n.transpose)({inputs:{x:$},backend:c,attrs:{perm:[0,2,1]}}),E.push(s));const a=1===S;let u=e;1!==S&&(u=(0,p.reshape)({inputs:{x:e},backend:c,attrs:{shape:[L,P,1]}}),E.push(u));const l=1===S?2:1;let h=s;a&&(h=(0,p.reshape)({inputs:{x:s},backend:c,attrs:{shape:[L,1,P]}}),E.push(h));const d=(0,t.multiply)({inputs:{a:u,b:h},backend:c});j=(0,r.sum)({inputs:{x:d},backend:c,attrs:{axis:l,keepDims:!0}}),E.push(d)}else{const s=(0,e.upcastType)(l.dtype,h.dtype),t=new a.MatMulPackedProgram(v,H,[L,A,S],i,o,R,O,w,B),p=[I,$];if(null!=d&&p.push(d),w&&p.push(m),B){const s=c.makeTensorInfo([],"float32",e.util.createScalarValue(k,"float32"));p.push(s),E.push(s)}j=c.runWebGLProgram(t,p,s)}const z=(0,p.reshape)({inputs:{x:j},backend:c,attrs:{shape:D}});E.push(j);for(const e of E)c.disposeIntermediateTensorInfo(e);return z}
},{"@tensorflow/tfjs-core":"kSBl","../kernel_utils/kernel_funcs_utils":"ciwP","../mulmat_packed_gpu":"QKYo","./Multiply":"xWNx","./Reshape":"OCN8","./Sum":"FqPw","./Transpose":"ukag"}],"QEU7":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports._fusedMatMul=a,exports._fusedMatMulConfig=void 0;var e=require("@tensorflow/tfjs-core"),t=require("./BatchMatMul_impl");function a(e){const{inputs:a,backend:s,attrs:r}=e,{a:n,b:o,bias:u,preluActivationWeights:i}=a,{transposeA:l,transposeB:c,activation:p,leakyreluAlpha:M}=r;return(0,t.batchMatMulImpl)({a:n,b:o,transposeA:l,transposeB:c,backend:s,bias:u,preluActivationWeights:i,leakyreluAlpha:M,activation:p})}const s=exports._fusedMatMulConfig={kernelName:e._FusedMatMul,backendName:"webgl",kernelFunc:a};
},{"@tensorflow/tfjs-core":"kSBl","./BatchMatMul_impl":"kzNd"}],"ovwb":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.abs=s,exports.absConfig=void 0;var e=require("@tensorflow/tfjs-core"),r=require("../kernel_utils/shared"),n=require("../unaryop_gpu"),t=require("../unaryop_packed_gpu");const a="return abs(x);";function s(s){const{inputs:o,backend:p}=s,{x:u}=o;if(p.shouldExecuteOnCPU([u])&&"complex64"!==u.dtype){const e=p.texData.get(u.dataId),n=(0,r.simpleAbsImplCPU)(e.values);return p.makeTensorInfo(u.shape,u.dtype,n)}let c;return c=(0,e.env)().getBool("WEBGL_PACK_UNARY_OPERATIONS")?new t.UnaryOpPackedProgram(u.shape,a):new n.UnaryOpProgram(u.shape,a),p.runWebGLProgram(c,[u],u.dtype)}const o=exports.absConfig={kernelName:e.Abs,backendName:"webgl",kernelFunc:s};
},{"@tensorflow/tfjs-core":"kSBl","../kernel_utils/shared":"cNPH","../unaryop_gpu":"CK3x","../unaryop_packed_gpu":"zBLd"}],"Olb2":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.acosConfig=exports.acos=void 0;var e=require("@tensorflow/tfjs-core"),r=require("../kernel_utils/kernel_funcs_utils"),n=require("../unaryop_gpu");const o=n.CHECK_NAN_SNIPPET+"\n  if (abs(x) > 1.) {\n    return NAN;\n  }\n  return acos(x);\n",s=exports.acos=(0,r.unaryKernelFunc)({opSnippet:o}),t=exports.acosConfig={kernelName:e.Acos,backendName:"webgl",kernelFunc:s};
},{"@tensorflow/tfjs-core":"kSBl","../kernel_utils/kernel_funcs_utils":"ciwP","../unaryop_gpu":"CK3x"}],"wCgD":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.acoshConfig=exports.acosh=void 0;var e=require("@tensorflow/tfjs-core"),r=require("../kernel_utils/kernel_funcs_utils"),o=require("../unaryop_gpu");const n=o.CHECK_NAN_SNIPPET+"\n  if (x < 1.0) return NAN;\nreturn log(x + sqrt(x * x - 1.0));",s=exports.acosh=(0,r.unaryKernelFunc)({opSnippet:n}),t=exports.acoshConfig={kernelName:e.Acosh,backendName:"webgl",kernelFunc:s};
},{"@tensorflow/tfjs-core":"kSBl","../kernel_utils/kernel_funcs_utils":"ciwP","../unaryop_gpu":"CK3x"}],"lyYz":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.addKernelFunc=exports.addConfig=void 0;var e=require("@tensorflow/tfjs-core"),r=require("../kernel_utils/kernel_funcs_utils"),n=require("../kernel_utils/shared");const l="return a + b;",p=exports.addKernelFunc=(0,r.binaryKernelFunc)({opSnippet:l,packedOpSnippet:l,supportsComplex:!0,cpuKernelImpl:n.addImplCPU}),t=exports.addConfig={kernelName:e.Add,backendName:"webgl",kernelFunc:p};
},{"@tensorflow/tfjs-core":"kSBl","../kernel_utils/kernel_funcs_utils":"ciwP","../kernel_utils/shared":"cNPH"}],"a1NC":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.AddNProgram=void 0;class t{constructor(t,s){this.outputShape=[],this.outputShape=t,this.variableNames=s.map((t,s)=>`T${s}`);const e=[];this.variableNames.forEach(t=>{e.push(`float v${t} = get${t}AtOutCoords();`)});const o=this.variableNames.map(t=>`v${t}`).join(" + ");this.userCode=`\n      void main() {\n        ${e.join("\n        ")}\n\n        float result = ${o};\n        setOutput(result);\n      }\n    `}}exports.AddNProgram=t;
},{}],"dN0g":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.AddNPackedProgram=void 0;class t{constructor(t,e){this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t,this.variableNames=e.map((t,e)=>`T${e}`);const s=[];this.variableNames.forEach(t=>{s.push(`vec4 v${t} = get${t}AtOutCoords();`)});const a=this.variableNames.map(t=>`v${t}`).join(" + ");this.userCode=`\n      void main() {\n        ${s.join("\n        ")}\n\n        vec4 result = ${a};\n        setOutput(result);\n      }\n    `}}exports.AddNPackedProgram=t;
},{}],"SS4q":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.addN=d,exports.addNConfig=void 0;var e=require("@tensorflow/tfjs-core"),n=require("../addn_gpu"),r=require("../addn_packed_gpu"),t=require("./Identity");function d(a){const{inputs:o,backend:s}=a,u=o;if(1===u.length)return(0,t.identity)({inputs:{x:u[0]},backend:s});if(u.length>(0,e.env)().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER")){const e=Math.floor(u.length/2),n=d({inputs:u.slice(0,e),backend:s}),r=d({inputs:u.slice(e),backend:s});return d({inputs:[n,r],backend:s})}const i=u.map(e=>e.dtype).reduce((n,r)=>(0,e.upcastType)(n,r)),c=u.map(e=>e.shape),p=(0,e.env)().getBool("WEBGL_PACK")?new r.AddNPackedProgram(u[0].shape,c):new n.AddNProgram(u[0].shape,c);return s.runWebGLProgram(p,u,i)}const a=exports.addNConfig={kernelName:e.AddN,backendName:"webgl",kernelFunc:d};
},{"@tensorflow/tfjs-core":"kSBl","../addn_gpu":"a1NC","../addn_packed_gpu":"dN0g","./Identity":"LUQG"}],"JMnO":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.all=a,exports.allConfig=void 0;var e=require("@tensorflow/tfjs-core"),s=require("../kernel_utils/reduce"),t=require("./Reshape"),n=require("./Transpose");function a(a){const{inputs:r,backend:i,attrs:l}=a,{x:o}=r,{axis:p,keepDims:u}=l,d=o.shape.length,c=e.util.parseAxisParam(p,o.shape);let h=c;const k=e.backend_util.getAxesPermutation(h,d);let x=o;null!=k&&(x=(0,n.transpose)({inputs:{x:o},backend:i,attrs:{perm:k}}),h=e.backend_util.getInnerMostAxes(h.length,d)),e.backend_util.assertAxesAreInnerMostDims("all",h,d);const[b,m]=e.backend_util.computeOutAndReduceShapes(x.shape,h),f=e.util.sizeFromShape(m),I=(0,t.reshape)({inputs:{x:x},backend:i,attrs:{shape:[-1,f]}}),_=(0,s.reduce)(I,I.dtype,"all",i);let g;if(u){const s=e.backend_util.expandShapeToKeepDim(b,c);g=(0,t.reshape)({inputs:{x:_},backend:i,attrs:{shape:s}})}else g=(0,t.reshape)({inputs:{x:_},backend:i,attrs:{shape:b}});return i.disposeIntermediateTensorInfo(I),i.disposeIntermediateTensorInfo(_),null!=k&&i.disposeIntermediateTensorInfo(x),g}const r=exports.allConfig={kernelName:e.All,backendName:"webgl",kernelFunc:a};
},{"@tensorflow/tfjs-core":"kSBl","../kernel_utils/reduce":"tZI5","./Reshape":"OCN8","./Transpose":"ukag"}],"KErF":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.any=a,exports.anyConfig=void 0;var e=require("@tensorflow/tfjs-core"),s=require("../kernel_utils/reduce"),t=require("./Reshape"),n=require("./Transpose");function a(a){const{inputs:r,backend:i,attrs:o}=a,{x:p}=r,{axis:u,keepDims:d}=o,c=p.shape.length,l=e.util.parseAxisParam(u,p.shape);let h=l;const k=e.backend_util.getAxesPermutation(h,c);let x=p;null!=k&&(x=(0,n.transpose)({inputs:{x:p},backend:i,attrs:{perm:k}}),h=e.backend_util.getInnerMostAxes(h.length,c)),e.backend_util.assertAxesAreInnerMostDims("any",h,c);const[b,m]=e.backend_util.computeOutAndReduceShapes(x.shape,h),f=e.util.sizeFromShape(m),y=(0,t.reshape)({inputs:{x:x},backend:i,attrs:{shape:[-1,f]}}),I=(0,s.reduce)(y,y.dtype,"any",i);let _;if(d){const s=e.backend_util.expandShapeToKeepDim(b,l);_=(0,t.reshape)({inputs:{x:I},backend:i,attrs:{shape:s}})}else _=(0,t.reshape)({inputs:{x:I},backend:i,attrs:{shape:b}});return i.disposeIntermediateTensorInfo(y),i.disposeIntermediateTensorInfo(I),null!=k&&i.disposeIntermediateTensorInfo(x),_}const r=exports.anyConfig={kernelName:e.Any,backendName:"webgl",kernelFunc:a};
},{"@tensorflow/tfjs-core":"kSBl","../kernel_utils/reduce":"tZI5","./Reshape":"OCN8","./Transpose":"ukag"}],"VKTJ":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.ArgMinMaxProgram=void 0;class t{constructor(t,e,n){this.variableNames=["A"];const{windowSize:i,batchSize:s,outSize:a}=t;n||this.variableNames.push("bestIndicesA"),this.outputShape=[s,a];const o="max"===e?">":"<",d=n?"inOffset + i;":"round(getBestIndicesA(batch, inOffset + i));";this.userCode=`\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * ${i};\n\n        int bestIndex = inOffset;\n        float bestValue = getA(batch, bestIndex);\n\n        for (int i = 0; i < ${i}; i++) {\n          int inIdx = ${d};\n          float candidate = getA(batch, inIdx);\n          if (candidate ${o} bestValue) {\n            bestValue = candidate;\n            bestIndex = inIdx;\n          }\n        }\n        setOutput(float(bestIndex));\n      }\n    `}}exports.ArgMinMaxProgram=t;
},{}],"gzgT":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.ArgMinMaxPackedProgram=void 0;var e=require("@tensorflow/tfjs-core"),n=require("./packing_util"),t=require("./shader_compiler");class c{constructor(c,o,s,a){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,e.util.assert(c.length>2,()=>`Packed arg${s.charAt(0).toUpperCase()+s.slice(1)} supports only inputs with rank above 2.`);const i=c[c.length-1],r=Math.ceil(i/o);this.outputShape=c.slice(0,-1),r>1&&this.outputShape.push(r),a||this.variableNames.push("bestIndicesA");const d=this.outputShape,l=d.length,$=(0,t.getCoordsDataType)(l),u=(0,n.getChannels)("coords",l);let h,p;if(1===r){p=l+1;const e=(0,t.getCoordsDataType)(p);h=`\n        ${e} sourceLocR = ${e}(${u.join()}, 0);\n        ++${u[l-1]};\n        ${e} sourceLocG = ${e}(${u.join()}, 0);\n        ++${u[l-2]};\n        ${e} sourceLocA = ${e}(${u.join()}, 0);\n        --${u[l-1]};\n        ${e} sourceLocB = ${e}(${u.join()}, 0);\n        --${u[l-2]};`}else p=l,h=`\n        ${$} sourceLocR = coords;\n        ++${u[l-1]};\n        ${$} sourceLocG = coords;\n        ++${u[l-2]};\n        ${$} sourceLocA = coords;\n        --${u[l-1]};\n        ${$} sourceLocB = coords;\n        --${u[l-2]};`;const x=["x","y","z","w","u","v"].slice(0,p),g="."+x[p-1],v=x.map(e=>"int "+e),C=(0,n.getChannels)("sourceLocR",p-1).concat("inIdx.r"),I=(0,n.getChannels)("sourceLocG",p-1).concat("inIdx.g"),b=(0,n.getChannels)("sourceLocB",p-1).concat("inIdx.b"),A=(0,n.getChannels)("sourceLocA",p-1).concat("inIdx.a"),j="max"===s?"greaterThan":"lessThan",L=a?"":`\n          inIdx = round(vec4(getBestIndicesAChannel(${C.join()}),\n                             getBestIndicesAChannel(${I.join()}),\n                             getBestIndicesAChannel(${b.join()}),\n                             getBestIndicesAChannel(${A.join()})));`,B=`vec4(\n            getAChannel(${C.join()}),\n            hasNextCol ? getAChannel(${I.join()}) : 0.,\n            hasNextRow ? getAChannel(${b.join()}) : 0.,\n            hasNextRow && hasNextCol ? getAChannel(${A.join()}) : 0.)`,m=a?"":`\n      float getBestIndicesAChannel(${v.join()}) {\n        return getChannel(getBestIndicesA(${x.join()}),\n                                          vec2(${x.slice(-2).join()}));\n      }`;this.userCode=`\n      float getAChannel(${v.join()}) {\n        return getChannel(getA(${x.join()}),\n                               vec2(${x.slice(-2).join()}));\n      }\n      ${m}\n      void main() {\n        ${$} coords = getOutputCoords();\n        bool hasNextCol = ${u[l-1]} < ${d[l-1]-1};\n        bool hasNextRow = ${u[l-2]} < ${d[l-2]-1};\n        ${h}\n        ivec4 srcIdx = ivec4(sourceLocR${g}, sourceLocG${g},\n          sourceLocB${g}, sourceLocA${g}) * ${o};\n        ivec4 inIdx = srcIdx;\n        vec4 bestIndex = vec4(inIdx);\n        vec4 bestValue = ${B};\n\n        for (int i = 0; i < ${o}; i++) {\n          inIdx = srcIdx;\n          ${L}\n          vec4 candidate = ${B};\n          bvec4 nan = isnan(candidate);\n          bvec4 replace = bvec4(\n            vec4(${j}(candidate, bestValue)) * (vec4(1.0) - vec4(nan)));\n\n          bestValue = vec4(replace.x  ? candidate.x : bestValue.x,\n                           replace.y  ? candidate.y : bestValue.y,\n                           replace.z  ? candidate.z : bestValue.z,\n                           replace.w  ? candidate.w : bestValue.w);\n          bestIndex = mix(bestIndex, vec4(inIdx), vec4(replace));\n          srcIdx++;\n        }\n        setOutput(bestIndex);\n      }\n    `}}exports.ArgMinMaxPackedProgram=c;
},{"@tensorflow/tfjs-core":"kSBl","./packing_util":"BqvU","./shader_compiler":"xhhc"}],"miTP":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.argMinMaxReduce=i;var e=require("@tensorflow/tfjs-core"),n=require("../argminmax_gpu"),t=require("../argminmax_packed_gpu"),r=require("../kernels/Reshape");function s(t,r,a,i=null){let u=r.shape[0],o=r.shape[1];null!=i&&(u=i.shape[0],o=i.shape[1]);const p=e.backend_util.computeOptimalWindowSize(o),l={windowSize:p,inSize:o,batchSize:u,outSize:Math.ceil(o/p)},c=new n.ArgMinMaxProgram(l,a,null==i),h=[r];null!=i&&h.push(i);const d=t.runWebGLProgram(c,h,"int32");if(1===d.shape[1])return d;const g=s(t,r,a,d);return t.disposeIntermediateTensorInfo(d),g}function a(n,r,s,i=null){const u=null!=i?i.shape:r.shape,o=u[u.length-1],p=e.backend_util.computeOptimalWindowSize(o),l=new t.ArgMinMaxPackedProgram(u,p,s,null==i),c=null==i?[r]:[r,i],h=n.runWebGLProgram(l,c,"int32");if(h.shape.length===r.shape.length){const e=a(n,r,s,h);return n.disposeIntermediateTensorInfo(h),e}return h}function i(n,t,i,u){const o=[i];if(e.backend_util.assertAxesAreInnerMostDims("arg"+u.charAt(0).toUpperCase()+u.slice(1),o,t.shape.length),!(0,e.env)().getBool("WEBGL_PACK_REDUCE")||t.shape.length<=2){const a=[],i=n.texData.get(t.dataId);let p=t;null!==i&&i.isPacked&&(p=n.unpackTensor(t),a.push(p));const[l,c]=e.backend_util.computeOutAndReduceShapes(p.shape,o),h=e.util.sizeFromShape(c),d=(0,r.reshape)({inputs:{x:p},backend:n,attrs:{shape:[-1,h]}});a.push(d);const g=s(n,d,u);a.push(g);const m=(0,r.reshape)({inputs:{x:g},backend:n,attrs:{shape:l}});return a.forEach(e=>n.disposeIntermediateTensorInfo(e)),m}return a(n,t,u)}
},{"@tensorflow/tfjs-core":"kSBl","../argminmax_gpu":"VKTJ","../argminmax_packed_gpu":"gzgT","../kernels/Reshape":"OCN8"}],"x2EH":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.argMax=s,exports.argMaxConfig=void 0;var e=require("@tensorflow/tfjs-core"),t=require("../kernel_utils/arg_min_max"),r=require("./Transpose");function s(s){const{inputs:n,backend:a,attrs:o}=s,{x:i}=n,{axis:l}=o;let u=e.util.parseAxisParam(l,i.shape);const x=e.backend_util.getAxesPermutation(u,i.shape.length);let c=i;const p=[];null!=x&&(c=(0,r.transpose)({inputs:{x:i},backend:a,attrs:{perm:x}}),p.push(c),u=e.backend_util.getInnerMostAxes(u.length,c.shape.length)),e.backend_util.assertAxesAreInnerMostDims("argMax",[u[0]],c.shape.length);const g=(0,t.argMinMaxReduce)(a,c,u[0],"max");return p.forEach(e=>a.disposeIntermediateTensorInfo(e)),g}const n=exports.argMaxConfig={kernelName:e.ArgMax,backendName:"webgl",kernelFunc:s};
},{"@tensorflow/tfjs-core":"kSBl","../kernel_utils/arg_min_max":"miTP","./Transpose":"ukag"}],"hkwZ":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.argMin=r,exports.argMinConfig=void 0;var e=require("@tensorflow/tfjs-core"),n=require("../kernel_utils/arg_min_max"),t=require("./Transpose");function r(r){const{inputs:s,backend:a,attrs:i}=r,{x:o}=s,{axis:l}=i;let u=e.util.parseAxisParam(l,o.shape);const c=e.backend_util.getAxesPermutation(u,o.shape.length);let p=o;const g=[];null!=c&&(p=(0,t.transpose)({inputs:{x:o},backend:a,attrs:{perm:c}}),g.push(p),u=e.backend_util.getInnerMostAxes(u.length,p.shape.length)),e.backend_util.assertAxesAreInnerMostDims("argMin",[u[0]],p.shape.length);const x=(0,n.argMinMaxReduce)(a,p,u[0],"min");return g.forEach(e=>a.disposeIntermediateTensorInfo(e)),x}const s=exports.argMinConfig={kernelName:e.ArgMin,backendName:"webgl",kernelFunc:r};
},{"@tensorflow/tfjs-core":"kSBl","../kernel_utils/arg_min_max":"miTP","./Transpose":"ukag"}],"OFJK":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.asinConfig=exports.asin=void 0;var e=require("@tensorflow/tfjs-core"),n=require("../kernel_utils/kernel_funcs_utils"),r=require("../unaryop_gpu");const s=r.CHECK_NAN_SNIPPET+"\n  if (abs(x) > 1.) {\n    return NAN;\n  }\n  return asin(x);\n",i=exports.asin=(0,n.unaryKernelFunc)({opSnippet:s}),t=exports.asinConfig={kernelName:e.Asin,backendName:"webgl",kernelFunc:i};
},{"@tensorflow/tfjs-core":"kSBl","../kernel_utils/kernel_funcs_utils":"ciwP","../unaryop_gpu":"CK3x"}],"Z5zC":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.asinhConfig=exports.asinh=void 0;var e=require("@tensorflow/tfjs-core"),r=require("../kernel_utils/kernel_funcs_utils"),n=require("../unaryop_gpu");const s=n.CHECK_NAN_SNIPPET+"return log(x + sqrt(x * x + 1.0));",o=exports.asinh=(0,r.unaryKernelFunc)({opSnippet:s}),t=exports.asinhConfig={kernelName:e.Asinh,backendName:"webgl",kernelFunc:o};
},{"@tensorflow/tfjs-core":"kSBl","../kernel_utils/kernel_funcs_utils":"ciwP","../unaryop_gpu":"CK3x"}],"OiG7":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.atanConfig=exports.atan=void 0;var e=require("@tensorflow/tfjs-core"),n=require("../kernel_utils/kernel_funcs_utils"),r=require("../unaryop_gpu");const t=r.CHECK_NAN_SNIPPET+"\n  return atan(x);\n",a=exports.atan=(0,n.unaryKernelFunc)({opSnippet:t}),o=exports.atanConfig={kernelName:e.Atan,backendName:"webgl",kernelFunc:a};
},{"@tensorflow/tfjs-core":"kSBl","../kernel_utils/kernel_funcs_utils":"ciwP","../unaryop_gpu":"CK3x"}],"nymv":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.atan2Config=exports.atan2=void 0;var e=require("@tensorflow/tfjs-core"),n=require("../binaryop_gpu"),a=require("../binaryop_packed_gpu"),r=require("../kernel_utils/kernel_funcs_utils");const N=n.CHECK_NAN_SNIPPET+"\n  return atan(a, b);\n",i="\n  vec4 result = atan(a, b);\n  bvec4 isNaNA = isnan(a);\n  bvec4 isNaNB = isnan(b);\n  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);\n  "+a.CHECK_NAN_SNIPPET_PACKED+"\n  return result;\n",s=exports.atan2=(0,r.binaryKernelFunc)({opSnippet:N,packedOpSnippet:i}),t=exports.atan2Config={kernelName:e.Atan2,backendName:"webgl",kernelFunc:s};
},{"@tensorflow/tfjs-core":"kSBl","../binaryop_gpu":"wbV2","../binaryop_packed_gpu":"mFR1","../kernel_utils/kernel_funcs_utils":"ciwP"}],"vHhq":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.atanhConfig=exports.atanh=void 0;var e=require("@tensorflow/tfjs-core"),r=require("../kernel_utils/kernel_funcs_utils"),n=require("../unaryop_gpu");const t=n.CHECK_NAN_SNIPPET+"\n  if ((x < -1.0) || (x > 1.0)) return NAN;\nreturn (log(1.0 + x) - log(1.0 - x)) / 2.0;",o=exports.atanh=(0,r.unaryKernelFunc)({opSnippet:t}),a=exports.atanhConfig={kernelName:e.Atanh,backendName:"webgl",kernelFunc:o};
},{"@tensorflow/tfjs-core":"kSBl","../kernel_utils/kernel_funcs_utils":"ciwP","../unaryop_gpu":"CK3x"}],"QOnm":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.Pool3DProgram=exports.Pool2DProgram=void 0;class n{constructor(n,e,t,i=!1,a=!1){if(this.variableNames=["x"],"avg"===e&&t)throw new Error("Cannot compute positions for average pool.");const o=n.filterWidth,x=n.strideHeight,r=n.strideWidth,c=n.dilationHeight,l=n.dilationWidth,u=n.effectiveFilterHeight,s=n.effectiveFilterWidth,C=n.padInfo.top,d=n.padInfo.left;this.outputShape=n.outShape;const $="avg"===e,h=`((batch  * ${n.inHeight} + xR) * ${n.inWidth} + xC) * ${n.inChannels} + d`,v=`(xR * ${n.inWidth} + xC) * ${n.inChannels} + d`;let f="0.0";if($||(f="-1.0 / 1e-20"),t){const e=">=";return void(this.userCode=`\n        const ivec2 strides = ivec2(${x}, ${r});\n        const ivec2 pads = ivec2(${C}, ${d});\n\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int batch = coords[0];\n          int d = coords[3];\n\n          ivec2 xRCCorner = coords.yz * strides - pads;\n          int xRCorner = xRCCorner.x;\n          int xCCorner = xRCCorner.y;\n\n          // max/min x(?, ?, d) to get y(yR, yC, d).\n          // ? = to be determined\n          float minMaxValue = 0.0;\n          float minMaxValueFound = 0.0;\n          int minMaxPosition = 0;\n          float avgValue = 0.0;\n\n          for (int wR = 0; wR < ${u};\n              wR += ${c}) {\n            int xR = xRCorner + wR;\n\n            if (xR < 0 || xR >= ${n.inHeight}) {\n              continue;\n            }\n\n            for (int wC = 0; wC < ${s};\n                wC += ${l}) {\n              int xC = xCCorner + wC;\n\n              if (xC < 0 || xC >= ${n.inWidth}) {\n                continue;\n              }\n\n              float value = getX(batch, xR, xC, d);\n\n              // If a min / max value has already been found, use it. If not,\n              // use the current value.\n              float currMinMaxValue = mix(\n                  value, minMaxValue, minMaxValueFound);\n              if (value ${e} currMinMaxValue) {\n                minMaxValue = value;\n                minMaxValueFound = 1.0;\n                minMaxPosition = ${i?a?h:v:`wR * ${s} + wC`};\n              }\n            }\n          }\n          setOutput(float(minMaxPosition));\n        }\n      `)}let R=`${e}(${e}(${e}(`+"minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])";"avg"===e&&(R="avgValue / max(count, 1.0)");const V=4*Math.floor(o/4),g=o%4,m=`\n      if (${$}) {\n        avgValue += dot(values, ones);\n      } else {\n        minMaxValue = max(values, minMaxValue);\n      }\n    `;this.userCode=`\n      const ivec2 strides = ivec2(${x}, ${r});\n      const ivec2 pads = ivec2(${C}, ${d});\n      const float initializationValue = ${f};\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float count = 0.0;\n\n      float getValue(int batch, int xR, int xC, int d) {\n        if (xC < 0 || xC >= ${n.inWidth}) {\n          return initializationValue;\n        }\n        count += 1.0;\n        return getX(batch, xR, xC, d);\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d = coords[3];\n\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // max/min x(?, ?, d) to get y(yR, yC, d).\n        // ? = to be determined\n        vec4 minMaxValue = vec4(${f});\n        float avgValue = 0.0;\n        count = 0.0;\n\n        for (int wR = 0; wR < ${u};\n            wR += ${c}) {\n          int xR = xRCorner + wR;\n\n          if (xR < 0 || xR >= ${n.inHeight}) {\n            continue;\n          }\n\n          for (int wC = 0; wC < ${V}; wC += 4) {\n            int xC = xCCorner + wC * ${l};\n\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ${l}, d),\n              getValue(batch, xR, xC + 2 * ${l}, d),\n              getValue(batch, xR, xC + 3 * ${l}, d)\n            );\n\n            ${m}\n          }\n\n          int xC = xCCorner + ${V};\n          if (${1===g}) {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              initializationValue,\n              initializationValue,\n              initializationValue\n            );\n\n            ${m}\n          } else if (${2===g}) {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ${l}, d),\n              initializationValue,\n              initializationValue\n            );\n\n            ${m}\n          } else if (${3===g}) {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ${l}, d),\n              getValue(batch, xR, xC + 2 * ${l}, d),\n              initializationValue\n            );\n\n            ${m}\n          }\n        }\n        setOutput(${R});\n      }\n    `}}exports.Pool2DProgram=n;class e{constructor(n,e,t,i=!1,a=!1){if(this.variableNames=["x"],"avg"===e&&t)throw new Error("Cannot compute positions for average pool.");const o=n.filterWidth,x=n.strideDepth,r=n.strideHeight,c=n.strideWidth,l=n.dilationDepth,u=n.dilationHeight,s=n.dilationWidth,C=n.effectiveFilterDepth,d=n.effectiveFilterHeight,$=n.effectiveFilterWidth,h=n.padInfo.front,v=n.padInfo.top,f=n.padInfo.left;this.outputShape=n.outShape;const R="avg"===e;let V="0.0";if(R||(V="-1.0 / 1e-20"),t){const e=">=";return void(this.userCode=`\n        const ivec3 strides =\n            ivec3(${x}, ${r}, ${c});\n        const ivec3 pads = ivec3(${h}, ${v}, ${f});\n\n        void main() {\n          ivec5 coords = getOutputCoords();\n          int batch = coords.x;\n          int ch = coords.u;\n\n          ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n          int xDCorner = xCorner.x;\n          int xRCorner = xCorner.y;\n          int xCCorner = xCorner.z;\n\n          // max/min x(?, ?, ?, ch) to get y(yD, yR, yC, ch).\n          // ? = to be determined\n          float minMaxValue = 0.0;\n          float minMaxValueFound = 0.0;\n          int minMaxPosition = 0;\n\n          for (int wD = 0; wD < ${C};\n              wD += ${l}) {\n            int xD = xDCorner + wD;\n\n            if (xD < 0 || xD >= ${n.inDepth}) {\n              continue;\n            }\n\n            for (int wR = 0; wR < ${d};\n                wR += ${u}) {\n              int xR = xRCorner + wR;\n\n              if (xR < 0 || xR >= ${n.inHeight}) {\n                continue;\n              }\n\n              for (int wC = 0; wC < ${$};\n                  wC += ${s}) {\n                int xC = xCCorner + wC;\n\n                if (xC < 0 || xC >= ${n.inWidth}) {\n                  continue;\n                }\n\n                float value = getX(batch, xD, xR, xC, ch);\n\n                // If a min / max value has already been found, use it. If not,\n                // use the current value.\n                float currMinMaxValue = mix(\n                    value, minMaxValue, minMaxValueFound);\n                if (value ${e} currMinMaxValue) {\n                  minMaxValue = value;\n                  minMaxValueFound = 1.0;\n                  minMaxPosition = ${i?a?`(((batch * ${n.inDepth} + xD) * ${n.inHeight} + xR) * ${n.inWidth} + xC) * ${n.inChannels} + ch`:`((xD * ${n.inHeight} + xR) * ${n.inWidth} + xC) * ${n.inChannels} + ch`:`wD * ${d} * ${$} +\n                      wR * ${$} + wC`};\n                }\n              }\n            }\n          }\n          setOutput(float(minMaxPosition));\n        }\n      `)}let g=`${e}(${e}(${e}(`+"minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])";"avg"===e&&(g="avgValue / max(count, 1.0)");const m=4*Math.floor(o/4),w=o%4,p=`\n      if (${R}) {\n        avgValue += dot(values, ones);\n      } else {\n        minMaxValue = max(values, minMaxValue);\n      }\n    `;this.userCode=`\n      const ivec3 strides =\n        ivec3(${x}, ${r}, ${c});\n      const ivec3 pads = ivec3(${h}, ${v}, ${f});\n      const float initializationValue = ${V};\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float count = 0.0;\n\n      float getValue(int batch, int xD, int xR, int xC, int ch) {\n        if (xC < 0 || xC >= ${n.inWidth}) {\n          return initializationValue;\n        }\n        count += 1.0;\n        return getX(batch, xD, xR, xC, ch);\n      }\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n        int xDCorner = xCorner.x;\n        int xRCorner = xCorner.y;\n        int xCCorner = xCorner.z;\n\n        // max/min x(?, ?, ?, d) to get y(yD, yR, yC, ch).\n        // ? = to be determined\n        vec4 minMaxValue = vec4(${V});\n        float avgValue = 0.0;\n        count = 0.0;\n\n        for (int wD = 0; wD < ${C};\n            wD += ${l}) {\n          int xD = xDCorner + wD;\n\n          if (xD < 0 || xD >= ${n.inDepth}) {\n            continue;\n          }\n\n          for (int wR = 0; wR < ${d};\n            wR += ${u}) {\n            int xR = xRCorner + wR;\n\n            if (xR < 0 || xR >= ${n.inHeight}) {\n              continue;\n            }\n\n            for (int wC = 0; wC < ${m}; wC += 4) {\n              int xC = xCCorner + wC * ${s};\n\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ${s}, ch),\n                getValue(batch, xD, xR, xC + 2 * ${s}, ch),\n                getValue(batch, xD, xR, xC + 3 * ${s}, ch)\n              );\n\n              ${p}\n            }\n\n            int xC = xCCorner + ${m};\n            if (${1===w}) {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                initializationValue,\n                initializationValue,\n                initializationValue\n              );\n\n              ${p}\n            } else if (${2===w}) {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ${s}, ch),\n                initializationValue,\n                initializationValue\n              );\n\n              ${p}\n            } else if (${3===w}) {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ${s}, ch),\n                getValue(batch, xD, xR, xC + 2 * ${s}, ch),\n                initializationValue\n              );\n\n              ${p}\n            }\n          }\n        }\n        setOutput(${g});\n      }\n    `}}exports.Pool3DProgram=e;
},{}],"x8sT":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.avgPool=i,exports.avgPoolConfig=void 0;var e=require("@tensorflow/tfjs-core"),t=require("../pool_gpu"),o=require("../webgl_util"),r=require("./Identity");function i(i){const{inputs:n,backend:s,attrs:a}=i,{x:l}=n;(0,o.assertNotComplex)(l,"avgPool");const{filterSize:u,strides:d,pad:c,dimRoundingMode:g}=a;e.util.assert(e.backend_util.eitherStridesOrDilationsAreOne(d,1),()=>"Error in avgPool: Either strides or dilations must be 1. "+`Got strides ${d} and dilations '1'`);const p=e.backend_util.computePool2DInfo(l.shape,u,d,1,c,g);if(1===p.filterWidth&&1===p.filterHeight&&e.util.arraysEqual(p.inShape,p.outShape))return(0,r.identity)({inputs:{x:l},backend:s});const f=new t.Pool2DProgram(p,"avg",!1);return s.runWebGLProgram(f,[l],"float32")}const n=exports.avgPoolConfig={kernelName:e.AvgPool,backendName:"webgl",kernelFunc:i};
},{"@tensorflow/tfjs-core":"kSBl","../pool_gpu":"QOnm","../webgl_util":"u1ML","./Identity":"LUQG"}],"rMW3":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.avgPool3D=r,exports.avgPool3DConfig=void 0;var e=require("@tensorflow/tfjs-core"),o=require("../pool_gpu");function r(r){const{inputs:t,backend:n,attrs:a}=r,{x:l}=t,{filterSize:s,strides:i,pad:u,dimRoundingMode:d,dataFormat:g}=a,c=e.backend_util.computePool3DInfo(l.shape,s,i,[1,1,1],u,d,g),p=new o.Pool3DProgram(c,"avg",!1);return n.runWebGLProgram(p,[l],"float32")}const t=exports.avgPool3DConfig={kernelName:e.AvgPool3D,backendName:"webgl",kernelFunc:r};
},{"@tensorflow/tfjs-core":"kSBl","../pool_gpu":"QOnm"}],"ro1H":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.AvgPool3DBackpropProgram=exports.AvgPool2DBackpropProgram=void 0;class t{constructor(t){this.variableNames=["dy"],this.outputShape=t.inShape;const n=t.filterHeight,o=t.filterWidth,i=t.strideHeight,d=t.strideWidth,e=t.dilationHeight,r=t.dilationWidth,a=t.effectiveFilterHeight,y=t.effectiveFilterWidth,l=a-1-t.padInfo.top,s=y-1-t.padInfo.left,c=1/(n*o);this.userCode=`\n      const ivec2 pads = ivec2(${l}, ${s});\n      const float avgMultiplier = float(${c});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n\n        ivec2 dyRCCorner = coords.yz - pads;\n        int dyRCorner = dyRCCorner.x;\n        int dyCCorner = dyRCCorner.y;\n\n        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${a};\n            wR += ${e}) {\n          float dyR = float(dyRCorner + wR) / ${i}.0;\n\n          if (dyR < 0.0 || dyR >= ${t.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          for (int wC = 0; wC < ${y};\n            wC+= ${r}) {\n            float dyC = float(dyCCorner + wC) / ${d}.0;\n\n            if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            float dyValue = getDy(b, idyR, idyC, d);\n\n            dotProd += dyValue * avgMultiplier;\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}exports.AvgPool2DBackpropProgram=t;class n{constructor(t){this.variableNames=["dy"],this.outputShape=t.inShape;const n=t.filterDepth,o=t.filterHeight,i=t.filterWidth,d=t.strideDepth,e=t.strideHeight,r=t.strideWidth,a=t.dilationDepth,y=t.dilationHeight,l=t.dilationWidth,s=t.effectiveFilterDepth,c=t.effectiveFilterHeight,f=t.effectiveFilterWidth,C=s-1-t.padInfo.front,p=c-1-t.padInfo.top,h=f-1-t.padInfo.left,u=1/(n*o*i);this.userCode=`\n      const ivec3 pads = ivec3(${C}, ${p}, ${h});\n      const float avgMultiplier = float(${u});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyDCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        // Convolve dy(?, ?, ?, d) with pos mask(:, :, :, ch) to get\n        // dx(xD, xR, xC, ch).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int wD = 0; wD < ${s};\n            wD += ${a}) {\n          float dyD = float(dyDCorner + wD) / ${d}.0;\n\n          if (dyD < 0.0 || dyD >= ${t.outDepth}.0 || fract(dyD) > 0.0) {\n            continue;\n          }\n          int idyD = int(dyD);\n\n          for (int wR = 0; wR < ${c};\n              wR += ${y}) {\n            float dyR = float(dyRCorner + wR) / ${e}.0;\n\n            if (dyR < 0.0 || dyR >= ${t.outHeight}.0 ||\n                fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            for (int wC = 0; wC < ${f};\n                wC += ${l}) {\n              float dyC = float(dyCCorner + wC) / ${r}.0;\n\n              if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              float dyValue = getDy(batch, idyD, idyR, idyC, ch);\n\n              dotProd += dyValue * avgMultiplier;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}exports.AvgPool3DBackpropProgram=n;
},{}],"rSf2":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.avgPool3DGrad=r,exports.avgPool3DGradConfig=void 0;var e=require("@tensorflow/tfjs-core"),o=require("../avg_pool_backprop_gpu");function r(r){const{inputs:t,backend:a,attrs:n}=r,{dy:d,input:p}=t,i=p,{filterSize:s,strides:l,pad:u,dimRoundingMode:c}=n,g=e.backend_util.computePool3DInfo(i.shape,s,l,[1,1,1],u,c),v=new o.AvgPool3DBackpropProgram(g);return a.runWebGLProgram(v,[d],i.dtype)}const t=exports.avgPool3DGradConfig={kernelName:e.AvgPool3DGrad,backendName:"webgl",kernelFunc:r};
},{"@tensorflow/tfjs-core":"kSBl","../avg_pool_backprop_gpu":"ro1H"}],"GujH":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.avgPoolGrad=t,exports.avgPoolGradConfig=void 0;var e=require("@tensorflow/tfjs-core"),o=require("../avg_pool_backprop_gpu"),r=require("../webgl_util");function t(t){const{inputs:a,backend:n,attrs:l}=t,{dy:s,input:p}=a,i=p;(0,r.assertNotComplex)([s,p],"avgPoolGrad");const{filterSize:u,strides:d,pad:c}=l,g=e.backend_util.computePool2DInfo(i.shape,u,d,1,c),v=new o.AvgPool2DBackpropProgram(g);return n.runWebGLProgram(v,[s],i.dtype)}const a=exports.avgPoolGradConfig={kernelName:e.AvgPoolGrad,backendName:"webgl",kernelFunc:t};
},{"@tensorflow/tfjs-core":"kSBl","../avg_pool_backprop_gpu":"ro1H","../webgl_util":"u1ML"}],"oT54":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.batchMatMul=a,exports.batchMatMulConfig=void 0;var e=require("@tensorflow/tfjs-core"),t=require("./BatchMatMul_impl");function a(e){const{inputs:a,backend:r,attrs:s}=e,{a:n,b:o}=a,{transposeA:c,transposeB:u}=s;return(0,t.batchMatMulImpl)({a:n,b:o,transposeA:c,transposeB:u,backend:r})}const r=exports.batchMatMulConfig={kernelName:e.BatchMatMul,backendName:"webgl",kernelFunc:a};
},{"@tensorflow/tfjs-core":"kSBl","./BatchMatMul_impl":"kzNd"}],"hGmP":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.BatchNormProgram=void 0;var t=require("@tensorflow/tfjs-core");class e{constructor(e,a,s,o,r,n){this.outputShape=[],this.variableNames=["x","mean","variance"],t.backend_util.assertAndGetBroadcastShape(e,a),t.backend_util.assertAndGetBroadcastShape(e,s);let l="0.0";null!=o&&(t.backend_util.assertAndGetBroadcastShape(e,o),this.variableNames.push("offset"),l="getOffsetAtOutCoords()");let i="1.0";null!=r&&(t.backend_util.assertAndGetBroadcastShape(e,r),this.variableNames.push("scale"),i="getScaleAtOutCoords()"),this.outputShape=e,this.userCode=`\n      void main() {\n        float x = getXAtOutCoords();\n        float mean = getMeanAtOutCoords();\n        float variance = getVarianceAtOutCoords();\n        float offset = ${l};\n        float scale = ${i};\n        float inv = scale * inversesqrt(variance + float(${n}));\n        setOutput(dot(vec3(x, -mean, offset), vec3(inv, inv, 1)));\n      }\n    `}}exports.BatchNormProgram=e;
},{"@tensorflow/tfjs-core":"kSBl"}],"oHWE":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.BatchNormPackedProgram=void 0;var e=require("@tensorflow/tfjs-core");class t{constructor(t,a,s,r,n,c){this.packedInputs=!0,this.packedOutput=!0,this.variableNames=["x","mean","variance"],e.backend_util.assertAndGetBroadcastShape(t,a),e.backend_util.assertAndGetBroadcastShape(t,s);let o="vec4(0.0)";null!=r&&(e.backend_util.assertAndGetBroadcastShape(t,r),this.variableNames.push("offset"),o="getOffsetAtOutCoords()");let i="vec4(1.0)";null!=n&&(e.backend_util.assertAndGetBroadcastShape(t,n),this.variableNames.push("scale"),i="getScaleAtOutCoords()"),this.outputShape=t,this.userCode=`\n      void main() {\n        vec4 offset = ${o};\n        vec4 scale = ${i};\n\n        vec4 x = getXAtOutCoords();\n        vec4 mean = getMeanAtOutCoords();\n        vec4 variance = getVarianceAtOutCoords();\n\n        vec4 inv = scale * inversesqrt(variance + vec4(${c}));\n\n        setOutput((x - mean) * inv + offset);\n      }\n    `}}exports.BatchNormPackedProgram=t;
},{"@tensorflow/tfjs-core":"kSBl"}],"g2b2":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.batchNormConfig=exports.batchNorm=void 0;var e=require("@tensorflow/tfjs-core"),a=require("../batchnorm_gpu"),t=require("../batchnorm_packed_gpu");const r=({inputs:r,backend:n,attrs:s})=>{const{x:o,mean:l,variance:h,offset:u,scale:c}=r;e.util.assert(l.shape.length===h.shape.length,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),e.util.assert(null==u||l.shape.length===u.shape.length,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),e.util.assert(null==c||l.shape.length===c.shape.length,()=>"Batch normalization gradient requires mean and scale to have equal ranks.");let{varianceEpsilon:i}=s;null==i&&(i=.001);const p=[o,l,h];let m=null;null!=u&&(m=u.shape,p.push(u));let g=null;null!=c&&(g=c.shape,p.push(c));const d=(0,e.env)().getBool("WEBGL_PACK_NORMALIZATION")?new t.BatchNormPackedProgram(o.shape,l.shape,h.shape,m,g,i):new a.BatchNormProgram(o.shape,l.shape,h.shape,m,g,i);return n.runWebGLProgram(d,p,p[0].dtype)};exports.batchNorm=r;const n=exports.batchNormConfig={kernelName:e.FusedBatchNorm,backendName:"webgl",kernelFunc:r};
},{"@tensorflow/tfjs-core":"kSBl","../batchnorm_gpu":"hGmP","../batchnorm_packed_gpu":"oHWE"}],"utcd":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.SliceProgram=void 0;var r=require("./shader_compiler");class t{constructor(t){this.variableNames=["source"],this.outputShape=t,this.rank=t.length;const s=(0,r.getCoordsDataType)(this.rank);this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];const n=e(this.rank);let i;i=`\n        ${s} sourceLoc;\n        ${s} coords = getOutputCoords();\n        ${t.map((r,t)=>`sourceLoc.${o[t]} = start[${t}] + coords.${o[t]};`).join("\n")}\n      `,this.userCode=`\n      void main() {\n        ${i}\n        setOutput(getSource(${n}));\n      }\n    `}}exports.SliceProgram=t;const o=["x","y","z","w","u","v"];function e(r){if(1===r)return"sourceLoc";if(r<=6)return o.slice(0,r).map(r=>"sourceLoc."+r).join(",");throw Error(`Slicing for rank ${r} is not yet supported`)}
},{"./shader_compiler":"xhhc"}],"z2Lk":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.SlicePackedProgram=void 0;var n=require("./packing_util"),t=require("./shader_compiler");class s{constructor(s){this.variableNames=["source"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=s,this.rank=s.length,this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];const r=(0,t.getCoordsDataType)(this.rank),e=(0,n.getChannels)("coords",this.rank),a=(0,n.getChannels)("sourceLoc",this.rank),i=1===this.rank?"sourceLoc":`vec2(${a.slice(-2).join()})`,o=`getChannel(getSource(${a.join()}), ${i})`,c=`\n      result.x = ${o};\n      if (++${e[this.rank-1]} < ${s[this.rank-1]}) {\n        ++${a[this.rank-1]};\n        result.y = ${o};\n        --${a[this.rank-1]};\n      }\n    `,h=1===this.rank?"":`\n      --${e[this.rank-1]};\n      if (++${e[this.rank-2]} < ${s[this.rank-2]}) {\n        ++${a[this.rank-2]};\n        result.z = ${o};\n        if (++${e[this.rank-1]} < ${s[this.rank-1]}) {\n          ++${a[this.rank-1]};\n          result.w = ${o};\n        }\n      }\n    `,u=this.rank<=4?`sourceLoc = coords +\n            ${r}(${s.map((n,t)=>`start[${t}]`).join()});`:s.map((n,t)=>`${a[t]} = ${e[t]} + start[${t}];`).join("\n");this.userCode=`\n      void main() {\n        ${r} coords = getOutputCoords();\n        ${r} sourceLoc;\n        ${u}\n        vec4 result = vec4(0.);\n        ${c}\n        ${h}\n        setOutput(result);\n      }\n    `}}exports.SlicePackedProgram=s;
},{"./packing_util":"BqvU","./shader_compiler":"xhhc"}],"i5TP":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.slice=r,exports.sliceConfig=void 0;var e=require("@tensorflow/tfjs-core"),t=require("../kernel_utils/shared"),a=require("../slice_gpu"),s=require("../slice_packed_gpu");function i(t,a,s,i){const r=i.texData.get(t.dataId),o=i.makeTensorInfo(s,t.dtype),l=i.texData.get(o.dataId);Object.assign(l,r),l.refCount=1,l.shape=s,l.dtype=t.dtype;let n=e.slice_util.computeFlatOffset(a,e.util.computeStrides(t.shape));r.slice&&(n+=r.slice.flatOffset),l.slice={flatOffset:n,origDataId:r.slice&&r.slice.origDataId||t.dataId};const c=i.dataRefCount.get(l.slice.origDataId)||1;return i.dataRefCount.set(l.slice.origDataId,c+1),o}function r(r){const{inputs:o,backend:l,attrs:n}=r,{x:c}=o,{begin:d,size:u}=n,[p,f]=e.slice_util.parseSliceParams(c,d,u);if(e.slice_util.assertParamsValid(c,p,f),0===e.util.sizeFromShape(f))return l.makeTensorInfo(f,c.dtype,[]);if(l.shouldExecuteOnCPU([c])||"string"===c.dtype){const e=l.texData.get(c.dataId),a=(0,t.sliceImplCPU)(e.values,p,f,c.shape,c.dtype);return l.makeTensorInfo(f,c.dtype,a)}const{isPacked:g}=l.texData.get(c.dataId),I=e.slice_util.isSliceContinous(c.shape,p,f);if(g||!I){const t=(0,e.env)().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new s.SlicePackedProgram(f):new a.SliceProgram(f),i=[p];return l.runWebGLProgram(t,[c],c.dtype,i)}return l.uploadToGPU(c.dataId),i(c,p,f,l)}const o=exports.sliceConfig={kernelName:e.Slice,backendName:"webgl",kernelFunc:r};
},{"@tensorflow/tfjs-core":"kSBl","../kernel_utils/shared":"cNPH","../slice_gpu":"utcd","../slice_packed_gpu":"z2Lk"}],"Tq84":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.batchToSpaceNDConfig=exports.batchToSpaceND=void 0;var e=require("@tensorflow/tfjs-core"),t=require("./Reshape"),a=require("./Slice"),s=require("./Transpose");const n=n=>{const{inputs:r,backend:c,attrs:p}=n,{x:o}=r,{blockShape:i,crops:h}=p;e.util.assert(o.shape.length<=4,()=>"batchToSpaceND for rank > 4 with a WebGL backend not implemented yet");const u=i.reduce((e,t)=>e*t),d=e.backend_util.getReshaped(o.shape,i,u),l=e.backend_util.getPermuted(d.length,i.length),b=e.backend_util.getReshapedPermuted(o.shape,i,u),k=e.backend_util.getSliceBeginCoords(h,i.length),g=e.backend_util.getSliceSize(b,h,i.length),S=[],x=(0,t.reshape)({inputs:{x:o},backend:c,attrs:{shape:d}}),f=(0,s.transpose)({inputs:{x:x},backend:c,attrs:{perm:l}}),m=(0,t.reshape)({inputs:{x:f},backend:c,attrs:{shape:b}}),N=(0,a.slice)({inputs:{x:m},backend:c,attrs:{begin:k,size:g}});return S.push(x),S.push(f),S.push(m),S.forEach(e=>c.disposeIntermediateTensorInfo(e)),N};exports.batchToSpaceND=n;const r=exports.batchToSpaceNDConfig={kernelName:e.BatchToSpaceND,backendName:"webgl",kernelFunc:n};
},{"@tensorflow/tfjs-core":"kSBl","./Reshape":"OCN8","./Slice":"i5TP","./Transpose":"ukag"}],"ZZuu":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.bincount=t,exports.bincountConfig=void 0;var e=require("@tensorflow/tfjs-core"),n=require("../kernel_utils/shared");function t(e){const{inputs:t,backend:r,attrs:o}=e,{x:s,weights:i}=t,{size:a}=o,c=r.readSync(s.dataId),u=r.readSync(i.dataId),d=(0,n.bincountImplCPU)(c,u,i.dtype,i.shape,a);return r.makeTensorInfo([a],i.dtype,d)}const r=exports.bincountConfig={kernelName:e.Bincount,backendName:"webgl",kernelFunc:t};
},{"@tensorflow/tfjs-core":"kSBl","../kernel_utils/shared":"cNPH"}],"uEw3":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.BITWISEAND_UNPACKED=exports.BITWISEAND=void 0,exports.bitwiseAnd=s,exports.bitwiseAndConfig=void 0;var e=require("@tensorflow/tfjs-core"),t=require("../binaryop_gpu"),n=require("../binaryop_packed_gpu"),r=require("../kernel_utils/shared");const a=exports.BITWISEAND="\n  int r = int(a.r) & int(b.r);\n  int g = int(a.g) & int(b.g);\n  int rb = int(a.b) & int(b.b);\n  int ra = int(a.a) & int(b.a);\n  return vec4(r, g, rb, ra);\n",i=exports.BITWISEAND_UNPACKED="\n  return float(int(a.r) & int(b.r));\n";function s(s){const{inputs:o,backend:p}=s,{a:d,b:u}=o,b=(0,e.env)().getBool("WEBGL_PACK_BINARY_OPERATIONS"),g=(0,e.env)().getNumber("WEBGL_VERSION");if(p.shouldExecuteOnCPU([d,u])||1===g){const e=p.texData.get(d.dataId).values,t=p.texData.get(u.dataId).values,[n,a]=(0,r.bitwiseAndImplCPU)(d.shape,u.shape,e,t,d.dtype),i=p.makeTensorInfo(a,d.dtype);return p.texData.get(i.dataId).values=n,i}let l;return l=b?new n.BinaryOpPackedProgram(a,d.shape,u.shape,!1):new t.BinaryOpProgram(i,d.shape,u.shape),p.runWebGLProgram(l,[d,u],d.dtype)}const o=exports.bitwiseAndConfig={kernelName:e.BitwiseAnd,backendName:"webgl",kernelFunc:s};
},{"@tensorflow/tfjs-core":"kSBl","../binaryop_gpu":"wbV2","../binaryop_packed_gpu":"mFR1","../kernel_utils/shared":"cNPH"}],"imIn":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.broadcastArgs=e,exports.broadcastArgsConfig=void 0;var r=require("@tensorflow/tfjs-core");function e(e){const{inputs:a,backend:t}=e,{s0:s,s1:o}=a,n=t.readSync(s.dataId),d=t.readSync(o.dataId),c=r.backend_util.assertAndGetBroadcastShape(Array.from(n),Array.from(d));return t.makeTensorInfo([c.length],"int32",Int32Array.from(c))}const a=exports.broadcastArgsConfig={kernelName:r.BroadcastArgs,backendName:"webgl",kernelFunc:e};
},{"@tensorflow/tfjs-core":"kSBl"}],"Fgvd":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.notEqualConfig=exports.notEqual=void 0;var e=require("@tensorflow/tfjs-core"),r=require("../kernel_utils/kernel_funcs_utils"),t=require("../kernel_utils/shared");const l="return float(a != b);",n=exports.notEqual=(0,r.binaryKernelFunc)({opSnippet:l,cpuKernelImpl:t.notEqualImplCPU,dtype:"bool"}),o=exports.notEqualConfig={kernelName:e.NotEqual,backendName:"webgl",kernelFunc:n};
},{"@tensorflow/tfjs-core":"kSBl","../kernel_utils/kernel_funcs_utils":"ciwP","../kernel_utils/shared":"cNPH"}],"Jbfj":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.real=r,exports.realConfig=void 0;var e=require("@tensorflow/tfjs-core"),t=require("./Identity");function r(e){const{inputs:r,backend:n}=e,{input:o}=r,a=n.texData.get(o.dataId);return(0,t.identity)({inputs:{x:a.complexTensorInfos.real},backend:n})}const n=exports.realConfig={kernelName:e.Real,backendName:"webgl",kernelFunc:r};
},{"@tensorflow/tfjs-core":"kSBl","./Identity":"LUQG"}],"obtE":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.int=t;var e=require("../unaryop_gpu");const r="return float(int(x));";function t(t,a){const n=new e.UnaryOpProgram(t.shape,r),o=a.runWebGLProgram(n,[t],"int32");return{dataId:o.dataId,shape:o.shape,dtype:o.dtype}}
},{"../unaryop_gpu":"CK3x"}],"Yp2K":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.cast=p,exports.castConfig=void 0;var e=u(require("@tensorflow/tfjs-core")),t=e,n=require("../kernel_utils/shared"),r=require("./Complex"),o=require("./Identity"),s=require("./NotEqual"),a=require("./Real"),i=require("../kernel_utils/int");function u(e,t){if("function"==typeof WeakMap)var n=new WeakMap,r=new WeakMap;return(u=function(e,t){if(!t&&e&&e.__esModule)return e;var o,s,a={__proto__:null,default:e};if(null===e||"object"!=typeof e&&"function"!=typeof e)return a;if(o=t?r:n){if(o.has(e))return o.get(e);o.set(e,a)}for(const n in e)"default"!==n&&{}.hasOwnProperty.call(e,n)&&((s=(o=Object.defineProperty)&&Object.getOwnPropertyDescriptor(e,n))&&(s.get||s.set)?o(a,n,s):a[n]=e[n]);return a})(e,t)}function p(u){const{inputs:d,backend:c,attrs:l}=u,{x:f}=d,{dtype:y}=l;if("complex64"===y){if("complex64"===f.dtype)return(0,o.identity)({inputs:{x:f},backend:c});const e=t.zeros(f.shape),n=p({inputs:{x:f},backend:c,attrs:{dtype:"float32"}}),s=(0,r.complex)({inputs:{real:n,imag:e},backend:c});return e.dispose(),c.disposeIntermediateTensorInfo(n),s}if("complex64"===f.dtype){const e=(0,a.real)({inputs:{input:f},backend:c}),t=p({inputs:{x:e},backend:c,attrs:{dtype:y}});return c.disposeIntermediateTensorInfo(e),t}if(!e.util.hasEncodingLoss(f.dtype,y)){const e=(0,o.identity)({inputs:{x:f},backend:c});return{dataId:e.dataId,shape:e.shape,dtype:y}}if(c.shouldExecuteOnCPU([f])){const e=c.texData.get(f.dataId).values,[t,r,o]=(0,n.castImplCPU)(e,f.shape,f.dtype,y);return c.makeTensorInfo(t,r,o)}if("int32"===y)return(0,i.int)(f,c);if("bool"===y){const t=c.makeTensorInfo([],"bool",e.util.getTypedArrayFromDType("bool",1)),n={a:f,b:t},r=(0,s.notEqual)({inputs:n,backend:c});return c.disposeIntermediateTensorInfo(t),r}throw new Error(`Error in Cast: failed to cast ${f.dtype} to ${y}`)}const d=exports.castConfig={kernelName:e.Cast,backendName:"webgl",kernelFunc:p};
},{"@tensorflow/tfjs-core":"kSBl","../kernel_utils/shared":"cNPH","./Complex":"BU0Z","./Identity":"LUQG","./NotEqual":"Fgvd","./Real":"Jbfj","../kernel_utils/int":"obtE"}],"RdSo":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.ceilConfig=exports.ceil=void 0;var e=require("@tensorflow/tfjs-core"),r=require("../kernel_utils/kernel_funcs_utils"),l=require("../kernel_utils/shared");const i="return ceil(x);",n=exports.ceil=(0,r.unaryKernelFunc)({opSnippet:i,packedOpSnippet:i,cpuKernelImpl:l.ceilImplCPU}),t=exports.ceilConfig={kernelName:e.Ceil,backendName:"webgl",kernelFunc:n};
},{"@tensorflow/tfjs-core":"kSBl","../kernel_utils/kernel_funcs_utils":"ciwP","../kernel_utils/shared":"cNPH"}],"TBVD":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.ClipProgram=void 0;class t{constructor(t){this.variableNames=["A"],this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=t,this.userCode="\n\n      void main() {\n        float value = getAAtOutCoords();\n        if (isnan(value)) {\n          setOutput(value);\n          return;\n        }\n\n        setOutput(clamp(value, minVal, maxVal));\n      }\n    "}}exports.ClipProgram=t;
},{}],"ShEb":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.ClipPackedProgram=void 0;class e{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=e,this.userCode="\n      void main() {\n        vec4 value = getAAtOutCoords();\n\n        if (any(isnan(value))) {\n          setOutput(value);\n          return;\n        }\n\n        setOutput(clamp(value, vec4(minVal), vec4(maxVal)));\n      }\n    "}}exports.ClipPackedProgram=e;
},{}],"uqpD":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.clipByValue=p,exports.clipByValueConfig=void 0;var e=require("@tensorflow/tfjs-core"),r=require("../clip_gpu"),l=require("../clip_packed_gpu");function p(p){const{inputs:a,backend:i,attrs:n}=p,{x:o}=a,{clipValueMin:t,clipValueMax:c}=n;let u;u=(0,e.env)().getBool("WEBGL_PACK_CLIP")?new l.ClipPackedProgram(o.shape):new r.ClipProgram(o.shape);const s=[[t],[c]];return i.runWebGLProgram(u,[o],o.dtype,s)}const a=exports.clipByValueConfig={kernelName:e.ClipByValue,backendName:"webgl",kernelFunc:p};
},{"@tensorflow/tfjs-core":"kSBl","../clip_gpu":"TBVD","../clip_packed_gpu":"ShEb"}],"NIhf":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.ComplexAbsProgram=void 0;class e{constructor(e){this.variableNames=["real","imag"],this.outputShape=e,this.userCode="\n      void main() {\n        float re = abs(getRealAtOutCoords());\n        float im = abs(getImagAtOutCoords());\n        float mx = max(re, im);\n\n        // sadly the length function in glsl is not underflow-safe\n        // (at least not on Intel GPUs). So the safe solution is\n        // to ensure underflow-safety in all cases.\n        setOutput(\n          mx == 0.0 ? 0.0 : mx * length(vec2(1, min(re, im)/mx))\n        );\n      }\n    "}}exports.ComplexAbsProgram=e;
},{}],"fzhf":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.complexAbs=t,exports.complexAbsConfig=void 0;var e=require("@tensorflow/tfjs-core"),o=require("../complex_abs_gpu");function r(e,o){return{dataId:o.dataId,dtype:o.dtype,shape:e.shape}}function t(e){const{inputs:t,backend:s}=e,{x:n}=t,a=s.texData.get(n.dataId),p=new o.ComplexAbsProgram(n.shape),c=[r(n,a.complexTensorInfos.real),r(n,a.complexTensorInfos.imag)];return s.runWebGLProgram(p,c,c[0].dtype)}const s=exports.complexAbsConfig={kernelName:e.ComplexAbs,backendName:"webgl",kernelFunc:t};
},{"@tensorflow/tfjs-core":"kSBl","../complex_abs_gpu":"NIhf"}],"mfXa":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.ConcatProgram=void 0;var t=require("@tensorflow/tfjs-core");class e{constructor(e){this.outputShape=[],this.outputShape=t.backend_util.computeOutShape(e,1),this.variableNames=e.map((t,e)=>`T${e}`);const o=new Array(e.length-1);o[0]=e[0][1];for(let t=1;t<o.length;t++)o[t]=o[t-1]+e[t][1];const s=[`if (yC < ${o[0]}) setOutput(getT0(yR, yC));`];for(let t=1;t<o.length;t++){const e=o[t-1];s.push(`else if (yC < ${o[t]}) `+`setOutput(getT${t}(yR, yC-${e}));`)}const n=o.length,r=o[o.length-1];s.push(`else setOutput(getT${n}(yR, yC-${r}));`),this.userCode=`\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int yR = coords.x;\n        int yC = coords.y;\n\n        ${s.join("\n        ")}\n      }\n    `}}exports.ConcatProgram=e;
},{"@tensorflow/tfjs-core":"kSBl"}],"F0l2":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.ConcatPackedProgram=void 0;var e=require("@tensorflow/tfjs-core"),t=require("./packing_util"),n=require("./shader_compiler");class r{constructor(r,s){this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[],this.outputShape=e.backend_util.computeOutShape(r,s);const u=this.outputShape,a=u.length,$=(0,n.getCoordsDataType)(a),l=(0,t.getChannels)("coords",a),i=["x","y","z","w","u","v"].slice(0,a);this.variableNames=r.map((e,t)=>`T${t}`);const c=new Array(r.length-1);c[0]=r[0][s];for(let e=1;e<c.length;e++)c[e]=c[e-1]+r[e][s];const g=i[s],p=i.slice(-2),h=i.join();let d=`if (${g} < ${c[0]}) {\n        return getChannel(\n            getT0(${h}), vec2(${p.join()}));\n        }`;for(let e=1;e<c.length;e++){const t=c[e-1];d+=`\n        if (${g} < ${c[e]}  && ${g} >= ${c[e-1]}) {\n          return getChannel(\n            getT${e}(${o(i,g,t)}),\n            vec2(${o(p,g,t)}));\n        }`}const f=c.length,v=c[c.length-1];d+=`\n        return getChannel(\n          getT${f}(${o(i,g,v)}),\n          vec2(${o(p,g,v)}));`,this.userCode=`\n      float getValue(${i.map(e=>"int "+e)}) {\n        ${d}\n      }\n\n      void main() {\n        ${$} coords = getOutputCoords();\n        vec4 result = vec4(getValue(${l}), 0., 0., 0.);\n\n        ${l[a-1]} = ${l[a-1]} + 1;\n        if (${l[a-1]} < ${u[a-1]}) {\n          result.g = getValue(${l});\n        }\n\n        ${l[a-2]} = ${l[a-2]} + 1;\n        if (${l[a-2]} < ${u[a-2]}) {\n          result.a = getValue(${l});\n        }\n\n        ${l[a-1]} = ${l[a-1]} - 1;\n        if (${l[a-2]} < ${u[a-2]} &&\n            ${l[a-1]} < ${u[a-1]}) {\n          result.b = getValue(${l});\n        }\n        setOutput(result);\n      }\n    `}}function o(e,t,n){const r=e.indexOf(t);return e.map((e,t)=>t===r?`${e} - ${n}`:e).join()}exports.ConcatPackedProgram=r;
},{"@tensorflow/tfjs-core":"kSBl","./packing_util":"BqvU","./shader_compiler":"xhhc"}],"uHuu":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.imag=n,exports.imagConfig=void 0;var e=require("@tensorflow/tfjs-core"),t=require("./Identity");function n(e){const{inputs:n,backend:r}=e,{input:i}=n,o=r.texData.get(i.dataId);return(0,t.identity)({inputs:{x:o.complexTensorInfos.imag},backend:r})}const r=exports.imagConfig={kernelName:e.Imag,backendName:"webgl",kernelFunc:n};
},{"@tensorflow/tfjs-core":"kSBl","./Identity":"LUQG"}],"T7u8":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.concatImpl=c;var e=require("@tensorflow/tfjs-core"),r=require("../concat_gpu"),n=require("../concat_packed_gpu"),t=require("../kernel_utils/shared"),a=require("../unaryop_gpu"),s=require("../unaryop_packed_gpu"),o=require("./Complex"),p=require("./Imag"),i=require("./Real"),u=require("./Reshape");function c(h,d,l){const f=h[0].dtype;if("complex64"===f){const e=h.map(e=>(0,i.real)({inputs:{input:e},backend:l})),r=h.map(e=>(0,p.imag)({inputs:{input:e},backend:l})),n=c(e,d,l),t=c(r,d,l),a=(0,o.complex)({inputs:{real:n,imag:t},backend:l});return e.forEach(e=>l.disposeIntermediateTensorInfo(e)),r.forEach(e=>l.disposeIntermediateTensorInfo(e)),l.disposeIntermediateTensorInfo(n),l.disposeIntermediateTensorInfo(t),a}let I=l.shouldExecuteOnCPU(h);if("string"===f&&(I=!0),I){const r=h.map(r=>{const n=[-1,e.util.sizeFromShape(r.shape.slice(d))];return(0,u.reshape)({inputs:{x:r},backend:l,attrs:{shape:n}})}),n=r.map(e=>({vals:l.readSync(e.dataId),shape:e.shape})),a=e.backend_util.computeOutShape(r.map(e=>e.shape),1),s=1===r[0].shape[0],o=(0,t.concatImplCPU)(n,a,f,s),p=e.backend_util.computeOutShape(h.map(e=>e.shape),d),i=l.makeTensorInfo(p,f,o);return r.forEach(e=>l.disposeIntermediateTensorInfo(e)),i}const g=h.filter(r=>e.util.sizeFromShape(r.shape)>0),_=(0,e.env)().getBool("WEBGL_PACK_ARRAY_OPERATIONS")&&g[0].shape.length>1;if(1===g.length){const e=_?new a.UnaryOpProgram(h[0].shape,a.CLONE):new s.UnaryOpPackedProgram(h[0].shape,a.CLONE);return l.runWebGLProgram(e,h,f)}const k=(0,e.env)().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER");if(g.length>k){const e=[];for(let n=0;n<g.length;n+=k){const r=g.slice(n,n+k);e.push(c(r,d,l))}const r=c(e,d,l);for(const n of e)l.disposeIntermediateTensorInfo(n);return r}if(_){const e=new n.ConcatPackedProgram(g.map(e=>e.shape),d);return l.runWebGLProgram(e,g,f)}const{tensors2D:b,outShape:P}=m(g,d,l),E=new r.ConcatProgram(b.map(e=>e.shape)),S=l.runWebGLProgram(E,b,f);b.forEach(e=>l.disposeIntermediateTensorInfo(e));const T=(0,u.reshape)({inputs:{x:S},attrs:{shape:P},backend:l});return l.disposeIntermediateTensorInfo(S),T}function m(r,n,t){const a=e.backend_util.computeOutShape(r.map(e=>e.shape),n);return{tensors2D:r.map(r=>(0,u.reshape)({inputs:{x:r},attrs:{shape:[-1,e.util.sizeFromShape(r.shape.slice(n))]},backend:t})),outShape:a}}
},{"@tensorflow/tfjs-core":"kSBl","../concat_gpu":"mfXa","../concat_packed_gpu":"F0l2","../kernel_utils/shared":"cNPH","../unaryop_gpu":"CK3x","../unaryop_packed_gpu":"zBLd","./Complex":"BU0Z","./Imag":"uHuu","./Real":"Jbfj","./Reshape":"OCN8"}],"sjik":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.concat=a,exports.concatConfig=void 0;var e=require("@tensorflow/tfjs-core"),t=require("./Concat_impl"),n=require("./Identity");function a(a){const{inputs:r,backend:s,attrs:o}=a,{axis:i}=o,c=e.util.parseAxisParam(i,r[0].shape)[0],p=r.map(e=>e.shape);e.backend_util.assertParamsConsistent(p,c);const u=e.backend_util.computeOutShape(r.map(e=>e.shape),c);if(0===e.util.sizeFromShape(u))return s.makeTensorInfo(u,r[0].dtype,[]);const l=r.filter(t=>e.util.sizeFromShape(t.shape)>0);return 1===l.length?(0,n.identity)({inputs:{x:l[0]},backend:s}):(0,t.concatImpl)(l,c,s)}const r=exports.concatConfig={kernelName:e.Concat,backendName:"webgl",kernelFunc:a};
},{"@tensorflow/tfjs-core":"kSBl","./Concat_impl":"T7u8","./Identity":"LUQG"}],"viLo":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.Conv3DProgram=exports.Conv2DProgram=void 0;class n{constructor(n,t=!1,e=null,o=!1,a=!1){this.variableNames=["x","W"],this.outputShape=n.outShape;const d=n.padInfo.top,i=n.padInfo.left,s=n.strideHeight,x=n.strideWidth,r=n.dilationHeight,c=n.dilationWidth,C=n.filterHeight,l=n.filterWidth,w=4*Math.floor(n.inChannels/4),h=n.inChannels%4,u="channelsLast"===n.dataFormat,R=u?1:2,$=u?2:3,g=u?3:1;let v="",f="";e&&(v=o?`float activation(float a) {\n          float b = getPreluActivationWeightsAtOutCoords();\n          ${e}\n        }`:a?`float activation(float a) {\n          float b = getLeakyreluAlphaAtOutCoords();\n          ${e}\n        }`:`\n          float activation(float x) {\n            ${e}\n          }\n        `,f="result = activation(result);");const b=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),o&&this.variableNames.push("preluActivationWeights"),a&&this.variableNames.push("leakyreluAlpha"),this.userCode=`\n      ${v}\n\n      const ivec2 strides = ivec2(${s}, ${x});\n      const ivec2 pads = ivec2(${d}, ${i});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d2 = coords[${g}];\n\n        ivec2 xRCCorner =\n            ivec2(coords[${R}], coords[${$}]) * strides - pads;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // Convolve x(?, ?, d1) with w(:, :, d1, d2) to get y(yR, yC, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${C}; wR++) {\n          int xR = xRCorner + wR * ${r};\n\n          if (xR < 0 || xR >= ${n.inHeight}) {\n            continue;\n          }\n\n          for (int wC = 0; wC < ${l}; wC++) {\n            int xC = xCCorner + wC * ${c};\n\n            if (xC < 0 || xC >= ${n.inWidth}) {\n              continue;\n            }\n\n            for (int d1 = 0; d1 < ${w}; d1 += 4) {\n              vec4 wValues = vec4(\n                getW(wR, wC, d1, d2),\n                getW(wR, wC, d1 + 1, d2),\n                getW(wR, wC, d1 + 2, d2),\n                getW(wR, wC, d1 + 3, d2)\n              );\n\n              if (${u}) {\n                vec4 xValues = vec4(\n                  getX(batch, xR, xC, d1),\n                  getX(batch, xR, xC, d1 + 1),\n                  getX(batch, xR, xC, d1 + 2),\n                  getX(batch, xR, xC, d1 + 3)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec4 xValues = vec4(\n                  getX(batch, d1, xR, xC),\n                  getX(batch, d1 + 1, xR, xC),\n                  getX(batch, d1 + 2, xR, xC),\n                  getX(batch, d1 + 3, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n            }\n\n            if (${1===h}) {\n\n              if (${u}) {\n                dotProd +=\n                    getX(batch, xR, xC, ${w}) *\n                    getW(wR, wC, ${w}, d2);\n              } else {\n                dotProd +=\n                    getX(batch, ${w}, xR, xC) *\n                    getW(wR, wC, ${w}, d2);\n              }\n\n            } else if (${2===h}) {\n              vec2 wValues = vec2(\n                getW(wR, wC, ${w}, d2),\n                getW(wR, wC, ${w} + 1, d2)\n              );\n\n              if (${u}) {\n                vec2 xValues = vec2(\n                  getX(batch, xR, xC, ${w}),\n                  getX(batch, xR, xC, ${w} + 1)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec2 xValues = vec2(\n                  getX(batch, ${w}, xR, xC),\n                  getX(batch, ${w} + 1, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n\n            } else if (${3===h}) {\n              vec3 wValues = vec3(\n                getW(wR, wC, ${w}, d2),\n                getW(wR, wC, ${w} + 1, d2),\n                getW(wR, wC, ${w} + 2, d2)\n              );\n\n              if (${u}) {\n                vec3 xValues = vec3(\n                  getX(batch, xR, xC, ${w}),\n                  getX(batch, xR, xC, ${w} + 1),\n                  getX(batch, xR, xC, ${w} + 2)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec3 xValues = vec3(\n                  getX(batch, ${w}, xR, xC),\n                  getX(batch, ${w} + 1, xR, xC),\n                  getX(batch, ${w} + 2, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n\n            }\n          }\n        }\n\n        float result = dotProd;\n        ${b}\n        ${f}\n        setOutput(result);\n      }\n    `}}exports.Conv2DProgram=n;class t{constructor(n){this.variableNames=["x","W"],this.outputShape=n.outShape;const t=n.padInfo.front,e=n.padInfo.top,o=n.padInfo.left,a=n.strideDepth,d=n.strideHeight,i=n.strideWidth,s=n.dilationDepth,x=n.dilationHeight,r=n.dilationWidth,c=n.filterDepth,C=n.filterHeight,l=n.filterWidth,w=4*Math.floor(n.inChannels/4),h=n.inChannels%4;this.userCode=`\n      const ivec3 strides = ivec3(${a}, ${d}, ${i});\n      const ivec3 pads = ivec3(${t}, ${e}, ${o});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int d2 = coords.u;\n\n        ivec3 xFRCCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n        int xFCorner = xFRCCorner.x;\n        int xRCorner = xFRCCorner.y;\n        int xCCorner = xFRCCorner.z;\n\n        // Convolve x(?, ?, ?, d1) with w(:, :, :, d1, d2) to get\n        // y(yF, yR, yC, d2). ? = to be determined. : = across all\n        // values in that axis.\n        float dotProd = 0.0;\n        for (int wF = 0; wF < ${c}; wF++) {\n          int xF = xFCorner + wF * ${s};\n\n          if (xF < 0 || xF >= ${n.inDepth}) {\n            continue;\n          }\n\n          for (int wR = 0; wR < ${C}; wR++) {\n            int xR = xRCorner + wR * ${x};\n\n            if (xR < 0 || xR >= ${n.inHeight}) {\n              continue;\n            }\n\n            for (int wC = 0; wC < ${l}; wC++) {\n              int xC = xCCorner + wC * ${r};\n\n              if (xC < 0 || xC >= ${n.inWidth}) {\n                continue;\n              }\n\n              for (int d1 = 0; d1 < ${w}; d1 += 4) {\n                vec4 xValues = vec4(\n                  getX(batch, xF, xR, xC, d1),\n                  getX(batch, xF, xR, xC, d1 + 1),\n                  getX(batch, xF, xR, xC, d1 + 2),\n                  getX(batch, xF, xR, xC, d1 + 3)\n                );\n                vec4 wValues = vec4(\n                  getW(wF, wR, wC, d1, d2),\n                  getW(wF, wR, wC, d1 + 1, d2),\n                  getW(wF, wR, wC, d1 + 2, d2),\n                  getW(wF, wR, wC, d1 + 3, d2)\n                );\n\n                dotProd += dot(xValues, wValues);\n              }\n\n              if (${1===h}) {\n                dotProd +=\n                  getX(batch, xF, xR, xC, ${w}) *\n                  getW(wF, wR, wC, ${w}, d2);\n              } else if (${2===h}) {\n                vec2 xValues = vec2(\n                  getX(batch, xF, xR, xC, ${w}),\n                  getX(batch, xF, xR, xC, ${w} + 1)\n                );\n                vec2 wValues = vec2(\n                  getW(wF, wR, wC, ${w}, d2),\n                  getW(wF, wR, wC, ${w} + 1, d2)\n                );\n                dotProd += dot(xValues, wValues);\n              } else if (${3===h}) {\n                vec3 xValues = vec3(\n                  getX(batch, xF, xR, xC, ${w}),\n                  getX(batch, xF, xR, xC, ${w} + 1),\n                  getX(batch, xF, xR, xC, ${w} + 2)\n                );\n                vec3 wValues = vec3(\n                  getW(wF, wR, wC, ${w}, d2),\n                  getW(wF, wR, wC, ${w} + 1, d2),\n                  getW(wF, wR, wC, ${w} + 2, d2)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}exports.Conv3DProgram=t;
},{}],"g3Bb":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.Conv2DPackedProgram=void 0;var e=require("@tensorflow/tfjs-core"),n=require("./gpgpu_math");class x{constructor(x,t=!1,i=null,s=!1,C=!1){this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=x.outShape,this.enableShapeUniforms=(0,n.useShapeUniforms)(this.outputShape.length);const l=x.padInfo.left,a=x.strideWidth,f=x.dilationWidth,r=x.filterHeight,c=x.filterWidth,d=c;let o="\n       int xR; int xC; int xCOffset;\n       vec4 wTexel; vec4 previous; vec4 final;";for(let e=0;e<c;e++)o+=`\n           vec4 xTexelC${2*e};\n           int xTexelC${2*e}Ready;\n           vec4 xTexelC${2*e+1};\n           int xTexelC${2*e+1}Ready;\n           vec4 xC${e};`;o+=`\n     for (int r = 0; r < ${r}; r++) {\n      for (int d1 = 0; d1 < ${x.inChannels}; d1 += 2) {\n       `;for(let e=0;e<c;e++)o+=`\n           xTexelC${2*e} = vec4(0.0);\n           xTexelC${2*e}Ready = 0;\n           xTexelC${2*e+1} = vec4(0.0);\n           xTexelC${2*e+1}Ready = 0;\n           xC${e} = vec4(0.0);`;o+="\n         xR = xRCorner + r * dilations[0];\n         if (xR >=0 && xR < inDims[0]) {\n       ";for(let n=0;n<(d+1)/2;n++){const t=2*n;if(o+=`\n           xC = xCCorner + ${t*f};\n           `,1===a){if(t<c&&(l%2==1?(o+=`\n                 xCOffset = xC + 1;\n                 if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${t}Ready == 0) {\n                   xTexelC${t} = getX(batch, xR, xCOffset, d1);\n\n                   // Need to manually clear unused channels in case\n                   // we're reading from recycled texture.\n                   if (xCOffset + 1 >= inDims[1]) {\n                     xTexelC${t}.zw = vec2(0.0);\n                   }\n                   xTexelC${t}Ready = 1;\n                 }\n               `,o+=1===f&&t>0?`\n                 xC${t} = vec4(xTexelC${t-2}.zw, xTexelC${t}.xy);\n                 `:`\n                   xCOffset = xC + 1 - 2;\n\n                   if (xCOffset >= 0 && xCOffset < inDims[1]) {\n                     previous = getX(batch, xR, xCOffset, d1);\n\n                     // Need to manually clear unused channels in case\n                     // we're reading from recycled texture.\n                     if (xCOffset + 1 >= inDims[1]) {\n                       previous.zw = vec2(0.0);\n                     }\n\n                     xC${t} = vec4(previous.zw, xTexelC${t}.xy);\n                   } else {\n                     xC${t} = vec4(0.0, 0.0, xTexelC${t}.xy);\n                   }\n                   `):o+=`\n                 if (xC >= 0 && xC < inDims[1] && xTexelC${t}Ready == 0) {\n                   xTexelC${t} = getX(batch, xR, xC, d1);\n                   if (xC + 1 >= inDims[1]) {\n                     xTexelC${t}.zw = vec2(0.0);\n                   }\n                   xTexelC${t}Ready = 1;\n                 }\n\n                 xC${t} = xTexelC${t};\n                 `,t+1<c)){const n=l%2==0?e.util.nearestLargerEven(f):f;f%2==0&&l%2==1||f%2!=0&&l%2!=1?(o+=`\n                   xCOffset = xC + imod(pads[1], 2) + ${n};\n\n                   if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${t+1}Ready == 0) {\n                     xTexelC${t+1} = getX(batch, xR, xCOffset, d1);\n\n                     // Need to manually clear unused channels in case\n                     // we're reading from recycled texture.\n                     if (xCOffset + 1 >= inDims[1]) {\n                       xTexelC${t+1}.zw = vec2(0.0);\n                     }\n                     xTexelC${t+1}Ready = 1;\n                   }\n                   `,o+=f>1?`\n                     xCOffset -= 2;\n                     if (xCOffset >= 0 && xCOffset < inDims[1]) {\n                      previous = getX(batch, xR, xCOffset, d1);\n                      xC${t+1} = vec4(previous.zw, xTexelC${t+1}.xy);\n                     } else {\n                      xC${t+1} = vec4(0.0, 0.0, xTexelC${t+1}.xy);\n                     }\n                     `:`\n                     xC${t+1} = vec4(xTexelC${t}.zw, xTexelC${t+1}.xy);\n                     `):o+=1===n?`\n                     xC${t+1} = xTexelC${t};\n                     `:`\n                     xCOffset = xC + ${n};\n\n                     if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${t+1}Ready == 0) {\n                       xTexelC${t+1} = getX(batch, xR, xCOffset, d1);\n                       if (xCOffset + 1 >= inDims[1]) {\n                         xTexelC${t+1}.zw = vec2(0.0);\n                       }\n                       xTexelC${t+1}Ready = 1;\n                     }\n\n                     xC${t+1} = xTexelC${t+1};\n                     `}}else t<c&&(l%2==1?(o+=`\n                 xCOffset = xC + 1 - strides[1];\n                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${t}Ready == 0) {\n                   xTexelC${t} = getX(batch, xR, xCOffset, d1);\n                   // Need to manually clear unused channels in case\n                   // we're reading from recycled texture.\n                   if (xCOffset + 1 >= inDims[1]) {\n                     xTexelC${t}.zw = vec2(0.0);\n                   }\n                   xTexelC${t}Ready = 1;\n                 }\n\n                 if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC${t+1}Ready == 0) {\n                   xTexelC${t+1} = getX(batch, xR, xC + 1, d1);\n                   // Need to manually clear unused channels in case\n                   // we're reading from recycled texture.\n                   if (xC + 2 >= inDims[1]) {\n                     xTexelC${t+1}.zw = vec2(0.0);\n                   }\n                   xTexelC${t+1}Ready = 1;\n                 }\n\n                 xC${t} = vec4(xTexelC${t}.zw, xTexelC${t+1}.zw);\n               `,t+1<c&&(o+=`\n                   final = vec4(0.0);\n                   xCOffset = xC + 1 + strides[1];\n                   if(xCOffset >= 0 && xCOffset < inDims[1]) {\n                     final = getX(batch, xR, xCOffset, d1);\n                   }\n                   xC${t+1} = vec4(xTexelC${t+1}.xy, final.xy);\n                 `)):(o+=`\n                 if(xC >= 0 && xC < inDims[1] && xTexelC${t}Ready == 0) {\n                   xTexelC${t} = getX(batch, xR, xC, d1);\n                   if (xC + 1 >= inDims[1]) {\n                     xTexelC${t}.zw = vec2(0.0);\n                   }\n                   xTexelC${t}Ready = 1;\n                 }\n\n                 xCOffset = xC + strides[1];\n                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${t+1}Ready == 0) {\n                   xTexelC${t+1} = getX(batch, xR, xCOffset, d1);\n                   if (xCOffset + 1 >= inDims[1]) {\n                     xTexelC${t+1}.zw = vec2(0.);\n                   }\n                   xTexelC${t+1}Ready = 1;\n                 }\n\n                 xC${t} = vec4(\n                   xTexelC${t}.xy, xTexelC${t+1}.xy);\n               `,t+1<c&&(o+=`\n                   xC${t+1} = vec4(xTexelC${t}.zw, xTexelC${t+1}.zw);\n                 `)));t<c&&(o+=`\n             wTexel = getW(r, ${t}, d1, d2);\n             dotProd += xC${t}.xxzz * vec4(wTexel.xy, wTexel.xy);\n             if(d1 + 1 < ${x.inChannels}) {\n               dotProd += xC${t}.yyww * vec4(wTexel.zw, wTexel.zw);\n             }\n           `,t+1<c&&(o+=`\n               wTexel = getW(r, ${t+1}, d1, d2);\n               dotProd += xC${t+1}.xxzz * vec4(wTexel.xy, wTexel.xy);\n               if(d1 + 1 < ${x.inChannels}) {\n                 dotProd += xC${t+1}.yyww * vec4(wTexel.zw, wTexel.zw);\n               }\n             `))}o+="\n     }\n   ",o+="\n     }\n   ",o+="\n     }\n   ";let $="",v="";i&&($=s?`vec4 activation(vec4 a) {\n           vec4 b = getPreluActivationWeightsAtOutCoords();\n           ${i}\n         }`:C?`vec4 activation(vec4 a) {\n           vec4 b = getLeakyreluAlphaAtOutCoords();\n           ${i}\n         }`:`vec4 activation(vec4 x) {\n           ${i}\n         }`,v="result = activation(result);");const T=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),s&&this.variableNames.push("preluActivationWeights"),C&&this.variableNames.push("leakyreluAlpha"),this.userCode=`\n       ${$}\n\n       void main() {\n         ivec4 coords = getOutputCoords();\n         int batch = coords.x;\n         ivec2 xRCCorner = coords.yz * strides - pads;\n         int d2 = coords.w;\n         int xRCorner = xRCCorner.x;\n         int xCCorner = xRCCorner.y;\n\n         //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.\n         vec4 dotProd = vec4(0.000000000000001);\n\n         ${o}\n\n         vec4 result = dotProd - vec4(0.000000000000001);\n         ${T}\n         ${v}\n         setOutput(result);\n       }\n     `}}exports.Conv2DPackedProgram=x;
},{"@tensorflow/tfjs-core":"kSBl","./gpgpu_math":"eeKH"}],"bI75":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.Im2ColPackedProgram=void 0;var e=require("./glsl_version"),n=require("./gpgpu_math");class t{constructor(t,i){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec4"},{name:"pad",type:"ivec2"},{name:"stride",type:"ivec2"},{name:"dilation",type:"ivec2"},{name:"inChannels",type:"int"},{name:"itemsPerBlockRow",type:"int"},{name:"outWidth",type:"int"}],this.outputShape=t,this.enableShapeUniforms=(0,n.useShapeUniforms)(this.outputShape.length);const{dataFormat:s}=i,o=(0,e.getGlslDifferences)(),r="channelsLast"===s,a=r?1:2,d=r?2:3,p=this.enableShapeUniforms?"if(blockIndex < outShape[2] && pos < outShape[1]) {":`if(blockIndex < ${t[2]} && pos < ${t[1]}) {`;let c="";for(let e=0;e<=1;e++)for(let n=0;n<=1;n++)c+=`\n          blockIndex = rc.z + ${n};\n          pos = rc.y + ${e};\n\n          ${p}\n            offsetY = int(blockIndex / outWidth) * stride[0] - pad[0];\n            d0 = offsetY + dilation[0] * (pos / itemsPerBlockRow);\n\n            if(d0 < inputShape[${a}] && d0 >= 0) {\n              // Use custom imod instead mod. On Intel GPU, mod may generate\n              // unexpected value.\n              // https://github.com/tensorflow/tfjs/issues/5447\n              offsetX = imod(blockIndex, outWidth) * stride[1] - pad[1];\n              d1 = offsetX + dilation[1] * (imod(pos, itemsPerBlockRow) /\n                  inChannels);\n\n              if(d1 < inputShape[${d}] && d1 >= 0) {\n\n                ch = imod(pos, inChannels);\n\n                if (${r}) {\n                  innerDims = vec2(d1, ch);\n                  result[${2*e+n}] = getChannel(\n                    getA(rc.x, d0, int(innerDims.x),\n                    int(innerDims.y)), innerDims);\n                } else {\n                  innerDims = vec2(d0, d1);\n                  result[${2*e+n}] = getChannel(\n                    getA(rc.x, ch, int(innerDims.x),\n                    int(innerDims.y)), innerDims);\n                }\n              }\n            }\n          }\n        `;this.userCode=`\n      void main() {\n        ivec3 rc = getOutputCoords();\n\n        vec4 result = vec4(0);\n\n        int blockIndex, pos, offsetY, d0, offsetX, d1, ch;\n        vec2 innerDims;\n\n        ${c}\n\n        ${o.output} = result;\n      }\n    `}}exports.Im2ColPackedProgram=t;
},{"./glsl_version":"fXvw","./gpgpu_math":"eeKH"}],"CtO4":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.conv2dByMatMul=h,exports.conv2dWithIm2Row=o;var e=require("@tensorflow/tfjs-core"),t=require("../im2col_packed_gpu"),a=require("../kernel_utils/kernel_funcs_utils"),s=require("../mulmat_packed_gpu"),n=p(require("../webgl_util")),i=require("./BatchMatMul_impl"),l=require("./Identity"),r=require("./Reshape");function p(e,t){if("function"==typeof WeakMap)var a=new WeakMap,s=new WeakMap;return(p=function(e,t){if(!t&&e&&e.__esModule)return e;var n,i,l={__proto__:null,default:e};if(null===e||"object"!=typeof e&&"function"!=typeof e)return l;if(n=t?s:a){if(n.has(e))return n.get(e);n.set(e,l)}for(const a in e)"default"!==a&&{}.hasOwnProperty.call(e,a)&&((i=(n=Object.defineProperty)&&Object.getOwnPropertyDescriptor(e,a))&&(i.get||i.set)?n(l,a,i):l[a]=e[a]);return l})(e,t)}function u(e,t){const a=e.length;return a>=3?t?[...e.slice(0,-3),e[a-3]*e[a-2],e[a-1]]:[...e.slice(0,-3),e[a-3],e[a-2]*e[a-1]]:!t&&1===a&&e[0]>1?[e[0],1]:null}function h({x:t,filter:a,convInfo:s,backend:p,bias:h=null,preluActivationWeights:o=null,leakyreluAlpha:c=0,activation:d=null}){const f=t.shape,b=p.texData.get(t.dataId),k=s.inChannels,g=f[0]*f[1]*f[2],x=s.outChannels,m="channelsLast"===s.dataFormat;let M;const _=[];if(null!=o){const e=u(o.shape,m);null!=e&&(o=(0,r.reshape)({inputs:{x:o},backend:p,attrs:{shape:e}}),_.push(o))}if(null!=h){const e=u(h.shape,m);null!=e&&(h=(0,r.reshape)({inputs:{x:h},backend:p,attrs:{shape:e}}),_.push(h))}if(!((1===g||1===x)&&k>i.MATMUL_SHARED_DIM_THRESHOLD)&&b.isPacked&&m&&null!=b.texture&&f[2]%2!=0&&e.util.arraysEqual(b.shape.slice(-3),f.slice(-3))){const u=f[0]*f[1]*(f[2]+1),k={dataId:t.dataId,shape:[1,u,s.inChannels],dtype:t.dtype},g=b.shape;b.shape=b.shape.slice(),b.shape[b.shape.length-2]++,e.util.assert(n.isReshapeFree(b.shape,k.shape),()=>`packed reshape ${b.shape} to ${k.shape} isn't free`);const x=(0,r.reshape)({inputs:{x:a},backend:p,attrs:{shape:[1,s.inChannels,s.outChannels]}});_.push(x);const m=(0,i.batchMatMulImpl)({a:k,b:x,backend:p,transposeA:!1,transposeB:!1,bias:h,activation:d,preluActivationWeights:o,leakyreluAlpha:c}),I=p.texData.get(m.dataId);e.util.assert(I.isPacked,()=>"batchMatMul result is expected to be packed"),b.shape=g,I.shape=s.outShape,(M=(0,l.identity)({inputs:{x:m},backend:p})).shape=s.outShape,_.push(m)}else{const e=s.outHeight*s.outWidth,n=(0,r.reshape)({inputs:{x:t},backend:p,attrs:{shape:m?[s.batchSize,e,s.inChannels]:[s.batchSize,s.inChannels,e]}}),l=(0,r.reshape)({inputs:{x:a},backend:p,attrs:{shape:[1,s.inChannels,s.outChannels]}}),u=(0,i.batchMatMulImpl)({a:m?n:l,b:m?l:n,transposeA:!m,transposeB:!1,backend:p,bias:h,activation:d,preluActivationWeights:o,leakyreluAlpha:c});M=(0,r.reshape)({inputs:{x:u},backend:p,attrs:{shape:s.outShape}}),_.push(n),_.push(l),_.push(u)}for(const e of _)p.disposeIntermediateTensorInfo(e);return M}function o({x:n,filter:i,convInfo:l,backend:p,bias:h=null,preluActivationWeights:o=null,leakyreluAlpha:c=0,activation:d=null}){const{filterWidth:f,filterHeight:b,inChannels:k,outWidth:g,outHeight:x,dataFormat:m}=l,M="channelsLast"===m,_=f*b*k,I=x*g,y=[l.batchSize,_,I],v=[];if(null!=o){const e=u(o.shape,M);null!=e&&(o=(0,r.reshape)({inputs:{x:o},backend:p,attrs:{shape:e}}),v.push(o))}if(null!=h){const e=u(h.shape,M);null!=e&&(h=(0,r.reshape)({inputs:{x:h},backend:p,attrs:{shape:e}}),v.push(h))}const W=(0,r.reshape)({inputs:{x:i},backend:p,attrs:{shape:[1,_,e.util.sizeFromShape(i.shape)/_]}});v.push(W);const C=new t.Im2ColPackedProgram(y,l),S=[n.shape,[l.padInfo.top,l.padInfo.left],[l.strideHeight,l.strideWidth],[l.dilationHeight,l.dilationWidth],[l.inChannels],[l.filterWidth*l.inChannels],[l.outWidth]],A=p.runWebGLProgram(C,[n],"float32",S),P=(0,r.reshape)({inputs:{x:A},backend:p,attrs:{shape:y}});v.push(A),v.push(P);const q=null!=h,w=null!=o,H="leakyrelu"===d,z=d?(0,a.mapActivationToShaderProgram)(d,!0):null,D=new s.MatMulPackedProgram(M?P.shape:W.shape,M?W.shape:P.shape,M?[l.batchSize,I,l.outChannels]:[l.batchSize,l.outChannels,I],!0,!1,q,z,w,H),L=M?[P,W]:[W,P];if(h&&L.push(h),w&&L.push(o),H){const t=p.makeTensorInfo([],"float32",e.util.createScalarValue(c,"float32"));L.push(t),v.push(t)}const O=p.runWebGLProgram(D,L,"float32"),T=(0,r.reshape)({inputs:{x:O},backend:p,attrs:{shape:l.outShape}});v.push(O);for(const e of v)p.disposeIntermediateTensorInfo(e);return T}
},{"@tensorflow/tfjs-core":"kSBl","../im2col_packed_gpu":"bI75","../kernel_utils/kernel_funcs_utils":"ciwP","../mulmat_packed_gpu":"QKYo","../webgl_util":"u1ML","./BatchMatMul_impl":"kzNd","./Identity":"LUQG","./Reshape":"OCN8"}],"UXwB":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.conv2DConfig=void 0,exports.conv2d=r;var e=require("@tensorflow/tfjs-core"),t=require("../conv_gpu"),n=require("../conv_packed_gpu"),o=require("./Conv2D_impl"),i=require("./Reshape");function r(r){const{inputs:a,backend:d,attrs:s}=r,{x:c,filter:l}=a,{strides:p,pad:f,dataFormat:u,dilations:h,dimRoundingMode:v}=s,g=e.backend_util.convertConv2DDataFormat(u),m=e.backend_util.computeConv2DInfo(c.shape,l.shape,p,h,f,v,!1,g);let I;if(1!==m.filterHeight||1!==m.filterWidth||1!==m.dilationHeight||1!==m.dilationWidth||1!==m.strideHeight||1!==m.strideWidth||"SAME"!==m.padInfo.type&&"VALID"!==m.padInfo.type)if(m.strideWidth<=2&&"channelsLast"===g&&(0,e.env)().getBool("WEBGL_EXP_CONV")){const e=new n.Conv2DPackedProgram(m),t=[[m.padInfo.top,m.padInfo.left],[m.strideHeight,m.strideWidth],[m.dilationHeight,m.dilationWidth],[m.inHeight,m.inWidth]];I=d.runWebGLProgram(e,[c,l],"float32",t)}else if((0,e.env)().getBool("WEBGL_CONV_IM2COL"))I=(0,o.conv2dWithIm2Row)({x:c,filter:l,convInfo:m,backend:d});else{const e=new t.Conv2DProgram(m);I=d.runWebGLProgram(e,[c,l],"float32")}else I=(0,o.conv2dByMatMul)({x:c,filter:l,convInfo:m,backend:d});const W=(0,i.reshape)({inputs:{x:I},backend:d,attrs:{shape:m.outShape}});return d.disposeIntermediateTensorInfo(I),W}const a=exports.conv2DConfig={kernelName:e.Conv2D,backendName:"webgl",kernelFunc:r};
},{"@tensorflow/tfjs-core":"kSBl","../conv_gpu":"viLo","../conv_packed_gpu":"g3Bb","./Conv2D_impl":"CtO4","./Reshape":"OCN8"}],"J5U2":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.Conv3DDerInputProgram=exports.Conv3DDerFilterProgram=exports.Conv2DDerInputProgram=exports.Conv2DDerFilterProgram=void 0;class n{constructor(n){this.variableNames=["x","dy"],this.outputShape=n.filterShape;const t=n.strideHeight,o=n.strideWidth,d=n.padInfo.top,e=n.padInfo.left,i="channelsLast"===n.dataFormat;this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int wR = coords.x;\n        int wC = coords.y;\n        int d1 = coords.z;\n        int d2 = coords.w;\n\n        // Convolve x(?, ?, d1) with dy(:, :, d2) to get dw(wR, wC, d1, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int b = 0; b < ${n.batchSize}; b++) {\n          for (int yR = 0; yR < ${n.outHeight}; yR++) {\n            int xR = wR + yR * ${t} - ${d};\n\n            if (xR < 0 || xR >= ${n.inHeight}) {\n              continue;\n            }\n\n            for (int yC = 0; yC < ${n.outWidth}; yC++) {\n              int xC = wC + yC * ${o} - ${e};\n\n              if (xC < 0 || xC >= ${n.inWidth}) {\n                continue;\n              }\n\n              ${i?"float dyValue = getDy(b, yR, yC, d2);\n              float xValue = getX(b, xR, xC, d1);\n              dotProd += (xValue * dyValue);":"float dyValue = getDy(b, d2, yR, yC);\n              float xValue = getX(b, d1, xR, xC);\n              dotProd += (xValue * dyValue);"}\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}exports.Conv2DDerFilterProgram=n;class t{constructor(n){this.variableNames=["dy","W"],this.outputShape=n.inShape;const t=n.filterHeight,o=n.filterWidth,d=n.strideHeight,e=n.strideWidth,i="channelsLast"===n.dataFormat,r=t-1-n.padInfo.top,a=o-1-n.padInfo.left,s=i?1:2,y=i?2:3,C=i?3:1;this.userCode=`\n      const ivec2 pads = ivec2(${r}, ${a});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d1 = coords[${C}];\n\n        ivec2 dyCorner = ivec2(coords[${s}], coords[${y}]) - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${t}; wR++) {\n          float dyR = float(dyRCorner + wR) / ${d}.0;\n\n          if (dyR < 0.0 || dyR >= ${n.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          int wRPerm = ${t} - 1 - wR;\n\n          for (int wC = 0; wC < ${o}; wC++) {\n            float dyC = float(dyCCorner + wC) / ${e}.0;\n\n            if (dyC < 0.0 || dyC >= ${n.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            int wCPerm = ${o} - 1 - wC;\n\n            for (int d2 = 0; d2 < ${n.outChannels}; d2++) {\n\n              if (${i}) {\n                float xValue = getDy(batch, idyR, idyC, d2);\n                float wValue = getW(wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              } else {\n                float xValue = getDy(batch, d2, idyR, idyC);\n                float wValue = getW(wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              }\n\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}exports.Conv2DDerInputProgram=t;class o{constructor(n){this.variableNames=["x","dy"],this.outputShape=n.filterShape;const t=n.strideDepth,o=n.strideHeight,d=n.strideWidth,e=n.padInfo.front,i=n.padInfo.top,r=n.padInfo.left;this.userCode=`\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int wF = coords.x;\n        int wR = coords.y;\n        int wC = coords.z;\n        int d1 = coords.w;\n        int d2 = coords.u;\n\n        float dotProd = 0.0;\n\n        for (int b = 0; b < ${n.batchSize}; b++) {\n          for (int yF = 0; yF < ${n.outDepth}; yF++) {\n            int xF = wF + yF * ${t} - ${e};\n\n            if (xF < 0 || xF >= ${n.inDepth}) {\n              continue;\n            }\n\n            for (int yR = 0; yR < ${n.outHeight}; yR++) {\n              int xR = wR + yR * ${o} - ${i};\n\n              if (xR < 0 || xR >= ${n.inHeight}) {\n                continue;\n              }\n\n              for (int yC = 0; yC < ${n.outWidth}; yC++) {\n                int xC = wC + yC * ${d} - ${r};\n\n                if (xC < 0 || xC >= ${n.inWidth}) {\n                  continue;\n                }\n\n                float dyValue = getDy(b, yF, yR, yC, d2);\n                float xValue = getX(b, xF, xR, xC, d1);\n                dotProd += (xValue * dyValue);\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}exports.Conv3DDerFilterProgram=o;class d{constructor(n){this.variableNames=["dy","W"],this.outputShape=n.inShape;const t=n.filterDepth,o=n.filterHeight,d=n.filterWidth,e=n.strideDepth,i=n.strideHeight,r=n.strideWidth,a=t-1-n.padInfo.front,s=o-1-n.padInfo.top,y=d-1-n.padInfo.left;this.userCode=`\n      const ivec3 pads = ivec3(${a}, ${s}, ${y});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int d1 = coords.u;\n\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyFCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        float dotProd = 0.0;\n        for (int wF = 0; wF < ${t}; wF++) {\n          float dyF = float(dyFCorner + wF) / ${e}.0;\n\n          if (dyF < 0.0 || dyF >= ${n.outDepth}.0 || fract(dyF) > 0.0) {\n            continue;\n          }\n          int idyF = int(dyF);\n\n          int wFPerm = ${t} - 1 - wF;\n\n          for (int wR = 0; wR < ${o}; wR++) {\n            float dyR = float(dyRCorner + wR) / ${i}.0;\n\n            if (dyR < 0.0 || dyR >= ${n.outHeight}.0 ||\n              fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            int wRPerm = ${o} - 1 - wR;\n\n            for (int wC = 0; wC < ${d}; wC++) {\n              float dyC = float(dyCCorner + wC) / ${r}.0;\n\n              if (dyC < 0.0 || dyC >= ${n.outWidth}.0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              int wCPerm = ${d} - 1 - wC;\n\n              for (int d2 = 0; d2 < ${n.outChannels}; d2++) {\n                float xValue = getDy(batch, idyF, idyR, idyC, d2);\n                float wValue = getW(wFPerm, wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}exports.Conv3DDerInputProgram=d;
},{}],"LTFn":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.conv2DBackpropFilter=o,exports.conv2DBackpropFilterConfig=void 0;var e=require("@tensorflow/tfjs-core"),r=require("../conv_backprop_gpu");function o(o){const{inputs:t,backend:n,attrs:a}=o,{x:c,dy:p}=t,{strides:i,pad:s,dataFormat:l,dimRoundingMode:u,filterShape:d}=a,v=e.backend_util.convertConv2DDataFormat(l),k=e.backend_util.computeConv2DInfo(c.shape,d,i,1,s,u,!1,v),f=new r.Conv2DDerFilterProgram(k);return n.runWebGLProgram(f,[c,p],"float32")}const t=exports.conv2DBackpropFilterConfig={kernelName:e.Conv2DBackpropFilter,backendName:"webgl",kernelFunc:o};
},{"@tensorflow/tfjs-core":"kSBl","../conv_backprop_gpu":"J5U2"}],"VTk9":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.Conv2DDerInputPackedProgram=void 0;var e=require("./gpgpu_math");class d{constructor(d){this.variableNames=["dy","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"strides",type:"vec2"}],this.outputShape=d.inShape,this.enableShapeUniforms=(0,e.useShapeUniforms)(this.outputShape.length);const n=d.filterHeight,t=d.filterWidth,y=n-1-d.padInfo.top,a=t-1-d.padInfo.left;this.userCode=`\n      const ivec2 pads = ivec2(${y}, ${a});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d1 = coords[3];\n\n        ivec2 dyCorner = ivec2(coords[1], coords[2]) - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        vec4 result = vec4(0.);\n        for (int wR = 0; wR < ${n}; wR++) {\n          float dyR = float(dyRCorner + wR) / strides[0];\n          if (dyR < 0.0 || dyR >= ${d.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n          int wRPerm = ${n} - 1 - wR;\n\n          for (int wC = 0; wC < ${t}; wC++) {\n            int wCPerm = ${t} - 1 - wC;\n\n            float dyC = float(dyCCorner + wC) / strides[1];\n            bool idyCVal = (dyC >= 0.0) && (dyC < ${d.outWidth}.0)\n              && (fract(dyC) == 0.0);\n            int idyC = int(dyC);\n\n            float dyC2 = float(dyCCorner + wC + 1) / strides[1];\n            bool idyCVal2 = (dyC2 >= 0.0) && (dyC2 < ${d.outWidth}.0)\n              && (fract(dyC2) == 0.0);\n            int idyC2 = int(dyC2);\n\n            if (idyCVal && idyCVal2) {\n              for (int d2 = 0; d2 < ${d.outChannels}; d2 += 2) {\n                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);\n                vec4 dySample = getDy(batch, idyR, idyC, d2);\n                vec4 dySample2 = (idyC / 2 == idyC2 / 2) ?\n                  dySample : getDy(batch, idyR, idyC2, d2);\n\n                vec2 dyValue = mod(float(idyC), 2.) == 0. ?\n                  dySample.xy : dySample.zw;\n                result.xy += vec2(dot(dyValue, wValue.xy),\n                  dot(dyValue, wValue.zw));\n\n                dyValue = mod(float(idyC2), 2.) == 0. ?\n                  dySample2.xy : dySample2.zw;\n                result.zw += vec2(dot(dyValue, wValue.xy),\n                  dot(dyValue, wValue.zw));\n              }\n            } else if (idyCVal) {\n              for (int d2 = 0; d2 < ${d.outChannels}; d2 += 2) {\n                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);\n                vec4 dySample = getDy(batch, idyR, idyC, d2);\n                vec2 dyValue = mod(float(idyC), 2.) == 0. ?\n                  dySample.xy : dySample.zw;\n                result.xy += vec2(dot(dyValue, wValue.xy),\n                  dot(dyValue, wValue.zw));\n              }\n            } else if (idyCVal2) {\n              for (int d2 = 0; d2 < ${d.outChannels}; d2 += 2) {\n                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);\n                vec4 dySample = getDy(batch, idyR, idyC2, d2);\n                vec2 dyValue = mod(float(idyC2), 2.) == 0. ?\n                  dySample.xy : dySample.zw;\n                result.zw += vec2(dot(dyValue, wValue.xy),\n                  dot(dyValue, wValue.zw));\n              }\n            }\n          }\n        }\n        setOutput(result);\n      }\n    `}}exports.Conv2DDerInputPackedProgram=d;
},{"./gpgpu_math":"eeKH"}],"x6Y6":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.conv2DBackpropInput=r,exports.conv2DBackpropInputConfig=void 0;var e=require("@tensorflow/tfjs-core"),n=require("../conv_backprop_gpu"),o=require("../conv_backprop_packed_gpu");function r(r){const{inputs:t,backend:a,attrs:p}=r,{dy:c,filter:u}=t,{inputShape:i,strides:s,pad:d,dataFormat:v,dimRoundingMode:k}=p,l=e.backend_util.convertConv2DDataFormat(v),g=e.backend_util.computeConv2DInfo(i,u.shape,s,1,d,k,!1,l);if((0,e.env)().getBool("WEBGL_PACK_CONV2DTRANSPOSE")&&"channelsLast"===l){const e=[[g.strideHeight,g.strideWidth]],n=new o.Conv2DDerInputPackedProgram(g);return a.runWebGLProgram(n,[c,u],"float32",e)}{const e=new n.Conv2DDerInputProgram(g);return a.runWebGLProgram(e,[c,u],"float32")}}const t=exports.conv2DBackpropInputConfig={kernelName:e.Conv2DBackpropInput,backendName:"webgl",kernelFunc:r};
},{"@tensorflow/tfjs-core":"kSBl","../conv_backprop_gpu":"J5U2","../conv_backprop_packed_gpu":"VTk9"}],"oJAB":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.conv3D=n,exports.conv3DConfig=void 0;var e=require("@tensorflow/tfjs-core"),o=require("../conv_gpu");function n(n){const{inputs:r,backend:t,attrs:s}=n,{x:a,filter:c}=r,{strides:i,pad:u,dilations:p}=s,l=e.backend_util.computeConv3DInfo(a.shape,c.shape,i,p,u),v=new o.Conv3DProgram(l);return t.runWebGLProgram(v,[a,c],"float32")}const r=exports.conv3DConfig={kernelName:e.Conv3D,backendName:"webgl",kernelFunc:n};
},{"@tensorflow/tfjs-core":"kSBl","../conv_gpu":"viLo"}],"O5Li":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.conv3DBackpropFilterV2=o,exports.conv3DBackpropFilterV2Config=void 0;var e=require("@tensorflow/tfjs-core"),r=require("../conv_backprop_gpu");function o(o){const{inputs:t,backend:n,attrs:p}=o,{x:c,dy:a}=t,{strides:i,pad:s,filterShape:l}=p,u=e.backend_util.computeConv3DInfo(c.shape,l,i,1,s),k=new r.Conv3DDerFilterProgram(u);return n.runWebGLProgram(k,[c,a],"float32")}const t=exports.conv3DBackpropFilterV2Config={kernelName:e.Conv3DBackpropFilterV2,backendName:"webgl",kernelFunc:o};
},{"@tensorflow/tfjs-core":"kSBl","../conv_backprop_gpu":"J5U2"}],"CNdb":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.conv3DBackpropInput=o,exports.conv3DBackpropInputConfig=void 0;var e=require("@tensorflow/tfjs-core"),n=require("../conv_backprop_gpu");function o(o){const{inputs:r,backend:t,attrs:p}=o,{dy:c,filter:a}=r,{pad:u,strides:s,inputShape:i}=p,k=e.backend_util.computeConv3DInfo(i,a.shape,s,1,u),v=new n.Conv3DDerInputProgram(k);return t.runWebGLProgram(v,[c,a],"float32")}const r=exports.conv3DBackpropInputConfig={kernelName:e.Conv3DBackpropInputV2,backendName:"webgl",kernelFunc:o};
},{"@tensorflow/tfjs-core":"kSBl","../conv_backprop_gpu":"J5U2"}],"mMLU":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.cosConfig=exports.cos=void 0;var e=require("@tensorflow/tfjs-core"),r=require("../binaryop_packed_gpu"),n=require("../kernel_utils/kernel_funcs_utils");const s=n.CHECK_NAN_SNIPPET_UNARY+"\n  return cos(x);\n",o=`\n  vec4 result = cos(x);\n  bvec4 isNaN = isnan(x);\n  ${r.CHECK_NAN_SNIPPET_PACKED}\n  return result;\n`,t=exports.cos=(0,n.unaryKernelFunc)({opSnippet:s,packedOpSnippet:o}),c=exports.cosConfig={kernelName:e.Cos,backendName:"webgl",kernelFunc:t};
},{"@tensorflow/tfjs-core":"kSBl","../binaryop_packed_gpu":"mFR1","../kernel_utils/kernel_funcs_utils":"ciwP"}],"GsRh":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.coshConfig=exports.cosh=void 0;var e=require("@tensorflow/tfjs-core"),r=require("../kernel_utils/kernel_funcs_utils");const o="\n  float e2x = exp(-x);\n  return (e2x + 1.0 / e2x) / 2.0;\n",n=exports.cosh=(0,r.unaryKernelFunc)({opSnippet:o}),s=exports.coshConfig={kernelName:e.Cosh,backendName:"webgl",kernelFunc:n};
},{"@tensorflow/tfjs-core":"kSBl","../kernel_utils/kernel_funcs_utils":"ciwP"}],"F9Be":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.CropAndResizeProgram=void 0;class e{constructor(e,t,o,n,r){this.variableNames=["Image","Boxes","BoxInd"],this.outputShape=[];const[a,i,s,c]=e,[l]=t,[u,f]=o;this.outputShape=[l,u,f,c];const d="bilinear"===n?1:0,[x,C]=[`${i-1}.0`,`${s-1}.0`],[g,R,b]=u>1?[`${(i-1)/(u-1)}`,"(y2-y1) * height_ratio",`y1*${x} + float(y)*(height_scale)`]:["0.0","0.0",`0.5 * (y1+y2) * ${x}`],[h,p,m]=f>1?[`${(s-1)/(f-1)}`,"(x2-x1) * width_ratio",`x1*${C} + float(x)*(width_scale)`]:["0.0","0.0",`0.5 * (x1+x2) * ${C}`];this.userCode=`\n      const float height_ratio = float(${g});\n      const float width_ratio = float(${h});\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int y = coords[1];\n        int x = coords[2];\n        int d = coords[3];\n\n        // get box vals\n        float y1 = getBoxes(b,0);\n        float x1 = getBoxes(b,1);\n        float y2 = getBoxes(b,2);\n        float x2 = getBoxes(b,3);\n\n        // get image in batch index\n        int bInd = round(getBoxInd(b));\n        if(bInd < 0 || bInd >= ${a}) {\n          return;\n        }\n\n        float height_scale = ${R};\n        float width_scale = ${p};\n\n        float in_y = ${b};\n        if( in_y < 0.0 || in_y > ${x} ) {\n          setOutput(float(${r}));\n          return;\n        }\n        float in_x = ${m};\n        if( in_x < 0.0 || in_x > ${C} ) {\n          setOutput(float(${r}));\n          return;\n        }\n\n        vec2 sourceFracIndexCR = vec2(in_x,in_y);\n        if(${d} == 1) {\n          // Compute the four integer indices.\n          ivec2 sourceFloorCR = ivec2(sourceFracIndexCR);\n          ivec2 sourceCeilCR = ivec2(ceil(sourceFracIndexCR));\n\n          float topLeft = getImage(b, sourceFloorCR.y, sourceFloorCR.x, d);\n          float bottomLeft = getImage(b, sourceCeilCR.y, sourceFloorCR.x, d);\n          float topRight = getImage(b, sourceFloorCR.y, sourceCeilCR.x, d);\n          float bottomRight = getImage(b, sourceCeilCR.y, sourceCeilCR.x, d);\n\n          vec2 fracCR = sourceFracIndexCR - vec2(sourceFloorCR);\n\n          float top = topLeft + (topRight - topLeft) * fracCR.x;\n          float bottom = bottomLeft + (bottomRight - bottomLeft) * fracCR.x;\n          float newValue = top + (bottom - top) * fracCR.y;\n          setOutput(newValue);\n        } else {\n          // Compute the coordinators of nearest neighbor point.\n          ivec2 sourceNearestCR = ivec2(floor(\n            sourceFracIndexCR + vec2(0.5,0.5)));\n          float newValue = getImage(b, sourceNearestCR.y, sourceNearestCR.x, d);\n          setOutput(newValue);\n        }\n      }\n    `}}exports.CropAndResizeProgram=e;
},{}],"mjLq":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.cropAndResizeConfig=exports.cropAndResize=void 0;var e=require("@tensorflow/tfjs-core"),r=require("../crop_and_resize_gpu");const o=e=>{const{inputs:o,backend:n,attrs:s}=e,{image:t,boxes:p,boxInd:i}=o,{cropSize:a,method:c,extrapolationValue:d}=s,u=new r.CropAndResizeProgram(t.shape,p.shape,a,c,d);return n.runWebGLProgram(u,[t,p,i],"float32")};exports.cropAndResize=o;const n=exports.cropAndResizeConfig={kernelName:e.CropAndResize,backendName:"webgl",kernelFunc:o};
},{"@tensorflow/tfjs-core":"kSBl","../crop_and_resize_gpu":"F9Be"}],"tnEN":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.CumProgram=exports.CumOpType=void 0;var t,o=require("./shader_compiler");!function(t){t.Prod="*",t.Sum="+"}(t||(exports.CumOpType=t={}));class e{constructor(e,i,s,u){this.op=e,this.outputShape=i,this.variableNames=["x"],this.customUniforms=[{name:"index",type:"float"}];const p=this.outputShape.length,d=this.op===t.Prod?"1.0":"0.0",$=s?d:`getX(${r(p,"coords",this.op)})`,a=this.outputShape[this.outputShape.length-1];let h="",f="";s?(h=u?`end != ${a-1}`:"end != 0",f=u?"end + 1":"end - 1"):(h=u?`end + pow2 < ${a}`:"end >= pow2",f=u?"end + pow2":"end - pow2"),this.userCode=`\n      void main() {\n        ${(0,o.getCoordsDataType)(p)} coords = getOutputCoords();\n        int end = ${n(p,"coords",this.op)};\n        float val = ${$};\n        int pow2 = int(pow(2.0, index));\n        if (${h}) {\n          int idx = ${f};\n          ${n(p,"coords",this.op)} = idx;\n          val ${this.op}= getX(${r(p,"coords",this.op)});\n        }\n        setOutput(val);\n      }\n    `}}function r(t,o,e){if(1===t)return`${o}`;if(2===t)return`${o}.x, ${o}.y`;if(3===t)return`${o}.x, ${o}.y, ${o}.z`;if(4===t)return`${o}.x, ${o}.y, ${o}.z, ${o}.w`;throw new Error(`Cumulative ${e} for rank ${t} is not yet supported`)}function n(t,o,e){if(1===t)return`${o}`;if(2===t)return`${o}.y`;if(3===t)return`${o}.z`;if(4===t)return`${o}.w`;throw new Error(`Cumulative ${e} for rank ${t} is not yet supported`)}exports.CumProgram=e;
},{"./shader_compiler":"xhhc"}],"jO9r":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.cumImpl=s;var e=require("@tensorflow/tfjs-core"),t=require("../cum_gpu"),r=require("./Identity"),n=require("./Transpose");function s(s,o,a,i,u,p){const d=o.shape.length,c=e.backend_util.getAxesPermutation([i],d);let m=o;null!=c&&(m=(0,n.transpose)({inputs:{x:o},backend:a,attrs:{perm:c}}));const l=e.backend_util.getInnerMostAxes(1,d)[0];if(l!==d-1)throw new Error(`WebGL cumprod shader expects an inner-most axis=${o.shape.length-1} `+`but got axis=${i}`);const f=m.shape[l];let g=(0,r.identity)({inputs:{x:m},backend:a});for(let e=0;e<=Math.ceil(Math.log2(f))-1;e++){const r=new t.CumProgram(s,m.shape,!1,p),n=[[e]],o=g;g=a.runWebGLProgram(r,[g],g.dtype,n),a.disposeIntermediateTensorInfo(o)}if(u){const e=new t.CumProgram(s,m.shape,u,p),r=g;g=a.runWebGLProgram(e,[g],g.dtype),a.disposeIntermediateTensorInfo(r)}if(null!=c){const t=e.backend_util.getUndoAxesPermutation(c),r=(0,n.transpose)({inputs:{x:g},backend:a,attrs:{perm:t}});return a.disposeIntermediateTensorInfo(g),a.disposeIntermediateTensorInfo(m),r}return g}
},{"@tensorflow/tfjs-core":"kSBl","../cum_gpu":"tnEN","./Identity":"LUQG","./Transpose":"ukag"}],"eLGh":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.cumprod=u,exports.cumprodConfig=void 0;var e=require("@tensorflow/tfjs-core"),r=require("../cum_gpu"),o=require("./Cum_impl");function u(e){const{inputs:u,backend:t,attrs:s}=e,{x:c}=u,{axis:n,exclusive:p,reverse:i}=s;return(0,o.cumImpl)(r.CumOpType.Prod,c,t,n,p,i)}const t=exports.cumprodConfig={kernelName:e.Cumprod,backendName:"webgl",kernelFunc:u};
},{"@tensorflow/tfjs-core":"kSBl","../cum_gpu":"tnEN","./Cum_impl":"jO9r"}],"DR3A":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.cumsum=s,exports.cumsumConfig=void 0;var e=require("@tensorflow/tfjs-core"),u=require("../cum_gpu"),r=require("./Cum_impl");function s(e){const{inputs:s,backend:m,attrs:t}=e,{x:c}=s,{axis:n,exclusive:o,reverse:i}=t;return(0,r.cumImpl)(u.CumOpType.Sum,c,m,n,o,i)}const m=exports.cumsumConfig={kernelName:e.Cumsum,backendName:"webgl",kernelFunc:s};
},{"@tensorflow/tfjs-core":"kSBl","../cum_gpu":"tnEN","./Cum_impl":"jO9r"}],"M9Zz":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.denseBincount=t,exports.denseBincountConfig=void 0;var e=require("@tensorflow/tfjs-core"),n=require("../kernel_utils/shared");function t(e){const{inputs:t,backend:r,attrs:s}=e,{x:o,weights:u}=t,{size:a,binaryOutput:i}=s;if(1===o.shape.length){const e=r.readSync(o.dataId),t=r.readSync(u.dataId),s=(0,n.bincountImplCPU)(e,t,u.dtype,u.shape,a);return r.makeTensorInfo([a],u.dtype,s)}if(2===o.shape.length){const e=r.bufferSync(o),t=r.bufferSync(u),s=(0,n.bincountReduceImplCPU)(e,t,a,i);return r.makeTensorInfo(s.shape,u.dtype,s.values)}throw new Error("Error in denseBincount: input must be at most rank 2, but got rank"+`${o.shape.length}.`)}const r=exports.denseBincountConfig={kernelName:e.DenseBincount,backendName:"webgl",kernelFunc:t};
},{"@tensorflow/tfjs-core":"kSBl","../kernel_utils/shared":"cNPH"}],"MLa2":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.DepthToSpaceProgram=void 0;class t{constructor(t,o,i){this.variableNames=["x"],this.outputShape=[],this.outputShape=t,this.blockSize=o,this.dataFormat=i,this.userCode=`\n    void main() {\n      ivec4 coords = getOutputCoords();\n      int b = coords[0];\n      int h = ${this.getHeightCoordString()};\n      int w = ${this.getWidthCoordString()};\n      int d = ${this.getDepthCoordString()};\n\n      int in_h = h / ${o};\n      int offset_h = imod(h, ${o});\n      int in_w = w / ${o};\n      int offset_w = imod(w, ${o});\n      int offset_d = (offset_h * ${o} + offset_w) *\n        ${this.getOutputDepthSize()};\n      int in_d = d + offset_d;\n\n      float result = ${this.getInputSamplingString()};\n      setOutput(result);\n    }\n  `}getHeightCoordString(){return"NHWC"===this.dataFormat?"coords[1]":"coords[2]"}getWidthCoordString(){return"NHWC"===this.dataFormat?"coords[2]":"coords[3]"}getDepthCoordString(){return"NHWC"===this.dataFormat?"coords[3]":"coords[1]"}getOutputDepthSize(){return"NHWC"===this.dataFormat?this.outputShape[3]:this.outputShape[1]}getInputSamplingString(){return"NHWC"===this.dataFormat?"getX(b, in_h, in_w, in_d)":"getX(b, in_d, in_h, in_w)"}}exports.DepthToSpaceProgram=t;
},{}],"xZ5c":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.depthToSpace=t,exports.depthToSpaceConfig=void 0;var e=require("@tensorflow/tfjs-core"),p=require("../depth_to_space_gpu");function t(e){const{inputs:t,backend:a,attrs:o}=e,{x:r}=t,{blockSize:s,dataFormat:n}=o,c=r.shape[0],h=("NHWC"===n?r.shape[1]:r.shape[2])*s,d=("NHWC"===n?r.shape[2]:r.shape[3])*s,u=("NHWC"===n?r.shape[3]:r.shape[1])/(s*s),i="NHWC"===n?[c,h,d,u]:[c,u,h,d],l=new p.DepthToSpaceProgram(i,s,n);return a.runWebGLProgram(l,[r],r.dtype)}const a=exports.depthToSpaceConfig={kernelName:e.DepthToSpace,backendName:"webgl",kernelFunc:t};
},{"@tensorflow/tfjs-core":"kSBl","../depth_to_space_gpu":"MLa2"}],"ONBM":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.DepthwiseConv2DProgram=void 0;var t=require("./gpgpu_math");class n{constructor(n,e=!1,o=null,i=!1,a=!1){this.variableNames=["x","W"],this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=n.outShape,this.enableShapeUniforms=(0,t.useShapeUniforms)(this.outputShape.length);const s=n.filterHeight,r=n.filterWidth,l=n.outChannels/n.inChannels;let d="",u="";o&&(d=i?`float activation(float a) {\n          float b = getPreluActivationWeightsAtOutCoords();\n          ${o}\n        }`:a?`float activation(float a) {\n          float b = getLeakyreluAlphaAtOutCoords();\n          ${o}\n        }`:`\n          float activation(float x) {\n            ${o}\n          }\n        `,u="result = activation(result);");const h=e?"result += getBiasAtOutCoords();":"";e&&this.variableNames.push("bias"),i&&this.variableNames.push("preluActivationWeights"),a&&this.variableNames.push("leakyreluAlpha"),this.userCode=`\n      ${d}\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int d2 = coords.w;\n        int d1 = d2 / ${l};\n        int q = d2 - d1 * ${l};\n\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // Convolve x(?, ?, d1) with w(:, :, d1, q) to get y(yR, yC, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        // TO DO(dsmilkov): Flatten the two for loops and vec4 the operations.\n        for (int wR = 0; wR < ${s}; wR++) {\n          int xR = xRCorner + wR * dilations[0];\n\n          if (xR < 0 || xR >= inDims[0]) {\n            continue;\n          }\n\n          for (int wC = 0; wC < ${r}; wC++) {\n            int xC = xCCorner + wC * dilations[1];\n\n            if (xC < 0 || xC >= inDims[1]) {\n              continue;\n            }\n\n            float xVal = getX(batch, xR, xC, d1);\n            float wVal = getW(wR, wC, d1, q);\n            dotProd += xVal * wVal;\n          }\n        }\n\n        float result = dotProd;\n        ${h}\n        ${u}\n        setOutput(result);\n      }\n    `}}exports.DepthwiseConv2DProgram=n;
},{"./gpgpu_math":"eeKH"}],"s3KE":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.DepthwiseConvPacked2DProgram=void 0;var e=require("@tensorflow/tfjs-core"),n=require("./gpgpu_math");class x{constructor(x,t=!1,i=null,s=!1,C=!1){this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=x.outShape,this.enableShapeUniforms=(0,n.useShapeUniforms)(this.outputShape.length);const l=x.outChannels/x.inChannels,a=x.padInfo.left,f=x.strideWidth,r=x.dilationWidth,c=x.filterHeight,d=x.filterWidth,o=d;let $="\n      int xR; int xC; int xCOffset;\n      vec4 wTexel; vec4 previous; vec4 final;";for(let e=0;e<d;e++)$+=`\n          vec4 xTexelC${2*e};\n          int xTexelC${2*e}Ready;\n          vec4 xTexelC${2*e+1};\n          int xTexelC${2*e+1}Ready;\n          vec4 xC${e};`;$+=`\n    for (int r = 0; r < ${c}; r++) {\n      `;for(let e=0;e<d;e++)$+=`\n          xTexelC${2*e} = vec4(0.0);\n          xTexelC${2*e}Ready = 0;\n          xTexelC${2*e+1} = vec4(0.0);\n          xTexelC${2*e+1}Ready = 0;\n          xC${e} = vec4(0.0);`;$+="\n        xR = xRCorner + r * dilations[0];\n        if (xR >=0 && xR < inDims[0]) {\n      ";for(let n=0;n<(o+1)/2;n++){const x=2*n;if($+=`\n          xC = xCCorner + ${x*r};\n          `,1===f){if(x<d&&(a%2==1?($+=`\n                xCOffset = xC + 1;\n                if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${x}Ready == 0) {\n                  xTexelC${x} = getX(batch, xR, xCOffset, d1);\n\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if (xCOffset + 1 >= inDims[1]) {\n                    xTexelC${x}.zw = vec2(0.0);\n                  }\n                  xTexelC${x}Ready = 1;\n                }\n              `,$+=1===r&&x>0?`\n                xC${x} = vec4(xTexelC${x-2}.zw, xTexelC${x}.xy);\n                `:`\n                  xCOffset = xC + 1 - 2;\n\n                  if (xCOffset >= 0 && xCOffset < inDims[1]) {\n                    previous = getX(batch, xR, xCOffset, d1);\n\n                    // Need to manually clear unused channels in case\n                    // we're reading from recycled texture.\n                    if (xCOffset + 1 >= inDims[1]) {\n                      previous.zw = vec2(0.0);\n                    }\n\n                    xC${x} = vec4(previous.zw, xTexelC${x}.xy);\n                  } else {\n                    xC${x} = vec4(0.0, 0.0, xTexelC${x}.xy);\n                  }\n                  `):$+=`\n                if (xC >= 0 && xC < inDims[1] && xTexelC${x}Ready == 0) {\n                  xTexelC${x} = getX(batch, xR, xC, d1);\n                  if (xC + 1 >= inDims[1]) {\n                    xTexelC${x}.zw = vec2(0.0);\n                  }\n                  xTexelC${x}Ready = 1;\n                }\n\n                xC${x} = xTexelC${x};\n                `,x+1<d)){const n=a%2==0?e.util.nearestLargerEven(r):r;r%2==0&&a%2==1||r%2!=0&&a%2!=1?($+=`\n                  xCOffset = xC + imod(pads[1], 2) + ${n};\n\n                  if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${x+1}Ready == 0) {\n                    xTexelC${x+1} = getX(batch, xR, xCOffset, d1);\n\n                    // Need to manually clear unused channels in case\n                    // we're reading from recycled texture.\n                    if (xCOffset + 1 >= inDims[1]) {\n                      xTexelC${x+1}.zw = vec2(0.0);\n                    }\n                    xTexelC${x+1}Ready = 1;\n                  }\n                  `,$+=r>1?`\n                    xCOffset -= 2;\n                    if (xCOffset >= 0 && xCOffset < inDims[1]) {\n                     previous = getX(batch, xR, xCOffset, d1);\n                     xC${x+1} = vec4(previous.zw, xTexelC${x+1}.xy);\n                    } else {\n                     xC${x+1} = vec4(0.0, 0.0, xTexelC${x+1}.xy);\n                    }\n                    `:`\n                    xC${x+1} = vec4(xTexelC${x}.zw, xTexelC${x+1}.xy);\n                    `):$+=1===n?`\n                    xC${x+1} = xTexelC${x};\n                    `:`\n                    xCOffset = xC + ${n};\n\n                    if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${x+1}Ready == 0) {\n                      xTexelC${x+1} = getX(batch, xR, xCOffset, d1);\n                      if (xCOffset + 1 >= inDims[1]) {\n                        xTexelC${x+1}.zw = vec2(0.0);\n                      }\n                      xTexelC${x+1}Ready = 1;\n                    }\n\n                    xC${x+1} = xTexelC${x+1};\n                    `}}else x<d&&(a%2==1?($+=`\n                xCOffset = xC + 1 - strides[1];\n                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${x}Ready == 0) {\n                  xTexelC${x} = getX(batch, xR, xCOffset, d1);\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if (xCOffset + 1 >= inDims[1]) {\n                    xTexelC${x}.zw = vec2(0.0);\n                  }\n                  xTexelC${x}Ready = 1;\n                }\n\n                if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC${x+1}Ready == 0) {\n                  xTexelC${x+1} = getX(batch, xR, xC + 1, d1);\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if (xC + 2 >= inDims[1]) {\n                    xTexelC${x+1}.zw = vec2(0.0);\n                  }\n                  xTexelC${x+1}Ready = 1;\n                }\n\n                xC${x} = vec4(xTexelC${x}.zw, xTexelC${x+1}.zw);\n              `,x+1<d&&($+=`\n                  final = vec4(0.0);\n                  xCOffset = xC + 1 + strides[1];\n                  if(xCOffset >= 0 && xCOffset < inDims[1]) {\n                    final = getX(batch, xR, xCOffset, d1);\n                  }\n                  xC${x+1} = vec4(xTexelC${x+1}.xy, final.xy);\n                `)):($+=`\n                if(xC >= 0 && xC < inDims[1] && xTexelC${x}Ready == 0) {\n                  xTexelC${x} = getX(batch, xR, xC, d1);\n                  if (xC + 1 >= inDims[1]) {\n                    xTexelC${x}.zw = vec2(0.0);\n                  }\n                  xTexelC${x}Ready = 1;\n                }\n\n                xCOffset = xC + strides[1];\n                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${x+1}Ready == 0) {\n                  xTexelC${x+1} = getX(batch, xR, xCOffset, d1);\n                  if (xCOffset + 1 >= inDims[1]) {\n                    xTexelC${x+1}.zw = vec2(0.);\n                  }\n                  xTexelC${x+1}Ready = 1;\n                }\n\n                xC${x} = vec4(\n                  xTexelC${x}.xy, xTexelC${x+1}.xy);\n              `,x+1<d&&($+=`\n                  xC${x+1} = vec4(xTexelC${x}.zw, xTexelC${x+1}.zw);\n                `)));x<d&&($+=`\n            wTexel = getW(r, ${x}, d1, q);\n            dotProd += xC${x} * vec4(wTexel.xz, wTexel.xz);\n          `,x+1<d&&($+=`\n              wTexel = getW(r, ${x+1}, d1, q);\n              dotProd += xC${x+1} * vec4(wTexel.xz, wTexel.xz);\n            `))}$+="\n    }\n  ",$+="\n      }\n    ";let v="",u="";i&&(v=s?`vec4 activation(vec4 a) {\n          vec4 b = getPreluActivationWeightsAtOutCoords();\n          ${i}\n        }`:C?`vec4 activation(vec4 a) {\n          vec4 b = getLeakyreluAlphaAtOutCoords();\n          ${i}\n        }`:`vec4 activation(vec4 x) {\n          ${i}\n        }`,u="result = activation(result);");const T=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),s&&this.variableNames.push("preluActivationWeights"),C&&this.variableNames.push("leakyreluAlpha"),this.userCode=`\n      ${v}\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int d2 = coords.w;\n        int d1 = d2 / ${l};\n        int q = d2 - d1 * ${l};\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.\n        vec4 dotProd = vec4(0.000000000000001);\n\n        ${$}\n\n        vec4 result = dotProd - vec4(0.000000000000001);\n        ${T}\n        ${u}\n        setOutput(result);\n      }\n    `}}exports.DepthwiseConvPacked2DProgram=x;
},{"@tensorflow/tfjs-core":"kSBl","./gpgpu_math":"eeKH"}],"hBFT":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.depthwiseConv2dNative=n,exports.depthwiseConv2dNativeConfig=void 0;var e=require("@tensorflow/tfjs-core"),t=require("../conv_gpu_depthwise"),i=require("../conv_packed_gpu_depthwise");function n(n){const{inputs:o,backend:r,attrs:s}=n,{x:d,filter:a}=o,{strides:l,pad:p,dilations:h,dimRoundingMode:u}=s;let c=h;null==c&&(c=[1,1]),e.util.assert(e.backend_util.eitherStridesOrDilationsAreOne(l,c),()=>"Error in depthwiseConv2d: Either strides or dilations must be "+`1. Got strides ${l} and dilations '${c}'`);const v=e.backend_util.computeConv2DInfo(d.shape,a.shape,l,c,p,u,!0);let C;C=(0,e.env)().getBool("WEBGL_PACK_DEPTHWISECONV")&&v.strideWidth<=2&&v.outChannels/v.inChannels==1?new i.DepthwiseConvPacked2DProgram(v):new t.DepthwiseConv2DProgram(v);const g=[[v.padInfo.top,v.padInfo.left],[v.strideHeight,v.strideWidth],[v.dilationHeight,v.dilationWidth],[v.inHeight,v.inWidth]];return r.runWebGLProgram(C,[d,a],"float32",g)}const o=exports.depthwiseConv2dNativeConfig={kernelName:e.DepthwiseConv2dNative,backendName:"webgl",kernelFunc:n};
},{"@tensorflow/tfjs-core":"kSBl","../conv_gpu_depthwise":"ONBM","../conv_packed_gpu_depthwise":"s3KE"}],"zI4s":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.DepthwiseConv2DDerInputProgram=exports.DepthwiseConv2DDerFilterProgram=void 0;class n{constructor(n){this.variableNames=["x","dy"],this.outputShape=n.filterShape;const t=n.strideHeight,o=n.strideWidth,e=n.padInfo.top,d=n.padInfo.left,i=n.outChannels/n.inChannels;this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int wR = coords.x;\n        int wC = coords.y;\n        int d1 = coords.z;\n        int dm = coords.w;\n        int d2 = d1 * ${i} + dm;\n\n        float dotProd = 0.0;\n\n        // TO DO: Vec4 over the batch size\n        for (int b = 0; b < ${n.batchSize}; b++) {\n          for (int yR = 0; yR < ${n.outHeight}; yR++) {\n            int xR = wR + yR * ${t} - ${e};\n\n            if (xR < 0 || xR >= ${n.inHeight}) {\n              continue;\n            }\n\n            for (int yC = 0; yC < ${n.outWidth}; yC++) {\n              int xC = wC + yC * ${o} - ${d};\n\n              if (xC < 0 || xC >= ${n.inWidth}) {\n                continue;\n              }\n\n              float dyValue = getDy(b, yR, yC, d2);\n              float xValue = getX(b, xR, xC, d1);\n              dotProd += (xValue * dyValue);\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}exports.DepthwiseConv2DDerFilterProgram=n;class t{constructor(n){this.variableNames=["dy","W"],this.outputShape=n.inShape;const t=n.filterHeight,o=n.filterWidth,e=n.strideHeight,d=n.strideWidth,i=t-1-n.padInfo.top,r=o-1-n.padInfo.left,s=n.outChannels/n.inChannels;this.userCode=`\n      const ivec2 pads = ivec2(${i}, ${r});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d1 = coords[3];\n        ivec2 dyCorner = coords.yz - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        float dotProd = 0.0;\n\n        for (int wR = 0; wR < ${t}; wR++) {\n          float dyR = float(dyRCorner + wR) / ${e}.0;\n\n          if (dyR < 0.0 || dyR >= ${n.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          int wRPerm = ${t} - 1 - wR;\n\n          for (int wC = 0; wC < ${o}; wC++) {\n            float dyC = float(dyCCorner + wC) / ${d}.0;\n\n            if (dyC < 0.0 || dyC >= ${n.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            int wCPerm = ${o} - 1 - wC;\n\n            // TO DO: Vec4 over the channelMul\n            for (int dm = 0; dm < ${s}; dm++) {\n              int d2 = d1 * ${s} + dm;\n              float xValue = getDy(batch, idyR, idyC, d2);\n              float wValue = getW(wRPerm, wCPerm, d1, dm);\n              dotProd += xValue * wValue;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}exports.DepthwiseConv2DDerInputProgram=t;
},{}],"OcXt":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.depthwiseConv2dNativeBackpropFilter=r,exports.depthwiseConv2dNativeBackpropFilterConfig=void 0;var e=require("@tensorflow/tfjs-core"),t=require("../conv_backprop_gpu_depthwise");function r(r){const{inputs:o,backend:i,attrs:n}=r,{x:p,dy:a}=o,{strides:s,dilations:d,pad:c,dimRoundingMode:l,filterShape:u}=n,v=e.backend_util.computeConv2DInfo(p.shape,u,s,d,c,l,!0),k=new t.DepthwiseConv2DDerFilterProgram(v);return i.runWebGLProgram(k,[p,a],"float32")}const o=exports.depthwiseConv2dNativeBackpropFilterConfig={kernelName:e.DepthwiseConv2dNativeBackpropFilter,backendName:"webgl",kernelFunc:r};
},{"@tensorflow/tfjs-core":"kSBl","../conv_backprop_gpu_depthwise":"zI4s"}],"BDt9":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.depthwiseConv2dNativeBackpropInput=n,exports.depthwiseConv2dNativeBackpropInputConfig=void 0;var e=require("@tensorflow/tfjs-core"),t=require("../conv_backprop_gpu_depthwise");function n(n){const{inputs:o,backend:p,attrs:r}=n,{dy:i,filter:a}=o,{strides:s,dilations:d,pad:u,dimRoundingMode:c,inputShape:v}=r,k=e.backend_util.computeConv2DInfo(v,a.shape,s,d,u,c,!0),l=new t.DepthwiseConv2DDerInputProgram(k);return p.runWebGLProgram(l,[i,a],"float32")}const o=exports.depthwiseConv2dNativeBackpropInputConfig={kernelName:e.DepthwiseConv2dNativeBackpropInput,backendName:"webgl",kernelFunc:n};
},{"@tensorflow/tfjs-core":"kSBl","../conv_backprop_gpu_depthwise":"zI4s"}],"Cg4e":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.DiagProgram=void 0;class o{constructor(o){this.variableNames=["X"],this.outputShape=[o,o],this.userCode="\n      void main() {\n          ivec2 coords = getOutputCoords();\n          float val = coords[0] == coords[1] ? getX(coords[0]) : 0.0;\n          setOutput(val);\n      }\n    "}}exports.DiagProgram=o;
},{}],"FBsW":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.diag=a,exports.diagConfig=void 0;var e=require("@tensorflow/tfjs-core"),r=require("../diag_gpu"),s=require("./Reshape");function a(a){const{inputs:n,backend:t}=a,{x:i}=n,o=[...i.shape,...i.shape],p=e.util.sizeFromShape(i.shape),d=(0,s.reshape)({inputs:{x:i},backend:t,attrs:{shape:[p]}}),u=new r.DiagProgram(p),g=t.runWebGLProgram(u,[d],d.dtype),c=(0,s.reshape)({inputs:{x:g},backend:t,attrs:{shape:o}});return t.disposeIntermediateTensorInfo(d),t.disposeIntermediateTensorInfo(g),c}const n=exports.diagConfig={kernelName:e.Diag,backendName:"webgl",kernelFunc:a};
},{"@tensorflow/tfjs-core":"kSBl","../diag_gpu":"Cg4e","./Reshape":"OCN8"}],"jHS7":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.Dilation2DProgram=void 0;class n{constructor(n){this.variableNames=["x","W"],this.outputShape=n.outShape;const{inHeight:t,inWidth:i,padInfo:e,strideHeight:o,strideWidth:r,filterHeight:a,filterWidth:s,dilationHeight:l,dilationWidth:d}=n,{top:h,left:c}=e;this.userCode=`\n      const ivec2 strides = ivec2(${o}, ${r});\n      const ivec2 pads = ivec2(${h}, ${c});\n      const float neg_infinity = -3.4e38;\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        int d1 = coords.w;\n        ivec2 outTopLeftCorner =\n            coords.yz * strides - pads;\n        int hBeg = outTopLeftCorner.x;\n        int wBeg = outTopLeftCorner.y;\n\n        float curVal = neg_infinity;\n        for (int h = 0; h < ${a}; h++) {\n          int hIn = hBeg + h * ${l};\n\n          if (hIn >= 0 && hIn < ${t}) {\n            for (int w = 0; w < ${s}; w++) {\n              int wIn = wBeg + w * ${d};\n\n              if (wIn >= 0 && wIn < ${i}) {\n                float xVal = getX(batch, hIn, wIn, d1);\n                float wVal = getW(h, w, d1);\n\n                float val = xVal + wVal;\n                if (val > curVal) {\n                  curVal = val;\n                }\n              }\n            }\n          }\n        }\n\n        float result = curVal;\n        setOutput(result);\n      }\n    `}}exports.Dilation2DProgram=n;
},{}],"X8vo":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.dilation2D=o,exports.dilation2DConfig=void 0;var e=require("@tensorflow/tfjs-core"),t=require("../dilation_gpu"),n=require("./Reshape");function o(o){const{inputs:i,backend:r,attrs:a}=o,{x:s,filter:l}=i,{strides:p,pad:d,dilations:u}=a,c=e.backend_util.computeDilation2DInfo(s.shape,l.shape,p,d,"NHWC",u);let f;const D=new t.Dilation2DProgram(c);f=r.runWebGLProgram(D,[s,l],"float32");const b=(0,n.reshape)({inputs:{x:f},backend:r,attrs:{shape:c.outShape}});return r.disposeIntermediateTensorInfo(f),b}const i=exports.dilation2DConfig={kernelName:e.Dilation2D,backendName:"webgl",kernelFunc:o};
},{"@tensorflow/tfjs-core":"kSBl","../dilation_gpu":"jHS7","./Reshape":"OCN8"}],"q6qu":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.einsum=u,exports.einsumConfig=void 0;var e=require("@tensorflow/tfjs-core"),t=require("./Multiply"),s=require("./Reshape"),n=require("./Sum"),i=require("./Transpose");function u(u){const{inputs:r,backend:a,attrs:o}=u,{equation:l}=o,p=r,{allDims:c,summedDims:m,idDims:d}=e.backend_util.decodeEinsumEquation(l,p.length);e.backend_util.checkEinsumDimSizes(c.length,d,p);const{path:h,steps:k}=e.backend_util.getEinsumComputePath(m,d),b=k.length;let f=null,g=c.length;const x=[];for(let q=0;q<b;++q){for(const n of k[q]){const{permutationIndices:u,expandDims:r}=e.backend_util.getEinsumPermutation(g,d[n]);let o;e.backend_util.isIdentityPermutation(u)?o=p[n]:(o=(0,i.transpose)({inputs:{x:p[n]},backend:a,attrs:{perm:u}}),x.push(o));const l=o.shape.slice();for(let e=0;e<r.length;++e)l.splice(r[e],0,1);e.util.arraysEqual(o.shape,l)||(o=(0,s.reshape)({inputs:{x:o},backend:a,attrs:{shape:l}}),x.push(o)),null===f?f=o:(f=(0,t.multiply)({inputs:{a:o,b:f},backend:a}),x.push(f))}q<b-1&&(h[q]>=0&&(f=(0,n.sum)({inputs:{x:f},backend:a,attrs:{axis:h[q]-(c.length-g),keepDims:!1}}),x.push(f)),g--)}for(const e of x)e!==f&&a.disposeIntermediateTensorInfo(e);return f}const r=exports.einsumConfig={kernelName:e.Einsum,backendName:"webgl",kernelFunc:u};
},{"@tensorflow/tfjs-core":"kSBl","./Multiply":"xWNx","./Reshape":"OCN8","./Sum":"FqPw","./Transpose":"ukag"}],"pPXB":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.eluConfig=void 0;var e=require("@tensorflow/tfjs-core"),r=require("../kernel_utils/kernel_funcs_utils");const n="return (x >= 0.0) ? x : (exp(x) - 1.0);",x="\n  vec4 result;\n\n  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);\n  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);\n  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);\n  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);\n\n  return result;\n",t=(0,r.unaryKernelFunc)({opSnippet:n,packedOpSnippet:x}),u=exports.eluConfig={kernelName:e.Elu,backendName:"webgl",kernelFunc:t};
},{"@tensorflow/tfjs-core":"kSBl","../kernel_utils/kernel_funcs_utils":"ciwP"}],"Oi5K":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.eluGradConfig=exports.eluGrad=void 0;var e=require("@tensorflow/tfjs-core"),r=require("../binaryop_gpu"),a=require("../binaryop_packed_gpu");const n="return (b >= 0.0) ? a : a * (b + 1.0);",o="\n  vec4 bGTEZero = vec4(greaterThanEqual(b, vec4(0.)));\n  return (bGTEZero * a) + ((vec4(1.0) - bGTEZero) * (a * (b + vec4(1.0))));\n",t=t=>{const{inputs:u,backend:p}=t,{dy:s,y:c}=u,b=(0,e.env)().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new a.BinaryOpPackedProgram(o,s.shape,c.shape):new r.BinaryOpProgram(n,s.shape,c.shape);return p.runWebGLProgram(b,[s,c],s.dtype)};exports.eluGrad=t;const u=exports.eluGradConfig={kernelName:e.EluGrad,backendName:"webgl",kernelFunc:t};
},{"@tensorflow/tfjs-core":"kSBl","../binaryop_gpu":"wbV2","../binaryop_packed_gpu":"mFR1"}],"CINd":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.equalConfig=exports.equal=void 0;var e=require("@tensorflow/tfjs-core"),r=require("../kernel_utils/kernel_funcs_utils"),l=require("../kernel_utils/shared");const n="\n  return vec4(equal(a, b));\n",u="return float(a == b);",t=exports.equal=(0,r.binaryKernelFunc)({opSnippet:u,packedOpSnippet:n,dtype:"bool",cpuKernelImpl:l.equalImplCPU}),a=exports.equalConfig={kernelName:e.Equal,backendName:"webgl",kernelFunc:t};
},{"@tensorflow/tfjs-core":"kSBl","../kernel_utils/kernel_funcs_utils":"ciwP","../kernel_utils/shared":"cNPH"}],"Ksgq":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.erfConfig=exports.erf=void 0;var e=require("@tensorflow/tfjs-core"),n=require("../kernel_utils/kernel_funcs_utils");const t=`\n  // Error function is calculated approximately with elementary function.\n  // See "Handbook of Mathematical Functions with Formulas,\n  // Graphs, and Mathematical Tables", Abramowitz and Stegun.\n  float p = ${e.backend_util.ERF_P};\n  float a1 = ${e.backend_util.ERF_A1};\n  float a2 = ${e.backend_util.ERF_A2};\n  float a3 = ${e.backend_util.ERF_A3};\n  float a4 = ${e.backend_util.ERF_A4};\n  float a5 = ${e.backend_util.ERF_A5};\n\n  float sign = sign(x);\n  x = abs(x);\n  float t = 1.0 / (1.0 + p * x);\n  return sign * (1.0 - (((((a5*t + a4)*t) + a3)*t + a2)*t + a1)*t*exp(-x*x));\n`,a=exports.erf=(0,n.unaryKernelFunc)({opSnippet:t}),r=exports.erfConfig={kernelName:e.Erf,backendName:"webgl",kernelFunc:a};
},{"@tensorflow/tfjs-core":"kSBl","../kernel_utils/kernel_funcs_utils":"ciwP"}],"zY0s":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.expConfig=exports.exp=exports.EXP=void 0;var e=require("@tensorflow/tfjs-core"),r=require("../kernel_utils/kernel_funcs_utils"),n=require("../kernel_utils/shared");const s=exports.EXP=r.CHECK_NAN_SNIPPET_UNARY+"\n  return exp(x);\n",t="\n  vec4 result = exp(x);\n  bvec4 isNaN = isnan(x);\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n",l=exports.exp=(0,r.unaryKernelFunc)({opSnippet:s,packedOpSnippet:t,cpuKernelImpl:n.expImplCPU,dtype:"float32"}),p=exports.expConfig={kernelName:e.Exp,backendName:"webgl",kernelFunc:l};
},{"@tensorflow/tfjs-core":"kSBl","../kernel_utils/kernel_funcs_utils":"ciwP","../kernel_utils/shared":"cNPH"}],"oL99":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.expandDims=t,exports.expandDimsConfig=void 0;var e=require("@tensorflow/tfjs-core"),s=require("./Reshape");function t(t){const{inputs:n,attrs:r,backend:i}=t,{dim:a}=r,{input:p}=n,o=p.shape.length,u=p.shape.slice();let c=a;return a<0&&(e.util.assert(-(o+1)<=a,()=>`Axis must be in the interval [${-(o+1)}, ${o}]`),c=o+a+1),u.splice(c,0,1),(0,s.reshape)({inputs:{x:p},backend:i,attrs:{shape:u}})}const n=exports.expandDimsConfig={kernelName:e.ExpandDims,backendName:"webgl",kernelFunc:t};
},{"@tensorflow/tfjs-core":"kSBl","./Reshape":"OCN8"}],"VaYT":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.expm1Config=exports.expm1=void 0;var e=require("@tensorflow/tfjs-core"),r=require("../kernel_utils/kernel_funcs_utils"),p=require("../kernel_utils/shared");const n="return exp(x) - 1.0;",t=exports.expm1=(0,r.unaryKernelFunc)({opSnippet:n,packedOpSnippet:n,cpuKernelImpl:p.expm1ImplCPU}),l=exports.expm1Config={kernelName:e.Expm1,backendName:"webgl",kernelFunc:t};
},{"@tensorflow/tfjs-core":"kSBl","../kernel_utils/kernel_funcs_utils":"ciwP","../kernel_utils/shared":"cNPH"}],"TApJ":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.FFTProgram=void 0;class e{constructor(e,t,n){this.variableNames=["real","imag"];const o=t[1];this.outputShape=t;const a=n?`2.0 * ${Math.PI}`:`-2.0 * ${Math.PI}`,i=n?`${o}.0`:"1.0";let l;if("real"===e)l="return real * expR - imag * expI;";else{if("imag"!==e)throw new Error(`FFT component must be either "real" or "imag", got ${e}.`);l="return real * expI + imag * expR;"}this.userCode=`\n      const float exponentMultiplier = ${a};\n\n      float unaryOpComplex(float real, float expR, float imag, float expI) {\n        ${l}\n      }\n\n      float mulMatDFT(int batch, int index) {\n        float indexRatio = float(index) / float(${o});\n        float exponentMultiplierTimesIndexRatio =\n            exponentMultiplier * indexRatio;\n\n        float result = 0.0;\n\n        for (int i = 0; i < ${o}; i++) {\n          // x = (-2|2 * PI / N) * index * i;\n          float x = exponentMultiplierTimesIndexRatio * float(i);\n          float expR = cos(x);\n          float expI = sin(x);\n          float real = getReal(batch, i);\n          float imag = getImag(batch, i);\n\n          result +=\n              unaryOpComplex(real, expR, imag, expI) / ${i};\n        }\n\n        return result;\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        setOutput(mulMatDFT(coords[0], coords[1]));\n      }\n    `}}exports.FFTProgram=e;
},{}],"WmX5":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.fftImpl=t;var e=require("@tensorflow/tfjs-core"),a=require("../fft_gpu"),r=require("./Complex"),s=require("./Reshape");function t(t,o,n){const p=n.texData.get(t.dataId),d=e.util.sizeFromShape(t.shape),i=t.shape[t.shape.length-1],m=d/i,f=(0,s.reshape)({inputs:{x:t},backend:n,attrs:{shape:[m,i]}}),l=f.shape,I=new a.FFTProgram("real",l,o),u=new a.FFTProgram("imag",l,o),c=[{dataId:p.complexTensorInfos.real.dataId,dtype:p.complexTensorInfos.real.dtype,shape:l},{dataId:p.complexTensorInfos.imag.dataId,dtype:p.complexTensorInfos.imag.dtype,shape:l}],h=n.runWebGLProgram(I,c,"float32"),g=n.runWebGLProgram(u,c,"float32"),x=(0,r.complex)({inputs:{real:h,imag:g},backend:n});n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(g);const T=(0,s.reshape)({inputs:{x:x},backend:n,attrs:{shape:t.shape}});return n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(x),T}
},{"@tensorflow/tfjs-core":"kSBl","../fft_gpu":"TApJ","./Complex":"BU0Z","./Reshape":"OCN8"}],"Kmz9":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.fft=r,exports.fftConfig=void 0;var e=require("@tensorflow/tfjs-core"),t=require("./FFT_impl");function r(e){const{inputs:r,backend:n}=e,{input:o}=r;return(0,t.fftImpl)(o,!1,n)}const n=exports.fftConfig={kernelName:e.FFT,backendName:"webgl",kernelFunc:r};
},{"@tensorflow/tfjs-core":"kSBl","./FFT_impl":"WmX5"}],"Y68Y":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.FillProgram=void 0;class t{constructor(t,e){this.outputShape=[],this.customUniforms=[{name:"value",type:"float"}],this.variableNames=["x"],this.outputShape=t,this.userCode="\n      void main() {\n        // Input can be obtained from uniform value.\n        setOutput(value);\n      }\n    "}}exports.FillProgram=t;
},{}],"LGba":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.fill=t,exports.fillConfig=void 0;var e=require("@tensorflow/tfjs-core"),r=require("../fill_gpu");function t(t){const{backend:l,attrs:n}=t,{shape:o,value:i}=n;let{dtype:s}=n;if("string"===(s=s||e.util.inferDtype(i))){const r=e.util.getArrayFromDType(s,e.util.sizeFromShape(o));return r.fill(i),l.makeTensorInfo(o,s,r)}{const e=new r.FillProgram(o,i),t=[[i]];return l.runWebGLProgram(e,[],s,t)}}const l=exports.fillConfig={kernelName:e.Fill,backendName:"webgl",kernelFunc:t};
},{"@tensorflow/tfjs-core":"kSBl","../fill_gpu":"Y68Y"}],"i85L":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.FlipLeftRightProgram=void 0;class o{constructor(o){this.variableNames=["Image"],this.outputShape=[];const t=o[2];this.outputShape=o,this.userCode=`\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int x = coords[2];\n\n          int coordX = ${t} - x - 1;\n          float outputValue;\n          if(coordX >= 0 && coordX < ${t}) {\n            outputValue = getImage(coords[0], coords[1], coordX, coords[3]);\n          } else {\n            outputValue = getImage(coords[0], coords[1], coords[2], coords[3]);\n          }\n          setOutput(outputValue);\n        }\n    `}}exports.FlipLeftRightProgram=o;
},{}],"gC7C":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.flipLeftRightConfig=void 0;var e=require("@tensorflow/tfjs-core"),t=require("../flip_left_right_gpu");const r=exports.flipLeftRightConfig={kernelName:e.FlipLeftRight,backendName:"webgl",kernelFunc:({inputs:e,backend:r})=>{const{image:i}=e,n=r,o=new t.FlipLeftRightProgram(i.shape);return n.runWebGLProgram(o,[i],i.dtype)}};
},{"@tensorflow/tfjs-core":"kSBl","../flip_left_right_gpu":"i85L"}],"SsfV":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.floorConfig=exports.floor=void 0;var e=require("@tensorflow/tfjs-core"),r=require("../kernel_utils/kernel_funcs_utils"),o=require("../kernel_utils/shared");const l="return floor(x);",n=exports.floor=(0,r.unaryKernelFunc)({opSnippet:l,packedOpSnippet:l,cpuKernelImpl:o.floorImplCPU}),t=exports.floorConfig={kernelName:e.Floor,backendName:"webgl",kernelFunc:n};
},{"@tensorflow/tfjs-core":"kSBl","../kernel_utils/kernel_funcs_utils":"ciwP","../kernel_utils/shared":"cNPH"}],"UMGZ":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.floorDivConfig=exports.floorDiv=void 0;var n=require("@tensorflow/tfjs-core"),i=require("../kernel_utils/kernel_funcs_utils");const e="\n  float s = sign(a) * sign(b);\n  int ia = round(a);\n  int ib = round(b);\n  if (ib != 0) {\n    // Windows (D3D) wants guaranteed non-zero int division at compile-time.\n    return float(idiv(ia, ib, s));\n  } else {\n    return NAN;\n  }\n",o="\n  ivec4 ia = round(a);\n  ivec4 ib = round(b);\n  bvec4 cond = notEqual(ib, ivec4(0));\n  ivec4 result = ivec4(0);\n  vec4 s = sign(a) * sign(b);\n\n  // Windows (D3D) wants guaranteed non-zero int division at compile-time.\n  if (cond[0]) {\n    result[0] = idiv(ia[0], ib[0], s[0]);\n  }\n  if (cond[1]) {\n    result[1] = idiv(ia[1], ib[1], s[1]);\n  }\n  if (cond[2]) {\n    result[2] = idiv(ia[2], ib[2], s[2]);\n  }\n  if (cond[3]) {\n    result[3] = idiv(ia[3], ib[3], s[3]);\n  }\n  return vec4(result);\n",r=exports.floorDiv=(0,i.binaryKernelFunc)({opSnippet:e,packedOpSnippet:o,dtype:"int32"}),t=exports.floorDivConfig={kernelName:n.FloorDiv,backendName:"webgl",kernelFunc:r};
},{"@tensorflow/tfjs-core":"kSBl","../kernel_utils/kernel_funcs_utils":"ciwP"}],"mavs":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.FromPixelsProgram=void 0;var e=require("../../glsl_version");class t{constructor(t){this.variableNames=["A"];const s=(0,e.getGlslDifferences)(),[n,o]=t;this.outputShape=t,this.userCode=`\n      void main() {\n        ivec3 coords = getOutputCoords();\n        int texR = coords[0];\n        int texC = coords[1];\n        int depth = coords[2];\n        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${o}.0, ${n}.0);\n\n        vec4 values = ${s.texture2D}(A, uv);\n        float value;\n        if (depth == 0) {\n          value = values.r;\n        } else if (depth == 1) {\n          value = values.g;\n        } else if (depth == 2) {\n          value = values.b;\n        } else if (depth == 3) {\n          value = values.a;\n        }\n\n        setOutput(floor(value * 255.0 + 0.5));\n      }\n    `}}exports.FromPixelsProgram=t;
},{"../../glsl_version":"fXvw"}],"XUB0":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.FromPixelsPackedProgram=void 0;var e=require("../../glsl_version");class t{constructor(t){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0;const o=(0,e.getGlslDifferences)(),[n,s]=t;this.outputShape=t,this.userCode=`\n      void main() {\n        ivec3 coords = getOutputCoords();\n        int texR = coords[0];\n        int texC = coords[1];\n        int depth = coords[2];\n\n        vec4 result = vec4(0.);\n\n        for(int row=0; row<=1; row++) {\n          for(int col=0; col<=1; col++) {\n            texC = coords[1] + row;\n            depth = coords[2] + col;\n\n            vec2 uv = (vec2(texC, texR) + halfCR) /\n                       vec2(${s}.0, ${n}.0);\n            vec4 values = ${o.texture2D}(A, uv);\n            float value;\n            if (depth == 0) {\n              value = values.r;\n            } else if (depth == 1) {\n              value = values.g;\n            } else if (depth == 2) {\n              value = values.b;\n            } else if (depth == 3) {\n              value = values.a;\n            }\n\n            result[row * 2 + col] = floor(value * 255.0 + 0.5);\n          }\n        }\n\n        ${o.output} = result;\n      }\n    `}}exports.FromPixelsPackedProgram=t;
},{"../../glsl_version":"fXvw"}],"ryYF":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.fromPixelsConfig=void 0;var e=require("@tensorflow/tfjs-core"),t=require("../tex_util"),n=require("./FromPixels_utils/from_pixels_gpu"),o=require("./FromPixels_utils/from_pixels_packed_gpu");const a=exports.fromPixelsConfig={kernelName:e.FromPixels,backendName:"webgl",kernelFunc:s};let r,i=(0,e.env)().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");function s(a){const{inputs:s,backend:l,attrs:d}=a;let{pixels:u}=s;const{numChannels:m}=d,g="undefined"!=typeof HTMLVideoElement&&u instanceof HTMLVideoElement,c="undefined"!=typeof HTMLImageElement&&u instanceof HTMLImageElement,[_,x]=g?[u.videoWidth,u.videoHeight]:[u.width,u.height],f=[x,_],p=[x,_,m];if(c||g){const t=(0,e.env)().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");null!=r&&t===i||(i=t,r=document.createElement("canvas").getContext("2d",{willReadFrequently:i})),r.canvas.width=_,r.canvas.height=x,r.drawImage(u,0,0,_,x),u=r.canvas}const P=l.makeTensorInfo(f,"int32");l.texData.get(P.dataId).usage=t.TextureUsage.PIXELS,l.gpgpu.uploadPixelDataToTexture(l.getTexture(P.dataId),u);const E=(0,e.env)().getBool("WEBGL_PACK")?new o.FromPixelsPackedProgram(p):new n.FromPixelsProgram(p),L=l.runWebGLProgram(E,[P],"int32");return l.disposeData(P.dataId),L}
},{"@tensorflow/tfjs-core":"kSBl","../tex_util":"jAWT","./FromPixels_utils/from_pixels_gpu":"mavs","./FromPixels_utils/from_pixels_packed_gpu":"XUB0"}],"wsrZ":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.fusedConv2DConfig=void 0,exports.fusedConv2d=r;var e=require("@tensorflow/tfjs-core"),t=require("../conv_gpu"),n=require("../conv_packed_gpu"),a=require("../kernel_utils/kernel_funcs_utils"),i=require("./Conv2D_impl"),o=require("./Reshape");function r(r){const{inputs:s,backend:l,attrs:u}=r,{x:d,filter:p,bias:c,preluActivationWeights:h}=s,{strides:f,pad:v,dataFormat:g,dilations:k,dimRoundingMode:m,activation:W,leakyreluAlpha:b}=u,C=e.backend_util.convertConv2DDataFormat(g),_=e.backend_util.computeConv2DInfo(d.shape,p.shape,f,k,v,m,!1,C);let I;const A=[],D=null!=c,x=null!=h,P="leakyrelu"===W,y=()=>{const t=[d,p],n=(e,t)=>{if("NCHW"===t&&1===e.shape.length&&1!==e.shape[0]){const t=(0,o.reshape)({inputs:{x:e},backend:l,attrs:{shape:[e.shape[0],1,1]}});return A.push(t),t}return e};if(D&&t.push(n(c,g)),x&&t.push(n(h,g)),P){const n=l.makeTensorInfo([],"float32",e.util.createScalarValue(b,"float32"));t.push(n),A.push(n)}return t};if(1!==_.filterHeight||1!==_.filterWidth||1!==_.dilationHeight||1!==_.dilationWidth||1!==_.strideHeight||1!==_.strideWidth||"SAME"!==_.padInfo.type&&"VALID"!==_.padInfo.type)if(_.strideWidth<=2&&"channelsLast"===C&&(0,e.env)().getBool("WEBGL_EXP_CONV")){const e=W?(0,a.mapActivationToShaderProgram)(W,!0):null,t=new n.Conv2DPackedProgram(_,D,e,x,P),i=[[_.padInfo.top,_.padInfo.left],[_.strideHeight,_.strideWidth],[_.dilationHeight,_.dilationWidth],[_.inHeight,_.inWidth]],o=y();I=l.runWebGLProgram(t,o,"float32",i)}else if((0,e.env)().getBool("WEBGL_CONV_IM2COL"))I=(0,i.conv2dWithIm2Row)({x:d,filter:p,convInfo:_,backend:l,bias:c,activation:W,preluActivationWeights:h,leakyreluAlpha:b});else{const e=W?(0,a.mapActivationToShaderProgram)(W,!1):null,n=new t.Conv2DProgram(_,D,e,x,P),i=y();I=l.runWebGLProgram(n,i,"float32")}else I=(0,i.conv2dByMatMul)({x:d,filter:p,convInfo:_,backend:l,bias:c,activation:W,preluActivationWeights:h,leakyreluAlpha:b});const H=(0,o.reshape)({inputs:{x:I},backend:l,attrs:{shape:_.outShape}});return A.push(I),A.forEach(e=>l.disposeIntermediateTensorInfo(e)),H}const s=exports.fusedConv2DConfig={kernelName:e.FusedConv2D,backendName:"webgl",kernelFunc:r};
},{"@tensorflow/tfjs-core":"kSBl","../conv_gpu":"viLo","../conv_packed_gpu":"g3Bb","../kernel_utils/kernel_funcs_utils":"ciwP","./Conv2D_impl":"CtO4","./Reshape":"OCN8"}],"FsyW":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.fusedDepthwiseConv2D=o,exports.fusedDepthwiseConv2DConfig=void 0;var e=require("@tensorflow/tfjs-core"),t=require("../conv_gpu_depthwise"),i=require("../conv_packed_gpu_depthwise"),n=require("../kernel_utils/kernel_funcs_utils");function o(o){const{inputs:s,backend:r,attrs:a}=o,{x:l,filter:d,bias:u,preluActivationWeights:p}=s,{strides:h,pad:c,dilations:f,dimRoundingMode:v,activation:g,leakyreluAlpha:D}=a,C=[];let _=f;null==_&&(_=[1,1]),e.util.assert(e.backend_util.eitherStridesOrDilationsAreOne(h,_),()=>"Error in depthwiseConv2d: Either strides or dilations must be "+`1. Got strides ${h} and dilations '${_}'`);const k=e.backend_util.computeConv2DInfo(l.shape,d.shape,h,_,c,v,!0),w=(0,e.env)().getBool("WEBGL_PACK_DEPTHWISECONV")&&k.strideWidth<=2&&k.outChannels/k.inChannels==1,m=g?(0,n.mapActivationToShaderProgram)(g,w):null,b=[l,d],P=null!=u,W=null!=p,I="leakyrelu"===g;if(P&&b.push(u),W&&b.push(p),I){const t=r.makeTensorInfo([],"float32",e.util.createScalarValue(D,"float32"));b.push(t),C.push(t)}let E;E=w?new i.DepthwiseConvPacked2DProgram(k,P,m,W,I):new t.DepthwiseConv2DProgram(k,P,m,W,I);const x=[[k.padInfo.top,k.padInfo.left],[k.strideHeight,k.strideWidth],[k.dilationHeight,k.dilationWidth],[k.inHeight,k.inWidth]],A=r.runWebGLProgram(E,b,"float32",x);return C.forEach(e=>r.disposeIntermediateTensorInfo(e)),A}const s=exports.fusedDepthwiseConv2DConfig={kernelName:e.FusedDepthwiseConv2D,backendName:"webgl",kernelFunc:o};
},{"@tensorflow/tfjs-core":"kSBl","../conv_gpu_depthwise":"ONBM","../conv_packed_gpu_depthwise":"s3KE","../kernel_utils/kernel_funcs_utils":"ciwP"}],"uFxL":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.GatherNDProgram=void 0;var t=require("./shader_compiler");class e{constructor(e,o,s,n){this.sliceDim=e,this.strides=o,this.paramsShape=n,this.variableNames=["x","indices"],this.outputShape=s;const i=(0,t.getCoordsDataType)(s.length);let r="\n    int index;";for(let t=0;t<this.sliceDim;t++)r+=`\n          index = round(getIndices(coords[0], ${t}));\n          out_of_bounds = out_of_bounds || index < 0;\n          out_of_bounds = out_of_bounds || index >= ${this.paramsShape[t]};\n          flattenIndex += index * ${this.strides[t]};`;this.userCode=`\n         void main() {\n          ${i} coords = getOutputCoords();\n          int flattenIndex = 0;\n          bool out_of_bounds = false;\n\n          ${r}\n\n          setOutput(out_of_bounds ? 0.0 : getX(flattenIndex, coords[1]));\n        }\n      `}}exports.GatherNDProgram=e;
},{"./shader_compiler":"xhhc"}],"DXdr":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.gatherNd=a,exports.gatherNdConfig=void 0;var e=require("@tensorflow/tfjs-core"),r=require("../gather_nd_gpu"),t=require("../kernel_utils/shared"),s=require("./Reshape");function a(a){const{inputs:n,backend:p}=a,{params:d,indices:o}=n,i=o.shape,u=i[i.length-1],h=e.util.sizeFromShape(d.shape),[c,l,f,g]=e.backend_util.prepareAndValidate(d,o),m=(0,s.reshape)({inputs:{x:o},backend:p,attrs:{shape:[l,u]}}),b=(0,s.reshape)({inputs:{x:d},backend:p,attrs:{shape:[e.util.sizeFromShape(d.shape)/f,f]}});if(p.shouldExecuteOnCPU([d,o])||"string"===d.dtype){const e=p.readSync(o.dataId),r=p.bufferSync(d),s=(0,t.gatherNdImplCPU)(e,r,d.dtype,l,u,f,g,d.shape,h);return p.makeTensorInfo(c,d.dtype,s.values)}const k=new r.GatherNDProgram(u,g,[l,f],d.shape),I=p.runWebGLProgram(k,[b,m],b.dtype),x=(0,s.reshape)({inputs:{x:I},backend:p,attrs:{shape:c}});return p.disposeIntermediateTensorInfo(m),p.disposeIntermediateTensorInfo(b),p.disposeIntermediateTensorInfo(I),x}const n=exports.gatherNdConfig={kernelName:e.GatherNd,backendName:"webgl",kernelFunc:a};
},{"@tensorflow/tfjs-core":"kSBl","../gather_nd_gpu":"uFxL","../kernel_utils/shared":"cNPH","./Reshape":"OCN8"}],"avEA":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.GatherProgram=void 0;var e=require("./shader_compiler");class t{constructor(t,s){this.variableNames=["A","indices"],this.outputShape=s,this.rank=s.length;const n=(0,e.getCoordsDataType)(this.rank),i=r(t,2);this.userCode=`\n      void main() {\n        ${n} resRC = getOutputCoords();\n        int index = int(getIndices(resRC.x, resRC.z));\n        float inBounds = (index >= 0) && (index < ${t[2]}) ? 1.0 : 0.0;\n        setOutput(inBounds * getA(${i}));\n      }\n    `}}function r(e,t){const r=["resRC.x","resRC.y","resRC.z","resRC.w"],s=[];for(let n=0;n<e.length;n++)2===n?s.push("index"):s.push(`${r[n]}`);return s.join()}exports.GatherProgram=t;
},{"./shader_compiler":"xhhc"}],"SjQ7":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.gatherV2=a,exports.gatherV2Config=void 0;var e=require("@tensorflow/tfjs-core"),t=require("../gather_gpu"),r=require("../kernel_utils/shared"),s=require("./Reshape");function a(a){const{inputs:n,backend:i,attrs:o}=a,{x:h,indices:p}=n,{axis:u,batchDims:c}=o,d=e.util.parseAxisParam(u,h.shape)[0];if((0,e.env)().get("DEBUG")){const t=i.readSync(p.dataId),r=h.shape[d];for(let s=0;s<t.length;++s){const a=t[s];e.util.assert(a<=r-1&&a>=0,()=>`GatherV2: the index value ${a} is not in [0, ${r-1}]`)}}const l=e.backend_util.segment_util.collectGatherOpShapeInfo(h,p,d,c),f=e.util.sizeFromShape(p.shape),b=[],S=(0,s.reshape)({inputs:{x:h},backend:i,attrs:{shape:[l.batchSize,l.outerSize,l.dimSize,l.sliceSize]}}),g=(0,s.reshape)({inputs:{x:p},backend:i,attrs:{shape:[l.batchSize,f/l.batchSize]}});b.push(S),b.push(g);const m=[l.batchSize,l.outerSize,f/l.batchSize,l.sliceSize];if(i.shouldExecuteOnCPU([h,p])||"string"===h.dtype){const e=i.bufferSync(g),t=i.bufferSync(S),s=(0,r.gatherV2ImplCPU)(t,e,m);return b.forEach(e=>i.disposeIntermediateTensorInfo(e)),i.makeTensorInfo(l.outputShape,s.dtype,s.values)}const x=new t.GatherProgram(S.shape,m),z=i.runWebGLProgram(x,[S,g],S.dtype);b.push(z);const k=(0,s.reshape)({inputs:{x:z},backend:i,attrs:{shape:l.outputShape}});return b.forEach(e=>i.disposeIntermediateTensorInfo(e)),k}const n=exports.gatherV2Config={kernelName:e.GatherV2,backendName:"webgl",kernelFunc:a};
},{"@tensorflow/tfjs-core":"kSBl","../gather_gpu":"avEA","../kernel_utils/shared":"cNPH","./Reshape":"OCN8"}],"mJSN":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.greaterConfig=exports.greater=void 0;var e=require("@tensorflow/tfjs-core"),r=require("../kernel_utils/kernel_funcs_utils"),t=require("../kernel_utils/shared");const n="return float(a > b);",a="\n  return vec4(greaterThan(a, b));\n",l=exports.greater=(0,r.binaryKernelFunc)({opSnippet:n,packedOpSnippet:a,cpuKernelImpl:t.greaterImplCPU,dtype:"bool"}),o=exports.greaterConfig={kernelName:e.Greater,backendName:"webgl",kernelFunc:l};
},{"@tensorflow/tfjs-core":"kSBl","../kernel_utils/kernel_funcs_utils":"ciwP","../kernel_utils/shared":"cNPH"}],"slmh":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.greaterEqualConfig=exports.greaterEqual=void 0;var e=require("@tensorflow/tfjs-core"),r=require("../kernel_utils/kernel_funcs_utils"),t=require("../kernel_utils/shared");const a="return float(a >= b);",l="\n  return vec4(greaterThanEqual(a, b));\n",n=exports.greaterEqual=(0,r.binaryKernelFunc)({opSnippet:a,packedOpSnippet:l,dtype:"bool",cpuKernelImpl:t.greaterEqualImplCPU}),u=exports.greaterEqualConfig={kernelName:e.GreaterEqual,backendName:"webgl",kernelFunc:n};
},{"@tensorflow/tfjs-core":"kSBl","../kernel_utils/kernel_funcs_utils":"ciwP","../kernel_utils/shared":"cNPH"}],"fOWs":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.ifft=r,exports.ifftConfig=void 0;var e=require("@tensorflow/tfjs-core"),t=require("./FFT_impl");function r(e){const{inputs:r,backend:n}=e,{input:o}=r;return(0,t.fftImpl)(o,!0,n)}const n=exports.ifftConfig={kernelName:e.IFFT,backendName:"webgl",kernelFunc:r};
},{"@tensorflow/tfjs-core":"kSBl","./FFT_impl":"WmX5"}],"ZxhQ":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.isFiniteConfig=exports.isFinite=void 0;var e=require("@tensorflow/tfjs-core"),i=require("../kernel_utils/kernel_funcs_utils");const n="return float(!isnan(x) && !isinf(x));",r=exports.isFinite=(0,i.unaryKernelFunc)({opSnippet:n,dtype:"bool"}),t=exports.isFiniteConfig={kernelName:e.IsFinite,backendName:"webgl",kernelFunc:r};
},{"@tensorflow/tfjs-core":"kSBl","../kernel_utils/kernel_funcs_utils":"ciwP"}],"MgGt":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.isInfConfig=exports.isInf=void 0;var e=require("@tensorflow/tfjs-core"),n=require("../kernel_utils/kernel_funcs_utils");const r="return float(isinf(x));",s=exports.isInf=(0,n.unaryKernelFunc)({opSnippet:r,dtype:"bool"}),o=exports.isInfConfig={kernelName:e.IsInf,backendName:"webgl",kernelFunc:s};
},{"@tensorflow/tfjs-core":"kSBl","../kernel_utils/kernel_funcs_utils":"ciwP"}],"q4GM":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.isNaNConfig=exports.isNaN=void 0;var e=require("@tensorflow/tfjs-core"),r=require("../kernel_utils/kernel_funcs_utils");const n="return float(isnan(x));",s=exports.isNaN=(0,r.unaryKernelFunc)({opSnippet:n,dtype:"bool"}),o=exports.isNaNConfig={kernelName:e.IsNan,backendName:"webgl",kernelFunc:s};
},{"@tensorflow/tfjs-core":"kSBl","../kernel_utils/kernel_funcs_utils":"ciwP"}],"ddK3":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.lessConfig=exports.less=void 0;var e=require("@tensorflow/tfjs-core"),r=require("../kernel_utils/kernel_funcs_utils"),s=require("../kernel_utils/shared");const l="return float(a < b);",n="\n  return vec4(lessThan(a, b));\n",t=exports.less=(0,r.binaryKernelFunc)({opSnippet:l,packedOpSnippet:n,cpuKernelImpl:s.lessImplCPU,dtype:"bool"}),o=exports.lessConfig={kernelName:e.Less,backendName:"webgl",kernelFunc:t};
},{"@tensorflow/tfjs-core":"kSBl","../kernel_utils/kernel_funcs_utils":"ciwP","../kernel_utils/shared":"cNPH"}],"Pgrg":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.lessEqualConfig=exports.lessEqual=exports.LESS_EQUAL_PACKED=exports.LESS_EQUAL=void 0;var e=require("@tensorflow/tfjs-core"),r=require("../kernel_utils/kernel_funcs_utils"),s=require("../kernel_utils/shared");const l=exports.LESS_EQUAL="return float(a <= b);",t=exports.LESS_EQUAL_PACKED="\n  return vec4(lessThanEqual(a, b));\n",n=exports.lessEqual=(0,r.binaryKernelFunc)({opSnippet:l,packedOpSnippet:t,cpuKernelImpl:s.lessEqualImplCPU,dtype:"bool"}),o=exports.lessEqualConfig={kernelName:e.LessEqual,backendName:"webgl",kernelFunc:n};
},{"@tensorflow/tfjs-core":"kSBl","../kernel_utils/kernel_funcs_utils":"ciwP","../kernel_utils/shared":"cNPH"}],"DW7C":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.linSpace=r,exports.linSpaceConfig=void 0;var e=require("@tensorflow/tfjs-core"),n=require("../kernel_utils/shared");function r(e){const{backend:r,attrs:t}=e,{start:o,stop:s,num:a}=t,l=(0,n.linSpaceImplCPU)(o,s,a);return r.makeTensorInfo([l.length],"float32",l)}const t=exports.linSpaceConfig={kernelName:e.LinSpace,backendName:"webgl",kernelFunc:r};
},{"@tensorflow/tfjs-core":"kSBl","../kernel_utils/shared":"cNPH"}],"QMgc":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.logConfig=exports.log=void 0;var e=require("@tensorflow/tfjs-core"),r=require("../kernel_utils/kernel_funcs_utils"),l=require("../kernel_utils/shared");const n=r.CHECK_NAN_SNIPPET_UNARY+"\n  return x < 0.0 ? 0./0. : log(x);\n",s="\n  vec4 result = log(x);\n  bvec4 isNaN = isnan(x);\n  result.r = isNaN.r ? x.r : (x.r < 0.0 ? 0./0. : result.r);\n  result.g = isNaN.g ? x.g : (x.g < 0.0 ? 0./0. : result.g);\n  result.b = isNaN.b ? x.b : (x.b < 0.0 ? 0./0. : result.b);\n  result.a = isNaN.a ? x.a : (x.a < 0.0 ? 0./0. : result.a);\n  return result;\n",t=exports.log=(0,r.unaryKernelFunc)({opSnippet:n,packedOpSnippet:s,cpuKernelImpl:l.logImplCPU}),u=exports.logConfig={kernelName:e.Log,backendName:"webgl",kernelFunc:t};
},{"@tensorflow/tfjs-core":"kSBl","../kernel_utils/kernel_funcs_utils":"ciwP","../kernel_utils/shared":"cNPH"}],"cToW":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.log1pConfig=exports.log1p=void 0;var e=require("@tensorflow/tfjs-core"),r=require("../kernel_utils/kernel_funcs_utils");const o=r.CHECK_NAN_SNIPPET_UNARY+"\n  return log(1.0 + x);\n",n=exports.log1p=(0,r.unaryKernelFunc)({opSnippet:o}),l=exports.log1pConfig={kernelName:e.Log1p,backendName:"webgl",kernelFunc:n};
},{"@tensorflow/tfjs-core":"kSBl","../kernel_utils/kernel_funcs_utils":"ciwP"}],"bfnB":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.logicalAndConfig=exports.logicalAnd=void 0;var e=require("@tensorflow/tfjs-core"),n=require("../kernel_utils/kernel_funcs_utils");const r="return float(a >= 1.0 && b >= 1.0);",l="\n  return vec4(\n    vec4(greaterThanEqual(a, vec4(1.0))) *\n    vec4(greaterThanEqual(b, vec4(1.0))));\n",o=exports.logicalAnd=(0,n.binaryKernelFunc)({opSnippet:r,packedOpSnippet:l,dtype:"bool"}),t=exports.logicalAndConfig={kernelName:e.LogicalAnd,backendName:"webgl",kernelFunc:o};
},{"@tensorflow/tfjs-core":"kSBl","../kernel_utils/kernel_funcs_utils":"ciwP"}],"crq9":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.logicalNotConfig=exports.logicalNot=void 0;var e=require("@tensorflow/tfjs-core"),o=require("../kernel_utils/kernel_funcs_utils");const r="return float(!(x >= 1.0));",t=exports.logicalNot=(0,o.unaryKernelFunc)({opSnippet:r}),l=exports.logicalNotConfig={kernelName:e.LogicalNot,backendName:"webgl",kernelFunc:t};
},{"@tensorflow/tfjs-core":"kSBl","../kernel_utils/kernel_funcs_utils":"ciwP"}],"QPdQ":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.logicalOrConfig=exports.logicalOr=void 0;var e=require("@tensorflow/tfjs-core"),r=require("../kernel_utils/kernel_funcs_utils");const n="return float(a >= 1.0 || b >= 1.0);",l="\n  return min(\n    vec4(greaterThanEqual(a, vec4(1.0))) +\n    vec4(greaterThanEqual(b, vec4(1.0))),\n    vec4(1.0));\n",o=exports.logicalOr=(0,r.binaryKernelFunc)({opSnippet:n,packedOpSnippet:l,dtype:"bool"}),t=exports.logicalOrConfig={kernelName:e.LogicalOr,backendName:"webgl",kernelFunc:o};
},{"@tensorflow/tfjs-core":"kSBl","../kernel_utils/kernel_funcs_utils":"ciwP"}],"UNBn":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.LRNProgram=void 0;class t{constructor(t,o,n,s,e){this.variableNames=["x"],this.outputShape=[];const r=o,i=t[3]-1;let a;this.outputShape=t;const d=`float(${n}) + float(${s}) * sum`;a=.5===e?`inversesqrt(${d})`:1===e?`1.0/(${d})`:`exp(log(${d}) * float(-${e}));`,this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int r = coords[1];\n        int c = coords[2];\n        int d = coords[3];\n        float x = getX(b, r, c, d);\n        float sum = 0.0;\n        for (int j = -${r}; j <= ${r}; j++) {\n          int idx = d + j;\n          if (idx >= 0 && idx <=  ${i}) {\n            float z = getX(b, r, c, idx);\n            sum += z * z;\n          }\n        }\n        float val = x * ${a};\n        setOutput(val);\n      }\n    `}}exports.LRNProgram=t;
},{}],"Ej1v":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.LRNPackedProgram=void 0;class e{constructor(e,n,t,o,a){this.variableNames=["x"],this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0;const r=n,c=e[3]-1;let s;this.outputShape=e;const u=`float(${t}) + float(${o}) * sum`;s=.5===a?`inversesqrt(${u})`:1===a?`1.0/(${u})`:`exp(log(${u}) * float(-${a}));`,this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords.x;\n        int r = coords.y;\n        int c = coords.z;\n        int d = coords.w;\n\n        bool hasNextCol = d < ${this.outputShape[3]};\n        bool hasNextRow = c < ${this.outputShape[2]};\n\n        vec4 sum = vec4(0.);\n        vec4 xFragAtOutputCoords = getX(b, r, c, d);\n\n        vec4 xAtOutputCoords = vec4(\n          getChannel(xFragAtOutputCoords, vec2(c, d)),\n          hasNextCol ?\n            getChannel(xFragAtOutputCoords, vec2(c, d + 1)) : 0.0,\n          hasNextRow ?\n            getChannel(xFragAtOutputCoords , vec2(c + 1, d)) : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getChannel(xFragAtOutputCoords, vec2(c + 1, d + 1)) : 0.0\n        );\n\n        int firstChannel = d - ${r};\n        vec2 cache = vec2(0.);\n        if(firstChannel >= 0){\n          vec4 firstChannelFrag = getX(b, r, c, firstChannel);\n          cache.x = getChannel(firstChannelFrag, vec2(c, firstChannel));\n            if(hasNextRow){\n              cache.y = getChannel(firstChannelFrag, vec2(c + 1, firstChannel));\n            }\n        }\n\n        ivec2 depth = ivec2(d, d + 1);\n        for (int j = - ${r}; j <= ${r}; j++) {\n          ivec2 idx = depth + j;\n          bvec2 aboveLowerBound = greaterThanEqual(idx, ivec2(0));\n          bvec2 belowUpperBound = lessThanEqual(idx, ivec2(${c}));\n\n          bool depthInRange = aboveLowerBound.x && belowUpperBound.x;\n          bool depthPlusOneInRange = aboveLowerBound.y && belowUpperBound.y;\n\n          if(depthInRange || depthPlusOneInRange){\n            vec4 z = vec4(0.);\n            vec4 xFragAtCurrentDepth;\n            z.xz = cache.xy;\n            if(depthPlusOneInRange && hasNextCol){\n              xFragAtCurrentDepth = idx.y != d ?\n                getX(b, r, c, idx.y) : xFragAtOutputCoords;\n              z.y = getChannel(xFragAtCurrentDepth, vec2(c, idx.y));\n              if(hasNextRow){\n                z.w = getChannel(xFragAtCurrentDepth, vec2(c + 1, idx.y));\n              }\n            }\n            cache.xy = z.yw;\n            sum += z * z;\n          }\n        }\n        vec4 result = xAtOutputCoords * ${s};\n        setOutput(result);\n      }\n    `}}exports.LRNPackedProgram=e;
},{}],"LYtN":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.lrn=exports.LRNConfig=void 0;var e=require("@tensorflow/tfjs-core"),r=require("../lrn_gpu"),n=require("../lrn_packed_gpu");const t=t=>{const{inputs:o,backend:a,attrs:s}=t,{x:p}=o,{depthRadius:u,bias:l,alpha:c,beta:i}=s,d=(0,e.env)().getBool("WEBGL_PACK_NORMALIZATION")?new n.LRNPackedProgram(p.shape,u,l,c,i):new r.LRNProgram(p.shape,u,l,c,i);return a.runWebGLProgram(d,[p],p.dtype)};exports.lrn=t;const o=exports.LRNConfig={kernelName:e.LRN,backendName:"webgl",kernelFunc:t};
},{"@tensorflow/tfjs-core":"kSBl","../lrn_gpu":"UNBn","../lrn_packed_gpu":"Ej1v"}],"SBA2":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.LRNGradProgram=void 0;class n{constructor(n,t,e,i,o){this.variableNames=["inputImage","outputImage","dy"],this.outputShape=[],this.outputShape=n,this.depth=n[3],this.depthRadius=t,this.bias=e,this.alpha=i,this.beta=o,this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int r = coords[1];\n        int c = coords[2];\n\n        float result = 0.0;\n        for (int d = 0; d < ${this.depth}; ++d) {\n          int depthBegin = int(max(0.0, float(d - ${t})));\n          int depthEnd = int(min(float(${this.depth}),\n              float(d + ${t} + 1)));\n\n          const int MIN_DEPTH_BEGIN = 0;\n          const int MAX_DEPTH_END = ${this.depth};\n\n          float norm = 0.0;\n          for (int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k) {\n            if (k < depthBegin){\n              continue;\n            }\n            else if (k >= depthBegin && k < depthEnd) {\n              norm += getInputImage(b, r, c, k) * getInputImage(b, r, c, k);\n            }\n            else {\n              break;\n            }\n          }\n\n          norm = float(${i}) * norm + float(${e});\n\n          for(int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k){\n            if (k < depthBegin){\n              continue;\n            }\n            else if (k >= depthBegin && k < depthEnd){\n              float dyi = -2.0 * float(${i})\n                * float(${o})\n                * getInputImage(b, r, c, k) * getOutputImage(b, r, c, d)\n                / norm;\n              if (k == d) {\n                dyi += pow(norm, -1.0 * ${o});\n              }\n              if (k == coords[3]) {\n                dyi *= getDy(b, r, c, d);\n                result += dyi;\n              }\n            }\n            else {\n              break;\n            }\n          }\n      }\n      setOutput(result);\n      }\n    `}}exports.LRNGradProgram=n;
},{}],"axL9":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.lrnGrad=exports.LRNGradConfig=void 0;var e=require("@tensorflow/tfjs-core"),r=require("../lrn_grad_gpu");const a=e=>{const{inputs:a,backend:t,attrs:n}=e,{x:o,y:s,dy:d}=a,{depthRadius:p,bias:u,alpha:i,beta:l}=n,c=new r.LRNGradProgram(o.shape,p,u,i,l);return t.runWebGLProgram(c,[o,s,d],o.dtype)};exports.lrnGrad=a;const t=exports.LRNGradConfig={kernelName:e.LRNGrad,backendName:"webgl",kernelFunc:a};
},{"@tensorflow/tfjs-core":"kSBl","../lrn_grad_gpu":"SBA2"}],"TnIL":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.maxImpl=t;var e=require("@tensorflow/tfjs-core"),r=require("../kernel_utils/reduce"),s=require("../kernels/Reshape");function t(t,a,n,i){const o=e.util.sizeFromShape(a),p=e.util.sizeFromShape(t.shape)/o,u=(0,s.reshape)({inputs:{x:t},attrs:{shape:[p,o]},backend:i}),d=(0,r.reduce)(u,t.dtype,"max",i),c=(0,s.reshape)({inputs:{x:d},attrs:{shape:n},backend:i});return i.disposeIntermediateTensorInfo(u),i.disposeIntermediateTensorInfo(d),c}
},{"@tensorflow/tfjs-core":"kSBl","../kernel_utils/reduce":"tZI5","../kernels/Reshape":"OCN8"}],"Scv7":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.max=n,exports.maxConfig=void 0;var e=require("@tensorflow/tfjs-core"),t=require("../kernel_utils/shared"),a=require("./Max_impl"),s=require("./Transpose_impl");function n(n){const{inputs:r,backend:o,attrs:l}=n,{x:i}=r,{reductionIndices:p,keepDims:d}=l,u=i.shape.length,c=e.util.parseAxisParam(p,i.shape);let m=c;const x=e.backend_util.getAxesPermutation(m,u),I=null!=x,f=o.shouldExecuteOnCPU([i]);let h=i;if(I){if(f){const e=o.texData.get(h.dataId).values,t=new Array(u);for(let s=0;s<t.length;s++)t[s]=i.shape[x[s]];const a=(0,s.transposeImplCPU)(e,i.shape,i.dtype,x,t);h=o.makeTensorInfo(t,i.dtype),o.texData.get(h.dataId).values=a}else h=(0,s.transposeImpl)(i,x,o);m=e.backend_util.getInnerMostAxes(m.length,u)}e.backend_util.assertAxesAreInnerMostDims("max",m,u);const[k,g]=e.backend_util.computeOutAndReduceShapes(h.shape,m);let _,b=k;if(d&&(b=e.backend_util.expandShapeToKeepDim(k,c)),f){const a=o.texData.get(h.dataId).values,s=(0,t.maxImplCPU)(a,e.util.sizeFromShape(g),b,i.dtype);_=o.makeTensorInfo(b,i.dtype),o.texData.get(_.dataId).values=s}else _=(0,a.maxImpl)(h,g,b,o);return I&&o.disposeIntermediateTensorInfo(h),_}const r=exports.maxConfig={kernelName:e.Max,backendName:"webgl",kernelFunc:n};
},{"@tensorflow/tfjs-core":"kSBl","../kernel_utils/shared":"cNPH","./Max_impl":"TnIL","./Transpose_impl":"VG4U"}],"G2Br":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.maximumConfig=exports.maximum=void 0;var e=require("@tensorflow/tfjs-core"),r=require("../binaryop_gpu"),i=require("../binaryop_packed_gpu"),n=require("../kernel_utils/kernel_funcs_utils"),a=require("../kernel_utils/shared");const s=r.CHECK_NAN_SNIPPET+"\n  return max(a, b);\n",N="\n  vec4 result = vec4(max(a, b));\n  bvec4 isNaNA = isnan(a);\n  bvec4 isNaNB = isnan(b);\n  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);\n  "+i.CHECK_NAN_SNIPPET_PACKED+"\n  return result;\n",u=exports.maximum=(0,n.binaryKernelFunc)({opSnippet:s,packedOpSnippet:N,cpuKernelImpl:a.maximumImplCPU}),m=exports.maximumConfig={kernelName:e.Maximum,backendName:"webgl",kernelFunc:u};
},{"@tensorflow/tfjs-core":"kSBl","../binaryop_gpu":"wbV2","../binaryop_packed_gpu":"mFR1","../kernel_utils/kernel_funcs_utils":"ciwP","../kernel_utils/shared":"cNPH"}],"c3Fl":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.maxPool=i,exports.maxPoolConfig=void 0;var e=require("@tensorflow/tfjs-core"),t=require("../pool_gpu"),o=require("../webgl_util"),r=require("./Identity");function i(i){const{inputs:n,backend:s,attrs:a}=i,{x:l}=n;(0,o.assertNotComplex)(l,"maxPool");const{filterSize:u,strides:d,pad:c,dimRoundingMode:p}=a;e.util.assert(e.backend_util.eitherStridesOrDilationsAreOne(d,1),()=>"Error in maxPool: Either strides or dilations must be 1. "+`Got strides ${d} and dilations '1'`);const m=e.backend_util.computePool2DInfo(l.shape,u,d,1,c,p);if(1===m.filterWidth&&1===m.filterHeight&&e.util.arraysEqual(m.inShape,m.outShape))return(0,r.identity)({inputs:{x:l},backend:s});const x=new t.Pool2DProgram(m,"max",!1);return s.runWebGLProgram(x,[l],l.dtype)}const n=exports.maxPoolConfig={kernelName:e.MaxPool,backendName:"webgl",kernelFunc:i};
},{"@tensorflow/tfjs-core":"kSBl","../pool_gpu":"QOnm","../webgl_util":"u1ML","./Identity":"LUQG"}],"qMOV":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.maxPool3DConfig=void 0,exports.maxPool3d=r;var e=require("@tensorflow/tfjs-core"),o=require("../pool_gpu");function r(r){const{inputs:t,backend:n,attrs:a}=r,{x:s}=t,{filterSize:i,strides:l,pad:d,dataFormat:u,dimRoundingMode:p}=a,c=e.backend_util.computePool3DInfo(s.shape,i,l,[1,1,1],d,p,u),m=new o.Pool3DProgram(c,"max",!1);return n.runWebGLProgram(m,[s],s.dtype)}const t=exports.maxPool3DConfig={kernelName:e.MaxPool3D,backendName:"webgl",kernelFunc:r};
},{"@tensorflow/tfjs-core":"kSBl","../pool_gpu":"QOnm"}],"apKT":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.MaxPool3DBackpropProgram=exports.MaxPool2DBackpropProgram=void 0;class n{constructor(n){this.variableNames=["dy","maxPos"],this.outputShape=n.inShape;const t=n.strideHeight,o=n.strideWidth,e=n.dilationHeight,i=n.effectiveFilterHeight,d=n.effectiveFilterWidth,r=i-1-n.padInfo.top,a=d-1-n.padInfo.left,s=i*d-1;this.userCode=`\n      const ivec2 pads = ivec2(${r}, ${a});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n\n        ivec2 dyRCCorner = coords.yz - pads;\n        int dyRCorner = dyRCCorner.x;\n        int dyCCorner = dyRCCorner.y;\n\n        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${i};\n          wR += ${e}) {\n          float dyR = float(dyRCorner + wR) / ${t}.0;\n\n          if (dyR < 0.0 || dyR >= ${n.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          for (int wC = 0; wC < ${d}; wC++) {\n            float dyC = float(dyCCorner + wC) / ${o}.0;\n\n            if (dyC < 0.0 || dyC >= ${n.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            float dyValue = getDy(b, idyR, idyC, d);\n            int maxPosValue = ${s} - int(getMaxPos(b, idyR, idyC, d));\n\n            // Get the current value, check it against the value from the\n            // position matrix.\n            int curPosValue = wR * ${d} + wC;\n            float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);\n\n            dotProd += dyValue * mask;\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}exports.MaxPool2DBackpropProgram=n;class t{constructor(n){this.variableNames=["dy","maxPos"],this.outputShape=n.inShape;const t=n.strideDepth,o=n.strideHeight,e=n.strideWidth,i=n.dilationDepth,d=n.dilationHeight,r=n.dilationWidth,a=n.effectiveFilterDepth,s=n.effectiveFilterHeight,y=n.effectiveFilterWidth,c=a-1-n.padInfo.front,l=s-1-n.padInfo.top,C=y-1-n.padInfo.left,f=a*s*y-1;this.userCode=`\n      const ivec3 pads = ivec3(${c}, ${l}, ${C});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyDCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        // Convolve dy(?, ?, ?, ch) with pos mask(:, :, :, d) to get\n        // dx(xD, xR, xC, ch).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int wD = 0; wD < ${a};\n           wD += ${i}) {\n          float dyD = float(dyDCorner + wD) / ${t}.0;\n\n          if (dyD < 0.0 || dyD >= ${n.outDepth}.0 || fract(dyD) > 0.0) {\n            continue;\n          }\n          int idyD = int(dyD);\n\n          for (int wR = 0; wR < ${s};\n              wR += ${d}) {\n            float dyR = float(dyRCorner + wR) / ${o}.0;\n\n            if (dyR < 0.0 || dyR >= ${n.outHeight}.0 ||\n                fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            for (int wC = 0; wC < ${y};\n                wC += ${r}) {\n              float dyC = float(dyCCorner + wC) / ${e}.0;\n\n              if (dyC < 0.0 || dyC >= ${n.outWidth}.0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              float dyValue = getDy(batch, idyD, idyR, idyC, ch);\n              int maxPosValue = ${f} -\n                  int(getMaxPos(batch, idyD, idyR, idyC, ch));\n\n              // Get the current value, check it against the value from the\n              // position matrix.\n              int curPosValue =\n                  wD * ${s} * ${y} +\n                  wR * ${y} + wC;\n              float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);\n\n              dotProd += dyValue * mask;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}exports.MaxPool3DBackpropProgram=t;
},{}],"RXwg":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.maxPool3DGrad=a,exports.maxPool3DGradConfig=void 0;var e=require("@tensorflow/tfjs-core"),o=require("../max_pool_backprop_gpu"),r=require("../pool_gpu");function a(a){const{inputs:n,backend:t,attrs:p}=a,{dy:d,input:i}=n,s=i,{filterSize:u,strides:l,pad:m,dimRoundingMode:c}=p,P=e.backend_util.computePool3DInfo(s.shape,u,l,[1,1,1],m,c),x=new r.Pool3DProgram(P,"max",!0),g=t.runWebGLProgram(x,[s],s.dtype),f=new o.MaxPool3DBackpropProgram(P),b=t.runWebGLProgram(f,[d,g],s.dtype);return t.disposeIntermediateTensorInfo(g),b}const n=exports.maxPool3DGradConfig={kernelName:e.MaxPool3DGrad,backendName:"webgl",kernelFunc:a};
},{"@tensorflow/tfjs-core":"kSBl","../max_pool_backprop_gpu":"apKT","../pool_gpu":"QOnm"}],"TmIQ":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.maxPoolGrad=a,exports.maxPoolGradConfig=void 0;var e=require("@tensorflow/tfjs-core"),o=require("../max_pool_backprop_gpu"),r=require("../pool_gpu"),t=require("../webgl_util");function a(a){const{inputs:n,backend:p,attrs:s}=a,{dy:u,input:d,output:i}=n,l=d;(0,t.assertNotComplex)([d,i],"maxPoolGrad");const{filterSize:m,strides:c,pad:x,dimRoundingMode:P}=s,g=e.backend_util.computePool2DInfo(l.shape,m,c,1,x,P),b=new r.Pool2DProgram(g,"max",!0),f=p.runWebGLProgram(b,[l],l.dtype),_=new o.MaxPool2DBackpropProgram(g),k=p.runWebGLProgram(_,[u,f],l.dtype);return p.disposeIntermediateTensorInfo(f),k}const n=exports.maxPoolGradConfig={kernelName:e.MaxPoolGrad,backendName:"webgl",kernelFunc:a};
},{"@tensorflow/tfjs-core":"kSBl","../max_pool_backprop_gpu":"apKT","../pool_gpu":"QOnm","../webgl_util":"u1ML"}],"dXRA":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.maxPoolWithArgmaxImpl=o;var r=require("../pool_gpu");function o(o,e,t,a){let l=new r.Pool2DProgram(t,"max",!1);const m=a.runWebGLProgram(l,[o],"float32");return l=new r.Pool2DProgram(t,"max",!0,!0,e),[m,a.runWebGLProgram(l,[o],"float32")]}
},{"../pool_gpu":"QOnm"}],"TNru":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.maxPoolWithArgmaxConfig=void 0;var e=require("@tensorflow/tfjs-core"),t=require("./MaxPoolWithArgmax_impl");const r=exports.maxPoolWithArgmaxConfig={kernelName:e.MaxPoolWithArgmax,backendName:"webgl",kernelFunc:({inputs:r,attrs:o,backend:i})=>{const{x:a}=r,{filterSize:n,strides:s,pad:l,includeBatchInIndex:u}=o,d=i;e.util.assert(4===a.shape.length,()=>`Error in maxPool: input must be rank 4 but got rank ${a.shape.length}.`);const m=[1,1];e.util.assert(e.backend_util.eitherStridesOrDilationsAreOne(s,m),()=>"Error in maxPool: Either strides or dilations must be 1. "+`Got strides ${s} and dilations '${m}'`);const x=e.backend_util.computePool2DInfo(a.shape,n,s,m,l),[c,h]=(0,t.maxPoolWithArgmaxImpl)(a,u,x,d);return[c,h]}};
},{"@tensorflow/tfjs-core":"kSBl","./MaxPoolWithArgmax_impl":"dXRA"}],"ct8E":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.meanImpl=t;var e=require("@tensorflow/tfjs-core"),r=require("../kernel_utils/reduce"),s=require("../kernels/Reshape");function t(t,n,a,o){const i=e.util.sizeFromShape(n),p=e.util.sizeFromShape(t.shape)/i,u=(0,s.reshape)({inputs:{x:t},attrs:{shape:[p,i]},backend:o}),d=(0,r.reduce)(u,"float32","mean",o),l=(0,s.reshape)({inputs:{x:d},attrs:{shape:a},backend:o});return o.disposeIntermediateTensorInfo(u),o.disposeIntermediateTensorInfo(d),l}
},{"@tensorflow/tfjs-core":"kSBl","../kernel_utils/reduce":"tZI5","../kernels/Reshape":"OCN8"}],"QecZ":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.meanConfig=void 0;var e=require("@tensorflow/tfjs-core"),t=require("./Mean_impl"),s=require("./Transpose_impl");const n=exports.meanConfig={kernelName:e.Mean,backendName:"webgl",kernelFunc:({inputs:n,attrs:a,backend:r})=>{const{x:o}=n,{keepDims:l,axis:p}=a,i=r,u=o.shape.length,c=e.util.parseAxisParam(p,o.shape);let d=c;const m=e.backend_util.getAxesPermutation(d,u),x=null!=m,f=i.shouldExecuteOnCPU([o]),h=[];let k=o;if(x){if(f){const e=i.texData.get(k.dataId).values,t=new Array(u);for(let s=0;s<t.length;s++)t[s]=o.shape[m[s]];const n=(0,s.transposeImplCPU)(e,o.shape,o.dtype,m,t);k=i.makeTensorInfo(t,o.dtype),i.texData.get(k.dataId).values=n}else k=(0,s.transposeImpl)(o,m,i);h.push(k),d=e.backend_util.getInnerMostAxes(d.length,u)}e.backend_util.assertAxesAreInnerMostDims("sum",d,u);const[g,I]=e.backend_util.computeOutAndReduceShapes(k.shape,d);let b=g;l&&(b=e.backend_util.expandShapeToKeepDim(g,c));const _=(0,t.meanImpl)(k,I,b,i);for(const e of h)i.disposeIntermediateTensorInfo(e);return _}};
},{"@tensorflow/tfjs-core":"kSBl","./Mean_impl":"ct8E","./Transpose_impl":"VG4U"}],"X4RS":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.min=r,exports.minConfig=void 0;var e=require("@tensorflow/tfjs-core"),s=require("../kernel_utils/reduce"),t=require("./Reshape"),n=require("./Transpose");function r(r){const{inputs:a,backend:i,attrs:p}=r,{x:o}=a,{axis:u,keepDims:d}=p,l=o.shape.length,c=e.util.parseAxisParam(u,o.shape);let m=c;const h=e.backend_util.getAxesPermutation(m,l);let k=o;null!=h&&(k=(0,n.transpose)({inputs:{x:o},backend:i,attrs:{perm:h}}),m=e.backend_util.getInnerMostAxes(m.length,o.shape.length)),e.backend_util.assertAxesAreInnerMostDims("min",m,l);const[x,b]=e.backend_util.computeOutAndReduceShapes(k.shape,m),f=e.util.sizeFromShape(b),g=(0,t.reshape)({inputs:{x:k},backend:i,attrs:{shape:[-1,f]}}),I=(0,s.reduce)(g,g.dtype,"min",i);let _;if(d){const s=e.backend_util.expandShapeToKeepDim(x,c);_=(0,t.reshape)({inputs:{x:I},backend:i,attrs:{shape:s}})}else _=(0,t.reshape)({inputs:{x:I},backend:i,attrs:{shape:x}});return i.disposeIntermediateTensorInfo(g),i.disposeIntermediateTensorInfo(I),null!=h&&i.disposeIntermediateTensorInfo(k),_}const a=exports.minConfig={kernelName:e.Min,backendName:"webgl",kernelFunc:r};
},{"@tensorflow/tfjs-core":"kSBl","../kernel_utils/reduce":"tZI5","./Reshape":"OCN8","./Transpose":"ukag"}],"ew2v":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.minimumConfig=exports.minimum=void 0;var e=require("@tensorflow/tfjs-core"),i=require("../binaryop_gpu"),n=require("../binaryop_packed_gpu"),r=require("../kernel_utils/kernel_funcs_utils"),s=require("../kernel_utils/shared");const N=i.CHECK_NAN_SNIPPET+"\n  return min(a, b);\n",a="\n  vec4 result = vec4(min(a, b));\n  bvec4 isNaNA = isnan(a);\n  bvec4 isNaNB = isnan(b);\n  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);\n  "+n.CHECK_NAN_SNIPPET_PACKED+"\n  return result;\n",u=exports.minimum=(0,r.binaryKernelFunc)({opSnippet:N,packedOpSnippet:a,cpuKernelImpl:s.minimumImplCPU}),m=exports.minimumConfig={kernelName:e.Minimum,backendName:"webgl",kernelFunc:u};
},{"@tensorflow/tfjs-core":"kSBl","../binaryop_gpu":"wbV2","../binaryop_packed_gpu":"mFR1","../kernel_utils/kernel_funcs_utils":"ciwP","../kernel_utils/shared":"cNPH"}],"o7aC":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.MirrorPadProgram=void 0;var t=require("./shader_compiler");class o{constructor(o,n,r){this.variableNames=["x"],this.outputShape=n.map((t,n)=>t[0]+o[n]+t[1]);const e=o.length,i=(0,t.getCoordsDataType)(e),s=n.map(t=>t[0]).join(","),u=n.map((t,n)=>t[0]+o[n]).join(","),a=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,e),d="reflect"===r?0:1;this.userCode=1!==e?`\n      ${i} start = ${i}(${s});\n      ${i} end = ${i}(${u});\n\n      void main() {\n        ${i} outC = getOutputCoords();\n        for (int i = 0; i < ${e}; i++) {\n          if (outC[i] < start[i]) {\n            outC[i] = start[i] * 2 - outC[i] - ${d};\n          } else if(outC[i] >= end[i]) {\n            outC[i] = (end[i] - 1) * 2 - outC[i] + ${d};\n          }\n        }\n        ${i} coords = outC - start;\n        setOutput(getX(${a}));\n      }\n    `:`\n        int start = ${s};\n        int end = ${u};\n\n        void main() {\n          int outC = getOutputCoords();\n          if (outC < start) {\n            outC = start * 2 - outC - ${d};\n          } else if(outC >= end) {\n            outC = (end - 1) * 2 - outC + ${d};\n          }\n          setOutput(getX(outC - start));\n        }\n      `}}exports.MirrorPadProgram=o;
},{"./shader_compiler":"xhhc"}],"j4rD":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.MirrorPadPackedProgram=void 0;var e=require("./packing_util"),n=require("./shader_compiler");class t{constructor(t,r,s){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=r.map((e,n)=>e[0]+t[n]+e[1]);const o=t.length,u=(0,n.getCoordsDataType)(o),$=r.map(e=>e[0]).join(","),c=r.map((e,n)=>e[0]+t[n]).join(","),a=(0,e.getChannels)("rc",o),i=(0,e.getChannels)("source",o),l=`${a[o-1]} < ${this.outputShape[o-1]}`,g=1===o?"source":`vec2(${i.slice(-2).join()})`,p="reflect"===s?0:1;let h="";if(1===o){const e=`\n        ${u} source = rc;\n        if (source < start) {\n          source = start * 2 - source - ${p};\n        } else if (source >= end) {\n          source = (end - 1) * 2 - source + ${p};\n        }\n        source -= start;\n      `;h=`\n        ${u} rc = outputLoc;\n        ${e}\n        result[0] = getChannel(getX(${i.join()}), ${g});\n        ${a[o-1]} += 1;\n        if(${l}) {\n          ${e}\n          result[1] = getChannel(getX(${i.join()}), ${g});\n        }\n      `}else{const e=`\n        ${u} source = rc;\n        ${u} lt = ${u}(lessThan(source, start));\n        ${u} gte = ${u}(greaterThanEqual(source, end));\n        ${u} orig = 1 - (lt + gte);\n        source = orig * source +\n                lt * (start * 2 - source - ${p}) +\n                gte * ((end - 1) * 2 - source + ${p});\n        source -= start;\n      `;h=`\n        ${u} rc = outputLoc;\n        ${e}\n        result[0] = getChannel(getX(${i.join()}), ${g});\n        ${a[o-1]} += 1;\n        if(${l}) {\n          ${e}\n          result[1] = getChannel(getX(${i.join()}), ${g});\n        }\n        rc = outputLoc;\n        ${a[o-2]} += 1;\n        if(${a[o-2]} < ${this.outputShape[o-2]}) {\n          ${e}\n          result[2] = getChannel(getX(${i.join()}), ${g});\n          ${a[o-1]} += 1;\n          if(${l}) {\n            ${e}\n            result[3] = getChannel(getX(${i.join()}), ${g});\n          }\n        }\n      `}this.userCode=`\n      const ${u} start = ${u}(${$});\n      const ${u} end = ${u}(${c});\n\n      void main() {\n        ${u} outputLoc = getOutputCoords();\n        vec4 result = vec4(0.);\n        ${h}\n        setOutput(result);\n      }\n    `}}exports.MirrorPadPackedProgram=t;
},{"./packing_util":"BqvU","./shader_compiler":"xhhc"}],"vzVL":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.mirrorPadKernelFunc=exports.mirrorPadConfig=void 0;var r=require("@tensorflow/tfjs-core"),e=require("../mirror_pad_gpu"),o=require("../mirror_pad_packed_gpu");const a=({inputs:a,backend:n,attrs:d})=>{const{x:t}=a,{paddings:i,mode:s}=d,p=(0,r.env)().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new o.MirrorPadPackedProgram(t.shape,i,s):new e.MirrorPadProgram(t.shape,i,s);return n.runWebGLProgram(p,[t],t.dtype)};exports.mirrorPadKernelFunc=a;const n=exports.mirrorPadConfig={kernelName:r.MirrorPad,backendName:"webgl",kernelFunc:a};
},{"@tensorflow/tfjs-core":"kSBl","../mirror_pad_gpu":"o7aC","../mirror_pad_packed_gpu":"j4rD"}],"C4Ln":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.modConfig=exports.mod=void 0;var e=require("@tensorflow/tfjs-core"),r=require("../binaryop_packed_gpu"),n=require("../kernel_utils/kernel_funcs_utils");const o="if (b == 0.0) return NAN;\n  return mod(a, b);",t="\n  vec4 result = mod(a, b);\n  bvec4 isNaN = equal(b, vec4(0.0));\n  "+r.CHECK_NAN_SNIPPET_PACKED+"\n  return result;\n",u=exports.mod=(0,n.binaryKernelFunc)({opSnippet:o,packedOpSnippet:t}),s=exports.modConfig={kernelName:e.Mod,backendName:"webgl",kernelFunc:u};
},{"@tensorflow/tfjs-core":"kSBl","../binaryop_packed_gpu":"mFR1","../kernel_utils/kernel_funcs_utils":"ciwP"}],"oY6B":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.MultinomialProgram=void 0;class t{constructor(t,e,n){this.variableNames=["probs"],this.customUniforms=[{name:"seed",type:"float"}],this.outputShape=[t,n],this.userCode=`\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n\n        float r = random(seed);\n        float cdf = 0.0;\n\n        for (int i = 0; i < ${e-1}; i++) {\n          cdf += getProbs(batch, i);\n\n          if (r < cdf) {\n            setOutput(float(i));\n            return;\n          }\n        }\n\n        // If no other event happened, last event happened.\n        setOutput(float(${e-1}));\n      }\n    `}}exports.MultinomialProgram=t;
},{}],"URW8":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.realDivConfig=exports.realDiv=void 0;var e=require("@tensorflow/tfjs-core"),n=require("../kernel_utils/kernel_funcs_utils");const r="\nif (a == b) {\n  return 1.0;\n};\nreturn a / b;",t="\n  // vec4 one = vec4(equal(a, b));\n  // return one + (vec4(1.0) - one) * a / b;\n  vec4 result = a / b;\n  if(a.x == b.x) {\n    result.x = 1.;\n  }\n  if(a.y == b.y) {\n    result.y = 1.;\n  }\n  if(a.z == b.z) {\n    result.z = 1.;\n  }\n  if(a.w == b.w) {\n    result.w = 1.;\n  }\n\n  return result;\n",l=exports.realDiv=(0,n.binaryKernelFunc)({opSnippet:r,packedOpSnippet:t,checkOutOfBounds:!0}),u=exports.realDivConfig={kernelName:e.RealDiv,backendName:"webgl",kernelFunc:l};
},{"@tensorflow/tfjs-core":"kSBl","../kernel_utils/kernel_funcs_utils":"ciwP"}],"jvgb":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.subConfig=exports.sub=void 0;var e=require("@tensorflow/tfjs-core"),r=require("../kernel_utils/kernel_funcs_utils"),s=require("../kernel_utils/shared");const u="return a - b;",n=exports.sub=(0,r.binaryKernelFunc)({opSnippet:u,packedOpSnippet:u,supportsComplex:!0,cpuKernelImpl:s.subImplCPU}),p=exports.subConfig={kernelName:e.Sub,backendName:"webgl",kernelFunc:n};
},{"@tensorflow/tfjs-core":"kSBl","../kernel_utils/kernel_funcs_utils":"ciwP","../kernel_utils/shared":"cNPH"}],"GaSh":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.softmax=o,exports.softmaxConfig=void 0;var e=require("@tensorflow/tfjs-core"),s=require("./Exp"),t=require("./Max"),n=require("./RealDiv"),r=require("./Reshape"),a=require("./Sub"),i=require("./Sum");function o(o){const{inputs:p,backend:d,attrs:u}=o,{logits:m}=p,{dim:x}=u,c=e.util.parseAxisParam([x],m.shape),b=(0,t.max)({inputs:{x:m},backend:d,attrs:{reductionIndices:c,keepDims:!1}}),f=e.backend_util.expandShapeToKeepDim(b.shape,c),k=(0,r.reshape)({inputs:{x:b},backend:d,attrs:{shape:f}}),I=(0,a.sub)({inputs:{a:m,b:k},backend:d}),l=(0,s.exp)({inputs:{x:I},backend:d}),h=(0,i.sum)({inputs:{x:l},backend:d,attrs:{axis:c,keepDims:!1}}),q=(0,r.reshape)({inputs:{x:h},backend:d,attrs:{shape:f}}),T=(0,n.realDiv)({inputs:{a:l,b:q},backend:d});return d.disposeIntermediateTensorInfo(b),d.disposeIntermediateTensorInfo(k),d.disposeIntermediateTensorInfo(I),d.disposeIntermediateTensorInfo(l),d.disposeIntermediateTensorInfo(h),d.disposeIntermediateTensorInfo(q),T}const p=exports.softmaxConfig={kernelName:e.Softmax,backendName:"webgl",kernelFunc:o};
},{"@tensorflow/tfjs-core":"kSBl","./Exp":"zY0s","./Max":"Scv7","./RealDiv":"URW8","./Reshape":"OCN8","./Sub":"jvgb","./Sum":"FqPw"}],"YFUH":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.multinomial=o,exports.multinomialConfig=void 0;var e=require("@tensorflow/tfjs-core"),t=require("../multinomial_gpu"),n=require("./Softmax");function o(e){const{inputs:o,backend:i,attrs:r}=e,{logits:s}=o,{numSamples:a,seed:l,normalized:m}=r,u=m?s:(0,n.softmax)({inputs:{logits:s},backend:i,attrs:{dim:s.shape.length-1}}),p=u.shape[0],d=u.shape[1],c=new t.MultinomialProgram(p,d,a),f=[[l]],g=i.runWebGLProgram(c,[u],"int32",f);return m||i.disposeIntermediateTensorInfo(u),g}const i=exports.multinomialConfig={kernelName:e.Multinomial,backendName:"webgl",kernelFunc:o};
},{"@tensorflow/tfjs-core":"kSBl","../multinomial_gpu":"oY6B","./Softmax":"GaSh"}],"DwHV":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.neg=u,exports.negConfig=void 0;var e=require("@tensorflow/tfjs-core"),r=require("../kernel_utils/shared"),n=require("../unaryop_gpu"),t=require("../unaryop_packed_gpu");const s=n.CHECK_NAN_SNIPPET+"\n  return -x;\n",a="\n  vec4 result = -x;\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n";function u(u){const{inputs:o,backend:l}=u,{x:p}=o;if(l.shouldExecuteOnCPU([p])){const e=l.texData.get(p.dataId),[n,t]=(0,r.negImplCPU)(e.values,p.shape,p.dtype);return l.makeTensorInfo(t,p.dtype,n)}let g;return g=(0,e.env)().getBool("WEBGL_PACK_UNARY_OPERATIONS")?new t.UnaryOpPackedProgram(p.shape,a):new n.UnaryOpProgram(p.shape,s),l.runWebGLProgram(g,[p],p.dtype)}const o=exports.negConfig={kernelName:e.Neg,backendName:"webgl",kernelFunc:u};
},{"@tensorflow/tfjs-core":"kSBl","../kernel_utils/shared":"cNPH","../unaryop_gpu":"CK3x","../unaryop_packed_gpu":"zBLd"}],"qOiR":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.nonMaxSuppressionV3=s,exports.nonMaxSuppressionV3Config=void 0;var e=require("@tensorflow/tfjs-core");const n=e.kernel_impls.nonMaxSuppressionV3Impl;function s(s){e.backend_util.warn("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:o,backend:r,attrs:t}=s,{boxes:a,scores:i}=o,{maxOutputSize:p,iouThreshold:c,scoreThreshold:u}=t,d=r.readSync(a.dataId),l=r.readSync(i.dataId),{selectedIndices:x}=n(d,l,p,c,u);return r.makeTensorInfo([x.length],"int32",new Int32Array(x))}const o=exports.nonMaxSuppressionV3Config={kernelName:e.NonMaxSuppressionV3,backendName:"webgl",kernelFunc:s};
},{"@tensorflow/tfjs-core":"kSBl"}],"MHTf":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.nonMaxSuppressionV4=s,exports.nonMaxSuppressionV4Config=void 0;var e=require("@tensorflow/tfjs-core");const n=e.kernel_impls.nonMaxSuppressionV4Impl;function s(s){e.backend_util.warn("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:o,backend:r,attrs:t}=s,{boxes:a,scores:i}=o,{maxOutputSize:p,iouThreshold:u,scoreThreshold:d,padToMaxOutputSize:c}=t,l=r.readSync(a.dataId),x=r.readSync(i.dataId),{selectedIndices:S,validOutputs:f}=n(l,x,p,u,d,c);return[r.makeTensorInfo([S.length],"int32",new Int32Array(S)),r.makeTensorInfo([],"int32",new Int32Array([f]))]}const o=exports.nonMaxSuppressionV4Config={kernelName:e.NonMaxSuppressionV4,backendName:"webgl",kernelFunc:s};
},{"@tensorflow/tfjs-core":"kSBl"}],"AzqR":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.nonMaxSuppressionV5=s,exports.nonMaxSuppressionV5Config=void 0;var e=require("@tensorflow/tfjs-core");const n=e.kernel_impls.nonMaxSuppressionV5Impl;function s(s){e.backend_util.warn("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:o,backend:r,attrs:t}=s,{boxes:a,scores:i}=o,{maxOutputSize:p,iouThreshold:l,scoreThreshold:c,softNmsSigma:d}=t,u=r.readSync(a.dataId),x=r.readSync(i.dataId),f=p,S=l,k=c,m=d,{selectedIndices:h,selectedScores:I}=n(u,x,f,S,k,m);return[r.makeTensorInfo([h.length],"int32",new Int32Array(h)),r.makeTensorInfo([I.length],"float32",new Float32Array(I))]}const o=exports.nonMaxSuppressionV5Config={kernelName:e.NonMaxSuppressionV5,backendName:"webgl",kernelFunc:s};
},{"@tensorflow/tfjs-core":"kSBl"}],"cWUh":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.OneHotProgram=void 0;class o{constructor(o,t,e,s){this.variableNames=["indices"],this.outputShape=[o,t],this.userCode=`\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int index = round(getIndices(coords.x));\n        setOutput(mix(float(${s}), float(${e}),\n                      float(index == coords.y)));\n      }\n    `}}exports.OneHotProgram=o;
},{}],"qyTz":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.oneHotConfig=exports.oneHot=void 0;var e=require("@tensorflow/tfjs-core"),o=require("../onehot_gpu"),t=require("./Reshape");const n=n=>{const{inputs:r,backend:s,attrs:a}=n,{indices:p}=r,{dtype:i,depth:u,onValue:d,offValue:c}=a,h=e.util.sizeFromShape(p.shape),f=new o.OneHotProgram(h,u,d,c),l=(0,t.reshape)({inputs:{x:p},backend:s,attrs:{shape:[h]}}),b=s.runWebGLProgram(f,[l],i);s.disposeIntermediateTensorInfo(l);const m=[...p.shape,u],x=(0,t.reshape)({inputs:{x:b},backend:s,attrs:{shape:m}});return s.disposeIntermediateTensorInfo(b),x};exports.oneHot=n;const r=exports.oneHotConfig={kernelName:e.OneHot,backendName:"webgl",kernelFunc:n};
},{"@tensorflow/tfjs-core":"kSBl","../onehot_gpu":"cWUh","./Reshape":"OCN8"}],"Rmax":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.zerosLike=i,exports.zerosLikeConfig=void 0;var e=require("@tensorflow/tfjs-core"),n=require("./Complex"),r=require("./Fill"),t=require("./Imag"),s=require("./Real");function i(e){const{inputs:o,backend:a}=e,{x:p}=o;if("complex64"===p.dtype){const e=(0,s.real)({inputs:{input:p},backend:a}),r=i({inputs:{x:e},backend:a}),o=(0,t.imag)({inputs:{input:p},backend:a}),d=i({inputs:{x:o},backend:a}),u=(0,n.complex)({inputs:{real:r,imag:d},backend:a});return a.disposeIntermediateTensorInfo(e),a.disposeIntermediateTensorInfo(r),a.disposeIntermediateTensorInfo(o),a.disposeIntermediateTensorInfo(d),u}return(0,r.fill)({attrs:{shape:p.shape,dtype:p.dtype,value:"string"===p.dtype?"":0},backend:a})}const o=exports.zerosLikeConfig={kernelName:e.ZerosLike,backendName:"webgl",kernelFunc:i};
},{"@tensorflow/tfjs-core":"kSBl","./Complex":"BU0Z","./Fill":"LGba","./Imag":"uHuu","./Real":"Jbfj"}],"NxrP":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.onesLike=o,exports.onesLikeConfig=void 0;var e=require("@tensorflow/tfjs-core"),n=require("./Complex"),r=require("./Fill"),i=require("./Imag"),s=require("./Real"),t=require("./ZerosLike");function o(e){const{inputs:p,backend:a}=e,{x:d}=p;if("string"===d.dtype)throw new Error("onesLike is not supported under string dtype");if("complex64"===d.dtype){const e=(0,s.real)({inputs:{input:d},backend:a}),r=o({inputs:{x:e},backend:a}),p=(0,i.imag)({inputs:{input:d},backend:a}),u=(0,t.zerosLike)({inputs:{x:p},backend:a}),c=(0,n.complex)({inputs:{real:r,imag:u},backend:a});return a.disposeIntermediateTensorInfo(e),a.disposeIntermediateTensorInfo(r),a.disposeIntermediateTensorInfo(p),a.disposeIntermediateTensorInfo(u),c}return(0,r.fill)({attrs:{shape:d.shape,dtype:d.dtype,value:1},backend:a})}const p=exports.onesLikeConfig={kernelName:e.OnesLike,backendName:"webgl",kernelFunc:o};
},{"@tensorflow/tfjs-core":"kSBl","./Complex":"BU0Z","./Fill":"LGba","./Imag":"uHuu","./Real":"Jbfj","./ZerosLike":"Rmax"}],"KYEF":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.pack=a,exports.packConfig=void 0;var e=require("@tensorflow/tfjs-core"),t=require("./Concat"),s=require("./ExpandDims");function a(a){const{inputs:n,backend:r,attrs:c}=a,{axis:i}=c;if(1===n.length)return(0,s.expandDims)({inputs:{input:n[0]},backend:r,attrs:{dim:i}});const o=n[0].shape,p=n[0].dtype;n.forEach(t=>{e.util.assertShapesMatch(o,t.shape,"All tensors passed to stack must have matching shapes"),e.util.assert(p===t.dtype,()=>"All tensors passed to stack must have matching dtypes")});const u=[],d=n.map(e=>{const t=(0,s.expandDims)({inputs:{input:e},backend:r,attrs:{dim:i}});return u.push(t),t}),h=(0,t.concat)({inputs:d,backend:r,attrs:{axis:i}});return u.forEach(e=>r.disposeIntermediateTensorInfo(e)),h}const n=exports.packConfig={kernelName:e.Pack,backendName:"webgl",kernelFunc:a};
},{"@tensorflow/tfjs-core":"kSBl","./Concat":"sjik","./ExpandDims":"oL99"}],"RJlw":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.PadProgram=void 0;var t=require("./shader_compiler");class e{constructor(e,n,o){this.variableNames=["x"],this.customUniforms=[{name:"value",type:"float"}],this.outputShape=n.map((t,n)=>t[0]+e[n]+t[1]);const s=e.length,a=(0,t.getCoordsDataType)(s),r=n.map(t=>t[0]).join(","),u=n.map((t,n)=>t[0]+e[n]).join(","),i=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,s);this.userCode=1!==s?`\n      ${a} start = ${a}(${r});\n      ${a} end = ${a}(${u});\n\n      void main() {\n        ${a} outC = getOutputCoords();\n        if (any(lessThan(outC, start)) || any(greaterThanEqual(outC, end))) {\n          setOutput(value);\n        } else {\n          ${a} coords = outC - start;\n          setOutput(getX(${i}));\n        }\n      }\n    `:`\n        int start = ${r};\n        int end = ${u};\n\n        void main() {\n          int outC = getOutputCoords();\n          if (outC < start || outC >= end) {\n            setOutput(value);\n          } else {\n            setOutput(getX(outC - start));\n          }\n        }\n      `}}exports.PadProgram=e;
},{"./shader_compiler":"xhhc"}],"Q15v":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.PadPackedProgram=void 0;var t=require("./packing_util"),e=require("./shader_compiler");class n{constructor(n,r,s){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"value",type:"float"}],this.outputShape=r.map((t,e)=>t[0]+n[e]+t[1]);const a=n.length,o=(0,e.getCoordsDataType)(a),u=r.map(t=>t[0]).join(","),c=r.map((t,e)=>t[0]+n[e]).join(","),i=(0,t.getChannels)("rc",a),p=(0,t.getChannels)("source",a),$=`${i[a-1]} < ${this.outputShape[a-1]}`,l=1===a?"source":`vec2(${p.slice(-2).join()})`,h=[`${o} rc = outputLoc;`,`${i[a-1]} += 1;\n       if(${$}) {\n      `,1===a?"":`}\n       rc = outputLoc;\n       ${i[a-2]} += 1;\n       if(${i[a-2]} < ${this.outputShape[a-2]}) {`,1===a?"":`  ${i[a-1]} += 1;\n         if(${$}) {`],d=1===a?"rc < start || rc >= end":"any(lessThan(rc, start)) || any(greaterThanEqual(rc, end))";let g="";for(let t=0,e=1===a?2:4;t<e;t++)g+=`\n        ${h[t]}\n        if (${d}) {\n          result[${t}] = float(value);\n        } else {\n          ${o} source = rc - start;\n          result[${t}] = getChannel(getX(${p.join()}), ${l});\n        }\n      `;g+=1===a?"} ":"}}",this.userCode=`\n      const ${o} start = ${o}(${u});\n      const ${o} end = ${o}(${c});\n\n      void main() {\n        ${o} outputLoc = getOutputCoords();\n        vec4 result = vec4(0.);\n        ${g}\n        setOutput(result);\n      }\n    `}}exports.PadPackedProgram=n;
},{"./packing_util":"BqvU","./shader_compiler":"xhhc"}],"CzrI":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.padV2Config=exports.padV2=void 0;var e=require("@tensorflow/tfjs-core"),r=require("../pad_gpu"),a=require("../pad_packed_gpu"),t=require("./Fill");const p=p=>{const{inputs:s,backend:n,attrs:o}=p,{x:d}=s,{paddings:u,constantValue:i}=o;if(0===e.util.sizeFromShape(d.shape)){const e=u.map((e,r)=>e[0]+d.shape[r]+e[1]);return(0,t.fill)({backend:n,attrs:{shape:e,value:i,dtype:d.dtype}})}const c=(0,e.env)().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new a.PadPackedProgram(d.shape,u,i):new r.PadProgram(d.shape,u,i),l=[[i]];return n.runWebGLProgram(c,[d],d.dtype,l)};exports.padV2=p;const s=exports.padV2Config={kernelName:e.PadV2,backendName:"webgl",kernelFunc:p};
},{"@tensorflow/tfjs-core":"kSBl","../pad_gpu":"RJlw","../pad_packed_gpu":"Q15v","./Fill":"LGba"}],"i8M0":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.powConfig=exports.pow=void 0;var e=require("@tensorflow/tfjs-core"),n=require("../binaryop_packed_gpu"),r=require("../kernel_utils/kernel_funcs_utils");const s="\n  if(a < 0.0 && floor(b) < b){\n    return NAN;\n  }\n  if (b == 0.0) {\n    return 1.0;\n  }\n  return (round(mod(b, 2.0)) != 1) ?\n      pow(abs(a), b) : sign(a) * pow(abs(a), b);\n",o="\n  // isModRound1 has 1 for components with round(mod(b, 2.0)) == 1, 0 otherwise.\n  vec4 isModRound1 = vec4(equal(round(mod(b, 2.0)), ivec4(1)));\n  vec4 multiplier = sign(a) * isModRound1 + (vec4(1.0) - isModRound1);\n  vec4 result = multiplier * pow(abs(a), b);\n\n  // Ensure that a^0 = 1, including 0^0 = 1 as this correspond to TF and JS\n  bvec4 isExpZero = equal(b, vec4(0.0));\n  result.r = isExpZero.r ? 1.0 : result.r;\n  result.g = isExpZero.g ? 1.0 : result.g;\n  result.b = isExpZero.b ? 1.0 : result.b;\n  result.a = isExpZero.a ? 1.0 : result.a;\n\n  bvec4 isNaN1 = lessThan(a, vec4(0.0));\n  bvec4 isNaN2 = lessThan(floor(b), b);\n  bvec4 isNaN = bvec4(isNaN1.x && isNaN2.x, isNaN1.y && isNaN2.y, isNaN1.z && isNaN2.z, isNaN1.w && isNaN2.w);\n  "+n.CHECK_NAN_SNIPPET_PACKED+"\n  return result;\n",i=exports.pow=(0,r.binaryKernelFunc)({opSnippet:s,packedOpSnippet:o}),a=exports.powConfig={kernelName:e.Pow,backendName:"webgl",kernelFunc:i};
},{"@tensorflow/tfjs-core":"kSBl","../binaryop_packed_gpu":"mFR1","../kernel_utils/kernel_funcs_utils":"ciwP"}],"RmdB":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.prod=n,exports.prodConfig=void 0;var e=require("@tensorflow/tfjs-core"),s=require("../kernel_utils/reduce"),t=require("../kernel_utils/shared"),r=require("./Reshape"),a=require("./Transpose");function n(n){const{inputs:p,backend:o,attrs:u}=n,{x:i}=p,{axis:d,keepDims:c}=u,l=i.shape.length,h=[],k=e.util.parseAxisParam(d,i.shape);let x=k;const m=e.backend_util.getAxesPermutation(x,l);let b,f=i;if(null!=m&&(f=(0,a.transpose)({inputs:{x:i},backend:o,attrs:{perm:m}}),x=e.backend_util.getInnerMostAxes(x.length,l),h.push(f)),e.backend_util.assertAxesAreInnerMostDims("prod",x,l),o.shouldExecuteOnCPU([f])){const e=o.texData.get(f.dataId).values,{outVals:s,outShape:r,outDtype:a}=(0,t.prodImplCPU)(f.shape,f.dtype,e,x);b=o.makeTensorInfo(r,a,s)}else{const[t,a]=e.backend_util.computeOutAndReduceShapes(f.shape,x),n=e.util.sizeFromShape(a),p=(0,r.reshape)({inputs:{x:f},backend:o,attrs:{shape:[-1,n]}}),u=(0,e.sumOutType)(i.dtype),d=(0,s.reduce)(p,u,"prod",o);b=(0,r.reshape)({inputs:{x:d},backend:o,attrs:{shape:t}}),h.push(p),h.push(d)}if(c){h.push(b);const s=e.backend_util.expandShapeToKeepDim(b.shape,k);b=(0,r.reshape)({inputs:{x:b},backend:o,attrs:{shape:s}})}return h.forEach(e=>o.disposeIntermediateTensorInfo(e)),b}const p=exports.prodConfig={kernelName:e.Prod,backendName:"webgl",kernelFunc:n};
},{"@tensorflow/tfjs-core":"kSBl","../kernel_utils/reduce":"tZI5","../kernel_utils/shared":"cNPH","./Reshape":"OCN8","./Transpose":"ukag"}],"wYNM":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.raggedGather=r,exports.raggedGatherConfig=void 0;var e=require("@tensorflow/tfjs-core"),a=require("../kernel_utils/shared");function r(e){const{inputs:r,backend:t,attrs:n}=e,{paramsNestedSplits:s,paramsDenseValues:d,indices:o}=r,{outputRaggedRank:p}=n,g=s.map(e=>t.readSync(e.dataId)),c=s.map(e=>e.shape),i=t.readSync(d.dataId),u=t.readSync(o.dataId),[l,h,m]=(0,a.raggedGatherImplCPU)(g,c,i,d.shape,d.dtype,u,o.shape,p),f=l.map(e=>t.makeTensorInfo([e.length],"int32",e)),k=t.makeTensorInfo(m,d.dtype,h);return f.concat([k])}const t=exports.raggedGatherConfig={kernelName:e.RaggedGather,backendName:"webgl",kernelFunc:r};
},{"@tensorflow/tfjs-core":"kSBl","../kernel_utils/shared":"cNPH"}],"zCtT":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.raggedRange=n,exports.raggedRangeConfig=void 0;var e=require("@tensorflow/tfjs-core"),a=require("../kernel_utils/shared");function n(e){const{inputs:n,backend:r}=e,{starts:t,limits:d,deltas:s}=n,g=r.readSync(t.dataId),o=r.readSync(d.dataId),i=r.readSync(s.dataId),[l,c]=(0,a.raggedRangeImplCPU)(g,t.shape,t.dtype,o,d.shape,i,s.shape);return[r.makeTensorInfo([l.length],"int32",l),r.makeTensorInfo([c.length],t.dtype,c)]}const r=exports.raggedRangeConfig={kernelName:e.RaggedRange,backendName:"webgl",kernelFunc:n};
},{"@tensorflow/tfjs-core":"kSBl","../kernel_utils/shared":"cNPH"}],"bgOI":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.raggedTensorToTensor=a,exports.raggedTensorToTensorConfig=void 0;var e=require("@tensorflow/tfjs-core"),r=require("../kernel_utils/shared");function a(e){const{inputs:a,backend:o,attrs:n}=e,{shape:s,values:t,defaultValue:d,rowPartitionTensors:T}=a,{rowPartitionTypes:p}=n,i=o.readSync(s.dataId),c=o.readSync(t.dataId),g=o.readSync(d.dataId),u=T.map(e=>o.readSync(e.dataId)),l=T.map(e=>e.shape),[f,y]=(0,r.raggedTensorToTensorImplCPU)(i,s.shape,c,t.shape,t.dtype,g,d.shape,u,l,p);return o.makeTensorInfo(f,t.dtype,y)}const o=exports.raggedTensorToTensorConfig={kernelName:e.RaggedTensorToTensor,backendName:"webgl",kernelFunc:a};
},{"@tensorflow/tfjs-core":"kSBl","../kernel_utils/shared":"cNPH"}],"M4RM":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.rangeConfig=exports.range=void 0;var e=require("@tensorflow/tfjs-core"),r=require("../kernel_utils/shared");const t=e=>{const{backend:t,attrs:n}=e,{start:s,stop:o,step:a,dtype:g}=n,l=(0,r.rangeImplCPU)(s,o,a,g);return t.makeTensorInfo([l.length],g,l)};exports.range=t;const n=exports.rangeConfig={kernelName:e.Range,backendName:"webgl",kernelFunc:t};
},{"@tensorflow/tfjs-core":"kSBl","../kernel_utils/shared":"cNPH"}],"GRla":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.reciprocalConfig=exports.reciprocal=void 0;var e=require("@tensorflow/tfjs-core"),r=require("../kernel_utils/kernel_funcs_utils");const o="return 1.0 / x;",c=exports.reciprocal=(0,r.unaryKernelFunc)({opSnippet:o}),n=exports.reciprocalConfig={kernelName:e.Reciprocal,backendName:"webgl",kernelFunc:c};
},{"@tensorflow/tfjs-core":"kSBl","../kernel_utils/kernel_funcs_utils":"ciwP"}],"VrOt":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.reluConfig=exports.relu=void 0;var e=require("@tensorflow/tfjs-core"),r=require("../kernel_utils/kernel_funcs_utils"),n=require("../unaryop_gpu");const u=n.CHECK_NAN_SNIPPET+"\n  return (x < 0.0) ? 0.0 : x;\n",s="\n  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n",t=exports.relu=(0,r.unaryKernelFunc)({opSnippet:u,packedOpSnippet:s}),l=exports.reluConfig={kernelName:e.Relu,backendName:"webgl",kernelFunc:t};
},{"@tensorflow/tfjs-core":"kSBl","../kernel_utils/kernel_funcs_utils":"ciwP","../unaryop_gpu":"CK3x"}],"xsDV":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.relu6Config=exports.relu6=void 0;var e=require("@tensorflow/tfjs-core"),r=require("../kernel_utils/kernel_funcs_utils"),n=require("../unaryop_gpu");const u=n.CHECK_NAN_SNIPPET+"\n  return (x < 0.0) ? 0.0 : min(6.0, x);\n",s="\n  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n",t=exports.relu6=(0,r.unaryKernelFunc)({opSnippet:u,packedOpSnippet:s}),l=exports.relu6Config={kernelName:e.Relu6,backendName:"webgl",kernelFunc:t};
},{"@tensorflow/tfjs-core":"kSBl","../kernel_utils/kernel_funcs_utils":"ciwP","../unaryop_gpu":"CK3x"}],"WV0L":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.ResizeBilinearProgram=void 0;class e{constructor(e,t,o,c,n){this.variableNames=["A"],this.outputShape=[];const[r,i,s,u]=e;this.outputShape=[r,t,o,u];const a=[c&&t>1?i-1:i,c&&o>1?s-1:s],R=[c&&t>1?t-1:t,c&&o>1?o-1:o];let C;C=n?"(vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC - vec2(0.5)":"vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`\n      const vec2 effectiveInputOverOutputRatioRC = vec2(\n          ${a[0]/R[0]},\n          ${a[1]/R[1]});\n      const vec2 inputShapeRC = vec2(${i}.0, ${s}.0);\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        ivec2 yRC = coords.yz;\n\n        // Fractional source index.\n        vec2 sourceFracIndexRC = ${C};\n\n        // Compute the four integer indices.\n        ivec2 sourceFloorRC = ivec2(max(sourceFracIndexRC, vec2(0.0)));\n        ivec2 sourceCeilRC = ivec2(\n          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));\n\n        float topLeft = getA(b, sourceFloorRC.x, sourceFloorRC.y, d);\n        float bottomLeft = getA(b, sourceCeilRC.x, sourceFloorRC.y, d);\n        float topRight = getA(b, sourceFloorRC.x, sourceCeilRC.y, d);\n        float bottomRight = getA(b, sourceCeilRC.x, sourceCeilRC.y, d);\n\n        vec2 fracRC = sourceFracIndexRC - vec2(sourceFloorRC);\n\n        float top = topLeft + (topRight - topLeft) * fracRC.y;\n        float bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;\n        float newValue = top + (bottom - top) * fracRC.x;\n\n        setOutput(newValue);\n      }\n    `}}exports.ResizeBilinearProgram=e;
},{}],"xogv":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.ResizeBilinearPackedProgram=void 0;class e{constructor(e,o,t,n,c){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];const[r,u,s,l]=e;this.outputShape=[r,o,t,l];const C=[n&&o>1?u-1:u,n&&t>1?s-1:s],a=[n&&o>1?o-1:o,n&&t>1?t-1:t];let i;i=c?"(vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC - vec3(0.5)":"vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`\n      const vec3 effectiveInputOverOutputRatioRC = vec3(\n          ${C[0]/a[0]},\n          ${C[1]/a[1]},\n          ${C[1]/a[1]});\n      const vec3 inputShapeRC = vec3(${u}.0, ${s}.0,\n                                     ${s}.0);\n\n      float getAValue(int b, int r, int c, int d) {\n        return getChannel(getA(b, r, c, d), vec2(c, d));\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        // Calculate values for next column in yRC.z.\n        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);\n\n        // Fractional source index.\n        vec3 sourceFracIndexRC = ${i};\n\n        // Compute the four integer indices.\n        ivec3 sourceFloorRC = ivec3(max(sourceFracIndexRC, vec3(0.0)));\n        ivec3 sourceCeilRC = ivec3(\n          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));\n\n        // Should we calculate next column and row elements in 2x2 packed cell.\n        bool hasNextCol = d < ${l-1};\n        bool hasNextRow = coords.z < ${t-1};\n\n        // In parallel, construct four corners for all four components in\n        // packed 2x2 cell.\n        vec4 topLeft = vec4(\n          getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d),\n          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d + 1) : 0.0);\n\n        vec4 bottomLeft = vec4(\n          getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d),\n          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d + 1) : 0.0);\n\n        vec4 topRight = vec4(\n          getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d),\n          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d + 1) : 0.0);\n\n        vec4 bottomRight = vec4(\n          getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d),\n          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d + 1) : 0.0);\n\n        vec3 fracRC = sourceFracIndexRC - vec3(sourceFloorRC);\n\n        vec4 top = mix(topLeft, topRight, fracRC.yyzz);\n        vec4 bottom = mix(bottomLeft, bottomRight, fracRC.yyzz);\n        vec4 newValue = mix(top, bottom, fracRC.x);\n\n        setOutput(newValue);\n      }\n    `}}exports.ResizeBilinearPackedProgram=e;
},{}],"zgo7":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.resizeBilinear=n,exports.resizeBilinearConfig=void 0;var e=require("@tensorflow/tfjs-core"),r=require("../resize_bilinear_gpu"),i=require("../resize_bilinear_packed_gpu");function n(n){const{inputs:s,backend:a,attrs:o}=n,{images:t}=s,{alignCorners:l,halfPixelCenters:u,size:c}=o,[g,p]=c,_=(0,e.env)().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new i.ResizeBilinearPackedProgram(t.shape,g,p,l,u):new r.ResizeBilinearProgram(t.shape,g,p,l,u);return a.runWebGLProgram(_,[t],"float32")}const s=exports.resizeBilinearConfig={kernelName:e.ResizeBilinear,backendName:"webgl",kernelFunc:n};
},{"@tensorflow/tfjs-core":"kSBl","../resize_bilinear_gpu":"WV0L","../resize_bilinear_packed_gpu":"xogv"}],"UnlZ":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.ResizeBilinearBackpropProgram=void 0;class t{constructor(t,n,e){this.variableNames=["dy"],this.outputShape=[],this.outputShape=n;const[,o,i]=n,[,d,r]=t,a=[e&&d>1?o-1:o,e&&r>1?i-1:i],f=[e&&d>1?d-1:d,e&&r>1?r-1:r],l=a[0]/f[0],s=a[1]/f[1],x=1/l,c=1/s,p=2*Math.ceil(x)+2,y=2*Math.ceil(c)+2;this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        int r = coords[1];\n        int c = coords[2];\n\n        float accumulator = 0.0;\n\n        const float heightScale = float(${l});\n        const float widthScale = float(${s});\n\n        const float invHeightScale = float(${x});\n        const float invWidthScale = float(${c});\n\n        const int winHeight = int(${p});\n        const int winWidth = int(${y});\n\n        // Compute bounds for where in dy we will look\n        float startRLerp = floor(float(r) * invHeightScale);\n        int startDyR = int(startRLerp - float(winHeight / 2));\n\n        float startCLerp = floor(float(c) * invWidthScale);\n        int startDyC = int(startCLerp - float(winWidth / 2));\n\n        // Loop over dy\n        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {\n          int dyR = dyROffset + startDyR;\n\n          // Guard against the window exceeding the bounds of dy\n          if (dyR < 0 || dyR >= ${d}) {\n            continue;\n          }\n\n          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {\n            int dyC = dyCOffset + startDyC;\n\n            // Guard against the window exceeding the bounds of dy\n            if (dyC < 0 || dyC >= ${r}) {\n              continue;\n            }\n\n            float dxR = float(dyR) * heightScale;\n            int topDxRIndex = int(floor(dxR));\n            int bottomDxRIndex = int(min(ceil(dxR), ${o-1}.0));\n            float dxRLerp = dxR - float(topDxRIndex);\n            float inverseDxRLerp = 1.0 - dxRLerp;\n\n            float dxC = float(dyC) * widthScale;\n            int leftDxCIndex = int(floor(dxC));\n            int rightDxCIndex = int(min(ceil(dxC), ${i-1}.0));\n            float dxCLerp = dxC - float(leftDxCIndex);\n            float inverseDxCLerp = 1.0 - dxCLerp;\n\n            if (r == topDxRIndex && c == leftDxCIndex) {\n              // topLeft\n              accumulator +=\n                getDy(b, dyR, dyC, d) * inverseDxRLerp * inverseDxCLerp;\n            }\n\n            if (r == topDxRIndex && c == rightDxCIndex) {\n              // topRight\n              accumulator += getDy(b, dyR, dyC, d) * inverseDxRLerp * dxCLerp;\n            }\n\n            if (r == bottomDxRIndex && c == leftDxCIndex) {\n              // bottomLeft\n              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * inverseDxCLerp;\n            }\n\n            if (r == bottomDxRIndex && c == rightDxCIndex) {\n              // bottomRight\n              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * dxCLerp;\n            }\n          }\n        }\n        // End loop over dy\n\n        setOutput(accumulator);\n      }\n    `}}exports.ResizeBilinearBackpropProgram=t;
},{}],"KZl4":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.resizeBilinearGrad=i,exports.resizeBilinearGradConfig=void 0;var e=require("@tensorflow/tfjs-core"),r=require("../resize_bilinear_backprop_gpu");function i(e){const{inputs:i,backend:a,attrs:n}=e,{images:s,dy:o}=i,{alignCorners:t}=n,p=new r.ResizeBilinearBackpropProgram(o.shape,s.shape,t);return a.runWebGLProgram(p,[o],o.dtype)}const a=exports.resizeBilinearGradConfig={kernelName:e.ResizeBilinearGrad,backendName:"webgl",kernelFunc:i};
},{"@tensorflow/tfjs-core":"kSBl","../resize_bilinear_backprop_gpu":"UnlZ"}],"TJbF":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.ResizeNearestNeighborProgram=void 0;class e{constructor(e,t,o,n,r){this.variableNames=["A"],this.outputShape=[];const[s,c,i,u]=e;this.outputShape=[s,t,o,u];const a=[n&&t>1?c-1:c,n&&o>1?i-1:i],v=[n&&t>1?t-1:t,n&&o>1?o-1:o],p=n?"0.5":"0.0";let R;R=r?"max((vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC, vec2(0.0))":"vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`\n      const vec2 effectiveInputOverOutputRatioRC = vec2(\n          ${a[0]/v[0]},\n          ${a[1]/v[1]});\n      const vec2 inputShapeRC = vec2(${c}.0, ${i}.0);\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        ivec2 yRC = coords.yz;\n\n        // Fractional source index.\n        vec2 sourceFracIndexRC = ${R};\n\n        // Compute the coordinators of nearest neighbor point.\n        ivec2 sourceNearestRC = ivec2(\n          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${p})));\n        float newValue = getA(b, sourceNearestRC.x, sourceNearestRC.y, d);\n\n        setOutput(newValue);\n      }\n    `}}exports.ResizeNearestNeighborProgram=e;
},{}],"ioD1":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.ResizeNearestNeighborPackedProgram=void 0;class e{constructor(e,t,n,o,c){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];const[s,r,a,u]=e;this.outputShape=[s,t,n,u];const i=[o&&t>1?r-1:r,o&&n>1?a-1:a],l=[o&&t>1?t-1:t,o&&n>1?n-1:n],d=o?"0.5":"0.0";let v;v=c?"max((vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC, vec3(0.0))":"vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`\n      const vec3 effectiveInputOverOutputRatioRC = vec3(\n          ${i[0]/l[0]},\n          ${i[1]/l[1]},\n          ${i[1]/l[1]});\n      const vec3 inputShapeRC = vec3(${r}.0, ${a}.0,\n                                     ${a}.0);\n\n      float getAValue(int b, int r, int c, int d) {\n        return getChannel(getA(b, r, c, d), vec2(c, d));\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        // Calculate values for next column in yRC.z.\n        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);\n\n        // Fractional source index.\n        vec3 sourceFracIndexRC = ${v};\n\n        // Compute the coordinators of nearest neighbor point.\n        ivec3 sourceNearestRC = ivec3(\n          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${d})));\n\n        // Should we calculate next column and row elements in 2x2 packed cell.\n        bool hasNextCol = d < ${u-1};\n        bool hasNextRow = coords.z < ${n-1};\n\n        vec4 newValue = vec4(\n          getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d),\n          hasNextCol ? getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d + 1) : 0.0);\n\n        setOutput(newValue);\n      }\n    `}}exports.ResizeNearestNeighborPackedProgram=e;
},{}],"acQQ":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.resizeNearestNeighbor=i,exports.resizeNearestNeighborConfig=void 0;var e=require("@tensorflow/tfjs-core"),r=require("../resize_nearest_neighbor_gpu"),s=require("../resize_nearest_neighbor_packed_gpu");function i(i){const{inputs:o,backend:t,attrs:n}=i,{images:a}=o,{alignCorners:g,halfPixelCenters:N,size:b}=n,[u,p]=b,_=(0,e.env)().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new s.ResizeNearestNeighborPackedProgram(a.shape,u,p,g,N):new r.ResizeNearestNeighborProgram(a.shape,u,p,g,N);return t.runWebGLProgram(_,[a],a.dtype)}const o=exports.resizeNearestNeighborConfig={kernelName:e.ResizeNearestNeighbor,backendName:"webgl",kernelFunc:i};
},{"@tensorflow/tfjs-core":"kSBl","../resize_nearest_neighbor_gpu":"TJbF","../resize_nearest_neighbor_packed_gpu":"ioD1"}],"Ps4L":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.ResizeNearestNeigborBackpropProgram=void 0;class t{constructor(t,n,o){this.variableNames=["dy"],this.outputShape=[],this.outputShape=n;const[,e,a]=n,[,r,i]=t,s=[o&&r>1?e-1:e,o&&i>1?a-1:a],f=[o&&r>1?r-1:r,o&&i>1?i-1:i],l=s[0]/f[0],c=s[1]/f[1],d=1/l,u=1/c,y=2*Math.ceil(d)+2,h=2*Math.ceil(u)+2;this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        int r = coords[1];\n        int c = coords[2];\n\n        float accumulator = 0.0;\n\n        const float heightScale = float(${l});\n        const float widthScale = float(${c});\n\n        const float invHeightScale = float(${d});\n        const float invWidthScale = float(${u});\n\n        const int winHeight = int(${y});\n        const int winWidth = int(${h});\n\n        // Compute bounds for where in dy we will look\n        float startRLerp = floor(float(r) * invHeightScale);\n        int startDyR = int(floor(startRLerp - float(winHeight / 2)));\n\n        float startCLerp = floor(float(c) * invWidthScale);\n        int startDyC = int(floor(startCLerp - float(winWidth / 2)));\n\n        // Loop over dy\n        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {\n          int dyR = dyROffset + startDyR;\n\n          // Guard against the window exceeding the bounds of dy\n          if (dyR < 0 || dyR >= ${r}) {\n            continue;\n          }\n\n          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {\n            int dyC = dyCOffset + startDyC;\n\n            // Guard against the window exceeding the bounds of dy\n            if (dyC < 0 || dyC >= ${i}) {\n              continue;\n            }\n\n            float sourceFracRow =\n              float(${s[0]}) *\n                (float(dyR) / float(${f[0]}));\n\n            float sourceFracCol =\n                float(${s[1]}) *\n                  (float(dyC) / float(${f[1]}));\n\n            int sourceNearestRow = int(min(\n                float(int(${e}) - 1),\n                ${o} ? float(round(sourceFracRow)) :\n                                  float(floor(sourceFracRow))));\n\n            int sourceNearestCol = int(min(\n                float(int(${a}) - 1),\n                ${o} ? float(round(sourceFracCol)) :\n                                  float(floor(sourceFracCol))));\n\n            if (r == sourceNearestRow && c == sourceNearestCol) {\n              accumulator += getDy(b, dyR, dyC, d);\n            }\n          }\n        }\n        // End loop over dy\n\n        setOutput(accumulator);\n      }\n    `}}exports.ResizeNearestNeigborBackpropProgram=t;
},{}],"hJ6K":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.resizeNearestNeighborGrad=s,exports.resizeNearestNeighborGradConfig=void 0;var e=require("@tensorflow/tfjs-core"),r=require("../resize_nearest_neighbor_backprop_gpu");function s(e){const{inputs:s,backend:o,attrs:a}=e,{images:t,dy:i}=s,{alignCorners:n}=a,g=new r.ResizeNearestNeigborBackpropProgram(i.shape,t.shape,n);return o.runWebGLProgram(g,[i],i.dtype)}const o=exports.resizeNearestNeighborGradConfig={kernelName:e.ResizeNearestNeighborGrad,backendName:"webgl",kernelFunc:s};
},{"@tensorflow/tfjs-core":"kSBl","../resize_nearest_neighbor_backprop_gpu":"Ps4L"}],"uIF6":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.ReverseProgram=void 0;var e=require("./shader_compiler");class o{constructor(o,t){this.variableNames=["x"];const r=o.length;if(r>4)throw new Error(`WebGL backend: Reverse of rank-${r} tensor is not yet supported`);if(this.outputShape=o,1===r)return void(this.userCode=`\n        void main() {\n          int coord = getOutputCoords();\n          setOutput(getX(${o[0]} - coord - 1));\n        }\n      `);const s=o.map((e,r)=>(e=>-1!==t.indexOf(e)&&1!==o[e]?`${o[e]} - coords[${e}] - 1`:`coords[${e}]`)(r)).join(","),n=(0,e.getCoordsDataType)(r);this.userCode=`\n      void main() {\n        ${n} coords = getOutputCoords();\n        setOutput(getX(${s}));\n      }\n    `}}exports.ReverseProgram=o;
},{"./shader_compiler":"xhhc"}],"M4lQ":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.ReversePackedProgram=void 0;var e=require("./packing_util"),t=require("./shader_compiler");class n{constructor(n,r){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0;const s=n.length;if(s>4)throw new Error(`WebGL backend: Reverse of rank-${s} tensor is not yet supported`);this.outputShape=n;const u=(0,e.getChannels)("rc",s),i=`${u[s-1]} + 1 < ${this.outputShape[s-1]}`,o=`${u[s-2]} + 1 < ${this.outputShape[s-2]}`,c=(0,t.getCoordsDataType)(s);function a(e){const t=n.map((t,s)=>(function(e,t){return-1!==r.indexOf(e)&&1!==n[e]?`${n[e]} - ${t[e]} - 1`:`${t[e]}`})(s,e));return`getChannel(getX(${t.join(",")}), vec2(${t.slice(-2).join(",")}))`}this.userCode=1===s?`\n        void main(){\n          int rc = getOutputCoords();\n          vec4 result = vec4(0.);\n          result.r = getChannel(getX(${n[0]} - rc - 1),\n            ${n[0]} - rc - 1);\n          if(${i}){\n              result.g = getChannel(getX(${n[0]} - (rc  + 1) - 1),\n                ${n[0]} - (rc  + 1) - 1);\n          }\n          setOutput(result);\n        }\n      `:`\n        void main() {\n          ${c} rc = getOutputCoords();\n          vec4 result = vec4(0.);\n          result.r = ${function(e){return a(e)}(u.slice())};\n          if(${i}){\n            result.g = ${function(e){return e[s-1]="("+e[s-1]+" + 1)",a(e)}(u.slice())};\n          }\n          if(${o}) {\n            result.b = ${function(e){return e[s-2]="("+e[s-2]+" + 1)",a(e)}(u.slice())};\n            if(${i}) {\n              result.a = ${function(e){return e[s-1]="("+e[s-1]+" + 1)",e[s-2]="("+e[s-2]+" + 1)",a(e)}(u.slice())};\n            }\n          }\n          setOutput(result);\n        }\n    `}}exports.ReversePackedProgram=n;
},{"./packing_util":"BqvU","./shader_compiler":"xhhc"}],"yvk0":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.reverse=n,exports.reverseConfig=void 0;var e=require("@tensorflow/tfjs-core"),r=require("../reverse_gpu"),s=require("../reverse_packed_gpu"),t=require("./Identity");function n(n){const{inputs:o,backend:a,attrs:i}=n,{x:u}=o,{dims:p}=i,c=u.shape.length,d=e.util.parseAxisParam(p,u.shape);if(0===c)return(0,t.identity)({inputs:{x:u},backend:a});const v=(0,e.env)().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new s.ReversePackedProgram(u.shape,d):new r.ReverseProgram(u.shape,d);return a.runWebGLProgram(v,[u],u.dtype)}const o=exports.reverseConfig={kernelName:e.Reverse,backendName:"webgl",kernelFunc:n};
},{"@tensorflow/tfjs-core":"kSBl","../reverse_gpu":"uIF6","../reverse_packed_gpu":"M4lQ","./Identity":"LUQG"}],"eP3p":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.RotateProgram=void 0;class o{constructor(o,t){this.variableNames=["Image"],this.outputShape=[],this.customUniforms=[{name:"params",type:"vec4"}];const a=o[1],r=o[2];this.outputShape=o;let e="";e="number"==typeof t?`float outputValue = ${t.toFixed(2)};`:`\n        vec3 fill = vec3(${t.join(",")});\n        float outputValue = fill[coords[3]];`,this.userCode=`\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int x = coords[2];\n          int y = coords[1];\n          float coordXFloat = (float(x) - params[0]) * params[3] -\n            (float(y) - params[1]) * params[2];\n          float coordYFloat = (float(x) - params[0]) * params[2] +\n            (float(y) - params[1]) * params[3];\n          int coordX = int(round(coordXFloat + params[0]));\n          int coordY = int(round(coordYFloat + params[1]));\n          ${e}\n          if(coordX >= 0 && coordX < ${r} && coordY >= 0 && coordY < ${a}) {\n            outputValue = getImage(coords[0], coordY, coordX, coords[3]);\n          }\n          setOutput(outputValue);\n        }\n    `}}exports.RotateProgram=o;
},{}],"voJu":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.rotateWithOffsetConfig=void 0;var e=require("@tensorflow/tfjs-core"),t=require("../rotate_gpu");const r=exports.rotateWithOffsetConfig={kernelName:e.RotateWithOffset,backendName:"webgl",kernelFunc:({inputs:r,attrs:a,backend:o})=>{const{image:s}=r,{radians:n,fillValue:i,center:f}=a,u=o,c=new t.RotateProgram(s.shape,i),[l,p]=e.backend_util.getImageCenter(f,s.shape[1],s.shape[2]),g=[[l,p,Math.sin(n),Math.cos(n)]];return u.runWebGLProgram(c,[s],s.dtype,g)}};
},{"@tensorflow/tfjs-core":"kSBl","../rotate_gpu":"eP3p"}],"rl0C":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.roundConfig=exports.round=void 0;var e=require("@tensorflow/tfjs-core"),n=require("../kernel_utils/kernel_funcs_utils");const r="\n  // OpenGL ES does not support round function.\n  // The algorithm is based on banker's rounding.\n  float base = floor(x);\n  if ((x - base) < 0.5) {\n    return floor(x);\n  } else if ((x - base) > 0.5) {\n    return ceil(x);\n  } else {\n    if (mod(base, 2.0) == 0.0) {\n      return base;\n    } else {\n      return base + 1.0;\n    }\n  }\n",o=exports.round=(0,n.unaryKernelFunc)({opSnippet:r}),s=exports.roundConfig={kernelName:e.Round,backendName:"webgl",kernelFunc:o};
},{"@tensorflow/tfjs-core":"kSBl","../kernel_utils/kernel_funcs_utils":"ciwP"}],"YW4p":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.rsqrtConfig=exports.rsqrt=void 0;var e=require("@tensorflow/tfjs-core"),r=require("../kernel_utils/kernel_funcs_utils"),s=require("../kernel_utils/shared");const t="return inversesqrt(x);",n=exports.rsqrt=(0,r.unaryKernelFunc)({opSnippet:t,cpuKernelImpl:s.rsqrtImplCPU}),l=exports.rsqrtConfig={kernelName:e.Rsqrt,backendName:"webgl",kernelFunc:n};
},{"@tensorflow/tfjs-core":"kSBl","../kernel_utils/kernel_funcs_utils":"ciwP","../kernel_utils/shared":"cNPH"}],"vOJf":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.ScatterProgram=void 0;var e=require("./shader_compiler");class t{constructor(t,n,o,s,r,d,i=!0,a=!1){this.variableNames=["updates","indices","defaultValue"],this.outputShape=d;const u=(0,e.getCoordsDataType)(r.length),l=(0,e.getCoordsDataType)(d.length);let c="";1===o?c="i":2===o&&(c="i, j");const f=`getIndices(${c})`;let p="";1===s?p="i":2===s&&(p="i, coords[1]");const $=`getUpdates(${p})`;let g="";a&&(g="coords[0], coords[1]");const m=`getDefaultValue(${g})`,x=n>1?"strides[j]":"strides";this.userCode=`\n        ${u} strides = ${u}(${r});\n\n        void main() {\n          ${l} coords = getOutputCoords();\n          float sum = 0.0;\n          bool found = false;\n          for (int i = 0; i < ${t}; i++) {\n            int flattenedIndex = 0;\n            for (int j = 0; j < ${n}; j++) {\n              int index = round(${f});\n              flattenedIndex += index * ${x};\n            }\n            if (flattenedIndex == coords[0]) {\n              sum += ${$};\n              found = true;\n            }\n          }\n          setOutput(mix(${m}, sum, float(found)));\n        }\n      `}}exports.ScatterProgram=t;
},{"./shader_compiler":"xhhc"}],"FQQg":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.ScatterPackedProgram=void 0;var e=require("./shader_compiler");class n{constructor(n,t,d,s,o,r,a=!0,i=!1){this.variableNames=["updates","indices","defaultValue"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=r;const c=(0,e.getCoordsDataType)(o.length),u=(0,e.getCoordsDataType)(r.length);let l="";1===d?l="i":2===d&&(l="i, j");const f=`getIndices(${l})`;let x="";1===s?x="i":2===s&&(x="i, coords[1]");const p=`getUpdates(${x})`;let v="";i&&(v="coords[0], coords[1]");const $=`getDefaultValue(${v})`,I=t>1?"strides[j]":"strides",m=t>1?"strides[j + 1]":"strides";this.userCode=`\n        ${c} strides = ${c}(${o});\n\n        void main() {\n          ${u} coords = getOutputCoords();\n          vec4 sum = vec4(0.);\n          vec4 found = vec4(0.);\n          for (int i = 0; i < ${n}; i+=2) {\n            ivec2 flattenedIndex = ivec2(0);\n            for (int j = 0; j < ${t}; j+=2) {\n              ivec4 index = round(${f});\n              flattenedIndex += index.xz * ${I};\n              if (j + 1 < ${t}) {\n                flattenedIndex += index.yw * ${m};\n              }\n            }\n            if (flattenedIndex[0] == coords[0] || flattenedIndex[1] == coords[0] ||\n                flattenedIndex[0] == coords[0] + 1 || flattenedIndex[1] == coords[0] + 1) {\n              vec4 updVals = ${p};\n              if (flattenedIndex[0] == coords[0]) {\n                sum.xy += updVals.xy;\n                found.xy = vec2(1.);\n              } else if (flattenedIndex[0] == coords[0] + 1) {\n                sum.zw += updVals.xy;\n                found.zw = vec2(1.);\n              }\n              if (flattenedIndex[1] == coords[0]) {\n                sum.xy += updVals.zw;\n                found.xy = vec2(1.);\n              } else if (flattenedIndex[1] == coords[0] + 1) {\n                sum.zw += updVals.zw;\n                found.zw = vec2(1.);\n              }\n            }\n          }\n          setOutput(mix(${$}, sum, found));\n        }\n      `}}exports.ScatterPackedProgram=n;
},{"./shader_compiler":"xhhc"}],"over":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.scatterNd=a,exports.scatterNdConfig=void 0;var e=require("@tensorflow/tfjs-core"),t=require("../scatter_gpu"),s=require("../scatter_packed_gpu"),r=require("./Reshape");function a(a){const{inputs:n,backend:o,attrs:p}=a,{indices:i,updates:c}=n,{shape:d}=p,{sliceRank:u,numUpdates:l,sliceSize:h,strides:f,outputSize:g}=e.backend_util.calculateShapes(c,i,d),k=[g/h,h];if(0===g)return o.makeTensorInfo(d,i.dtype);const m=(0,r.reshape)({inputs:{x:i},backend:o,attrs:{shape:[l,u]}}),I=(0,r.reshape)({inputs:{x:c},backend:o,attrs:{shape:[l,h]}}),b=o.makeTensorInfo([],"float32",new Float32Array([0]));let x;x=(0,e.env)().getBool("WEBGL_PACK")?new s.ScatterPackedProgram(l,u,m.shape.length,I.shape.length,f,k):new t.ScatterProgram(l,u,m.shape.length,I.shape.length,f,k);const _=o.runWebGLProgram(x,[I,m,b],I.dtype),N=(0,r.reshape)({inputs:{x:_},backend:o,attrs:{shape:d}});return o.disposeIntermediateTensorInfo(m),o.disposeIntermediateTensorInfo(I),o.disposeIntermediateTensorInfo(_),o.disposeIntermediateTensorInfo(b),N}const n=exports.scatterNdConfig={kernelName:e.ScatterNd,backendName:"webgl",kernelFunc:a};
},{"@tensorflow/tfjs-core":"kSBl","../scatter_gpu":"vOJf","../scatter_packed_gpu":"FQQg","./Reshape":"OCN8"}],"oE4t":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.SearchSortedProgram=void 0;var t=require("@tensorflow/tfjs-core");class e{constructor(e,n,i,r){this.variableNames=["sortedSequence","values"],this.customUniforms=[{name:"numInputs",type:"int"}],this.outputShape=[e,i];const o=`for (int i = 0; i < ${Math.ceil(Math.log2(n+1))}; ++i) { if (left >= right) break;`,a=2===(0,t.env)().getNumber("WEBGL_VERSION")?"while (left < right) {":o,s="left"===r?"<":"<=";this.userCode=`\n       int findBound(int batch, float value) {\n         int left = 0;\n         int right = numInputs;\n         int mid;\n         ${a}\n           mid = (left + right) / 2;\n           if (getSortedSequence(batch, mid) ${s} value) {\n             left = mid + 1;\n           } else {\n             right = mid;\n           }\n         }\n         return right;\n       }\n\n       void main() {\n         ivec2 coords = getOutputCoords();\n         int batch = coords[0];\n         int valueIndex = coords[1];\n\n         float value = getValues(batch, valueIndex);\n\n         setOutput(float(findBound(batch, value)));\n       }\n     `}}exports.SearchSortedProgram=e;
},{"@tensorflow/tfjs-core":"kSBl"}],"JeaS":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.searchSorted=s,exports.searchSortedConfig=void 0;var e=require("@tensorflow/tfjs-core"),r=require("../search_sorted_gpu");function s(e){const{inputs:s,backend:t,attrs:o}=e,{sortedSequence:a,values:n}=s,{side:c}=o,d=new r.SearchSortedProgram(a.shape[0],a.shape[1],n.shape[1],c),u=[[a.shape[1]]];return t.runWebGLProgram(d,[a,n],"int32",u)}const t=exports.searchSortedConfig={kernelName:e.SearchSorted,backendName:"webgl",kernelFunc:s};
},{"@tensorflow/tfjs-core":"kSBl","../search_sorted_gpu":"oE4t"}],"E1Yw":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.SelectProgram=void 0;var e=require("./shader_compiler");class t{constructor(t,r,s){let o,n;if(this.variableNames=["c","a","b"],this.outputShape=r,s>4)throw Error(`Where for rank ${s} is not yet supported`);if(1===s)n="resRC",o="resRC";else{const e=["resRC.x","resRC.y","resRC.z","resRC.w"],s=[],a=[];for(let o=0;o<r.length;o++)a.push(`${e[o]}`),o<t&&s.push(`${e[o]}`);o=s.join(),n=a.join()}const a=(0,e.getCoordsDataType)(s);this.userCode=`\n      void main() {\n        ${a} resRC = getOutputCoords();\n        float cVal = getC(${o});\n        if (cVal >= 1.0) {\n          setOutput(getA(${n}));\n        } else {\n          setOutput(getB(${n}));\n        }\n      }\n    `}}exports.SelectProgram=t;
},{"./shader_compiler":"xhhc"}],"VO4x":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.select=r,exports.selectConfig=void 0;var e=require("@tensorflow/tfjs-core"),t=require("../select_gpu");function r(r){const{inputs:n,backend:s}=r,{condition:o,t:c,e:l}=n,p=new t.SelectProgram(o.shape.length,c.shape,c.shape.length);return s.runWebGLProgram(p,[o,c,l],(0,e.upcastType)(c.dtype,l.dtype))}const n=exports.selectConfig={kernelName:e.Select,backendName:"webgl",kernelFunc:r};
},{"@tensorflow/tfjs-core":"kSBl","../select_gpu":"E1Yw"}],"iGiQ":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.seluConfig=exports.selu=void 0;var e=require("@tensorflow/tfjs-core"),l=require("../kernel_utils/kernel_funcs_utils");const n=`\n  // Stable and Attracting Fixed Point (0, 1) for Normalized Weights.\n  // see: https://arxiv.org/abs/1706.02515\n  float scaleAlpha = ${e.backend_util.SELU_SCALEALPHA};\n  float scale = ${e.backend_util.SELU_SCALE};\n  return (x >= 0.0) ? scale * x : scaleAlpha * (exp(x) - 1.0);\n`,r=exports.selu=(0,l.unaryKernelFunc)({opSnippet:n}),t=exports.seluConfig={kernelName:e.Selu,backendName:"webgl",kernelFunc:r};
},{"@tensorflow/tfjs-core":"kSBl","../kernel_utils/kernel_funcs_utils":"ciwP"}],"Xsk6":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.sigmoidConfig=exports.sigmoid=void 0;var e=require("@tensorflow/tfjs-core"),r=require("../kernel_utils/kernel_funcs_utils"),s=require("../kernel_utils/shared");const n=r.CHECK_NAN_SNIPPET_UNARY+"\n  return 1.0 / (1.0 + exp(-1.0 * x));\n",i="\n  vec4 result = 1.0 / (1.0 + exp(-1.0 * x));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n",t=exports.sigmoid=(0,r.unaryKernelFunc)({opSnippet:n,packedOpSnippet:i,cpuKernelImpl:s.sigmoidImplCPU}),l=exports.sigmoidConfig={kernelName:e.Sigmoid,backendName:"webgl",kernelFunc:t};
},{"@tensorflow/tfjs-core":"kSBl","../kernel_utils/kernel_funcs_utils":"ciwP","../kernel_utils/shared":"cNPH"}],"eg93":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.signConfig=exports.sign=void 0;var e=require("@tensorflow/tfjs-core"),n=require("../kernel_utils/kernel_funcs_utils");const r="\n  if (isnan(x)) { return 0.0; }\n  return sign(x);\n",s=exports.sign=(0,n.unaryKernelFunc)({opSnippet:r}),i=exports.signConfig={kernelName:e.Sign,backendName:"webgl",kernelFunc:s};
},{"@tensorflow/tfjs-core":"kSBl","../kernel_utils/kernel_funcs_utils":"ciwP"}],"XVYV":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.sinConfig=exports.sin=void 0;var e=require("@tensorflow/tfjs-core"),n=require("../binaryop_packed_gpu"),r=require("../kernel_utils/kernel_funcs_utils");const s=r.CHECK_NAN_SNIPPET_UNARY+"\n  return sin(x);\n",i=`\n  vec4 result = sin(x);\n  bvec4 isNaN = isnan(x);\n  ${n.CHECK_NAN_SNIPPET_PACKED}\n  return result;\n`,t=exports.sin=(0,r.unaryKernelFunc)({opSnippet:s,packedOpSnippet:i}),u=exports.sinConfig={kernelName:e.Sin,backendName:"webgl",kernelFunc:t};
},{"@tensorflow/tfjs-core":"kSBl","../binaryop_packed_gpu":"mFR1","../kernel_utils/kernel_funcs_utils":"ciwP"}],"mBz3":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.sinhConfig=exports.sinh=void 0;var e=require("@tensorflow/tfjs-core"),n=require("../kernel_utils/kernel_funcs_utils");const r="\n  float e2x = exp(x);\n  return (e2x - 1.0 / e2x) / 2.0;\n",s=exports.sinh=(0,n.unaryKernelFunc)({opSnippet:r}),t=exports.sinhConfig={kernelName:e.Sinh,backendName:"webgl",kernelFunc:s};
},{"@tensorflow/tfjs-core":"kSBl","../kernel_utils/kernel_funcs_utils":"ciwP"}],"ZBTw":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.softplusConfig=exports.softplus=void 0;var e=require("@tensorflow/tfjs-core"),o=require("../kernel_utils/kernel_funcs_utils");const l="\n  float epsilon = 1.1920928955078125e-7;\n  float threshold = log(epsilon) + 2.0;\n\n  bool too_large = x > -threshold;\n  bool too_small = x < threshold;\n\n  float result;\n  float exp_x = exp(x);\n\n  if (too_large){\n    result = x;\n  }\n  else if (too_small){\n    result = exp_x;\n  }\n  else{\n    result = log(exp_x + 1.0);\n  }\n  return result;\n",n=exports.softplus=(0,o.unaryKernelFunc)({opSnippet:l}),s=exports.softplusConfig={kernelName:e.Softplus,backendName:"webgl",kernelFunc:n};
},{"@tensorflow/tfjs-core":"kSBl","../kernel_utils/kernel_funcs_utils":"ciwP"}],"ZGig":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.spaceToBatchNDConfig=exports.spaceToBatchND=void 0;var e=require("@tensorflow/tfjs-core"),t=require("./PadV2"),s=require("./Reshape"),a=require("./Transpose");const n=n=>{const{inputs:r,backend:p,attrs:c}=n,{x:o}=r,{blockShape:h,paddings:d}=c;e.util.assert(o.shape.length<=4,()=>"spaceToBatchND for rank > 4 with a WebGL backend not implemented yet");const u=h.reduce((e,t)=>e*t),i=[[0,0]];i.push(...d);for(let e=1+h.length;e<o.shape.length;++e)i.push([0,0]);const l=[],b=(0,t.padV2)({inputs:{x:o},backend:p,attrs:{paddings:i,constantValue:0}}),k=e.backend_util.getReshaped(b.shape,h,u,!1),g=e.backend_util.getPermuted(k.length,h.length,!1),x=e.backend_util.getReshapedPermuted(b.shape,h,u,!1),f=(0,s.reshape)({inputs:{x:b},backend:p,attrs:{shape:k}}),m=(0,a.transpose)({inputs:{x:f},backend:p,attrs:{perm:g}}),N=(0,s.reshape)({inputs:{x:m},backend:p,attrs:{shape:x}});return l.push(b),l.push(f),l.push(m),l.forEach(e=>p.disposeIntermediateTensorInfo(e)),N};exports.spaceToBatchND=n;const r=exports.spaceToBatchNDConfig={kernelName:e.SpaceToBatchND,backendName:"webgl",kernelFunc:n};
},{"@tensorflow/tfjs-core":"kSBl","./PadV2":"CzrI","./Reshape":"OCN8","./Transpose":"ukag"}],"eOf8":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.sparseFillEmptyRows=r,exports.sparseFillEmptyRowsConfig=void 0;var e=require("@tensorflow/tfjs-core"),a=require("../kernel_utils/shared");function r(e){const{inputs:r,backend:s}=e,{indices:t,values:n,denseShape:o,defaultValue:p}=r;if(1!==o.shape.length)throw new Error(`Dense shape must be a vector, saw:\n         ${o.shape}`);if(2!==t.shape.length)throw new Error(`Indices must be a matrix, saw:\n         ${t.shape}`);if(1!==n.shape.length)throw new Error(`Values must be a vector, saw:\n         ${n.shape}`);if(0!==p.shape.length)throw new Error(`Default value must be a scalar, saw:\n        ${p.shape}`);const l=s.readSync(t.dataId),d=s.readSync(n.dataId),i=s.readSync(o.dataId),h=s.readSync(p.dataId)[0],[u,w,c,m,y]=(0,a.sparseFillEmptyRowsImplCPU)(l,t.shape,t.dtype,d,n.dtype,i,h);return[s.makeTensorInfo(w,t.dtype,u),s.makeTensorInfo([w[0]],n.dtype,c),s.makeTensorInfo([m.length],"bool",new Uint8Array(m.map(e=>Number(e)))),s.makeTensorInfo([y.length],t.dtype,new Int32Array(y))]}const s=exports.sparseFillEmptyRowsConfig={kernelName:e.SparseFillEmptyRows,backendName:"webgl",kernelFunc:r};
},{"@tensorflow/tfjs-core":"kSBl","../kernel_utils/shared":"cNPH"}],"kviu":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.sparseReshape=a,exports.sparseReshapeConfig=void 0;var e=require("@tensorflow/tfjs-core"),r=require("../kernel_utils/shared");function a(e){const{inputs:a,backend:s}=e,{inputIndices:t,inputShape:n,newShape:p}=a;if(2!==t.shape.length)throw new Error(`Input indices should be a matrix but received shape ${t.shape}`);if(1!==n.shape.length)throw new Error(`Input shape should be a vector but received shape ${n.shape}`);if(1!==p.shape.length)throw new Error(`Target shape should be a vector but received shape ${p.shape}`);const o=Array.from(s.readSync(n.dataId)),h=s.readSync(t.dataId),d=Array.from(s.readSync(p.dataId)),[i,c,u]=(0,r.sparseReshapeImplCPU)(h,t.shape,t.dtype,o,d);return[s.makeTensorInfo(c,t.dtype,i),s.makeTensorInfo([u.length],p.dtype,new Int32Array(u))]}const s=exports.sparseReshapeConfig={kernelName:e.SparseReshape,backendName:"webgl",kernelFunc:a};
},{"@tensorflow/tfjs-core":"kSBl","../kernel_utils/shared":"cNPH"}],"fkXI":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.sparseSegmentMean=n,exports.sparseSegmentMeanConfig=void 0;var e=require("@tensorflow/tfjs-core"),r=require("../kernel_utils/shared");function n(e){const{inputs:n,backend:a}=e,{data:t,indices:s,segmentIds:o}=n;if(t.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==s.shape.length)throw new Error(`Indices should be a vector but received shape\n              ${s.shape}`);if(1!==o.shape.length)throw new Error(`Segment ids should be a vector but received shape\n              ${o.shape}`);const d=a.readSync(t.dataId),i=a.readSync(s.dataId),c=a.readSync(o.dataId),[p,h]=(0,r.sparseSegmentReductionImplCPU)(d,t.shape,t.dtype,i,c,!0);return a.makeTensorInfo(h,t.dtype,p)}const a=exports.sparseSegmentMeanConfig={kernelName:e.SparseSegmentMean,backendName:"webgl",kernelFunc:n};
},{"@tensorflow/tfjs-core":"kSBl","../kernel_utils/shared":"cNPH"}],"p9WO":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.sparseSegmentSum=t,exports.sparseSegmentSumConfig=void 0;var e=require("@tensorflow/tfjs-core"),r=require("../kernel_utils/shared");function t(e){const{inputs:t,backend:s}=e,{data:n,indices:a,segmentIds:o}=t;if(n.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==a.shape.length)throw new Error(`Indices should be a vector but received shape\n             ${a.shape}`);if(1!==o.shape.length)throw new Error(`Segment ids should be a vector but received shape\n             ${o.shape}`);const d=s.readSync(n.dataId),i=s.readSync(a.dataId),c=s.readSync(o.dataId),[p,u]=(0,r.sparseSegmentReductionImplCPU)(d,n.shape,n.dtype,i,c);return s.makeTensorInfo(u,n.dtype,p)}const s=exports.sparseSegmentSumConfig={kernelName:e.SparseSegmentSum,backendName:"webgl",kernelFunc:t};
},{"@tensorflow/tfjs-core":"kSBl","../kernel_utils/shared":"cNPH"}],"orjd":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.sparseToDense=n,exports.sparseToDenseConfig=void 0;var e=require("@tensorflow/tfjs-core"),s=require("../kernel_utils/shared"),r=require("../scatter_gpu"),t=require("./Reshape");function n(n){const{inputs:a,backend:o,attrs:u}=n,{sparseIndices:p,sparseValues:i,defaultValue:c}=a,{outputShape:d}=u,{sliceRank:l,numUpdates:f,sliceSize:g,strides:h,outputSize:S}=e.backend_util.calculateShapes(i,p,d);if("string"===i.dtype){const r=o.bufferSync(p),t=o.bufferSync(i),n=e.util.decodeString(o.readSync(c.dataId)[0]),a=(0,s.scatterImplCPU)(r,t,d,S,g,f,l,h,n,!1);return o.makeTensorInfo(d,a.dtype,a.values)}const b=new r.ScatterProgram(f,l,p.shape.length,i.shape.length,h,[S,1],!1),k=o.runWebGLProgram(b,[i,p,c],i.dtype),m=(0,t.reshape)({inputs:{x:k},backend:o,attrs:{shape:d}});return o.disposeIntermediateTensorInfo(k),m}const a=exports.sparseToDenseConfig={kernelName:e.SparseToDense,backendName:"webgl",kernelFunc:n};
},{"@tensorflow/tfjs-core":"kSBl","../kernel_utils/shared":"cNPH","../scatter_gpu":"vOJf","./Reshape":"OCN8"}],"eg0P":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.splitV=s,exports.splitVConfig=void 0;var e=require("@tensorflow/tfjs-core"),t=require("./Slice");function s(s){const{inputs:r,backend:i,attrs:n}=s,{x:a}=r,{numOrSizeSplits:l,axis:p}=n,o=e.util.parseAxisParam(p,a.shape)[0],c=e.backend_util.prepareSplitSize(a,l,o),u=a.shape.length,x=new Array(u).fill(0),b=a.shape.slice();return c.map(e=>{const s=[...b];s[o]=e;const r=(0,t.slice)({inputs:{x:a},backend:i,attrs:{begin:x,size:s}});return x[o]+=e,r})}const r=exports.splitVConfig={kernelName:e.SplitV,backendName:"webgl",kernelFunc:s};
},{"@tensorflow/tfjs-core":"kSBl","./Slice":"i5TP"}],"XK1L":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.sqrtConfig=exports.sqrt=void 0;var e=require("@tensorflow/tfjs-core"),r=require("../kernel_utils/kernel_funcs_utils"),t=require("../kernel_utils/shared");const s="return sqrt(x);",n=exports.sqrt=(0,r.unaryKernelFunc)({opSnippet:s,packedOpSnippet:s,cpuKernelImpl:t.sqrtImplCPU}),l=exports.sqrtConfig={kernelName:e.Sqrt,backendName:"webgl",kernelFunc:n};
},{"@tensorflow/tfjs-core":"kSBl","../kernel_utils/kernel_funcs_utils":"ciwP","../kernel_utils/shared":"cNPH"}],"ELIZ":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.squareConfig=exports.square=void 0;var e=require("@tensorflow/tfjs-core"),r=require("../kernel_utils/kernel_funcs_utils");const s="return x * x;",n=exports.square=(0,r.unaryKernelFunc)({opSnippet:s}),u=exports.squareConfig={kernelName:e.Square,backendName:"webgl",kernelFunc:n};
},{"@tensorflow/tfjs-core":"kSBl","../kernel_utils/kernel_funcs_utils":"ciwP"}],"fP4n":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.squaredDifferenceConfig=exports.squaredDifference=void 0;var e=require("@tensorflow/tfjs-core"),r=require("../kernel_utils/kernel_funcs_utils");const n="return (a - b) * (a - b);",s=exports.squaredDifference=(0,r.binaryKernelFunc)({opSnippet:n,packedOpSnippet:n}),i=exports.squaredDifferenceConfig={kernelName:e.SquaredDifference,backendName:"webgl",kernelFunc:s};
},{"@tensorflow/tfjs-core":"kSBl","../kernel_utils/kernel_funcs_utils":"ciwP"}],"Dxkl":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.staticRegexReplace=r,exports.staticRegexReplaceConfig=void 0;var e=require("@tensorflow/tfjs-core"),t=require("../kernel_utils/shared");function r(r){const{inputs:n,backend:a,attrs:s}=r,{x:i}=n;if("string"!==i.dtype)throw new Error("Input must be of datatype string");const o=a.readSync(i.dataId),c=e.backend_util.fromUint8ToStringArray(o),p=(0,t.staticRegexReplaceImplCPU)(c,"string",s);return a.makeTensorInfo(i.shape,"string",p)}const n=exports.staticRegexReplaceConfig={kernelName:e.StaticRegexReplace,backendName:"webgl",kernelFunc:r};
},{"@tensorflow/tfjs-core":"kSBl","../kernel_utils/shared":"cNPH"}],"hUPU":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.step=t,exports.stepConfig=void 0;var e=require("@tensorflow/tfjs-core"),r=require("../unaryop_gpu");function t({inputs:e,attrs:t,backend:n}){const{x:o}=e,s=r.CHECK_NAN_SNIPPET+`\n    return x > 0.0 ? 1.0 : float(${t.alpha});\n  `,p=new r.UnaryOpProgram(o.shape,s);return n.runWebGLProgram(p,[o],o.dtype)}const n=exports.stepConfig={kernelName:e.Step,backendName:"webgl",kernelFunc:t};
},{"@tensorflow/tfjs-core":"kSBl","../unaryop_gpu":"CK3x"}],"ovHx":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.StridedSliceProgram=void 0;var e=require("./shader_compiler");class t{constructor(t,s,r){this.variableNames=["x"],this.outputShape=r;const o=r.length,i=(0,e.getCoordsDataType)(r.length),d=(0,e.getCoordsDataType)(r.length);let n="";if(1===o)n="coords * strides + begin";else{let e=0;n=r.map((t,s)=>(e++,1===r.length?`coords * strides[${s}] + begin[${s}]`:`coords[${e-1}] * strides[${s}] + begin[${s}]`)).join(",")}this.userCode=`\n      ${i} begin = ${i}(${t});\n      ${i} strides = ${i}(${s});\n\n      void main() {\n        ${d} coords = getOutputCoords();\n        setOutput(getX(${n}));\n      }\n    `}}exports.StridedSliceProgram=t;
},{"./shader_compiler":"xhhc"}],"spAd":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.stridedSlice=n,exports.stridedSliceConfig=void 0;var e=require("@tensorflow/tfjs-core"),s=require("../kernel_utils/shared"),t=require("../strided_slice_gpu"),i=require("./Reshape"),r=require("./Slice");function n(n){const{inputs:a,backend:d,attrs:l}=n,{x:p}=a,{begin:c,end:o,strides:u,beginMask:h,endMask:f,ellipsisMask:k,newAxisMask:S,shrinkAxisMask:b}=l,{finalShapeSparse:g,finalShape:m,isIdentity:x,sliceDim0:I,isSimpleSlice:_,begin:y,end:M,strides:q}=e.slice_util.sliceInfo(p.shape,c,o,u,h,f,k,S,b);let v;if(x)v=(0,i.reshape)({inputs:{x:p},backend:d,attrs:{shape:m}});else if(I||_){e.util.assert(p.shape.length>=1,()=>`Input must have rank at least 1, got: ${p.shape.length}`);const s=e.slice_util.computeOutShape(y,M,q),t=(0,r.slice)({inputs:{x:p},backend:d,attrs:{begin:y,size:s}});v=(0,i.reshape)({inputs:{x:t},backend:d,attrs:{shape:m}}),d.disposeIntermediateTensorInfo(t)}else{if(d.shouldExecuteOnCPU([p])){const t=d.readSync(p.dataId),i=(0,e.buffer)(p.shape,p.dtype,t),r=(0,s.stridedSliceImplCPU)(g,i,q,y);v=d.makeTensorInfo(m,p.dtype,r.values)}else{const e=new t.StridedSliceProgram(y,q,g);v=d.runWebGLProgram(e,[p],p.dtype)}}const P=(0,i.reshape)({inputs:{x:v},backend:d,attrs:{shape:m}});return d.disposeIntermediateTensorInfo(v),P}const a=exports.stridedSliceConfig={kernelName:e.StridedSlice,backendName:"webgl",kernelFunc:n};
},{"@tensorflow/tfjs-core":"kSBl","../kernel_utils/shared":"cNPH","../strided_slice_gpu":"ovHx","./Reshape":"OCN8","./Slice":"i5TP"}],"XlJk":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.stringNGrams=t,exports.stringNGramsConfig=void 0;var e=require("@tensorflow/tfjs-core"),r=require("../kernel_utils/shared");function t(e){const{inputs:t,backend:s,attrs:a}=e,{separator:n,nGramWidths:i,leftPad:o,rightPad:d,padWidth:c,preserveShortSequences:l}=a,{data:p,dataSplits:g}=t,m=s.readSync(p.dataId),u=s.readSync(g.dataId),[f,h]=(0,r.stringNGramsImplCPU)(m,u,n,i,o,d,c,l);return[s.makeTensorInfo([f.length],"string",f),s.makeTensorInfo(g.shape,"int32",h)]}const s=exports.stringNGramsConfig={kernelName:e.StringNGrams,backendName:"webgl",kernelFunc:t};
},{"@tensorflow/tfjs-core":"kSBl","../kernel_utils/shared":"cNPH"}],"PlyH":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.stringSplit=r,exports.stringSplitConfig=void 0;var e=require("@tensorflow/tfjs-core"),t=require("../kernel_utils/shared");function r(e){const{inputs:r,backend:n,attrs:s}=e,{skipEmpty:i}=s,{input:o,delimiter:a}=r;if("string"!==o.dtype)throw new Error("Input must be of datatype string");if(1!==o.shape.length)throw new Error(`Input must be a vector, got shape: ${o.shape}`);if(0!==a.shape.length)throw new Error(`Delimiter must be a scalar, got shape: ${a.shape}`);const p=n.readSync(o.dataId),l=n.readSync(a.dataId)[0],[g,u,d]=(0,t.stringSplitImplCPU)(p,l,i),c=u.length;return[n.makeTensorInfo([c,2],"int32",g),n.makeTensorInfo([c],"string",u),n.makeTensorInfo([2],"int32",new Int32Array(d))]}const n=exports.stringSplitConfig={kernelName:e.StringSplit,backendName:"webgl",kernelFunc:r};
},{"@tensorflow/tfjs-core":"kSBl","../kernel_utils/shared":"cNPH"}],"bPQd":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.stringToHashBucketFast=r,exports.stringToHashBucketFastConfig=void 0;var t=require("@tensorflow/tfjs-core"),e=require("../kernel_utils/shared");function r(t){const{inputs:r,backend:s,attrs:n}=t,{numBuckets:o}=n,{input:a}=r;if("string"!==a.dtype)throw new Error("Input must be of datatype string");if(o<=0)throw new Error("Number of buckets must be at least 1");const u=s.readSync(a.dataId),i=(0,e.stringToHashBucketFastImplCPU)(u,o);return s.makeTensorInfo(a.shape,"int32",i)}const s=exports.stringToHashBucketFastConfig={kernelName:t.StringToHashBucketFast,backendName:"webgl",kernelFunc:r};
},{"@tensorflow/tfjs-core":"kSBl","../kernel_utils/shared":"cNPH"}],"akym":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.tanConfig=exports.tan=void 0;var e=require("@tensorflow/tfjs-core"),n=require("../kernel_utils/kernel_funcs_utils");const r="return tan(x);",t=exports.tan=(0,n.unaryKernelFunc)({opSnippet:r}),o=exports.tanConfig={kernelName:e.Tan,backendName:"webgl",kernelFunc:t};
},{"@tensorflow/tfjs-core":"kSBl","../kernel_utils/kernel_funcs_utils":"ciwP"}],"hn5V":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.tanhConfig=exports.tanh=void 0;var e=require("@tensorflow/tfjs-core"),n=require("../kernel_utils/kernel_funcs_utils");const r="\n  float e2x = exp(-2.0 * abs(x));\n  return sign(x) * (1.0 - e2x) / (1.0 + e2x);\n",t=exports.tanh=(0,n.unaryKernelFunc)({opSnippet:r}),o=exports.tanhConfig={kernelName:e.Tanh,backendName:"webgl",kernelFunc:t};
},{"@tensorflow/tfjs-core":"kSBl","../kernel_utils/kernel_funcs_utils":"ciwP"}],"UNcX":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.tensorScatterUpdate=r,exports.tensorScatterUpdateConfig=void 0;var e=require("@tensorflow/tfjs-core"),t=require("../scatter_gpu"),s=require("./Reshape");function r(r){const{inputs:a,backend:n,attrs:p}=r,{tensor:o,indices:i,updates:d}=a,{}=p,{sliceRank:c,numUpdates:u,sliceSize:h,strides:l,outputSize:f}=e.backend_util.calculateShapes(d,i,o.shape),k=[f/h,h];if(0===f)return n.makeTensorInfo(o.shape,i.dtype);const b=(0,s.reshape)({inputs:{x:i},backend:n,attrs:{shape:[u,c]}}),m=(0,s.reshape)({inputs:{x:d},backend:n,attrs:{shape:[u,h]}}),I=(0,s.reshape)({inputs:{x:o},backend:n,attrs:{shape:k}}),g=new t.ScatterProgram(u,c,b.shape.length,m.shape.length,l,k,!1,!0),x=n.runWebGLProgram(g,[m,b,I],I.dtype),S=(0,s.reshape)({inputs:{x:x},backend:n,attrs:{shape:o.shape}});return n.disposeIntermediateTensorInfo(b),n.disposeIntermediateTensorInfo(m),n.disposeIntermediateTensorInfo(I),n.disposeIntermediateTensorInfo(x),S}const a=exports.tensorScatterUpdateConfig={kernelName:e.TensorScatterUpdate,backendName:"webgl",kernelFunc:r};
},{"@tensorflow/tfjs-core":"kSBl","../scatter_gpu":"vOJf","./Reshape":"OCN8"}],"H2AH":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.TileProgram=void 0;var e=require("./shader_compiler");class r{constructor(r,s){this.variableNames=["A"];const o=new Array(r.length);for(let e=0;e<o.length;e++)o[e]=r[e]*s[e];this.outputShape=o,this.rank=o.length;const n=(0,e.getCoordsDataType)(this.rank),i=t(r);this.userCode=`\n      void main() {\n        ${n} resRC = getOutputCoords();\n        setOutput(getA(${i}));\n      }\n    `}}function t(e){const r=e.length;if(r>5)throw Error(`Tile for rank ${r} is not yet supported`);if(1===r)return`imod(resRC, ${e[0]})`;const t=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u"],s=[];for(let o=0;o<e.length;o++)s.push(`imod(${t[o]}, ${e[o]})`);return s.join()}exports.TileProgram=r;
},{"./shader_compiler":"xhhc"}],"u848":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.tile=n,exports.tileConfig=void 0;var e=require("@tensorflow/tfjs-core"),r=require("../kernel_utils/shared"),t=require("../tile_gpu");function n(n){const{inputs:s,backend:i,attrs:o}=n,{x:a}=s,{reps:l}=o;if("string"===a.dtype||a.shape.length>5){const t=i.readSync(a.dataId),n="string"===a.dtype?t.map(r=>e.util.decodeString(r)):t,s=(0,e.buffer)(a.shape,a.dtype,n),o=(0,r.tileImplCPU)(s,l);return i.makeTensorInfo(o.shape,o.dtype,o.values)}const p=new t.TileProgram(a.shape,l);return i.runWebGLProgram(p,[a],a.dtype)}const s=exports.tileConfig={kernelName:e.Tile,backendName:"webgl",kernelFunc:n};
},{"@tensorflow/tfjs-core":"kSBl","../kernel_utils/shared":"cNPH","../tile_gpu":"H2AH"}],"s9hX":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.SwapProgram=exports.MergeProgram=void 0;class e{constructor(e){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"negativeInf",type:"float"},{name:"dir",type:"int"},{name:"inc",type:"int"}],this.outputShape=e,this.userCode="\n       void main() {\n         ivec2 coords = getOutputCoords();\n         int batch = coords[0];\n         int elemIdx = coords[1];\n\n         // We compare elements pair-wise within a group of size 2 * inc.\n         // The comparing rule for each group alternates between ascending\n         // and descending. Within each group, we compare each pair at\n         // positions i and i+inc. To decide whether an element at position i\n         // is x0 or x1, we mod it by 2 * inc, if the result is smaller than\n         // inc, it is in the first half of the group, we denote it as x0,\n         // otherwise we denote it as x1.\n         // For example, as shown in the Bitonic top K paper referenced above,\n         // Figure5(a) shows that element[1] is in the\n         // second half of the group when group size is 2, but it is in the\n         // first half of the group when group size is 4.\n\n         bool isFirstInPair = imod(elemIdx, 2 * inc) < inc;\n         int i = isFirstInPair ? elemIdx : elemIdx - inc;\n\n         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));\n         int i1 = firstPass == 1 ? i + inc : int(getIndices(batch, i + inc));\n         float x0 = i0 < n ? getX(batch, i0) : negativeInf;\n         float x1 = i1 < n ? getX(batch, i1) : negativeInf;\n\n         // Denotes which direction indices are in (ascending or descending).\n         bool reverse = imod(elemIdx, 2 * dir) >= dir;\n         bool isGreater = x0 > x1 || (x0 == x1 && i1 > i0);\n         if (reverse == isGreater) { // Elements in opposite order of direction\n           int iTemp = i0;\n           i0 = i1;\n           i1 = iTemp;\n         }\n         if (isFirstInPair) {\n            setOutput(float(i0));\n         } else {\n            setOutput(float(i1));\n         }\n       }\n     "}}exports.SwapProgram=e;class n{constructor(e){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"k",type:"int"}],this.outputShape=e,this.userCode="\n    void main() {\n         // Takes max of indices (0, k), (1, k + 1), (2, k + 2) ...\n         ivec2 coords = getOutputCoords();\n         int batch = coords[0];\n         int elemIdx = coords[1];\n\n         // The output size is half of the previous size.\n         // If the previous sequence is | | | | _ _ _ _  | | | |  _ _ _ _ (k=4),\n         // we only need to output the indices at positions |, the indices at\n         // positions _ can be thrown away, see Figure5(b) After Phase 2\n         // (Merge phase) in the Bitonic Top K paper referenced above.\n         // For example, the paper shows we only need to output the orange bars.\n         // The output sequence should look like this | | | | | | | |.\n         // Because the sequence is halved, to map the output index back\n         // to the previous sequence to find the corresponding value,\n         // we need to double the index. When we double the index,\n         // we basically interpolate a position, so 2i looks like\n         // | _ | _ | _ | _ | _ | _ | _. We move the | to the first k position\n         // of each 2k positions by - elemIdx % k. E.g. for output at\n         // index 4,5,6,7, we want to get the corresponding element at\n         // original index 8,9,10,11, for output at index 8,9,10,11,\n         // we want to get the corresponding element at original index\n         // 16,17,18,19, so on and so forth.\n\n         int i = elemIdx < k ? elemIdx : (elemIdx * 2 - imod(elemIdx, k));\n         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));\n         int i1 = firstPass == 1 ? i + k : int(getIndices(batch, i + k));\n\n         float x0 = getX(batch, i0);\n         float x1 = i1 < n ? getX(batch, i1) : x0;\n\n         setOutput(x0 >= x1 ? float(i0) : float(i1));\n       }\n     "}}exports.MergeProgram=n;
},{}],"Chz9":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.topK=l,exports.topKConfig=void 0;var e=require("@tensorflow/tfjs-core"),t=require("../kernel_utils/shared"),n=require("../top_k_gpu"),r=require("./Fill"),s=require("./GatherV2"),a=require("./Reshape"),o=require("./Slice");function u(e,t){null!==t&&e.disposeIntermediateTensorInfo(t)}function i(e){let t=1;for(;t<e;)t*=2;return t}function l(l){const{inputs:p,backend:c,attrs:d}=l,{x:f}=p,{k:h,sorted:k}=d,b=(0,e.env)().getNumber("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD"),m=(0,e.env)().getNumber("TOPK_K_CPU_HANDOFF_THRESHOLD"),g=f.shape,_=g[g.length-1];if(c.shouldExecuteOnCPU([f])||_<b||h>m){const e=c.readSync(f.dataId),[n,r]=(0,t.topKImplCPU)(e,g,f.dtype,h,k);return[c.makeTensorInfo(n.shape,n.dtype,n.values),c.makeTensorInfo(r.shape,r.dtype,r.values)]}if(0===h)return g[g.length-1]=0,[c.makeTensorInfo(g,f.dtype,[]),c.makeTensorInfo(g,"int32",[])];if(1===_)return[f,(0,r.fill)({attrs:{shape:g,dtype:"int32",value:0},backend:c})];const I=c.texData.get(f.dataId),T=null!==I&&I.isPacked,x=T?c.unpackTensor(f):f,P=e.util.sizeFromShape(g)/_,N=(0,a.reshape)({inputs:{x:x},attrs:{shape:[P,_]},backend:c});T&&u(c,x);const v=i(h),F=i(_);let K=null;const O=()=>null===K?[N,N]:[N,K],S=(e,t,r)=>{const s=O(),a=new n.SwapProgram(r),o=[[_],[null===K?1:0],[Number.NEGATIVE_INFINITY],[e],[t]],i=K;K=c.runWebGLProgram(a,s,"int32",o),u(c,i)};for(let e=1;e<v;e*=2){const t=2*e;for(let n=e;n>=1;n/=2)S(t,n,[P,F])}for(let e=F;e>v;e/=2){const t=O(),r=new n.MergeProgram([P,e/2]),s=[[_],[null===K?1:0],[v]],a=K;K=c.runWebGLProgram(r,t,"int32",s),u(c,a);const o=v/2,i=2*o;for(let e=o;e>=1;e/=2)S(i,e,K.shape)}let q=K;K=(0,o.slice)({inputs:{x:K},backend:c,attrs:{begin:0,size:[P,h]}}),u(c,q);let y=(0,s.gatherV2)({inputs:{x:N,indices:K},backend:c,attrs:{axis:1,batchDims:1}});u(c,N);const D=g.slice(0,-1);D.push(h),q=K,K=(0,a.reshape)({inputs:{x:K},attrs:{shape:D},backend:c}),u(c,q);const C=y;return y=(0,a.reshape)({inputs:{x:y},attrs:{shape:D},backend:c}),u(c,C),[y,K]}const p=exports.topKConfig={kernelName:e.TopK,backendName:"webgl",kernelFunc:l};
},{"@tensorflow/tfjs-core":"kSBl","../kernel_utils/shared":"cNPH","../top_k_gpu":"s9hX","./Fill":"LGba","./GatherV2":"SjQ7","./Reshape":"OCN8","./Slice":"i5TP"}],"sALq":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.TransformProgram=void 0;class n{constructor(n,o,t,a,l,e){this.variableNames=["Image","Transforms"],this.outputShape=e;const r="nearest"===t?1:2;let i;switch(a){case"constant":i=1;break;case"reflect":i=2;break;case"wrap":i=3;break;case"nearest":i=4;break;default:i=1}this.userCode=`\n            float mapCoord(float outCoord, float len) {\n              float inCoord = outCoord;\n              if(${i} == 2) {\n                if (inCoord < 0.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz2 = 2.0 * len;\n                    if (inCoord < sz2) {\n                      inCoord = sz2 * float(int(float(-inCoord / sz2))) +\n                      inCoord;\n                    }\n                    inCoord = inCoord < -len ? inCoord + sz2 : -inCoord - 1.0;\n                  }\n                } else if (inCoord > len - 1.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz2 = 2.0 * len;\n                    inCoord -= sz2 * float(int(float(inCoord / sz2)));\n                    if (inCoord >= len) {\n                      inCoord = sz2 - inCoord - 1.0;\n                    }\n                  }\n                }\n                return clamp(inCoord, 0.0, len - 1.0);\n              } else if (${i} == 3) {\n                if (inCoord < 0.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz = len - 1.0;\n                    inCoord += len * (float(int(float(-inCoord / sz))) + 1.0);\n                  }\n                } else if (inCoord > len - 1.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz = len - 1.0;\n                    inCoord -= len * float(int(float(inCoord / sz)));\n                  }\n                }\n                return clamp(inCoord, 0.0, len - 1.0);\n              } else if (${i} == 4) {\n                return clamp(outCoord, 0.0, len - 1.0);\n              } else {\n                return outCoord;\n              }\n            }\n\n            float readWithFillValue(int batch, int coordY, int coordX,\n              int channel) {\n              float outputValue;\n              if (0 <= coordY && coordY < ${n} && 0 <= coordX && coordX < ${o}) {\n                  outputValue = getImage(batch, coordY, coordX, channel);\n              } else {\n                outputValue = float(${l});\n              }\n              return outputValue;\n            }\n\n            void main() {\n              ivec4 coords = getOutputCoords();\n              float outputValue;\n              int batch = coords[0];\n              int x = coords[2];\n              int y = coords[1];\n              int channel = coords[3];\n              float xf = float(x);\n              float yf = float(y);\n              float a1 = getTransforms(batch, 0);\n              float a2 = getTransforms(batch, 1);\n              float a3 = getTransforms(batch, 2);\n              float b1 = getTransforms(batch, 3);\n              float b2 = getTransforms(batch, 4);\n              float b3 = getTransforms(batch, 5);\n              float c1 = getTransforms(batch, 6);\n              float c2 = getTransforms(batch, 7);\n              float projection = c1 * xf + c2 * yf + 1.0;\n              if (projection == 0.0) {\n                outputValue = float(${l});\n              } else {\n                float inX = (a1 * xf + a2 * yf + a3) / projection;\n                float inY = (b1 * xf + b2 * yf + b3) / projection;\n                float mapX = mapCoord(inX, float(${o}));\n                float mapY = mapCoord(inY, float(${n}));\n\n                if (${r} == 1) {\n                  int coordY = int(round(mapY));\n                  int coordX = int(round(mapX));\n                  outputValue = readWithFillValue(batch, coordY, coordX,\n                    channel);\n                } else {\n                  float yFloor = floor(mapY);\n                  float xFloor = floor(mapX);\n                  float yCeil = yFloor + 1.0;\n                  float xCeil = xFloor + 1.0;\n                  float valueYFloor = (xCeil - mapX) *\n                  readWithFillValue(batch, int(yFloor), int(xFloor), channel) +\n                  (mapX - xFloor) *\n                  readWithFillValue(batch, int(yFloor), int(xCeil), channel);\n                  float valueYCeil = (xCeil - mapX) *\n                  readWithFillValue(batch, int(yCeil), int(xFloor), channel) +\n                  (mapX - xFloor) *\n                  readWithFillValue(batch, int(yCeil), int(xCeil), channel);\n                  outputValue = (yCeil - mapY) * valueYFloor +\n                  (mapY - yFloor) * valueYCeil;\n                }\n              }\n              setOutput(outputValue);\n            }\n        `}}exports.TransformProgram=n;
},{}],"DBVn":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.transform=o,exports.transformConfig=void 0;var r=require("@tensorflow/tfjs-core"),e=require("../transform_gpu");function o(r){const{inputs:o,backend:n,attrs:t}=r,{image:a,transforms:s}=o,{interpolation:f,fillMode:l,fillValue:u,outputShape:i}=t,[m,p,c,g]=a.shape,[d,b]=null!=i?i:[p,c],k=[m,d,b,g],x=new e.TransformProgram(p,c,f,l,u,k);return n.runWebGLProgram(x,[a,s],"float32")}const n=exports.transformConfig={kernelName:r.Transform,backendName:"webgl",kernelFunc:o};
},{"@tensorflow/tfjs-core":"kSBl","../transform_gpu":"sALq"}],"JvES":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.unique=o,exports.uniqueConfig=void 0;var e=require("@tensorflow/tfjs-core"),n=require("../kernel_utils/shared"),t=require("../webgl_util");function o(e){const{inputs:o,attrs:r,backend:u}=e,{axis:s}=r,{x:i}=o;(0,t.assertNotComplex)(i,"unique"),console.warn("WARNING: ","UI might be locked temporarily as data is being downloaded");const a=u.readSync(i.dataId),{outputValues:l,outputShape:d,indices:p}=(0,n.uniqueImplCPU)(a,s,i.shape,i.dtype);return[u.makeTensorInfo(d,i.dtype,l),u.makeTensorInfo([p.length],"int32",p)]}const r=exports.uniqueConfig={kernelName:e.Unique,backendName:"webgl",kernelFunc:o};
},{"@tensorflow/tfjs-core":"kSBl","../kernel_utils/shared":"cNPH","../webgl_util":"u1ML"}],"qHku":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.unpack=t,exports.unpackConfig=void 0;var e=require("@tensorflow/tfjs-core"),n=require("./Reshape"),s=require("./Slice");function t(e){const{inputs:t,backend:r,attrs:a}=e,{value:o}=t;let{axis:c}=a;c<0&&(c+=o.shape.length);const p=o,i=p.shape.length,l=o.shape[c],u=new Array(i-1);let h=0;for(let n=0;n<i;n++)n!==c&&(u[h++]=p.shape[n]);const f=[],k=new Array(i).fill(0),d=p.shape.slice();d[c]=1;const b=new Array(l);for(let g=0;g<b.length;g++){k[c]=g;const e=(0,s.slice)({inputs:{x:p},backend:r,attrs:{begin:k,size:d}}),t=(0,n.reshape)({inputs:{x:e},backend:r,attrs:{shape:u}});b[g]=t,f.push(e)}return f.forEach(e=>r.disposeIntermediateTensorInfo(e)),b}const r=exports.unpackConfig={kernelName:e.Unpack,backendName:"webgl",kernelFunc:t};
},{"@tensorflow/tfjs-core":"kSBl","./Reshape":"OCN8","./Slice":"i5TP"}],"pSCY":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.SegmentOpProgram=void 0;class n{constructor(n,e){this.variableNames=["x","segmentIds"];const t=n.windowSize,i=n.batchSize,a=n.inSize,d=n.numSegments,g=d*Math.ceil(a/t);this.outputShape=[i,g];const I=4*Math.floor(t/4),l=t%4,u="\n        sumValue += dot(values, segFilter);\n    ";let r="";a%t>0&&(r=`\n        if (inIdx < 0 || inIdx >= ${a}) {\n          return initializationValue;\n        }\n      `);let c="";a%t>0&&(c=`\n        if (inIdx < 0 || inIdx >= ${a}) {\n          return -1.0;\n        }\n      `),this.userCode=`\n      const float initializationValue = 0.0;\n\n      float getValue(int batch, int inIdx) {\n        ${r}\n        return getX(batch, inIdx);\n      }\n\n      float getSegmentIdAtIndex(int inIdx) {\n        ${c}\n        return getSegmentIds(inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = int(floor(float(outIdx) / float(\n          ${d})) * float(${t}));\n        int currentSeg = int(mod(float(outIdx), float(${d})));\n\n        float sumValue = 0.0;\n\n        for (int i = 0; i < ${I}; i += 4) {\n          int inIdx = inOffset + i;\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 3)) == currentSeg ? 1 : 0\n          );\n\n          ${u}\n        }\n\n        int inIdx = inOffset + ${I};\n        if (${1===l}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            initializationValue,\n            initializationValue,\n            initializationValue\n          );\n\n          int inIdxSeg = int(getSegmentIdAtIndex(inIdx));\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            0,\n            0,\n            0\n          );\n\n          ${u}\n        } else if (${2===l}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            initializationValue,\n            initializationValue\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n              0,\n              0\n          );\n\n          ${u}\n        } else if (${3===l}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            initializationValue\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,\n            0\n          );\n\n          ${u}\n        }\n        setOutput(sumValue);\n      }\n    `}}exports.SegmentOpProgram=n;
},{}],"Se2T":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.unsortedSegmentSum=a,exports.unsortedSegmentSumConfig=void 0;var e=require("@tensorflow/tfjs-core"),t=require("../segment_gpu"),n=require("./Range"),s=require("./Reshape"),r=require("./Tile"),u=require("./Transpose");function a(a){const{inputs:p,backend:o,attrs:i}=a,{x:m,segmentIds:c}=p,{numSegments:d}=i,l=m.shape.length,g=[];let h=0;const S=e.backend_util.getAxesPermutation([h],l);let b=m;null!=S&&(b=(0,u.transpose)({inputs:{x:m},backend:o,attrs:{perm:S}}),g.push(b),h=e.backend_util.getInnerMostAxes(1,l)[0]);const k=e.backend_util.segment_util.computeOutShape(b.shape,h,d),x=e.util.sizeFromShape([b.shape[h]]),f=(0,s.reshape)({inputs:{x:b},backend:o,attrs:{shape:[-1,x]}});g.push(f);const _=(0,e.sumOutType)(m.dtype),q=(s,u,a,p,i)=>{const m=s.shape[0],c=s.shape[1],d=e.backend_util.segment_util.segOpComputeOptimalWindowSize(c,i),l={windowSize:d,inSize:c,batchSize:m,numSegments:i},h=new t.SegmentOpProgram(l,u),S=o.compileAndRun(h,[s,a],p);if(g.push(S),S.shape[1]===i)return S;const b=(0,n.range)({backend:o,attrs:{start:0,stop:i,step:1,dtype:"float32"}}),k=(0,r.tile)({inputs:{x:b},backend:o,attrs:{reps:[c/d]}});return g.push(b),g.push(k),q(S,u,k,p,i)},w=q(f,"unsortedSegmentSum",c,_,d),O=(0,s.reshape)({inputs:{x:w},backend:o,attrs:{shape:k}});let z=O;if(null!=S){g.push(O);const t=e.backend_util.getUndoAxesPermutation(S);z=(0,u.transpose)({inputs:{x:z},backend:o,attrs:{perm:t}})}return g.forEach(e=>o.disposeIntermediateTensorInfo(e)),z}const p=exports.unsortedSegmentSumConfig={kernelName:e.UnsortedSegmentSum,backendName:"webgl",kernelFunc:a};
},{"@tensorflow/tfjs-core":"kSBl","../segment_gpu":"pSCY","./Range":"M4RM","./Reshape":"OCN8","./Tile":"u848","./Transpose":"ukag"}],"Em4V":[function(require,module,exports) {
"use strict";var e=require("@tensorflow/tfjs-core"),r=require("./kernels/_FusedMatMul"),i=require("./kernels/Abs"),n=require("./kernels/Acos"),o=require("./kernels/Acosh"),s=require("./kernels/Add"),l=require("./kernels/AddN"),u=require("./kernels/All"),g=require("./kernels/Any"),a=require("./kernels/ArgMax"),f=require("./kernels/ArgMin"),C=require("./kernels/Asin"),k=require("./kernels/Asinh"),q=require("./kernels/Atan"),t=require("./kernels/Atan2"),p=require("./kernels/Atanh"),c=require("./kernels/AvgPool"),d=require("./kernels/AvgPool3D"),m=require("./kernels/AvgPool3DGrad"),S=require("./kernels/AvgPoolGrad"),h=require("./kernels/BatchMatMul"),D=require("./kernels/BatchNorm"),v=require("./kernels/BatchToSpaceND"),N=require("./kernels/Bincount"),x=require("./kernels/BitwiseAnd"),R=require("./kernels/BroadcastArgs"),M=require("./kernels/Cast"),A=require("./kernels/Ceil"),B=require("./kernels/ClipByValue"),P=require("./kernels/Complex"),T=require("./kernels/ComplexAbs"),F=require("./kernels/Concat"),G=require("./kernels/Conv2D"),L=require("./kernels/Conv2DBackpropFilter"),V=require("./kernels/Conv2DBackpropInput"),b=require("./kernels/Conv3D"),E=require("./kernels/Conv3DBackpropFilterV2"),w=require("./kernels/Conv3DBackpropInputV2"),I=require("./kernels/Cos"),y=require("./kernels/Cosh"),z=require("./kernels/CropAndResize"),O=require("./kernels/Cumprod"),U=require("./kernels/Cumsum"),H=require("./kernels/DenseBincount"),W=require("./kernels/DepthToSpace"),K=require("./kernels/DepthwiseConv2dNative"),_=require("./kernels/DepthwiseConv2dNativeBackpropFilter"),j=require("./kernels/DepthwiseConv2dNativeBackpropInput"),Z=require("./kernels/Diag"),J=require("./kernels/Dilation2D"),Q=require("./kernels/Einsum"),X=require("./kernels/Elu"),Y=require("./kernels/EluGrad"),$=require("./kernels/Equal"),ee=require("./kernels/Erf"),re=require("./kernels/Exp"),ie=require("./kernels/ExpandDims"),ne=require("./kernels/Expm1"),oe=require("./kernels/FFT"),se=require("./kernels/Fill"),le=require("./kernels/FlipLeftRight"),ue=require("./kernels/Floor"),ge=require("./kernels/FloorDiv"),ae=require("./kernels/FromPixels"),fe=require("./kernels/FusedConv2D"),Ce=require("./kernels/FusedDepthwiseConv2D"),ke=require("./kernels/GatherNd"),qe=require("./kernels/GatherV2"),te=require("./kernels/Greater"),pe=require("./kernels/GreaterEqual"),ce=require("./kernels/Identity"),de=require("./kernels/IFFT"),me=require("./kernels/Imag"),Se=require("./kernels/IsFinite"),he=require("./kernels/IsInf"),De=require("./kernels/IsNaN"),ve=require("./kernels/LeakyRelu"),Ne=require("./kernels/Less"),xe=require("./kernels/LessEqual"),Re=require("./kernels/LinSpace"),Me=require("./kernels/Log"),Ae=require("./kernels/Log1p"),Be=require("./kernels/LogicalAnd"),Pe=require("./kernels/LogicalNot"),Te=require("./kernels/LogicalOr"),Fe=require("./kernels/LRN"),Ge=require("./kernels/LRNGrad"),Le=require("./kernels/Max"),Ve=require("./kernels/Maximum"),be=require("./kernels/MaxPool"),Ee=require("./kernels/MaxPool3D"),we=require("./kernels/MaxPool3DGrad"),Ie=require("./kernels/MaxPoolGrad"),ye=require("./kernels/MaxPoolWithArgmax"),ze=require("./kernels/Mean"),Oe=require("./kernels/Min"),Ue=require("./kernels/Minimum"),He=require("./kernels/MirrorPad"),We=require("./kernels/Mod"),Ke=require("./kernels/Multinomial"),_e=require("./kernels/Multiply"),je=require("./kernels/Neg"),Ze=require("./kernels/NonMaxSuppressionV3"),Je=require("./kernels/NonMaxSuppressionV4"),Qe=require("./kernels/NonMaxSuppressionV5"),Xe=require("./kernels/NotEqual"),Ye=require("./kernels/OneHot"),$e=require("./kernels/OnesLike"),er=require("./kernels/Pack"),rr=require("./kernels/PadV2"),ir=require("./kernels/Pow"),nr=require("./kernels/Prelu"),or=require("./kernels/Prod"),sr=require("./kernels/RaggedGather"),lr=require("./kernels/RaggedRange"),ur=require("./kernels/RaggedTensorToTensor"),gr=require("./kernels/Range"),ar=require("./kernels/Real"),fr=require("./kernels/RealDiv"),Cr=require("./kernels/Reciprocal"),kr=require("./kernels/Relu"),qr=require("./kernels/Relu6"),tr=require("./kernels/Reshape"),pr=require("./kernels/ResizeBilinear"),cr=require("./kernels/ResizeBilinearGrad"),dr=require("./kernels/ResizeNearestNeighbor"),mr=require("./kernels/ResizeNearestNeighborGrad"),Sr=require("./kernels/Reverse"),hr=require("./kernels/RotateWithOffset"),Dr=require("./kernels/Round"),vr=require("./kernels/Rsqrt"),Nr=require("./kernels/ScatterNd"),xr=require("./kernels/SearchSorted"),Rr=require("./kernels/Select"),Mr=require("./kernels/Selu"),Ar=require("./kernels/Sigmoid"),Br=require("./kernels/Sign"),Pr=require("./kernels/Sin"),Tr=require("./kernels/Sinh"),Fr=require("./kernels/Slice"),Gr=require("./kernels/Softmax"),Lr=require("./kernels/Softplus"),Vr=require("./kernels/SpaceToBatchND"),br=require("./kernels/SparseFillEmptyRows"),Er=require("./kernels/SparseReshape"),wr=require("./kernels/SparseSegmentMean"),Ir=require("./kernels/SparseSegmentSum"),yr=require("./kernels/SparseToDense"),zr=require("./kernels/SplitV"),Or=require("./kernels/Sqrt"),Ur=require("./kernels/Square"),Hr=require("./kernels/SquaredDifference"),Wr=require("./kernels/StaticRegexReplace"),Kr=require("./kernels/Step"),_r=require("./kernels/StridedSlice"),jr=require("./kernels/StringNGrams"),Zr=require("./kernels/StringSplit"),Jr=require("./kernels/StringToHashBucketFast"),Qr=require("./kernels/Sub"),Xr=require("./kernels/Sum"),Yr=require("./kernels/Tan"),$r=require("./kernels/Tanh"),ei=require("./kernels/TensorScatterUpdate"),ri=require("./kernels/Tile"),ii=require("./kernels/TopK"),ni=require("./kernels/Transform"),oi=require("./kernels/Transpose"),si=require("./kernels/Unique"),li=require("./kernels/Unpack"),ui=require("./kernels/UnsortedSegmentSum"),gi=require("./kernels/ZerosLike");const ai=[r._fusedMatMulConfig,i.absConfig,n.acosConfig,o.acoshConfig,s.addConfig,l.addNConfig,u.allConfig,g.anyConfig,a.argMaxConfig,f.argMinConfig,C.asinConfig,k.asinhConfig,q.atanConfig,t.atan2Config,p.atanhConfig,c.avgPoolConfig,d.avgPool3DConfig,m.avgPool3DGradConfig,S.avgPoolGradConfig,h.batchMatMulConfig,D.batchNormConfig,v.batchToSpaceNDConfig,N.bincountConfig,x.bitwiseAndConfig,R.broadcastArgsConfig,M.castConfig,A.ceilConfig,B.clipByValueConfig,P.complexConfig,T.complexAbsConfig,F.concatConfig,G.conv2DConfig,L.conv2DBackpropFilterConfig,V.conv2DBackpropInputConfig,b.conv3DConfig,E.conv3DBackpropFilterV2Config,w.conv3DBackpropInputConfig,I.cosConfig,y.coshConfig,z.cropAndResizeConfig,O.cumprodConfig,U.cumsumConfig,H.denseBincountConfig,W.depthToSpaceConfig,K.depthwiseConv2dNativeConfig,_.depthwiseConv2dNativeBackpropFilterConfig,j.depthwiseConv2dNativeBackpropInputConfig,Z.diagConfig,J.dilation2DConfig,Q.einsumConfig,X.eluConfig,Y.eluGradConfig,$.equalConfig,ee.erfConfig,re.expConfig,ie.expandDimsConfig,ne.expm1Config,oe.fftConfig,se.fillConfig,le.flipLeftRightConfig,ue.floorConfig,ge.floorDivConfig,ae.fromPixelsConfig,fe.fusedConv2DConfig,Ce.fusedDepthwiseConv2DConfig,ke.gatherNdConfig,qe.gatherV2Config,te.greaterConfig,pe.greaterEqualConfig,ce.identityConfig,de.ifftConfig,me.imagConfig,Se.isFiniteConfig,he.isInfConfig,De.isNaNConfig,ve.leakyReluConfig,Ne.lessConfig,xe.lessEqualConfig,Re.linSpaceConfig,Me.logConfig,Ae.log1pConfig,Be.logicalAndConfig,Pe.logicalNotConfig,Te.logicalOrConfig,Fe.LRNConfig,Ge.LRNGradConfig,Le.maxConfig,Ve.maximumConfig,be.maxPoolConfig,Ee.maxPool3DConfig,we.maxPool3DGradConfig,Ie.maxPoolGradConfig,ye.maxPoolWithArgmaxConfig,ze.meanConfig,Oe.minConfig,Ue.minimumConfig,He.mirrorPadConfig,We.modConfig,Ke.multinomialConfig,_e.multiplyConfig,je.negConfig,Ze.nonMaxSuppressionV3Config,Je.nonMaxSuppressionV4Config,Qe.nonMaxSuppressionV5Config,Xe.notEqualConfig,Ye.oneHotConfig,$e.onesLikeConfig,er.packConfig,rr.padV2Config,ir.powConfig,nr.preluConfig,or.prodConfig,sr.raggedGatherConfig,lr.raggedRangeConfig,ur.raggedTensorToTensorConfig,gr.rangeConfig,ar.realConfig,fr.realDivConfig,Cr.reciprocalConfig,kr.reluConfig,qr.relu6Config,tr.reshapeConfig,pr.resizeBilinearConfig,cr.resizeBilinearGradConfig,dr.resizeNearestNeighborConfig,mr.resizeNearestNeighborGradConfig,Sr.reverseConfig,hr.rotateWithOffsetConfig,Dr.roundConfig,vr.rsqrtConfig,Nr.scatterNdConfig,xr.searchSortedConfig,Rr.selectConfig,Mr.seluConfig,Ar.sigmoidConfig,Br.signConfig,Pr.sinConfig,Tr.sinhConfig,Fr.sliceConfig,Gr.softmaxConfig,Lr.softplusConfig,Vr.spaceToBatchNDConfig,br.sparseFillEmptyRowsConfig,Er.sparseReshapeConfig,wr.sparseSegmentMeanConfig,Ir.sparseSegmentSumConfig,yr.sparseToDenseConfig,zr.splitVConfig,Or.sqrtConfig,Ur.squareConfig,Hr.squaredDifferenceConfig,Wr.staticRegexReplaceConfig,Kr.stepConfig,_r.stridedSliceConfig,jr.stringNGramsConfig,Zr.stringSplitConfig,Jr.stringToHashBucketFastConfig,Qr.subConfig,Xr.sumConfig,Yr.tanConfig,$r.tanhConfig,ei.tensorScatterUpdateConfig,ri.tileConfig,ii.topKConfig,ni.transformConfig,oi.transposeConfig,si.uniqueConfig,li.unpackConfig,ui.unsortedSegmentSumConfig,gi.zerosLikeConfig];for(const fi of ai)(0,e.registerKernel)(fi);
},{"@tensorflow/tfjs-core":"kSBl","./kernels/_FusedMatMul":"QEU7","./kernels/Abs":"ovwb","./kernels/Acos":"Olb2","./kernels/Acosh":"wCgD","./kernels/Add":"lyYz","./kernels/AddN":"SS4q","./kernels/All":"JMnO","./kernels/Any":"KErF","./kernels/ArgMax":"x2EH","./kernels/ArgMin":"hkwZ","./kernels/Asin":"OFJK","./kernels/Asinh":"Z5zC","./kernels/Atan":"OiG7","./kernels/Atan2":"nymv","./kernels/Atanh":"vHhq","./kernels/AvgPool":"x8sT","./kernels/AvgPool3D":"rMW3","./kernels/AvgPool3DGrad":"rSf2","./kernels/AvgPoolGrad":"GujH","./kernels/BatchMatMul":"oT54","./kernels/BatchNorm":"g2b2","./kernels/BatchToSpaceND":"Tq84","./kernels/Bincount":"ZZuu","./kernels/BitwiseAnd":"uEw3","./kernels/BroadcastArgs":"imIn","./kernels/Cast":"Yp2K","./kernels/Ceil":"RdSo","./kernels/ClipByValue":"uqpD","./kernels/Complex":"BU0Z","./kernels/ComplexAbs":"fzhf","./kernels/Concat":"sjik","./kernels/Conv2D":"UXwB","./kernels/Conv2DBackpropFilter":"LTFn","./kernels/Conv2DBackpropInput":"x6Y6","./kernels/Conv3D":"oJAB","./kernels/Conv3DBackpropFilterV2":"O5Li","./kernels/Conv3DBackpropInputV2":"CNdb","./kernels/Cos":"mMLU","./kernels/Cosh":"GsRh","./kernels/CropAndResize":"mjLq","./kernels/Cumprod":"eLGh","./kernels/Cumsum":"DR3A","./kernels/DenseBincount":"M9Zz","./kernels/DepthToSpace":"xZ5c","./kernels/DepthwiseConv2dNative":"hBFT","./kernels/DepthwiseConv2dNativeBackpropFilter":"OcXt","./kernels/DepthwiseConv2dNativeBackpropInput":"BDt9","./kernels/Diag":"FBsW","./kernels/Dilation2D":"X8vo","./kernels/Einsum":"q6qu","./kernels/Elu":"pPXB","./kernels/EluGrad":"Oi5K","./kernels/Equal":"CINd","./kernels/Erf":"Ksgq","./kernels/Exp":"zY0s","./kernels/ExpandDims":"oL99","./kernels/Expm1":"VaYT","./kernels/FFT":"Kmz9","./kernels/Fill":"LGba","./kernels/FlipLeftRight":"gC7C","./kernels/Floor":"SsfV","./kernels/FloorDiv":"UMGZ","./kernels/FromPixels":"ryYF","./kernels/FusedConv2D":"wsrZ","./kernels/FusedDepthwiseConv2D":"FsyW","./kernels/GatherNd":"DXdr","./kernels/GatherV2":"SjQ7","./kernels/Greater":"mJSN","./kernels/GreaterEqual":"slmh","./kernels/Identity":"LUQG","./kernels/IFFT":"fOWs","./kernels/Imag":"uHuu","./kernels/IsFinite":"ZxhQ","./kernels/IsInf":"MgGt","./kernels/IsNaN":"q4GM","./kernels/LeakyRelu":"kZ3p","./kernels/Less":"ddK3","./kernels/LessEqual":"Pgrg","./kernels/LinSpace":"DW7C","./kernels/Log":"QMgc","./kernels/Log1p":"cToW","./kernels/LogicalAnd":"bfnB","./kernels/LogicalNot":"crq9","./kernels/LogicalOr":"QPdQ","./kernels/LRN":"LYtN","./kernels/LRNGrad":"axL9","./kernels/Max":"Scv7","./kernels/Maximum":"G2Br","./kernels/MaxPool":"c3Fl","./kernels/MaxPool3D":"qMOV","./kernels/MaxPool3DGrad":"RXwg","./kernels/MaxPoolGrad":"TmIQ","./kernels/MaxPoolWithArgmax":"TNru","./kernels/Mean":"QecZ","./kernels/Min":"X4RS","./kernels/Minimum":"ew2v","./kernels/MirrorPad":"vzVL","./kernels/Mod":"C4Ln","./kernels/Multinomial":"YFUH","./kernels/Multiply":"xWNx","./kernels/Neg":"DwHV","./kernels/NonMaxSuppressionV3":"qOiR","./kernels/NonMaxSuppressionV4":"MHTf","./kernels/NonMaxSuppressionV5":"AzqR","./kernels/NotEqual":"Fgvd","./kernels/OneHot":"qyTz","./kernels/OnesLike":"NxrP","./kernels/Pack":"KYEF","./kernels/PadV2":"CzrI","./kernels/Pow":"i8M0","./kernels/Prelu":"wxXh","./kernels/Prod":"RmdB","./kernels/RaggedGather":"wYNM","./kernels/RaggedRange":"zCtT","./kernels/RaggedTensorToTensor":"bgOI","./kernels/Range":"M4RM","./kernels/Real":"Jbfj","./kernels/RealDiv":"URW8","./kernels/Reciprocal":"GRla","./kernels/Relu":"VrOt","./kernels/Relu6":"xsDV","./kernels/Reshape":"OCN8","./kernels/ResizeBilinear":"zgo7","./kernels/ResizeBilinearGrad":"KZl4","./kernels/ResizeNearestNeighbor":"acQQ","./kernels/ResizeNearestNeighborGrad":"hJ6K","./kernels/Reverse":"yvk0","./kernels/RotateWithOffset":"voJu","./kernels/Round":"rl0C","./kernels/Rsqrt":"YW4p","./kernels/ScatterNd":"over","./kernels/SearchSorted":"JeaS","./kernels/Select":"VO4x","./kernels/Selu":"iGiQ","./kernels/Sigmoid":"Xsk6","./kernels/Sign":"eg93","./kernels/Sin":"XVYV","./kernels/Sinh":"mBz3","./kernels/Slice":"i5TP","./kernels/Softmax":"GaSh","./kernels/Softplus":"ZBTw","./kernels/SpaceToBatchND":"ZGig","./kernels/SparseFillEmptyRows":"eOf8","./kernels/SparseReshape":"kviu","./kernels/SparseSegmentMean":"fkXI","./kernels/SparseSegmentSum":"p9WO","./kernels/SparseToDense":"orjd","./kernels/SplitV":"eg0P","./kernels/Sqrt":"XK1L","./kernels/Square":"ELIZ","./kernels/SquaredDifference":"fP4n","./kernels/StaticRegexReplace":"Dxkl","./kernels/Step":"hUPU","./kernels/StridedSlice":"spAd","./kernels/StringNGrams":"XlJk","./kernels/StringSplit":"PlyH","./kernels/StringToHashBucketFast":"bPQd","./kernels/Sub":"jvgb","./kernels/Sum":"FqPw","./kernels/Tan":"akym","./kernels/Tanh":"hn5V","./kernels/TensorScatterUpdate":"UNcX","./kernels/Tile":"u848","./kernels/TopK":"Chz9","./kernels/Transform":"DBVn","./kernels/Transpose":"ukag","./kernels/Unique":"JvES","./kernels/Unpack":"qHku","./kernels/UnsortedSegmentSum":"Se2T","./kernels/ZerosLike":"Rmax"}],"gNVZ":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0});var e=require("./base");Object.keys(e).forEach(function(r){"default"!==r&&"__esModule"!==r&&(r in exports&&exports[r]===e[r]||Object.defineProperty(exports,r,{enumerable:!0,get:function(){return e[r]}}))}),require("./register_all_kernels");
},{"./base":"We8e","./register_all_kernels":"Em4V"}],"foZc":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:!0});var e={version:!0,data:!0};exports.version=exports.data=void 0;var r=require("@tensorflow/tfjs-core");Object.keys(r).forEach(function(t){"default"!==t&&"__esModule"!==t&&(Object.prototype.hasOwnProperty.call(e,t)||t in exports&&exports[t]===r[t]||Object.defineProperty(exports,t,{enumerable:!0,get:function(){return r[t]}}))}),require("@tensorflow/tfjs-core/dist/register_all_gradients"),require("@tensorflow/tfjs-core/dist/public/chained_ops/register_all_chained_ops");var t=require("@tensorflow/tfjs-layers");Object.keys(t).forEach(function(r){"default"!==r&&"__esModule"!==r&&(Object.prototype.hasOwnProperty.call(e,r)||r in exports&&exports[r]===t[r]||Object.defineProperty(exports,r,{enumerable:!0,get:function(){return t[r]}}))});var o=require("@tensorflow/tfjs-converter");Object.keys(o).forEach(function(r){"default"!==r&&"__esModule"!==r&&(Object.prototype.hasOwnProperty.call(e,r)||r in exports&&exports[r]===o[r]||Object.defineProperty(exports,r,{enumerable:!0,get:function(){return o[r]}}))});var n=i(require("@tensorflow/tfjs-data")),s=n;exports.data=n;var a=require("@tensorflow/tfjs-backend-cpu");Object.keys(a).forEach(function(r){"default"!==r&&"__esModule"!==r&&(Object.prototype.hasOwnProperty.call(e,r)||r in exports&&exports[r]===a[r]||Object.defineProperty(exports,r,{enumerable:!0,get:function(){return a[r]}}))});var c=require("@tensorflow/tfjs-backend-webgl");Object.keys(c).forEach(function(r){"default"!==r&&"__esModule"!==r&&(Object.prototype.hasOwnProperty.call(e,r)||r in exports&&exports[r]===c[r]||Object.defineProperty(exports,r,{enumerable:!0,get:function(){return c[r]}}))});var f=require("./version");function i(e,r){if("function"==typeof WeakMap)var t=new WeakMap,o=new WeakMap;return(i=function(e,r){if(!r&&e&&e.__esModule)return e;var n,s,a={__proto__:null,default:e};if(null===e||"object"!=typeof e&&"function"!=typeof e)return a;if(n=r?o:t){if(n.has(e))return n.get(e);n.set(e,a)}for(const t in e)"default"!==t&&{}.hasOwnProperty.call(e,t)&&((s=(n=Object.defineProperty)&&Object.getOwnPropertyDescriptor(e,t))&&(s.get||s.set)?n(a,t,s):a[t]=e[t]);return a})(e,r)}const u=exports.version={"tfjs-core":r.version_core,"tfjs-backend-cpu":a.version_cpu,"tfjs-backend-webgl":c.version_webgl,"tfjs-data":n.version_data,"tfjs-layers":t.version_layers,"tfjs-converter":o.version_converter,tfjs:f.version};
},{"@tensorflow/tfjs-core":"kSBl","@tensorflow/tfjs-core/dist/register_all_gradients":"qJ5u","@tensorflow/tfjs-core/dist/public/chained_ops/register_all_chained_ops":"BFpO","@tensorflow/tfjs-layers":"lHR2","@tensorflow/tfjs-converter":"Mtvo","@tensorflow/tfjs-data":"DcRz","@tensorflow/tfjs-backend-cpu":"sqr6","@tensorflow/tfjs-backend-webgl":"gNVZ","./version":"KPnh"}],"FSNs":[function(require,module,exports) {
"use strict";var e=r(require("@tensorflow/tfjs"));function r(e,n){if("function"==typeof WeakMap)var t=new WeakMap,o=new WeakMap;return(r=function(e,r){if(!r&&e&&e.__esModule)return e;var n,i,a={__proto__:null,default:e};if(null===e||"object"!=typeof e&&"function"!=typeof e)return a;if(n=r?o:t){if(n.has(e))return n.get(e);n.set(e,a)}for(const t in e)"default"!==t&&{}.hasOwnProperty.call(e,t)&&((i=(n=Object.defineProperty)&&Object.getOwnPropertyDescriptor(e,t))&&(i.get||i.set)?n(a,t,i):a[t]=e[t]);return a})(e,n)}function n(){var e,r,o="function"==typeof Symbol?Symbol:{},i=o.iterator||"@@iterator",a=o.toStringTag||"@@toStringTag";function c(n,o,i,a){var c=o&&o.prototype instanceof s?o:s,f=Object.create(c.prototype);return t(f,"_invoke",function(n,t,o){var i,a,c,s=0,f=o||[],l=!1,p={p:0,n:0,v:e,a:d,f:d.bind(e,4),d:function(r,n){return i=r,a=0,c=e,p.n=n,u}};function d(n,t){for(a=n,c=t,r=0;!l&&s&&!o&&r<f.length;r++){var o,i=f[r],d=p.p,v=i[2];n>3?(o=v===t)&&(c=i[(a=i[4])?5:(a=3,3)],i[4]=i[5]=e):i[0]<=d&&((o=n<2&&d<i[1])?(a=0,p.v=t,p.n=i[1]):d<v&&(o=n<3||i[0]>t||t>v)&&(i[4]=n,i[5]=t,p.n=v,a=0))}if(o||n>1)return u;throw l=!0,t}return function(o,f,v){if(s>1)throw TypeError("Generator is already running");for(l&&1===f&&d(f,v),a=f,c=v;(r=a<2?e:c)||!l;){i||(a?a<3?(a>1&&(p.n=-1),d(a,c)):p.n=c:p.v=c);try{if(s=2,i){if(a||(o="next"),r=i[o]){if(!(r=r.call(i,c)))throw TypeError("iterator result is not an object");if(!r.done)return r;c=r.value,a<2&&(a=0)}else 1===a&&(r=i.return)&&r.call(i),a<2&&(c=TypeError("The iterator does not provide a '"+o+"' method"),a=1);i=e}else if((r=(l=p.n<0)?c:n.call(t,p))!==u)break}catch(r){i=e,a=1,c=r}finally{s=1}}return{value:r,done:l}}}(n,i,a),!0),f}var u={};function s(){}function f(){}function l(){}r=Object.getPrototypeOf;var p=[][i]?r(r([][i]())):(t(r={},i,function(){return this}),r),d=l.prototype=s.prototype=Object.create(p);function v(e){return Object.setPrototypeOf?Object.setPrototypeOf(e,l):(e.__proto__=l,t(e,a,"GeneratorFunction")),e.prototype=Object.create(d),e}return f.prototype=l,t(d,"constructor",l),t(l,"constructor",f),f.displayName="GeneratorFunction",t(l,a,"GeneratorFunction"),t(d),t(d,a,"Generator"),t(d,i,function(){return this}),t(d,"toString",function(){return"[object Generator]"}),(n=function(){return{w:c,m:v}})()}function t(e,r,n,o){var i=Object.defineProperty;try{i({},"",{})}catch(e){i=0}(t=function(e,r,n,o){if(r)i?i(e,r,{value:n,enumerable:!o,configurable:!o,writable:!o}):e[r]=n;else{function a(r,n){t(e,r,function(e){return this._invoke(r,n,e)})}a("next",0),a("throw",1),a("return",2)}})(e,r,n,o)}function o(e,r,n,t,o,i,a){try{var c=e[i](a),u=c.value}catch(e){return void n(e)}c.done?r(u):Promise.resolve(u).then(t,o)}function i(e){return function(){var r=this,n=arguments;return new Promise(function(t,i){var a=e.apply(r,n);function c(e){o(a,t,i,c,u,"next",e)}function u(e){o(a,t,i,c,u,"throw",e)}c(void 0)})}}var a=!0,c=!1;function u(e){var r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null;a&&console.log("[BACKGROUND] ".concat(e),r)}function s(e,r){a&&console.error("[BACKGROUND ERROR] ".concat(e),r)}u("Service worker started");var f=null,l=null;function p(){return d.apply(this,arguments)}function d(){return(d=i(n().m(function r(){var t,o;return n().w(function(r){for(;;)switch(r.n){case 0:return r.p=0,console.log("Loading model and word index..."),r.n=1,e.loadLayersModel(chrome.runtime.getURL("model/model.json"));case 1:return f=r.v,r.n=2,fetch(chrome.runtime.getURL("model/word_index.json"));case 2:return t=r.v,r.n=3,t.json();case 3:l=r.v,console.log("Model and word index loaded"),r.n=5;break;case 4:r.p=4,o=r.v,console.error("Error loading model or word index:",o);case 5:return r.a(2)}},r,null,[[0,4]])}))).apply(this,arguments)}function v(e){var r=e.toLowerCase().replace(/[^a-z0-9\s]/g,"").split(/\s+/).map(function(e){return l[e]||1});return r.length>80?r.slice(0,80):Array(80-r.length).fill(0).concat(r)}function y(e,r){return h.apply(this,arguments)}function h(){return(h=i(n().m(function r(t,o){var i,a,c,u,s,d;return n().w(function(r){for(;;)switch(r.n){case 0:if(r.p=0,f&&l){r.n=1;break}return r.n=1,p();case 1:if(f&&l){r.n=2;break}return o({success:!1,error:"Model not ready"}),r.a(2);case 2:return i=v(t.body),a=e.tensor2d([i],[1,80]),c=f.predict(a),r.n=3,c.data();case 3:u=r.v,s=u[0],a.dispose(),c.dispose(),o({success:!0,score:s,isPhishing:s>.5,confidence:s>.5?(100*s).toFixed(2):(100*(1-s)).toFixed(2),emailData:t}),r.n=5;break;case 4:r.p=4,d=r.v,console.error("Error analyzing email:",d),o({success:!1,error:d.message});case 5:return r.a(2)}},r,null,[[0,4]])}))).apply(this,arguments)}p(),chrome.runtime.onMessage.addListener(function(e,r,n){if("ANALYZE_EMAIL"===e.action)return y(e.emailData,n),!0});
},{"@tensorflow/tfjs":"foZc"}]},{},["FSNs"], null)